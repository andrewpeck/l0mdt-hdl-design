import os
import json
import shutil
from pathlib import Path
from datetime import datetime

from l0mdt_tb.utils import utils
from l0mdt_tb.utils import test_config


def autogen_string(test_name, comment_string="#"):

    timestamp = datetime.now().strftime("%d-%b-%Y (%H:%M:%S)")
    autogen_lines = []
    autogen_lines.append("")
    autogen_lines.append(50 * f"{comment_string}")
    autogen_lines.append(f"{comment_string} autogenerated file")
    autogen_lines.append(f"{comment_string} created by tb create on: {timestamp}")
    autogen_lines.append(f"{comment_string} created by tb create for test: {test_name}")
    autogen_lines.append(f"{comment_string} Author:Priya Sundararajan")
    autogen_lines.append(f"{comment_string} Email:priya.sundararajan@cern.ch")
    autogen_lines.append(50 * f"{comment_string}")
    autogen_lines.append("")
    return autogen_lines


def creator_dir():
    p_tp_fw = utils.tp_fw_path()
#    p_creator = p_tp_fw / "tb" / "src" / "l0mdt_tb" / "creator"
    p_creator = p_tp_fw / "tools" / "cocotb" / "src" / "l0mdt_tb" / "creator"
    return p_creator


def test_dir_from_test_name(test_name):

    p_tp_fw = utils.tp_fw_path()
#    p_testbench = p_tp_fw / "tb" / "src" / "l0mdt_tb" / "testbench"
    p_testbench = p_tp_fw / "tools" / "cocotb" / "src" / "l0mdt_tb" / "testbench"
    p_test_dir = p_testbench / test_name
    return p_test_dir


def test_class_name(test_name):

    splits = test_name.strip().replace("-", "_").split("_")
    capital_splits = []
    for s in splits:
        capital_splits.append(s.capitalize())
    class_name = "".join(capital_splits)
    return class_name


def create_directory(path_string=""):

    if not path_string:
        return False, f"ERROR Empty path provided (={path_string})"

    try:
        os.mkdir(path_string)
    except OSError as ex:
        return False, f"{ex}"
    return True, None


def create_initial_directory_structure(test_name=""):

    # p_tp_fw = utils.tp_fw_path()
    # p_testbench = p_tp_fw / "tb" / "src" / "l0mdt_tb" / "testbench"
    # dir_ok = p_testbench.exists() and p_testbench.is_dir()
    # if not dir_ok :
    #    return False, f"ERROR Could not find {p_testbench} directory"

    ##
    ## create directory for the new test
    ##
    p_test_dir = test_dir_from_test_name(test_name)
    ok, err = create_directory(str(p_test_dir))
    if not ok:
        return False, f"ERROR Could not create test directory: {err}"

    ##
    ## create __init__.py
    ##
    p_init_py_file = p_test_dir / "__init__.py"
    p_init_py_file.touch()
    file_ok = p_init_py_file.exists() and p_init_py_file.is_file()
    if not file_ok:
        return False, f"ERROR Could not create file: {p_init_py_file}"

    autogen_lines = autogen_string(test_name)
    with open(str(p_init_py_file), "w") as ofile:
        for line in autogen_lines:
            ofile.write(f"{line}\n")

    ##
    ## create generic readme file
    ##
    ok = create_readme(test_name, p_test_dir)
    if not ok:
        return False, "ERROR Failed ot create test README"

    ##
    ## create test/ directory
    ##
    p_test_subdir = p_test_dir / "test"
    ok, err = create_directory(str(p_test_subdir))
    if not ok:
        return False, f"ERROR Could not create the test sub-directory: {err}"

    return True, None


def create_readme(test_name, p_test_dir):

    autogen_lines = autogen_string(test_name)
    p_readme = p_test_dir / "README.md"
    with open(str(p_readme), "w") as ofile:
        ofile.write(f"# Testbench for {test_name}\n")
        ofile.write("\n")
        ofile.write("```bash\n")
        for line in autogen_lines:
            ofile.write(f"{line}\n")
        ofile.write("")
        ofile.write("```\n")

    file_ok = p_readme.exists() and p_readme.is_file()
    return file_ok


def create_test_utils_file(test_name):

    p_test_dir = test_dir_from_test_name(test_name)
    p_test_utils_file = p_test_dir / f"{test_name}_utils.py"
    class_name = test_class_name(test_name)

    lines = []
    autogen_lines = autogen_string(test_name)
    lines += autogen_lines

    lines += [
        "",
        "def get_testvector_files(testvector_dir):",
        '\t"""',
        f"\t{class_name} specific testvector getter",
        '\t"""',
        '\traise NotImplementedError("ERROR Method not implemented")',
    ]

    with open(str(p_test_utils_file), "w") as ofile:
        for line in lines:
            ofile.write(f"{line}\n")

    file_ok = p_test_utils_file.exists() and p_test_utils_file.is_file()
    if not file_ok:
        return False, f'ERROR Could not create file "{str(p_test_utils_file)}"'
    return True, None


def create_test_ports_file(test_name, n_inputs, n_outputs, input_ports, output_ports):

    p_test_dir = test_dir_from_test_name(test_name)
    p_ports_file = p_test_dir / f"{test_name}_ports.py"
    class_name = test_class_name(test_name)

    lines         = []
    autogen_lines = autogen_string(test_name)
    lines += autogen_lines

    lines.append("import enum")
    lines.append("")
    lines.append("from l0mdt_tb.utils import port_descriptor")
    lines.append("")
    lines.append("")
    lines.append(f"class {class_name}Ports(port_descriptor.PortDescriptor):")
    lines.append("\tdef __init__(self):")
    lines.append("\t\tsuper().__init__()")
    lines.append("")

    lines.append("")
    lines.append(f"\tn_input_interfaces = {n_inputs}")
    lines.append("")

    lines.append(f"\tn_output_interfaces = {n_outputs}")
    lines.append("")


    lines.append("\tdef get_input_interface_ports(interface):")
    lines.append(f"\t\tinput_ports = {input_ports}")
    lines.append(f"\t\treturn input_ports[interface]")
    lines.append("")

    lines.append("\tdef get_all_input_interface_ports():")
    lines.append(f"\t\tinput_ports = {input_ports}")
    lines.append(f"\t\treturn input_ports")
    lines.append("")

    lines.append("\tdef get_output_interface_ports(interface):")
    lines.append(f"\t\toutput_ports = {output_ports}")
    lines.append(f"\t\treturn output_ports[interface]")
    lines.append("")

    lines.append("\tdef get_all_output_interface_ports():")
    lines.append(f"\t\toutput_ports = {output_ports}")
    lines.append(f"\t\treturn output_ports")
    lines.append("")

    lines.append("\tdef n_input_ports(self):")
    lines.append(f"\t\tinput_ports = 0")
    lines.append(f"\t\tfor i in range(self.n_input_interfaces):")
    lines.append(f"\t\t\tinput_ports = input_ports + self.get_input_interface_ports(i)")
    lines.append(f"\t\treturn input_ports")

    lines.append("\tdef n_output_ports(self):")
    lines.append(f"\t\toutput_ports = 0")
    lines.append(f"\t\tfor i in range(self.n_output_interfaces):")
    lines.append(f"\t\t\toutput_ports = output_ports + self.get_output_interface_ports(i)")
    #lines.append(f"\t\t\toutput_ports = output_ports + self.n_output_interfaces")
    lines.append(f"\t\treturn output_ports")




    with open(str(p_ports_file), "w") as ofile:
        for line in lines:
            ofile.write(f"{line}\n")

    file_ok = p_ports_file.exists() and p_ports_file.is_file()
    if not file_ok:
        return False, f'ERROR Could not create file "{str(p_ports_file)}"'
    return True, None


def create_test_wrapper(test_name):

    p_test_dir = test_dir_from_test_name(test_name)
    p_wrapper_file = p_test_dir / f"{test_name}_wrapper.py"
    class_name = test_class_name(test_name)

    p_creator_dir = creator_dir()
    p_skeleton_wrapper = p_creator_dir / "CREATOR_SKELETON_wrapper.py"

    skeleton_ok = p_skeleton_wrapper.exists() and p_skeleton_wrapper.is_file()
    if not skeleton_ok:
        return (
            False,
            f'ERROR Creator skeleton file "{str(p_skeleton_wrapper)}" could not be found',
        )

    autogen_lines = autogen_string(test_name)
    with open(str(p_wrapper_file), "w") as ofile:
        for line in autogen_lines:
            ofile.write(f"{line}\n")
        with open(str(p_skeleton_wrapper), "r") as skeleton_file:

            for skeleton_line in skeleton_file:
                new_line = skeleton_line.replace("CREATORTESTNAME", test_name).replace(
                    "CREATORCLASSNAME", class_name
                )
                ofile.write(new_line)

    file_ok = p_wrapper_file.exists() and p_wrapper_file.is_file()
    if not file_ok:
        return (
            False,
            f'ERROR Could not create test wrapper file "{str(p_wrapper_file)}"',
        )
    return True, None

def copy_prj_cfg_default(test_name):
    p_test_dir = test_dir_from_test_name(test_name)
    p_prj_cfg_dst =  p_test_dir / "test" / "prj_cfg.vhd"
    p_creator_dir = creator_dir()
    p_prj_cfg_src = p_creator_dir / "prj_cfg.vhd"
    shutil.copy(p_prj_cfg_src, p_prj_cfg_dst)
    file_ok = p_prj_cfg_dst.exists() and p_prj_cfg_dst.is_file()
    if not file_ok:
        return False, f'ERROR Could not copy test prj_cfg_default.vhd "{str(p_prj_cfg_dst)}"'
    return True, None

def create_test_makefile(test_name):

    p_test_dir = test_dir_from_test_name(test_name)
    p_makefile_file = p_test_dir / "test" / "Makefile"
    class_name = test_class_name(test_name)

    p_creator_dir = creator_dir()
    p_skeleton_makefile = p_creator_dir / "CREATOR_SKELETON_Makefile"
    skeleton_ok = p_skeleton_makefile.exists() and p_skeleton_makefile.is_file()
    if not skeleton_ok:
        return (
            False,
            f'ERROR Creator skeleton file "{str(p_skeleton_makefile)}" could not be found',
        )

    autogen_lines = autogen_string(test_name)
    with open(str(p_makefile_file), "w") as ofile:
        for line in autogen_lines:
            ofile.write(f"{line}\n")
        with open(str(p_skeleton_makefile), "r") as skeleton_file:
            for skeleton_line in skeleton_file:
                new_line = skeleton_line.replace("CREATORTESTNAME", test_name).replace(
                    "CREATORCLASSNAME", class_name
                )
                ofile.write(new_line)
    file_ok = p_makefile_file.exists() and p_makefile_file.is_file()
    if not file_ok:
        return False, f'ERROR Could not create test Makefile "{str(p_makefile_file)}"'
    return True, None


def create_test_toplevel(test_name, n_inputs, n_outputs, input_ports, output_ports):

    total_inputs  = 0;
    total_outputs = 0;

    for i in range(n_inputs):
        total_inputs = input_ports[i] + total_inputs

    for i in range(n_outputs):
        total_outputs = output_ports[i] + total_outputs

    p_test_dir = test_dir_from_test_name(test_name)
    p_toplevel_file = p_test_dir / "test" / f"TopLevel_{test_name}.v"
    class_name = test_class_name(test_name)

    p_creator_dir = creator_dir()
    p_skeleton_toplevel = p_creator_dir / "CREATOR_SKELETON_TopLevel.v"
    skeleton_ok = p_skeleton_toplevel.exists() and p_skeleton_toplevel.is_file()
    if not skeleton_ok:
        return (
            False,
            f'ERROR Creator skeleton file "{str(p_skeleton_toplevel)}" could not be found',
        )

    autogen_lines = autogen_string(test_name, comment_string="//")
    with open(str(p_toplevel_file), "w") as ofile:
        for line in autogen_lines:
            ofile.write(f"{line}\n")
        with open(str(p_skeleton_toplevel), "r") as skeleton_file:
            for skeleton_line in skeleton_file:
                new_line = skeleton_line.replace("CREATORTESTNAME", test_name).replace(
                    "CREATORCLASSNAME", class_name
                )
                new_line = new_line.replace("CREATORNINPUTS", f"{total_inputs}").replace(
                    "CREATORNOUTPUTS", f"{total_outputs}"
                )
                ofile.write(new_line)
    file_ok = p_toplevel_file.exists() and p_toplevel_file.is_file()
    if not file_ok:
        return (
            False,
            f'ERROR Could not create test top level file "{str(p_toplevel_file)}"',
        )
    return True, None


def create_test_module(test_name, do_software_block=False):

    p_test_dir = test_dir_from_test_name(test_name)
    p_module_file = p_test_dir / "test" / f"test_{test_name}.py"
    class_name = test_class_name(test_name)

    p_creator_dir = creator_dir()
    p_skeleton_module = p_creator_dir / "CREATOR_SKELETON_test_module.py"
    skeleton_ok = p_skeleton_module.exists() and p_skeleton_module.is_file()
    if not skeleton_ok:
        return (
            False,
            f'ERROR Creator skeleton file "{str(p_skeleton_module)}" could not be found',
        )

    autogen_lines = autogen_string(test_name)
    with open(str(p_module_file), "w") as ofile:
        for line in autogen_lines:
            ofile.write(f"{line}\n")
        with open(str(p_skeleton_module), "r") as skeleton_file:
            for skeleton_line in skeleton_file:
                new_line = skeleton_line.replace("CREATORTESTNAME", test_name).replace(
                    "CREATORCLASSNAME", class_name
                )
                if "#CREATORSOFTWAREBLOCK" in skeleton_line and do_software_block:
                    new_line = new_line.replace("#CREATORSOFTWAREBLOCK", "")
                elif "#CREATORSOFTWAREBLOCK" in skeleton_line and not do_software_block:
                    continue
                ofile.write(new_line)
    file_ok = p_module_file.exists() and p_module_file.is_file()
    if not file_ok:
        return False, f'ERROR Could not create test module file "{str(p_module_file)}"'
    return True, None


def create_test_configuration(test_name, n_inputs, n_outputs, input_ports, output_ports):

    p_tp_fw   = utils.tp_fw_path()
    p_config  = p_tp_fw / "tools" / "cocotb" / "test_config"

    p_test_dir  = f"src/l0mdt_tb/testbench/{str(test_name)}"

    ##
    ## input_args
    ##
    config_input_args = {
        "n_events": 1,
        "event_detail": False,
        "clock_period": 5,
        "clock_time_unit": "ns",
        "_COMMENT": "Environment variables COMPONENTS_LIB_DIR, L0MDT_TESTVECTOR_DIR overrides components_lib_dir, testvector_dir definition"
    }

    ##
    ## run_config
    ##
    config_run_config = {
        "output_directory_name": test_name,
        "test_location"        : f"{str(p_test_dir)}/test",
        "components_lib_dir"   : "${XILINX_LIB_DIR}",
        "configure_rtl"        :True,
        "pt_type"              : "upt",

    }

    ##
    ## testvectors
    ##
    input_list = []
    for i in range(n_inputs):
        local_port = {f"tv_format": f"INTERFACE_FORMAT_{i}", f"ports":input_ports[i]}

        input_list.append(local_port)
    output_list = []
    for i in range(n_outputs):
        output_list.append({f"tv_format": f"INTERFACE_FORMAT_{i}", f"ports":output_ports[i]})

    config_testvectors = {
        "testvector_dir": "${L0MDT_TESTVECTOR_DIR}",
        "testvector_file": "B_A_3.xz",
        "inputs": input_list,
        "outputs": output_list,
    }

    ##
    ## final
    ##
    out_config = {
        "test_name": test_name,
        "input_args": config_input_args,
        "run_config": config_run_config,
        "testvectors": config_testvectors,
    }
    out_config = {"testbench_config": out_config}

    ##
    ## write out file
    ##
    p_test_config_file = p_config / f"config_{test_name}.json"
    with open(str(p_test_config_file), "w", encoding="utf-8") as f:
        json.dump(out_config, f, ensure_ascii=False, indent=4)

    file_ok = p_test_config_file.exists() and p_test_config_file.is_file()
    if not file_ok:
        return (
            False,
            f'ERROR Could not create test configuration file "{str(p_test_config_file)}"',
        )

    ##
    ## validate
    ##
    parsed_config, err = test_config.config_from_file(str(p_test_config_file))
    if err:
        return (
            False,
            f"ERROR Generated test configuration file (={str(p_test_config_file)}) failed schema check",
        )

    return True, None


def create_software_block(test_name):

    p_test_dir = test_dir_from_test_name(test_name)
    p_block_file = p_test_dir / f"{test_name}_block.py"
    class_name = test_class_name(test_name)

    p_creator_dir = creator_dir()
    p_skeleton_block = p_creator_dir / "CREATOR_SKELETON_sw_block.py"
    skeleton_ok = p_skeleton_block.exists() and p_skeleton_block.is_file()
    if not skeleton_ok:
        return (
            False,
            f'ERROR Creator skeleton file "{str(p_skeleton_block)}" could not be found',
        )

    autogen_lines = autogen_string(test_name)
    with open(str(p_block_file), "w") as ofile:
        for line in autogen_lines:
            ofile.write(f"{line}\n")
        with open(str(p_skeleton_block), "r") as skeleton_file:
            for skeleton_line in skeleton_file:
                new_line = skeleton_line.replace("CREATORTESTNAME", test_name).replace(
                    "CREATORCLASSNAME", class_name
                )
                ofile.write(new_line)
    file_ok = p_block_file.exists() and p_block_file.is_file()
    if not file_ok:
        return (
            False,
            f'ERROR Could not create test logic block file "{str(p_block_file)}"',
        )
    return True, None
