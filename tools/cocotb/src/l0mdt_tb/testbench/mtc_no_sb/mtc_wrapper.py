
##################################################
# autogenerated file
# created by tb create on: 03-Jun-2020 (10:30:39)
# created by tb create for test: mtc_no_sb
##################################################

import cocotb
from cocotb.triggers import Event, Combine, with_timeout, Timer

from l0mdt_tb.testbench.mtc_no_sb.mtc_ports import MtcPorts

from l0mdt_tb.utils import events
from l0mdt_tb.utils import block_wrapper


class MtcWrapper(block_wrapper.BlockWrapper):
    def __init__(self, clock, name):
        super().__init__(
            clock,
            name,
            MtcPorts.get_all_input_interface_ports(), #[len(MtcPorts.SlcPipeline_Inputs),len(MtcPorts.Ptcalc_Inputs)],
            MtcPorts.get_all_output_interface_ports(), #[len(MtcPorts.Mtc_Outputs)],
       #    len(MtcPorts.Ptcalc_Inputs),
        )

    def send_input_events(
        self, input_testvectors, input_interface,n_to_send, l0id_request=-1, event_delays=False
    ):
        flow_interface_kwargs = {}
        slcpipeline_dict = {"slcpipeline": 1}  # go to ~nearest whole unit
        ptcalc_dict = {"ptcalc": 1}  # go to ~nearest whole unit
        n_input_files = len(input_testvectors)
        if n_input_files != self._n_input_ports[input_interface]:
            raise ValueError(
                f"Number of input event tables (={n_input_files}) is not equal to number of Mtc input ports (={self.n_input_ports})"
            )
        input_tv_list = [["" for x in range(n_to_send)] for y in range(self._n_input_ports[input_interface])]
        input_tv_list = input_testvectors


        if(input_interface == 0):
            flow_interface_kwargs.update(slcpipeline_dict)
        elif(input_interface == 1):
            flow_interface_kwargs.update(ptcalc_dict)


        hooks = []

        for port_num, port_tv_list in enumerate(input_tv_list):
            driver, io, active = self._input_ports[input_interface][port_num]

            input_events = len(port_tv_list) #input_tv_list[port_num])
            cocotb.log.info(
                f"Sending {input_events} events to input (interface,port_num, port_name) = ({input_interface},{io}) "
            )

            hook = None
            for iword, word in enumerate(port_tv_list):
                flow_kwargs = flow_interface_kwargs

                #print("WORDS %x %x"%(iword, word))
                # delays are entered at event boundaries
                hook = (
                    Event()
                )  # used to tell outside world that all events have been queued to be sent into the fifos
                driver.append(word, event=hook, **flow_kwargs)
            if hook:
                hooks.append(hook.wait())
        #print(f" HOOKS len {len(hooks)} {hooks}")

        return hooks


    def drive_input_interface(
            self, input_testvector_list, total_input_interfaces, n_to_send
    ):
        hooks = []
        index = 0
        my_hooks = [[0 for y in range(n_to_send)] for x in range(total_input_interfaces)]
        for x in range(total_input_interfaces):            
            cocotb.log.debug(f"sending input to interface {x}: {input_testvector_list[x]}")
            my_hooks[x] =  self.send_input_events( input_testvector_list[x], x, n_to_send)

        for x in range(total_input_interfaces):
            #for y in range(n_to_send):
            for y in range(self._n_input_ports[x]):
                hooks.append(my_hooks[x][y])
                #index = index+1

        return hooks
