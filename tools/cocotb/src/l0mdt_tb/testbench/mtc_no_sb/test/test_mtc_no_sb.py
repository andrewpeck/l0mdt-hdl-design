##################################################
# autogenerated file
# created by tb create on: 03-Jun-2020 (10:30:39)
# created by tb create for test: mtc
##################################################
#!/usr/bin/env python3

import sys
import os
import json

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import ClockCycles, RisingEdge, Combine, Timer, with_timeout
from cocotb.result import TestFailure, TestSuccess

import l0mdt_tb.testbench.mtc_no_sb.mtc_wrapper as wrapper
from l0mdt_tb.testbench.mtc_no_sb.mtc_ports import MtcPorts

# CREATORSOFTWAREBLOCKimport l0mdt_tb.testbench.mtc.mtc_block as mtc_block

from l0mdt_tb.utils import test_config
from l0mdt_tb.utils import events
from l0mdt_tb.utils.mtc_builder_wrapper import mtc_builderDriver, mtc_builderMonitor



def initialize_spybuffers(fifos=[]):

    for ififo, fifo in enumerate(fifos):
        fifo.read_enable <= 0
        fifo.write_enable <= 0
        fifo.empty <= 1
        fifo.almost_full <= 0
        fifo.read_data <= 0
        fifo.write_data <= 0


def initialize_dut(dut):

    for x in range (0, MtcPorts.get_input_interface_ports(0)):
        dut.slcpipeline[x] <= 0
    for x in range (0, MtcPorts.get_input_interface_ports(1)):
        dut.ptcalc[x] <= 0


@cocotb.coroutine
def reset(dut):

    """
    Resets the testbench, having reset active LOW.
    """

    dut.reset_n <= 1
    yield ClockCycles(dut.clock, 10)
    dut.reset_n <= 0
    yield ClockCycles(dut.clock, 10)
    dut.reset_n <= 1


##
## TEST
##
@cocotb.test()
def mtc_test(dut):

    ##
    ## first grab the testbench configuration
    ##
    config = test_config.get_config()

    ##
    ## process input arguments for this test
    ##
    input_args = config["input_args"]
    num_events_to_process = int(input_args["n_events"])
    event_level_detail_in_sumary = bool(input_args["event_detail"])

    testvectors     = config["testvectors"]
    outputs         = testvectors["outputs"]
    output_tvformat = outputs[0]["tv_format"]

    mtc2sl_lsf_tol = {
        "mdt_pt": ["abs", 100],
    }

    ##
    ## setup the clock and start it
    ##
    sim_clock = Clock(
        dut.clock, int(input_args["clock_period"]), input_args["clock_time_unit"]
    )
    cocotb.fork(sim_clock.start())

    ##
    ## initialize the DUT to known state
    ##
    initialize_dut(dut)

    ##
    ## reset
    ##
    dut._log.info("Resetting DUT")
    yield reset(dut)


    (
        inputs_tvformats,
        outputs_tvformats,
    ) = test_config.get_tvformats_from_config(config)

    run_config                       = config["run_config"]
    output_dir_name                  = run_config["output_directory_name"]
    master_tv_file                   = test_config.get_testvector_file_from_config(config)
    output_dir                       = f"{os.getcwd()}/../../../../../test_output/{output_dir_name}"
    outputs_station_id= [["" for x in range(MtcPorts.get_output_interface_ports(y))]for y in range(MtcPorts.n_output_interfaces)]
#    print("TV FORMATS = ", inputs_tvformats, outputs_tvformats)
#    print("MASTER TV FILE = ",master_tv_file)


    ##
    ## initialize the Mtc block wrapper
    ##
    mtc_wrapper = wrapper.MtcWrapper(
        clock=dut.clock,
        name=f"MtcWrapper_SlcPipeline_Inputs",
    )
    for io in range(MtcPorts.get_input_interface_ports(0)): #SlcPipeline_Inputs):

        slcpipeline_driver = mtc_builderDriver(
            dut, #dut.slcpipeline[io],
            dut.clock,
            "slcpipeline",
            io,
            write_out=True,
            out_dir=output_dir
        )
        mtc_wrapper.add_input_driver(slcpipeline_driver, 0,io)

    for io in range(MtcPorts.get_input_interface_ports(1)): #Ptcalc_Inputs):
        ptcalc_driver = mtc_builderDriver(
            dut, #dut.slcpipeline[io],
            dut.clock,
            "ptcalc",
            io,
            write_out=True,
            out_dir=output_dir
        )
        mtc_wrapper.add_input_driver(ptcalc_driver, 1,io)

    for io in range(MtcPorts.get_output_interface_ports(0)): #Mtc_Outputs):
        active = True
        monitor = mtc_builderMonitor(
            dut, #io, #dut.mtc[io],
            dut.clock,
            "Mtc",
            io,
            callbacks=[],
            write_out=True,
            out_dir=output_dir
        )
        mtc_wrapper.add_output_monitor(monitor, 0, io, active=active)
    mtc_wrapper.sort_ports()

    #Read TV file
    tv_bcid_list = events.read_tv(
        filename=master_tv_file,
        n_to_load=num_events_to_process,
        region=0,
        side=3,
        sector=3
        )

    ###Get Input Test Vectors for all input Ports ##
    slcpipeline_tv_list_i = [["" for x in range(num_events_to_process)] for y in range(3)]
    slcpipeline_tv_list   = [["" for x in range(num_events_to_process)] for y in range(3)]

    slcpipeline_tv_list_i = events.parse_tvlist(
        tv_bcid_list,
        tvformat=inputs_tvformats[0],
        n_ports = MtcPorts.get_input_interface_ports(0),
        n_to_load=num_events_to_process
    )
    #for i in range(3): # Update PL2MTC dataformat with process_ch values
    #    for j in range(num_events_to_process):
    #        slcpipeline_tv_list[i][j] = (slcpipeline_tv_list_i[i][j] | (i << 107))


    ptcalc_tv_list = events.parse_tvlist(
        tv_bcid_list,tvformat=inputs_tvformats[1],n_ports = MtcPorts.get_input_interface_ports(1), n_to_load=num_events_to_process
    )
#    print("len=" ,len(slcpipeline_tv_list),"slcpipeline_tv_list = " ,slcpipeline_tv_list[0])
#    print("ptcalc_tv_list = ", ptcalc_tv_list[0])


    ##
    ## send input events
    ##
    my_input_tvs = [[["0" for x in range(num_events_to_process)] for y in range(3)] for z in range(len(slcpipeline_tv_list))]
    my_input_tvs[0] = slcpipeline_tv_list_i
    my_input_tvs[1] = ptcalc_tv_list


    #print("INPUT VECTORS = ", my_input_tvs[0], my_input_tvs[1])
    dut._log.info("Sending input events")

    send_finished_signal = mtc_wrapper.drive_input_interface(
        my_input_tvs, MtcPorts.n_input_interfaces(MtcPorts), n_to_send=num_events_to_process
#        my_input_testvector_files, 2, n_to_send=num_events_to_process
    )



#    send_finished_signal = mtc_wrapper.my_send_input_events(
#        input_testvector_files, 0, n_to_send=num_events_to_process
#    )

    if not send_finished_signal:
        raise cocotb.result.TestFailure(
            f"ERROR Event sending timed out! Number of expected inputs with events = {len(send_finished_signal)}"
        )


    try:
        yield with_timeout(Combine(*send_finished_signal), 20, "us")
    except Exception as ex:
        raise cocotb.result.TestFailure(
            f"ERROR Timed out waiting for events to send: {ex}"
        )
    dut._log.info("Sending finished!")

    timer = Timer(20, "us")
    dut._log.info("Going to wait 20 microseconds")
    yield timer


    #Read TV file
    tv_events_list = events.read_tv(
        filename=master_tv_file,
        n_to_load=num_events_to_process,
        region=0,
        side=3,
        sector=3
        )

    ##
    ## perform testvector comparison test
    ##
    all_tests_passed = True
    all_test_results = []
    output_tv_list = [["" for x in range(num_events_to_process)] for y in range(mtc_wrapper.n_output_ports(0))]

    output_tv_list = events.parse_tvlist(
        tv_bcid_list,tvformat=outputs_tvformats[0],n_ports = mtc_wrapper.n_output_ports(0), n_to_load=num_events_to_process
    )

    exp_output_tv = [[0 for x in range(num_events_to_process)] for y in range(mtc_wrapper.n_output_ports(0))]

    for n_oport,oport in enumerate(mtc_wrapper.output_ports(0)): # Pick Ouput port
        op_tv_list = output_tv_list[n_oport]
        transaction  = 0
        for ilist, op_word in enumerate(op_tv_list): # Transactions for port
            #port_events = op_list #list(op_list)
            #for  op_iword, op_word in enumerate(port_events):
            exp_output_tv[n_oport][transaction] = op_word
            transaction += 1

    #    print("EXP OUTPUT %d 0x%x  0x%x"%(len(exp_output_tv[0]), exp_output_tv[0][0], exp_output_tv[0][1]))

    recvd_events_all_ports = [["" for x in range(num_events_to_process)]for y in range(MtcPorts.get_output_interface_ports(0))]
    recvd_lineup           = [["" for x in range(num_events_to_process)]for y in range(MtcPorts.get_output_interface_ports(0))]
    recvd_time             = [["" for x in range(num_events_to_process)]for y in range(MtcPorts.get_output_interface_ports(0))]

    for n_oport,oport in enumerate(mtc_wrapper.output_ports(0)):

        ##
        ## extract the observed data for this output
        ##
        monitor, io, is_active = oport
        words = monitor.observed_words
        time  = monitor.observed_time
        recvd_events_all_ports[n_oport] = words
        recvd_time[n_oport]             = time
        cocotb.log.info(
          f"Output for MTC Interface (output port num {io}) received {len(recvd_events_all_ports[n_oport])} events"
        )
        ##
        ## extract the expected data for this output
        ##
        if config["run_config"]["expected_is_observed"]:
            # map the "expected" to be the same as the "observed"
            dut._log.warning(
                "WARNING Taking expected events to be the same as the observed events!"
            )
            output_testvector_file = "expected_is_observed"
            expected_output_events = recvd_events
        else:
            output_testvector_file = master_tv_file

            expected_output_events = exp_output_tv[n_oport] #output_tv_list[n_oport]

    #Multiple ports in this interface, need to lineup events across ports based on time
    #recvd_lineup = events.timebased_lineup(recvd_events_all_ports, recvd_time,num_events_to_process,MtcPorts.get_output_interface_ports(0))
    recvd_lineup = recvd_events_all_ports

    ##
    ## perform test by comparison with expected testvectors
    ##
    field_fail_count_header = []
    field_fail_count          = []
    field_fail_count_header.clear()
    field_fail_count.clear()
    events_are_equal,pass_count , fail_count, field_fail_count_i = events.compare_BitFields(
        tv_bcid_list, 
        output_tvformat ,
        MtcPorts.get_output_interface_ports(0) , 
        num_events_to_process , 
        recvd_lineup, 
        tolerances = mtc2sl_lsf_tol,
        output_path=output_dir,
        stationNum=events.station_list_name_to_id(outputs_station_id[0])
    );
    all_tests_passed = (all_tests_passed and events_are_equal)

    field_fail_count_header.append([output_tvformat +" "+ "FIELDS", "FAIL COUNT"])
    field_fail_count.append(field_fail_count_i)

    events.results_summary(
        num_events_to_process,
        pass_count,
        fail_count,
        MtcPorts.n_output_interfaces,
        field_fail_count_header,
        field_fail_count,
        total_ports = MtcPorts.total_output_ports()
    )


    cocotb_result = {True: cocotb.result.TestSuccess, False: cocotb.result.TestFailure}[
        all_tests_passed
    ]
    raise cocotb_result
