
////////////////////////////////////////////////////////////////////////////////////////////////////
// autogenerated file
// created by tb create on: 11-Apr-2022 (07:42:19)
// created by tb create for test: lsf_ptcalc
// Author:Priya Sundararajan
// Email:priya.sundararajan@cern.ch
////////////////////////////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ps
`default_nettype wire

  import l0mdt_dataformats_svh::*;
module TopLevel_lsf_ptcalc #(
    parameter DATA_WIDTH = 256, //65,
    parameter FIFO_DEPTH = 6,
    parameter N_OUTPUTS = 1,
    parameter N_INPUTS = 10

) (
    input wire clock,
    input wire reset_n,
    input wire [DATA_WIDTH-1:0] input_data [10],
    output wire [DATA_WIDTH-1:0] output_data [1]
);

    //
    // Here define the signals to connect the input and output Spy+FIFO
    // blocks with the input and output of the DUT.
    // Here we define one for each of the FIFO signals, but the test
    // creator should remove unnecessary signals.
    //

    wire BLOCK_input_write_enable [10];
    wire [DATA_WIDTH-1:0] BLOCK_input_data [10];
    wire BLOCK_input_read_enable [10];
    wire BLOCK_input_almost_full [10];
    wire BLOCK_input_empty [10];

    wire BLOCK_output_write_enable [1];
    wire [DATA_WIDTH-1:0] BLOCK_output_data [1];
    wire BLOCK_output_read_enable [1];
    wire BLOCK_output_almost_full [1];
    wire BLOCK_output_empty [1];


   //RTL Specific
   parameter n_threads = 3;
   
   wire [HEG2SFHIT_LEN-1:0] mdt_hit[3];
   wire [HEG2SFSLC_LEN-1:0] roi[3];
   wire [SF2PTCALC_LEN -1:0] lsf_output[3];
   wire 		     eof[3];
   wire [PL2PTCALC_LEN-1 :0] pl2pt;
   wire [PTCALC2MTC_LEN-1:0] pt2mtc;
   
    //
    // Input buffers
    //
    generate
       for(genvar i = 0; i < 10; i++)
         begin:input_spybuffers
            SpyBuffer #(
			.DATA_WIDTH_A(DATA_WIDTH),
			.DATA_WIDTH_B(DATA_WIDTH),
			.FC_FIFO_WIDTH(FIFO_DEPTH),
			.PASSTHROUGH(1)
			) spybuffer (
				     .rclock(clock),
				     .wclock(clock),
				     .rresetbar(reset_n),
				     .wresetbar(reset_n),
				     .write_data(input_data[i]),
				     .write_enable(BLOCK_input_write_enable[i]),
				     .read_data(BLOCK_input_data[i]),
				     .read_enable(BLOCK_input_read_enable[i]),
				     .almost_full(BLOCK_input_almost_full[i]),
				     .empty(BLOCK_input_empty[i]),
				     .freeze(1'b0),
				     .playback(2'b0)
				     );
         end
    endgenerate // end input_spybuffers generate

    //
    // Here place the DUT block(s)
    //
 
   
   



   for (genvar i =0; i< 3; i++)
     begin: lsf_blocks
	assign roi[i]     = BLOCK_input_data[i];
	assign mdt_hit[i] = BLOCK_input_data[3+i];
	assign eof[i]     = BLOCK_input_data[6+i] & 1;
	  top_lsf lsf_inst(.clock(clock),
                    .reset(~reset_n),
                    .mdt_hit(mdt_hit[i]),
                    .slc_roi(roi[i]),
                    .lsf(lsf_output[i]),
                    .hba_max_clocks(10'b0), //Unused, replaced by i_eof
                    .i_eof(eof[i])
		    );	
     end // block: lsf_blocks

   assign pl2pt = BLOCK_input_data[9];
   
      top_upt top_upt_inst(
			.clk(clock),
			.i_rst(~reset_n),
			.i_slc(pl2pt),
			.i_segment_i(lsf_output[0]),
			.i_segment_m(lsf_output[1]),
			.i_segment_o(lsf_output[2]),
			.o_mtc(pt2mtc)
			);
   assign BLOCK_output_data[0][PTCALC2MTC_LEN-1:0]          = pt2mtc;
   assign BLOCK_output_data[0][DATA_WIDTH-1:PTCALC2MTC_LEN] = 0;
   assign BLOCK_output_write_enable[0]                      = pt2mtc[PTCALC2MTC_DATA_VALID_MSB];
    //
    // Output buffers
    //
   generate
      for(genvar i = 0; i < 1; i++)
        begin:output_spybuffers
           SpyBuffer #(
		       .DATA_WIDTH_A(DATA_WIDTH),
		       .DATA_WIDTH_B(DATA_WIDTH),
		       .FC_FIFO_WIDTH(FIFO_DEPTH),
		       .PASSTHROUGH(1)
                       ) spybuffer (
				    .rclock(clock),
				    .wclock(clock),
				    .rresetbar(reset_n),
				    .wresetbar(reset_n),
				    .write_data(BLOCK_output_data[i]),
				    .write_enable(BLOCK_output_write_enable[i]),
				    .read_data(output_data[i]),
				    .read_enable(BLOCK_output_read_enable[i]),
				    .almost_full(BLOCK_output_almost_full[i]),
				    .empty(BLOCK_output_empty[i]),
				    .freeze(1'b0),
				    .playback(2'b0)
				    );
        end
   endgenerate // end output_spybuffers generate

endmodule // end TopLevel module definition
