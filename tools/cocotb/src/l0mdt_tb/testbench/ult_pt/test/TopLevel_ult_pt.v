
////////////////////////////////////////////////////////////////////////////////////////////////////
// autogenerated file
// created by tb create on: 13-May-2022 (05:23:11)
// created by tb create for test: ult_pt
// Author:Priya Sundararajan
// Email:priya.sundararajan@cern.ch
////////////////////////////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ps
`default_nettype wire

   import l0mdt_dataformats_svh::*;
module TopLevel_ult_pt #(
    parameter DATA_WIDTH = 256, //65,
    parameter FIFO_DEPTH = 6,
    parameter N_OUTPUTS = 3,
    parameter N_INPUTS = 12

) (
    input wire clock,
    input wire reset_n,
    input wire [DATA_WIDTH-1:0] input_data [12],
    output wire [DATA_WIDTH-1:0] output_data [3]
);

    //
    // Here define the signals to connect the input and output Spy+FIFO
    // blocks with the input and output of the DUT.
    // Here we define one for each of the FIFO signals, but the test
    // creator should remove unnecessary signals.
    //

    wire BLOCK_input_write_enable [12];
    wire [DATA_WIDTH-1:0] BLOCK_input_data [12];
    wire BLOCK_input_read_enable [12];
    wire BLOCK_input_almost_full [12];
    wire BLOCK_input_empty [12];

    wire BLOCK_output_write_enable [3];
    wire [DATA_WIDTH-1:0] BLOCK_output_data [3];
    wire BLOCK_output_read_enable [3];
    wire BLOCK_output_almost_full [3];
    wire BLOCK_output_empty [3];

    //
    // Input buffers
    //
    generate
       for(genvar i = 0; i < 12; i++)
         begin:input_spybuffers
            SpyBuffer #(
			.DATA_WIDTH_A(DATA_WIDTH),
			.DATA_WIDTH_B(DATA_WIDTH),
			.FC_FIFO_WIDTH(FIFO_DEPTH),
			.PASSTHROUGH(1)
			) spybuffer (
				     .rclock(clock),
				     .wclock(clock),
				     .rresetbar(reset_n),
				     .wresetbar(reset_n),
				     .write_data(input_data[i]),
				     .write_enable(BLOCK_input_write_enable[i]),
				     .read_data(BLOCK_input_data[i]),
				     .read_enable(BLOCK_input_read_enable[i]),
				     .almost_full(BLOCK_input_almost_full[i]),
				     .empty(BLOCK_input_empty[i]),
				     .freeze(1'b0),
				     .playback(2'b0)
				     );
         end
    endgenerate // end input_spybuffers generate

    //
    // Here place the DUT block(s)
    //

   // Here place the DUT block(s)
   //
   
   localparam THREADS_n  = 3;
   
   localparam STATIONS_n = 3;




   wire [SF2PTCALC_LEN-1 :0] sf2pt_INN[THREADS_n];

   wire [SF2PTCALC_LEN-1 :0] sf2pt_MID[THREADS_n];

   wire [SF2PTCALC_LEN-1 :0] sf2pt_OUT[THREADS_n];

   wire [SF2PTCALC_LEN-1 :0] sf2pt_EXT[THREADS_n];

   wire [PL2PTCALC_LEN-1 :0] pl2pt[THREADS_n];


   wire [PTCALC2MTC_LEN-1:0] pt2mtc[THREADS_n];


   wire                      dummy_in[THREADS_n];
   //wire                      dummy_in[THREADS_n-1];

   wire                      dummy_out[THREADS_n];


   assign sf2pt_INN[0]  = BLOCK_input_data[0];

   assign sf2pt_INN[1]  = BLOCK_input_data[1];

   assign sf2pt_INN[2]  = BLOCK_input_data[2];


   assign sf2pt_MID[0]  = BLOCK_input_data[3];

   assign sf2pt_MID[1]  = BLOCK_input_data[4];

   assign sf2pt_MID[2]  = BLOCK_input_data[5];


   assign sf2pt_OUT[0]  = BLOCK_input_data[6];

   assign sf2pt_OUT[1]  = BLOCK_input_data[7];

   assign sf2pt_OUT[2]  = BLOCK_input_data[8];

   
      
   assign pl2pt[0]           = BLOCK_input_data[9];

   assign pl2pt[1]           = BLOCK_input_data[10];

   assign pl2pt[2]           = BLOCK_input_data[11];


   for( genvar i=0; i < THREADS_n; i++)
     begin
   	assign dummy_in[i]   = 0;
   	assign sf2pt_EXT[i]  = 0;
     end

   
   // for( genvar i=0; i < THREADS_n; i++)
   //   begin
   // 	assign sf2pt_EXT[i]  = 0;
   //   end
   
   // for( genvar i=0; i < THREADS_n-1; i++)
   //   begin
   //       assign dummy_in[i]   = 0;
   //   end

   
   	

   tb_ptcalc tb_ptcalc_inst
       (
   	      .clock(clock),
   	      .rst(~reset_n),
   	      .ttc_commands(),
   	//.ctrl_v(dummy_in),
   	      .mon_v(dummy_out),
   	//        --  segments from neighbors
   	      .i_plus_neighbor_segments(),
   	      .i_minus_neighbor_segments(),
   	//        -- segments from hps
   	      .i_inn_segments(sf2pt_INN),
   	      .i_mid_segments(sf2pt_MID),
   	      .i_out_segments(sf2pt_OUT),
   	      .i_ext_segments(sf2pt_EXT),
   	//   -- from pipeline
   	      .i_pl2pt_av(pl2pt),
   	//   -- to mtc
   	      .o_pt2mtc(pt2mtc),
   	      .o_sump()
   	);


   assign BLOCK_output_data[0][PTCALC2MTC_LEN-1:0]                     = pt2mtc[0];

   assign BLOCK_output_data[1][PTCALC2MTC_LEN-1:0]                     = pt2mtc[1];

   assign BLOCK_output_data[2][PTCALC2MTC_LEN-1:0]                     = pt2mtc[2];


   assign BLOCK_output_data[0][DATA_WIDTH-1:PTCALC2MTC_LEN] = 0;

   assign BLOCK_output_data[1][DATA_WIDTH-1:PTCALC2MTC_LEN] = 0;

   assign BLOCK_output_data[2][DATA_WIDTH-1:PTCALC2MTC_LEN] = 0;


   assign BLOCK_output_write_enable[0]                                               = pt2mtc[0][PTCALC2MTC_DATA_VALID_MSB];

   assign BLOCK_output_write_enable[1]                                               = pt2mtc[1][PTCALC2MTC_DATA_VALID_MSB];

   assign BLOCK_output_write_enable[2]                                               = pt2mtc[2][PTCALC2MTC_DATA_VALID_MSB];


   
    //
    // Output buffers
    //
   generate
      for(genvar i = 0; i < 3; i++)
        begin:output_spybuffers
           SpyBuffer #(
		       .DATA_WIDTH_A(DATA_WIDTH),
		       .DATA_WIDTH_B(DATA_WIDTH),
		       .FC_FIFO_WIDTH(FIFO_DEPTH),
		       .PASSTHROUGH(1)
                       ) spybuffer (
				    .rclock(clock),
				    .wclock(clock),
				    .rresetbar(reset_n),
				    .wresetbar(reset_n),
				    .write_data(BLOCK_output_data[i]),
				    .write_enable(BLOCK_output_write_enable[i]),
				    .read_data(output_data[i]),
				    .read_enable(BLOCK_output_read_enable[i]),
				    .almost_full(BLOCK_output_almost_full[i]),
				    .empty(BLOCK_output_empty[i]),
				    .freeze(1'b0),
				    .playback(2'b0)
				    );
        end
   endgenerate // end output_spybuffers generate

endmodule // end TopLevel module definition
