
////////////////////////////////////////////////////////////////////////////////////////////////////
// autogenerated file
// created by tb create on: 20-Jan-2021 (08:35:52)
// created by tb create for test: pl_mtc_ps
////////////////////////////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ps
`default_nettype wire

module TopLevel_mpl_mtc #(
    parameter DATA_WIDTH = 256, //65,
    parameter FIFO_DEPTH = 6,
    parameter N_OUTPUTS = 6,
    parameter N_INPUTS = 6

) (
    input wire clock,
    input wire reset_n,
    input wire [DATA_WIDTH-1:0] input_data [6],
    output wire [DATA_WIDTH-1:0] output_data [6]
);

    //
    // Here define the signals to connect the input and output Spy+FIFO
    // blocks with the input and output of the DUT.
    // Here we define one for each of the FIFO signals, but the test
    // creator should remove unnecessary signals.
    //

    wire BLOCK_input_write_enable [6];
    wire [DATA_WIDTH-1:0] BLOCK_input_data [6];
    wire BLOCK_input_read_enable [6];
    wire BLOCK_input_almost_full [6];
    wire BLOCK_input_empty [6];

    wire BLOCK_output_write_enable [6];
    wire [DATA_WIDTH-1:0] BLOCK_output_data [6];
    wire BLOCK_output_read_enable [6];
    wire BLOCK_output_almost_full [6];
    wire BLOCK_output_empty [6];

   parameter TB_c_MAX_NUM_SL  = 3;
   parameter TB_c_NUM_THREADS = 3;
   parameter TB_c_NUM_MTC     = 3;



   wire [PL2MTC_LEN-1:0] pl2mtc [TB_c_MAX_NUM_SL];
   wire [MTC2SL_LEN-1:0] mtc2sl [TB_c_NUM_MTC];
   wire [UCM2PL_LEN-1:0] ucm2pl [TB_c_MAX_NUM_SL];
   wire [PTCALC2MTC_LEN-1:0] ptcalc2mtc[TB_c_NUM_THREADS];
   wire [PL2PTCALC_LEN-1:0]  pl2ptcalc[TB_c_NUM_THREADS-1:0];

   typedef struct 	     {
      logic 		     RESET;
      logic 		     ENABLE;
      logic 		     DISABLE;
      logic 		     FREEZE;
   } MPL_ACTIONS_CTRL_t ;

   typedef struct 	     {
      logic [3:0] 	     THREADS;
      logic 		     INPUT_EN;
      logic 		     OUTPUT_EN;
      logic 		     FLUSH_MEM_RESET;
   } MPL_CONFIGS_CTRL_t;

   typedef logic [4:0] 	     MPL_PL_MEM_PL_MEM_CTRL_t_ARRAY ;
   typedef struct 	     {
      MPL_PL_MEM_PL_MEM_CTRL_t_ARRAY PL_MEM;
   } MPL_PL_MEM_CTRL_t;




typedef struct {
   MPL_ACTIONS_CTRL_t actions;
   MPL_CONFIGS_CTRL_t configs;
   MPL_PL_MEM_CTRL_t pl_mem;
} MPL_CTRL_t;


   MPL_CTRL_t mpl_ctrl;
   assign   mpl_ctrl.actions.RESET   = 0;
   assign   mpl_ctrl.actions.ENABLE  = 0;
   assign   mpl_ctrl.actions.DISABLE = 0;
   assign   mpl_ctrl.actions.FREEZE = 0;

    //
    // Input buffers
    //
    generate
       for(genvar i = 0; i < 6; i++)
         begin:input_spybuffers
            SpyBuffer #(
			.DATA_WIDTH_A(DATA_WIDTH),
			.DATA_WIDTH_B(DATA_WIDTH),
			.FC_FIFO_WIDTH(FIFO_DEPTH),
			.PASSTHROUGH(1)
			) spybuffer (
				     .rclock(clock),
				     .wclock(clock),
				     .rresetbar(reset_n),
				     .wresetbar(reset_n),
				     .write_data(input_data[i]),
				     .write_enable(BLOCK_input_write_enable[i]),
				     .read_data(BLOCK_input_data[i]),
				     .read_enable(BLOCK_input_read_enable[i]),
				     .almost_full(BLOCK_input_almost_full[i]),
				     .empty(BLOCK_input_empty[i]),
				     .freeze(1'b0),
				     .playback(2'b0)
				     );
	    if(i < TB_c_MAX_NUM_SL)
	      begin
		 assign ucm2pl[i] = BLOCK_input_data[i];
	      end
	    else
	      begin
		 assign ptcalc2mtc[i-TB_c_MAX_NUM_SL] = BLOCK_input_data[i];
	      end

         end
    endgenerate // end input_spybuffers generate

    //
    // Here place the DUT block(s)
    //

   mpl_top_tb mpl_top_tb_inst
     (
      .clk(clock),
      .rst(~reset_n),
      .glob_en(1'b1),
      .i_uCM2pl_av(ucm2pl),
      .o_pl2ptcalc_av(pl2ptcalc),
      .o_pl2mtc_av(pl2mtc)
      );

   top_mtc  #(
	      .TOTAL_PTCALC_BLKS(TB_c_NUM_THREADS),
	      .MTC_PER_BCID(TB_c_MAX_NUM_SL),
	      .n_PRIMARY_MTC(TB_c_NUM_MTC)
	      ) mtc_inst
     (
      .clock(clock),
      .rst(~reset_n),
      .i_ptcalc(ptcalc2mtc),
      .i_pl2mtc(pl2mtc),
      .o_mtc(mtc2sl)
      );


    //
    // Output buffers
    //
   generate
      for(genvar i = 0; i < 6; i++)
        begin:output_spybuffers

	   if(i < 3)
	     begin
		assign BLOCK_output_data[i][PL2PTCALC_LEN-1:0]          = pl2ptcalc[i];
		assign BLOCK_output_data[i][DATA_WIDTH-1:PL2PTCALC_LEN] = 0;
		assign BLOCK_output_write_enable[i]                     = (pl2ptcalc[i][PL2PTCALC_LEN-1] == 1'b1)? 1'b1 : 1'b0;

	     end
	   else
	     begin
		assign BLOCK_output_data[i][MTC2SL_LEN-1:0]          = mtc2sl[i-3];
		assign BLOCK_output_data[i][DATA_WIDTH-1:MTC2SL_LEN] = 0;
		assign BLOCK_output_write_enable[i]                  = mtc2sl[i-3][MTC2SL_LEN-1];

	     end
           SpyBuffer #(
		       .DATA_WIDTH_A(DATA_WIDTH),
		       .DATA_WIDTH_B(DATA_WIDTH),
		       .FC_FIFO_WIDTH(FIFO_DEPTH),
		       .PASSTHROUGH(0)
                       ) spybuffer (
				    .rclock(clock),
				    .wclock(clock),
				    .rresetbar(reset_n),
				    .wresetbar(reset_n),
				    .write_data(BLOCK_output_data[i]),
				    .write_enable(BLOCK_output_write_enable[i]),
				    .read_data(output_data[i]),
				    .read_enable(BLOCK_output_read_enable[i]),
				    .almost_full(BLOCK_output_almost_full[i]),
				    .empty(BLOCK_output_empty[i]),
				    .freeze(1'b0),
				    .playback(2'b0)
				    );
        end
   endgenerate // end output_spybuffers generate

endmodule // end TopLevel module definition
