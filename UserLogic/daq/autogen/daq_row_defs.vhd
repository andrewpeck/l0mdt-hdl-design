-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.math_real.all;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

library ttc_def;
use ttc_def.ttc_defs.all;

library daq_def;
use daq_def.daq_config_defs.all;
use daq_def.daq_defs.all;

package daq_row_defs is

  type node_to_mngt_rt is record
    data_ready : std_logic;
    nempty : std_logic;
    err : std_logic;
  end record node_to_mngt_rt;
  function len(x: node_to_mngt_rt) return natural;
  function width(x: node_to_mngt_rt) return natural;
  function vectorify(x: node_to_mngt_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: node_to_mngt_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: node_to_mngt_rt) return node_to_mngt_rt;
  function convert(x: in std_logic_vector; t: node_to_mngt_rt) return node_to_mngt_rt;
  function nullify(t: node_to_mngt_rt) return node_to_mngt_rt;
  function zeroed(t: node_to_mngt_rt) return node_to_mngt_rt;

  type mngt_to_node_rt is record
    en : std_logic;
    rd_en : std_logic;
  end record mngt_to_node_rt;
  function len(x: mngt_to_node_rt) return natural;
  function width(x: mngt_to_node_rt) return natural;
  function vectorify(x: mngt_to_node_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: mngt_to_node_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: mngt_to_node_rt) return mngt_to_node_rt;
  function convert(x: in std_logic_vector; t: mngt_to_node_rt) return mngt_to_node_rt;
  function nullify(t: mngt_to_node_rt) return mngt_to_node_rt;
  function zeroed(t: mngt_to_node_rt) return mngt_to_node_rt;

  type src_to_node_fifo_rt is record
    wr_en : std_logic;
    data : std_logic_vector(DAQ_MAX_DATA_WIDTH-1 downto 0);
  end record src_to_node_fifo_rt;
  function len(x: src_to_node_fifo_rt) return natural;
  function width(x: src_to_node_fifo_rt) return natural;
  function vectorify(x: src_to_node_fifo_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: src_to_node_fifo_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: src_to_node_fifo_rt) return src_to_node_fifo_rt;
  function convert(x: in std_logic_vector; t: src_to_node_fifo_rt) return src_to_node_fifo_rt;
  function nullify(t: src_to_node_fifo_rt) return src_to_node_fifo_rt;
  function zeroed(t: src_to_node_fifo_rt) return src_to_node_fifo_rt;

  type node_fifo_to_src_rt is record
    full : std_logic;
  end record node_fifo_to_src_rt;
  function len(x: node_fifo_to_src_rt) return natural;
  function width(x: node_fifo_to_src_rt) return natural;
  function vectorify(x: node_fifo_to_src_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: node_fifo_to_src_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: node_fifo_to_src_rt) return node_fifo_to_src_rt;
  function convert(x: in std_logic_vector; t: node_fifo_to_src_rt) return node_fifo_to_src_rt;
  function nullify(t: node_fifo_to_src_rt) return node_fifo_to_src_rt;
  function zeroed(t: node_fifo_to_src_rt) return node_fifo_to_src_rt;

  subtype node_fifo_cnt_t is std_logic_vector(DAQ_MAX_DATA_WIDTH-1 downto 0);

  type node_fifo_to_dst_rt is record
    data : daq_stream_data_t;
    count : node_fifo_cnt_t;
    nempty : std_logic;
  end record node_fifo_to_dst_rt;
  function len(x: node_fifo_to_dst_rt) return natural;
  function width(x: node_fifo_to_dst_rt) return natural;
  function vectorify(x: node_fifo_to_dst_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: node_fifo_to_dst_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: node_fifo_to_dst_rt) return node_fifo_to_dst_rt;
  function convert(x: in std_logic_vector; t: node_fifo_to_dst_rt) return node_fifo_to_dst_rt;
  function nullify(t: node_fifo_to_dst_rt) return node_fifo_to_dst_rt;
  function zeroed(t: node_fifo_to_dst_rt) return node_fifo_to_dst_rt;

  type dst_to_node_fifo_rt is record
    rd_en : std_logic;
  end record dst_to_node_fifo_rt;
  function len(x: dst_to_node_fifo_rt) return natural;
  function width(x: dst_to_node_fifo_rt) return natural;
  function vectorify(x: dst_to_node_fifo_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: dst_to_node_fifo_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: dst_to_node_fifo_rt) return dst_to_node_fifo_rt;
  function convert(x: in std_logic_vector; t: dst_to_node_fifo_rt) return dst_to_node_fifo_rt;
  function nullify(t: dst_to_node_fifo_rt) return dst_to_node_fifo_rt;
  function zeroed(t: dst_to_node_fifo_rt) return dst_to_node_fifo_rt;

  type daq_node_fifo_irt is record
    sys : daq_sys_rt;
    src : src_to_node_fifo_rt;
    dst : dst_to_node_fifo_rt;
  end record daq_node_fifo_irt;
  function len(x: daq_node_fifo_irt) return natural;
  function width(x: daq_node_fifo_irt) return natural;
  function vectorify(x: daq_node_fifo_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_node_fifo_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_node_fifo_irt) return daq_node_fifo_irt;
  function convert(x: in std_logic_vector; t: daq_node_fifo_irt) return daq_node_fifo_irt;
  function nullify(t: daq_node_fifo_irt) return daq_node_fifo_irt;
  function zeroed(t: daq_node_fifo_irt) return daq_node_fifo_irt;

  type daq_node_fifo_ort is record
    src : node_fifo_to_src_rt;
    dst : node_fifo_to_dst_rt;
  end record daq_node_fifo_ort;
  function len(x: daq_node_fifo_ort) return natural;
  function width(x: daq_node_fifo_ort) return natural;
  function vectorify(x: daq_node_fifo_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_node_fifo_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_node_fifo_ort) return daq_node_fifo_ort;
  function convert(x: in std_logic_vector; t: daq_node_fifo_ort) return daq_node_fifo_ort;
  function nullify(t: daq_node_fifo_ort) return daq_node_fifo_ort;
  function zeroed(t: daq_node_fifo_ort) return daq_node_fifo_ort;

  type daq_node_fifo_ert is record
    i : daq_node_fifo_irt;
    o : daq_node_fifo_ort;
  end record daq_node_fifo_ert;
  function len(x: daq_node_fifo_ert) return natural;
  function width(x: daq_node_fifo_ert) return natural;
  function vectorify(x: daq_node_fifo_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_node_fifo_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_node_fifo_ert) return daq_node_fifo_ert;
  function convert(x: in std_logic_vector; t: daq_node_fifo_ert) return daq_node_fifo_ert;
  function nullify(t: daq_node_fifo_ert) return daq_node_fifo_ert;
  function zeroed(t: daq_node_fifo_ert) return daq_node_fifo_ert;

  type daq_node_fifo_grt is record
    WRITE_DATA_WIDTH : integer;
    READ_DATA_WIDTH : integer;
    READ_COUNT_WIDTH : integer;
    FIFO_DEPTH : integer;
  end record daq_node_fifo_grt;
  function len(x: daq_node_fifo_grt) return natural;
  function width(x: daq_node_fifo_grt) return natural;
  function vectorify(x: daq_node_fifo_grt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_node_fifo_grt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_node_fifo_grt) return daq_node_fifo_grt;
  function convert(x: in std_logic_vector; t: daq_node_fifo_grt) return daq_node_fifo_grt;
  function nullify(t: daq_node_fifo_grt) return daq_node_fifo_grt;
  function zeroed(t: daq_node_fifo_grt) return daq_node_fifo_grt;

  type node_ort is record
    mngt : node_to_mngt_rt;
    bconv : forward_rt;
    debug : std_logic;
  end record node_ort;
  function len(x: node_ort) return natural;
  function width(x: node_ort) return natural;
  function vectorify(x: node_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: node_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: node_ort) return node_ort;
  function convert(x: in std_logic_vector; t: node_ort) return node_ort;
  function nullify(t: node_ort) return node_ort;
  function zeroed(t: node_ort) return node_ort;

  subtype node_ovt is std_logic_vector(261-1 downto 0);

  type data_node_grt is record
    DATA_WIDTH : natural;
    COUNTER_WIDTH : natural;
    FIFO_DEPTH : natural;
  end record data_node_grt;
  function len(x: data_node_grt) return natural;
  function width(x: data_node_grt) return natural;
  function vectorify(x: data_node_grt; t: std_logic_vector) return std_logic_vector;
  function convert(x: data_node_grt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: data_node_grt) return data_node_grt;
  function convert(x: in std_logic_vector; t: data_node_grt) return data_node_grt;
  function nullify(t: data_node_grt) return data_node_grt;
  function zeroed(t: data_node_grt) return data_node_grt;

  type data_node_irt is record
    sys : daq_sys_rt;
    mngt : mngt_to_node_rt;
    req : req_to_row_common_rt;
    stream : daq_stream_rt;
    bconv : backward_rt;
  end record data_node_irt;
  function len(x: data_node_irt) return natural;
  function width(x: data_node_irt) return natural;
  function vectorify(x: data_node_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: data_node_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: data_node_irt) return data_node_irt;
  function convert(x: in std_logic_vector; t: data_node_irt) return data_node_irt;
  function nullify(t: data_node_irt) return data_node_irt;
  function zeroed(t: data_node_irt) return data_node_irt;

  subtype data_node_ort is node_ort;

  type data_node_ert is record
    i : data_node_irt;
    o : data_node_ort;
  end record data_node_ert;
  function len(x: data_node_ert) return natural;
  function width(x: data_node_ert) return natural;
  function vectorify(x: data_node_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: data_node_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: data_node_ert) return data_node_ert;
  function convert(x: in std_logic_vector; t: data_node_ert) return data_node_ert;
  function nullify(t: data_node_ert) return data_node_ert;
  function zeroed(t: data_node_ert) return data_node_ert;

  subtype data_node_ivt is std_logic_vector(300-1 downto 0);

  type header_node_grt is record
    COUNTER_WIDTH : natural;
  end record header_node_grt;
  function len(x: header_node_grt) return natural;
  function width(x: header_node_grt) return natural;
  function vectorify(x: header_node_grt; t: std_logic_vector) return std_logic_vector;
  function convert(x: header_node_grt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: header_node_grt) return header_node_grt;
  function convert(x: in std_logic_vector; t: header_node_grt) return header_node_grt;
  function nullify(t: header_node_grt) return header_node_grt;
  function zeroed(t: header_node_grt) return header_node_grt;

  type header_node_irt is record
    sys : daq_sys_rt;
    mngt : mngt_to_node_rt;
    req : req_to_row_rt;
    bconv : backward_rt;
  end record header_node_irt;
  function len(x: header_node_irt) return natural;
  function width(x: header_node_irt) return natural;
  function vectorify(x: header_node_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: header_node_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: header_node_irt) return header_node_irt;
  function convert(x: in std_logic_vector; t: header_node_irt) return header_node_irt;
  function nullify(t: header_node_irt) return header_node_irt;
  function zeroed(t: header_node_irt) return header_node_irt;

  subtype header_node_ort is node_ort;

  type header_node_ert is record
    i : header_node_irt;
    o : header_node_ort;
  end record header_node_ert;
  function len(x: header_node_ert) return natural;
  function width(x: header_node_ert) return natural;
  function vectorify(x: header_node_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: header_node_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: header_node_ert) return header_node_ert;
  function convert(x: in std_logic_vector; t: header_node_ert) return header_node_ert;
  function nullify(t: header_node_ert) return header_node_ert;
  function zeroed(t: header_node_ert) return header_node_ert;

  subtype header_node_ivt is std_logic_vector(122-1 downto 0);

  type bconv_grt is record
    INPUT_DATA_WIDTH : natural;
    OUTPUT_DATA_WIDTH : natural;
  end record bconv_grt;
  function len(x: bconv_grt) return natural;
  function width(x: bconv_grt) return natural;
  function vectorify(x: bconv_grt; t: std_logic_vector) return std_logic_vector;
  function convert(x: bconv_grt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: bconv_grt) return bconv_grt;
  function convert(x: in std_logic_vector; t: bconv_grt) return bconv_grt;
  function nullify(t: bconv_grt) return bconv_grt;
  function zeroed(t: bconv_grt) return bconv_grt;

  type bconv_irt is record
    sys : daq_sys_rt;
    node : forward_rt;
    pbldr : backward_rt;
  end record bconv_irt;
  function len(x: bconv_irt) return natural;
  function width(x: bconv_irt) return natural;
  function vectorify(x: bconv_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: bconv_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: bconv_irt) return bconv_irt;
  function convert(x: in std_logic_vector; t: bconv_irt) return bconv_irt;
  function nullify(t: bconv_irt) return bconv_irt;
  function zeroed(t: bconv_irt) return bconv_irt;

  type bconv_ort is record
    node : backward_rt;
    pbldr : forward_rt;
  end record bconv_ort;
  function len(x: bconv_ort) return natural;
  function width(x: bconv_ort) return natural;
  function vectorify(x: bconv_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: bconv_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: bconv_ort) return bconv_ort;
  function convert(x: in std_logic_vector; t: bconv_ort) return bconv_ort;
  function nullify(t: bconv_ort) return bconv_ort;
  function zeroed(t: bconv_ort) return bconv_ort;

  type bconv_ert is record
    i : bconv_irt;
    o : bconv_ort;
  end record bconv_ert;
  function len(x: bconv_ert) return natural;
  function width(x: bconv_ert) return natural;
  function vectorify(x: bconv_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: bconv_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: bconv_ert) return bconv_ert;
  function convert(x: in std_logic_vector; t: bconv_ert) return bconv_ert;
  function nullify(t: bconv_ert) return bconv_ert;
  function zeroed(t: bconv_ert) return bconv_ert;

  subtype bconv_ivt is std_logic_vector(260-1 downto 0);

  subtype bconv_ovt is std_logic_vector(258-1 downto 0);

  type hub_irt is record
    cnt : forward_rt;
    pld : forward_rt;
    dst : backward_rt;
  end record hub_irt;
  function len(x: hub_irt) return natural;
  function width(x: hub_irt) return natural;
  function vectorify(x: hub_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hub_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hub_irt) return hub_irt;
  function convert(x: in std_logic_vector; t: hub_irt) return hub_irt;
  function nullify(t: hub_irt) return hub_irt;
  function zeroed(t: hub_irt) return hub_irt;

  type hub_ort is record
    cnt : backward_rt;
    pld : backward_rt;
    dst : forward_rt;
  end record hub_ort;
  function len(x: hub_ort) return natural;
  function width(x: hub_ort) return natural;
  function vectorify(x: hub_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: hub_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hub_ort) return hub_ort;
  function convert(x: in std_logic_vector; t: hub_ort) return hub_ort;
  function nullify(t: hub_ort) return hub_ort;
  function zeroed(t: hub_ort) return hub_ort;

  type hub_ert is record
    i : hub_irt;
    o : hub_ort;
  end record hub_ert;
  function len(x: hub_ert) return natural;
  function width(x: hub_ert) return natural;
  function vectorify(x: hub_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: hub_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hub_ert) return hub_ert;
  function convert(x: in std_logic_vector; t: hub_ert) return hub_ert;
  function nullify(t: hub_ert) return hub_ert;
  function zeroed(t: hub_ert) return hub_ert;

  subtype hub_ivt is std_logic_vector(515-1 downto 0);

  subtype hub_ovt is std_logic_vector(259-1 downto 0);

end package daq_row_defs;

------------------------------------------------------------

package body daq_row_defs is

  function len(x: node_to_mngt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_ready);
    l := l + len(x.nempty);
    l := l + len(x.err);
    return l;
  end function len;
  function width(x: node_to_mngt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_ready);
    l := l + width(x.nempty);
    l := l + width(x.err);
    return l;
  end function width;
  function vectorify(x: node_to_mngt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_ready)-1), vectorify(x.data_ready, y(left to left+len(x.data_ready)-1)));
      left := left + len(x.data_ready);
      assign(y(left to left+len(x.nempty)-1), vectorify(x.nempty, y(left to left+len(x.nempty)-1)));
      left := left + len(x.nempty);
      assign(y(left to left+len(x.err)-1), vectorify(x.err, y(left to left+len(x.err)-1)));
    else
      assign(y(left downto left-len(x.data_ready)+1), vectorify(x.data_ready, y(left downto left-len(x.data_ready)+1)));
      left := left - len(x.data_ready);
      assign(y(left downto left-len(x.nempty)+1), vectorify(x.nempty, y(left downto left-len(x.nempty)+1)));
      left := left - len(x.nempty);
      assign(y(left downto left-len(x.err)+1), vectorify(x.err, y(left downto left-len(x.err)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: node_to_mngt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_ready)-1), convert(x.data_ready, y(left to left+len(x.data_ready)-1)));
      left := left + len(x.data_ready);
      assign(y(left to left+len(x.nempty)-1), convert(x.nempty, y(left to left+len(x.nempty)-1)));
      left := left + len(x.nempty);
      assign(y(left to left+len(x.err)-1), convert(x.err, y(left to left+len(x.err)-1)));
    else
      assign(y(left downto left-len(x.data_ready)+1), convert(x.data_ready, y(left downto left-len(x.data_ready)+1)));
      left := left - len(x.data_ready);
      assign(y(left downto left-len(x.nempty)+1), convert(x.nempty, y(left downto left-len(x.nempty)+1)));
      left := left - len(x.nempty);
      assign(y(left downto left-len(x.err)+1), convert(x.err, y(left downto left-len(x.err)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: node_to_mngt_rt) return node_to_mngt_rt is
    variable y: node_to_mngt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_ready := structify(x(left to left+len(y.data_ready)-1), y.data_ready);
      left := left + len(y.data_ready);
      y.nempty := structify(x(left to left+len(y.nempty)-1), y.nempty);
      left := left + len(y.nempty);
      y.err := structify(x(left to left+len(y.err)-1), y.err);
    else
      y.data_ready := structify(x(left downto left-len(y.data_ready)+1), y.data_ready);
      left := left - len(y.data_ready);
      y.nempty := structify(x(left downto left-len(y.nempty)+1), y.nempty);
      left := left - len(y.nempty);
      y.err := structify(x(left downto left-len(y.err)+1), y.err);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: node_to_mngt_rt) return node_to_mngt_rt is
    variable y: node_to_mngt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_ready := convert(x(left to left+len(y.data_ready)-1), y.data_ready);
      left := left + len(y.data_ready);
      y.nempty := convert(x(left to left+len(y.nempty)-1), y.nempty);
      left := left + len(y.nempty);
      y.err := convert(x(left to left+len(y.err)-1), y.err);
    else
      y.data_ready := convert(x(left downto left-len(y.data_ready)+1), y.data_ready);
      left := left - len(y.data_ready);
      y.nempty := convert(x(left downto left-len(y.nempty)+1), y.nempty);
      left := left - len(y.nempty);
      y.err := convert(x(left downto left-len(y.err)+1), y.err);
    end if;
    return y;
  end function convert;
  function nullify(t: node_to_mngt_rt) return node_to_mngt_rt is
  variable y: node_to_mngt_rt;
  begin
    y.data_ready := nullify(t.data_ready);
    y.nempty := nullify(t.nempty);
    y.err := nullify(t.err);
    return y;
  end function nullify;
  function zeroed(t: node_to_mngt_rt) return node_to_mngt_rt is
  variable y: node_to_mngt_rt;
  begin
    y.data_ready := zeroed(t.data_ready);
    y.nempty := zeroed(t.nempty);
    y.err := zeroed(t.err);
    return y;
  end function zeroed;

  function len(x: mngt_to_node_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.en);
    l := l + len(x.rd_en);
    return l;
  end function len;
  function width(x: mngt_to_node_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.en);
    l := l + width(x.rd_en);
    return l;
  end function width;
  function vectorify(x: mngt_to_node_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.en)-1), vectorify(x.en, y(left to left+len(x.en)-1)));
      left := left + len(x.en);
      assign(y(left to left+len(x.rd_en)-1), vectorify(x.rd_en, y(left to left+len(x.rd_en)-1)));
    else
      assign(y(left downto left-len(x.en)+1), vectorify(x.en, y(left downto left-len(x.en)+1)));
      left := left - len(x.en);
      assign(y(left downto left-len(x.rd_en)+1), vectorify(x.rd_en, y(left downto left-len(x.rd_en)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: mngt_to_node_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.en)-1), convert(x.en, y(left to left+len(x.en)-1)));
      left := left + len(x.en);
      assign(y(left to left+len(x.rd_en)-1), convert(x.rd_en, y(left to left+len(x.rd_en)-1)));
    else
      assign(y(left downto left-len(x.en)+1), convert(x.en, y(left downto left-len(x.en)+1)));
      left := left - len(x.en);
      assign(y(left downto left-len(x.rd_en)+1), convert(x.rd_en, y(left downto left-len(x.rd_en)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: mngt_to_node_rt) return mngt_to_node_rt is
    variable y: mngt_to_node_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.en := structify(x(left to left+len(y.en)-1), y.en);
      left := left + len(y.en);
      y.rd_en := structify(x(left to left+len(y.rd_en)-1), y.rd_en);
    else
      y.en := structify(x(left downto left-len(y.en)+1), y.en);
      left := left - len(y.en);
      y.rd_en := structify(x(left downto left-len(y.rd_en)+1), y.rd_en);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: mngt_to_node_rt) return mngt_to_node_rt is
    variable y: mngt_to_node_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.en := convert(x(left to left+len(y.en)-1), y.en);
      left := left + len(y.en);
      y.rd_en := convert(x(left to left+len(y.rd_en)-1), y.rd_en);
    else
      y.en := convert(x(left downto left-len(y.en)+1), y.en);
      left := left - len(y.en);
      y.rd_en := convert(x(left downto left-len(y.rd_en)+1), y.rd_en);
    end if;
    return y;
  end function convert;
  function nullify(t: mngt_to_node_rt) return mngt_to_node_rt is
  variable y: mngt_to_node_rt;
  begin
    y.en := nullify(t.en);
    y.rd_en := nullify(t.rd_en);
    return y;
  end function nullify;
  function zeroed(t: mngt_to_node_rt) return mngt_to_node_rt is
  variable y: mngt_to_node_rt;
  begin
    y.en := zeroed(t.en);
    y.rd_en := zeroed(t.rd_en);
    return y;
  end function zeroed;

  function len(x: src_to_node_fifo_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_en);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: src_to_node_fifo_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_en);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: src_to_node_fifo_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_en)-1), vectorify(x.wr_en, y(left to left+len(x.wr_en)-1)));
      left := left + len(x.wr_en);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.wr_en)+1), vectorify(x.wr_en, y(left downto left-len(x.wr_en)+1)));
      left := left - len(x.wr_en);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: src_to_node_fifo_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_en)-1), convert(x.wr_en, y(left to left+len(x.wr_en)-1)));
      left := left + len(x.wr_en);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.wr_en)+1), convert(x.wr_en, y(left downto left-len(x.wr_en)+1)));
      left := left - len(x.wr_en);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: src_to_node_fifo_rt) return src_to_node_fifo_rt is
    variable y: src_to_node_fifo_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_en := structify(x(left to left+len(y.wr_en)-1), y.wr_en);
      left := left + len(y.wr_en);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.wr_en := structify(x(left downto left-len(y.wr_en)+1), y.wr_en);
      left := left - len(y.wr_en);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: src_to_node_fifo_rt) return src_to_node_fifo_rt is
    variable y: src_to_node_fifo_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_en := convert(x(left to left+len(y.wr_en)-1), y.wr_en);
      left := left + len(y.wr_en);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.wr_en := convert(x(left downto left-len(y.wr_en)+1), y.wr_en);
      left := left - len(y.wr_en);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: src_to_node_fifo_rt) return src_to_node_fifo_rt is
  variable y: src_to_node_fifo_rt;
  begin
    y.wr_en := nullify(t.wr_en);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: src_to_node_fifo_rt) return src_to_node_fifo_rt is
  variable y: src_to_node_fifo_rt;
  begin
    y.wr_en := zeroed(t.wr_en);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: node_fifo_to_src_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.full);
    return l;
  end function len;
  function width(x: node_fifo_to_src_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.full);
    return l;
  end function width;
  function vectorify(x: node_fifo_to_src_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.full)-1), vectorify(x.full, y(left to left+len(x.full)-1)));
    else
      assign(y(left downto left-len(x.full)+1), vectorify(x.full, y(left downto left-len(x.full)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: node_fifo_to_src_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.full)-1), convert(x.full, y(left to left+len(x.full)-1)));
    else
      assign(y(left downto left-len(x.full)+1), convert(x.full, y(left downto left-len(x.full)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: node_fifo_to_src_rt) return node_fifo_to_src_rt is
    variable y: node_fifo_to_src_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.full := structify(x(left to left+len(y.full)-1), y.full);
    else
      y.full := structify(x(left downto left-len(y.full)+1), y.full);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: node_fifo_to_src_rt) return node_fifo_to_src_rt is
    variable y: node_fifo_to_src_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.full := convert(x(left to left+len(y.full)-1), y.full);
    else
      y.full := convert(x(left downto left-len(y.full)+1), y.full);
    end if;
    return y;
  end function convert;
  function nullify(t: node_fifo_to_src_rt) return node_fifo_to_src_rt is
  variable y: node_fifo_to_src_rt;
  begin
    y.full := nullify(t.full);
    return y;
  end function nullify;
  function zeroed(t: node_fifo_to_src_rt) return node_fifo_to_src_rt is
  variable y: node_fifo_to_src_rt;
  begin
    y.full := zeroed(t.full);
    return y;
  end function zeroed;

  function len(x: node_fifo_to_dst_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data);
    l := l + len(x.count);
    l := l + len(x.nempty);
    return l;
  end function len;
  function width(x: node_fifo_to_dst_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data);
    l := l + width(x.count);
    l := l + width(x.nempty);
    return l;
  end function width;
  function vectorify(x: node_fifo_to_dst_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
      left := left + len(x.data);
      assign(y(left to left+len(x.count)-1), vectorify(x.count, y(left to left+len(x.count)-1)));
      left := left + len(x.count);
      assign(y(left to left+len(x.nempty)-1), vectorify(x.nempty, y(left to left+len(x.nempty)-1)));
    else
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
      left := left - len(x.data);
      assign(y(left downto left-len(x.count)+1), vectorify(x.count, y(left downto left-len(x.count)+1)));
      left := left - len(x.count);
      assign(y(left downto left-len(x.nempty)+1), vectorify(x.nempty, y(left downto left-len(x.nempty)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: node_fifo_to_dst_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
      left := left + len(x.data);
      assign(y(left to left+len(x.count)-1), convert(x.count, y(left to left+len(x.count)-1)));
      left := left + len(x.count);
      assign(y(left to left+len(x.nempty)-1), convert(x.nempty, y(left to left+len(x.nempty)-1)));
    else
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
      left := left - len(x.data);
      assign(y(left downto left-len(x.count)+1), convert(x.count, y(left downto left-len(x.count)+1)));
      left := left - len(x.count);
      assign(y(left downto left-len(x.nempty)+1), convert(x.nempty, y(left downto left-len(x.nempty)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: node_fifo_to_dst_rt) return node_fifo_to_dst_rt is
    variable y: node_fifo_to_dst_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data := structify(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.count := structify(x(left to left+len(y.count)-1), y.count);
      left := left + len(y.count);
      y.nempty := structify(x(left to left+len(y.nempty)-1), y.nempty);
    else
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.count := structify(x(left downto left-len(y.count)+1), y.count);
      left := left - len(y.count);
      y.nempty := structify(x(left downto left-len(y.nempty)+1), y.nempty);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: node_fifo_to_dst_rt) return node_fifo_to_dst_rt is
    variable y: node_fifo_to_dst_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data := convert(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.count := convert(x(left to left+len(y.count)-1), y.count);
      left := left + len(y.count);
      y.nempty := convert(x(left to left+len(y.nempty)-1), y.nempty);
    else
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.count := convert(x(left downto left-len(y.count)+1), y.count);
      left := left - len(y.count);
      y.nempty := convert(x(left downto left-len(y.nempty)+1), y.nempty);
    end if;
    return y;
  end function convert;
  function nullify(t: node_fifo_to_dst_rt) return node_fifo_to_dst_rt is
  variable y: node_fifo_to_dst_rt;
  begin
    y.data := nullify(t.data);
    y.count := nullify(t.count);
    y.nempty := nullify(t.nempty);
    return y;
  end function nullify;
  function zeroed(t: node_fifo_to_dst_rt) return node_fifo_to_dst_rt is
  variable y: node_fifo_to_dst_rt;
  begin
    y.data := zeroed(t.data);
    y.count := zeroed(t.count);
    y.nempty := zeroed(t.nempty);
    return y;
  end function zeroed;

  function len(x: dst_to_node_fifo_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_en);
    return l;
  end function len;
  function width(x: dst_to_node_fifo_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_en);
    return l;
  end function width;
  function vectorify(x: dst_to_node_fifo_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_en)-1), vectorify(x.rd_en, y(left to left+len(x.rd_en)-1)));
    else
      assign(y(left downto left-len(x.rd_en)+1), vectorify(x.rd_en, y(left downto left-len(x.rd_en)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: dst_to_node_fifo_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_en)-1), convert(x.rd_en, y(left to left+len(x.rd_en)-1)));
    else
      assign(y(left downto left-len(x.rd_en)+1), convert(x.rd_en, y(left downto left-len(x.rd_en)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: dst_to_node_fifo_rt) return dst_to_node_fifo_rt is
    variable y: dst_to_node_fifo_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_en := structify(x(left to left+len(y.rd_en)-1), y.rd_en);
    else
      y.rd_en := structify(x(left downto left-len(y.rd_en)+1), y.rd_en);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: dst_to_node_fifo_rt) return dst_to_node_fifo_rt is
    variable y: dst_to_node_fifo_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_en := convert(x(left to left+len(y.rd_en)-1), y.rd_en);
    else
      y.rd_en := convert(x(left downto left-len(y.rd_en)+1), y.rd_en);
    end if;
    return y;
  end function convert;
  function nullify(t: dst_to_node_fifo_rt) return dst_to_node_fifo_rt is
  variable y: dst_to_node_fifo_rt;
  begin
    y.rd_en := nullify(t.rd_en);
    return y;
  end function nullify;
  function zeroed(t: dst_to_node_fifo_rt) return dst_to_node_fifo_rt is
  variable y: dst_to_node_fifo_rt;
  begin
    y.rd_en := zeroed(t.rd_en);
    return y;
  end function zeroed;

  function len(x: daq_node_fifo_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.src);
    l := l + len(x.dst);
    return l;
  end function len;
  function width(x: daq_node_fifo_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.src);
    l := l + width(x.dst);
    return l;
  end function width;
  function vectorify(x: daq_node_fifo_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.src)-1), vectorify(x.src, y(left to left+len(x.src)-1)));
      left := left + len(x.src);
      assign(y(left to left+len(x.dst)-1), vectorify(x.dst, y(left to left+len(x.dst)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.src)+1), vectorify(x.src, y(left downto left-len(x.src)+1)));
      left := left - len(x.src);
      assign(y(left downto left-len(x.dst)+1), vectorify(x.dst, y(left downto left-len(x.dst)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_node_fifo_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.src)-1), convert(x.src, y(left to left+len(x.src)-1)));
      left := left + len(x.src);
      assign(y(left to left+len(x.dst)-1), convert(x.dst, y(left to left+len(x.dst)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.src)+1), convert(x.src, y(left downto left-len(x.src)+1)));
      left := left - len(x.src);
      assign(y(left downto left-len(x.dst)+1), convert(x.dst, y(left downto left-len(x.dst)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_node_fifo_irt) return daq_node_fifo_irt is
    variable y: daq_node_fifo_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.src := structify(x(left to left+len(y.src)-1), y.src);
      left := left + len(y.src);
      y.dst := structify(x(left to left+len(y.dst)-1), y.dst);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.src := structify(x(left downto left-len(y.src)+1), y.src);
      left := left - len(y.src);
      y.dst := structify(x(left downto left-len(y.dst)+1), y.dst);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_node_fifo_irt) return daq_node_fifo_irt is
    variable y: daq_node_fifo_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.src := convert(x(left to left+len(y.src)-1), y.src);
      left := left + len(y.src);
      y.dst := convert(x(left to left+len(y.dst)-1), y.dst);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.src := convert(x(left downto left-len(y.src)+1), y.src);
      left := left - len(y.src);
      y.dst := convert(x(left downto left-len(y.dst)+1), y.dst);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_node_fifo_irt) return daq_node_fifo_irt is
  variable y: daq_node_fifo_irt;
  begin
    y.sys := nullify(t.sys);
    y.src := nullify(t.src);
    y.dst := nullify(t.dst);
    return y;
  end function nullify;
  function zeroed(t: daq_node_fifo_irt) return daq_node_fifo_irt is
  variable y: daq_node_fifo_irt;
  begin
    y.sys := zeroed(t.sys);
    y.src := zeroed(t.src);
    y.dst := zeroed(t.dst);
    return y;
  end function zeroed;

  function len(x: daq_node_fifo_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.src);
    l := l + len(x.dst);
    return l;
  end function len;
  function width(x: daq_node_fifo_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.src);
    l := l + width(x.dst);
    return l;
  end function width;
  function vectorify(x: daq_node_fifo_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.src)-1), vectorify(x.src, y(left to left+len(x.src)-1)));
      left := left + len(x.src);
      assign(y(left to left+len(x.dst)-1), vectorify(x.dst, y(left to left+len(x.dst)-1)));
    else
      assign(y(left downto left-len(x.src)+1), vectorify(x.src, y(left downto left-len(x.src)+1)));
      left := left - len(x.src);
      assign(y(left downto left-len(x.dst)+1), vectorify(x.dst, y(left downto left-len(x.dst)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_node_fifo_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.src)-1), convert(x.src, y(left to left+len(x.src)-1)));
      left := left + len(x.src);
      assign(y(left to left+len(x.dst)-1), convert(x.dst, y(left to left+len(x.dst)-1)));
    else
      assign(y(left downto left-len(x.src)+1), convert(x.src, y(left downto left-len(x.src)+1)));
      left := left - len(x.src);
      assign(y(left downto left-len(x.dst)+1), convert(x.dst, y(left downto left-len(x.dst)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_node_fifo_ort) return daq_node_fifo_ort is
    variable y: daq_node_fifo_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.src := structify(x(left to left+len(y.src)-1), y.src);
      left := left + len(y.src);
      y.dst := structify(x(left to left+len(y.dst)-1), y.dst);
    else
      y.src := structify(x(left downto left-len(y.src)+1), y.src);
      left := left - len(y.src);
      y.dst := structify(x(left downto left-len(y.dst)+1), y.dst);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_node_fifo_ort) return daq_node_fifo_ort is
    variable y: daq_node_fifo_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.src := convert(x(left to left+len(y.src)-1), y.src);
      left := left + len(y.src);
      y.dst := convert(x(left to left+len(y.dst)-1), y.dst);
    else
      y.src := convert(x(left downto left-len(y.src)+1), y.src);
      left := left - len(y.src);
      y.dst := convert(x(left downto left-len(y.dst)+1), y.dst);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_node_fifo_ort) return daq_node_fifo_ort is
  variable y: daq_node_fifo_ort;
  begin
    y.src := nullify(t.src);
    y.dst := nullify(t.dst);
    return y;
  end function nullify;
  function zeroed(t: daq_node_fifo_ort) return daq_node_fifo_ort is
  variable y: daq_node_fifo_ort;
  begin
    y.src := zeroed(t.src);
    y.dst := zeroed(t.dst);
    return y;
  end function zeroed;

  function len(x: daq_node_fifo_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: daq_node_fifo_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: daq_node_fifo_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_node_fifo_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_node_fifo_ert) return daq_node_fifo_ert is
    variable y: daq_node_fifo_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_node_fifo_ert) return daq_node_fifo_ert is
    variable y: daq_node_fifo_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_node_fifo_ert) return daq_node_fifo_ert is
  variable y: daq_node_fifo_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: daq_node_fifo_ert) return daq_node_fifo_ert is
  variable y: daq_node_fifo_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: daq_node_fifo_grt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.WRITE_DATA_WIDTH);
    l := l + len(x.READ_DATA_WIDTH);
    l := l + len(x.READ_COUNT_WIDTH);
    l := l + len(x.FIFO_DEPTH);
    return l;
  end function len;
  function width(x: daq_node_fifo_grt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.WRITE_DATA_WIDTH);
    l := l + width(x.READ_DATA_WIDTH);
    l := l + width(x.READ_COUNT_WIDTH);
    l := l + width(x.FIFO_DEPTH);
    return l;
  end function width;
  function vectorify(x: daq_node_fifo_grt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.WRITE_DATA_WIDTH)-1), vectorify(x.WRITE_DATA_WIDTH, y(left to left+len(x.WRITE_DATA_WIDTH)-1)));
      left := left + len(x.WRITE_DATA_WIDTH);
      assign(y(left to left+len(x.READ_DATA_WIDTH)-1), vectorify(x.READ_DATA_WIDTH, y(left to left+len(x.READ_DATA_WIDTH)-1)));
      left := left + len(x.READ_DATA_WIDTH);
      assign(y(left to left+len(x.READ_COUNT_WIDTH)-1), vectorify(x.READ_COUNT_WIDTH, y(left to left+len(x.READ_COUNT_WIDTH)-1)));
      left := left + len(x.READ_COUNT_WIDTH);
      assign(y(left to left+len(x.FIFO_DEPTH)-1), vectorify(x.FIFO_DEPTH, y(left to left+len(x.FIFO_DEPTH)-1)));
    else
      assign(y(left downto left-len(x.WRITE_DATA_WIDTH)+1), vectorify(x.WRITE_DATA_WIDTH, y(left downto left-len(x.WRITE_DATA_WIDTH)+1)));
      left := left - len(x.WRITE_DATA_WIDTH);
      assign(y(left downto left-len(x.READ_DATA_WIDTH)+1), vectorify(x.READ_DATA_WIDTH, y(left downto left-len(x.READ_DATA_WIDTH)+1)));
      left := left - len(x.READ_DATA_WIDTH);
      assign(y(left downto left-len(x.READ_COUNT_WIDTH)+1), vectorify(x.READ_COUNT_WIDTH, y(left downto left-len(x.READ_COUNT_WIDTH)+1)));
      left := left - len(x.READ_COUNT_WIDTH);
      assign(y(left downto left-len(x.FIFO_DEPTH)+1), vectorify(x.FIFO_DEPTH, y(left downto left-len(x.FIFO_DEPTH)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_node_fifo_grt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.WRITE_DATA_WIDTH)-1), convert(x.WRITE_DATA_WIDTH, y(left to left+len(x.WRITE_DATA_WIDTH)-1)));
      left := left + len(x.WRITE_DATA_WIDTH);
      assign(y(left to left+len(x.READ_DATA_WIDTH)-1), convert(x.READ_DATA_WIDTH, y(left to left+len(x.READ_DATA_WIDTH)-1)));
      left := left + len(x.READ_DATA_WIDTH);
      assign(y(left to left+len(x.READ_COUNT_WIDTH)-1), convert(x.READ_COUNT_WIDTH, y(left to left+len(x.READ_COUNT_WIDTH)-1)));
      left := left + len(x.READ_COUNT_WIDTH);
      assign(y(left to left+len(x.FIFO_DEPTH)-1), convert(x.FIFO_DEPTH, y(left to left+len(x.FIFO_DEPTH)-1)));
    else
      assign(y(left downto left-len(x.WRITE_DATA_WIDTH)+1), convert(x.WRITE_DATA_WIDTH, y(left downto left-len(x.WRITE_DATA_WIDTH)+1)));
      left := left - len(x.WRITE_DATA_WIDTH);
      assign(y(left downto left-len(x.READ_DATA_WIDTH)+1), convert(x.READ_DATA_WIDTH, y(left downto left-len(x.READ_DATA_WIDTH)+1)));
      left := left - len(x.READ_DATA_WIDTH);
      assign(y(left downto left-len(x.READ_COUNT_WIDTH)+1), convert(x.READ_COUNT_WIDTH, y(left downto left-len(x.READ_COUNT_WIDTH)+1)));
      left := left - len(x.READ_COUNT_WIDTH);
      assign(y(left downto left-len(x.FIFO_DEPTH)+1), convert(x.FIFO_DEPTH, y(left downto left-len(x.FIFO_DEPTH)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_node_fifo_grt) return daq_node_fifo_grt is
    variable y: daq_node_fifo_grt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.WRITE_DATA_WIDTH := structify(x(left to left+len(y.WRITE_DATA_WIDTH)-1), y.WRITE_DATA_WIDTH);
      left := left + len(y.WRITE_DATA_WIDTH);
      y.READ_DATA_WIDTH := structify(x(left to left+len(y.READ_DATA_WIDTH)-1), y.READ_DATA_WIDTH);
      left := left + len(y.READ_DATA_WIDTH);
      y.READ_COUNT_WIDTH := structify(x(left to left+len(y.READ_COUNT_WIDTH)-1), y.READ_COUNT_WIDTH);
      left := left + len(y.READ_COUNT_WIDTH);
      y.FIFO_DEPTH := structify(x(left to left+len(y.FIFO_DEPTH)-1), y.FIFO_DEPTH);
    else
      y.WRITE_DATA_WIDTH := structify(x(left downto left-len(y.WRITE_DATA_WIDTH)+1), y.WRITE_DATA_WIDTH);
      left := left - len(y.WRITE_DATA_WIDTH);
      y.READ_DATA_WIDTH := structify(x(left downto left-len(y.READ_DATA_WIDTH)+1), y.READ_DATA_WIDTH);
      left := left - len(y.READ_DATA_WIDTH);
      y.READ_COUNT_WIDTH := structify(x(left downto left-len(y.READ_COUNT_WIDTH)+1), y.READ_COUNT_WIDTH);
      left := left - len(y.READ_COUNT_WIDTH);
      y.FIFO_DEPTH := structify(x(left downto left-len(y.FIFO_DEPTH)+1), y.FIFO_DEPTH);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_node_fifo_grt) return daq_node_fifo_grt is
    variable y: daq_node_fifo_grt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.WRITE_DATA_WIDTH := convert(x(left to left+len(y.WRITE_DATA_WIDTH)-1), y.WRITE_DATA_WIDTH);
      left := left + len(y.WRITE_DATA_WIDTH);
      y.READ_DATA_WIDTH := convert(x(left to left+len(y.READ_DATA_WIDTH)-1), y.READ_DATA_WIDTH);
      left := left + len(y.READ_DATA_WIDTH);
      y.READ_COUNT_WIDTH := convert(x(left to left+len(y.READ_COUNT_WIDTH)-1), y.READ_COUNT_WIDTH);
      left := left + len(y.READ_COUNT_WIDTH);
      y.FIFO_DEPTH := convert(x(left to left+len(y.FIFO_DEPTH)-1), y.FIFO_DEPTH);
    else
      y.WRITE_DATA_WIDTH := convert(x(left downto left-len(y.WRITE_DATA_WIDTH)+1), y.WRITE_DATA_WIDTH);
      left := left - len(y.WRITE_DATA_WIDTH);
      y.READ_DATA_WIDTH := convert(x(left downto left-len(y.READ_DATA_WIDTH)+1), y.READ_DATA_WIDTH);
      left := left - len(y.READ_DATA_WIDTH);
      y.READ_COUNT_WIDTH := convert(x(left downto left-len(y.READ_COUNT_WIDTH)+1), y.READ_COUNT_WIDTH);
      left := left - len(y.READ_COUNT_WIDTH);
      y.FIFO_DEPTH := convert(x(left downto left-len(y.FIFO_DEPTH)+1), y.FIFO_DEPTH);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_node_fifo_grt) return daq_node_fifo_grt is
  variable y: daq_node_fifo_grt;
  begin
    y.WRITE_DATA_WIDTH := nullify(t.WRITE_DATA_WIDTH);
    y.READ_DATA_WIDTH := nullify(t.READ_DATA_WIDTH);
    y.READ_COUNT_WIDTH := nullify(t.READ_COUNT_WIDTH);
    y.FIFO_DEPTH := nullify(t.FIFO_DEPTH);
    return y;
  end function nullify;
  function zeroed(t: daq_node_fifo_grt) return daq_node_fifo_grt is
  variable y: daq_node_fifo_grt;
  begin
    y.WRITE_DATA_WIDTH := zeroed(t.WRITE_DATA_WIDTH);
    y.READ_DATA_WIDTH := zeroed(t.READ_DATA_WIDTH);
    y.READ_COUNT_WIDTH := zeroed(t.READ_COUNT_WIDTH);
    y.FIFO_DEPTH := zeroed(t.FIFO_DEPTH);
    return y;
  end function zeroed;

  function len(x: node_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.mngt);
    l := l + len(x.bconv);
    l := l + len(x.debug);
    return l;
  end function len;
  function width(x: node_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.mngt);
    l := l + width(x.bconv);
    l := l + width(x.debug);
    return l;
  end function width;
  function vectorify(x: node_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.mngt)-1), vectorify(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.bconv)-1), vectorify(x.bconv, y(left to left+len(x.bconv)-1)));
      left := left + len(x.bconv);
      assign(y(left to left+len(x.debug)-1), vectorify(x.debug, y(left to left+len(x.debug)-1)));
    else
      assign(y(left downto left-len(x.mngt)+1), vectorify(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.bconv)+1), vectorify(x.bconv, y(left downto left-len(x.bconv)+1)));
      left := left - len(x.bconv);
      assign(y(left downto left-len(x.debug)+1), vectorify(x.debug, y(left downto left-len(x.debug)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: node_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.mngt)-1), convert(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.bconv)-1), convert(x.bconv, y(left to left+len(x.bconv)-1)));
      left := left + len(x.bconv);
      assign(y(left to left+len(x.debug)-1), convert(x.debug, y(left to left+len(x.debug)-1)));
    else
      assign(y(left downto left-len(x.mngt)+1), convert(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.bconv)+1), convert(x.bconv, y(left downto left-len(x.bconv)+1)));
      left := left - len(x.bconv);
      assign(y(left downto left-len(x.debug)+1), convert(x.debug, y(left downto left-len(x.debug)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: node_ort) return node_ort is
    variable y: node_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.mngt := structify(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.bconv := structify(x(left to left+len(y.bconv)-1), y.bconv);
      left := left + len(y.bconv);
      y.debug := structify(x(left to left+len(y.debug)-1), y.debug);
    else
      y.mngt := structify(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.bconv := structify(x(left downto left-len(y.bconv)+1), y.bconv);
      left := left - len(y.bconv);
      y.debug := structify(x(left downto left-len(y.debug)+1), y.debug);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: node_ort) return node_ort is
    variable y: node_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.mngt := convert(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.bconv := convert(x(left to left+len(y.bconv)-1), y.bconv);
      left := left + len(y.bconv);
      y.debug := convert(x(left to left+len(y.debug)-1), y.debug);
    else
      y.mngt := convert(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.bconv := convert(x(left downto left-len(y.bconv)+1), y.bconv);
      left := left - len(y.bconv);
      y.debug := convert(x(left downto left-len(y.debug)+1), y.debug);
    end if;
    return y;
  end function convert;
  function nullify(t: node_ort) return node_ort is
  variable y: node_ort;
  begin
    y.mngt := nullify(t.mngt);
    y.bconv := nullify(t.bconv);
    y.debug := nullify(t.debug);
    return y;
  end function nullify;
  function zeroed(t: node_ort) return node_ort is
  variable y: node_ort;
  begin
    y.mngt := zeroed(t.mngt);
    y.bconv := zeroed(t.bconv);
    y.debug := zeroed(t.debug);
    return y;
  end function zeroed;

  function len(x: data_node_grt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.DATA_WIDTH);
    l := l + len(x.COUNTER_WIDTH);
    l := l + len(x.FIFO_DEPTH);
    return l;
  end function len;
  function width(x: data_node_grt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.DATA_WIDTH);
    l := l + width(x.COUNTER_WIDTH);
    l := l + width(x.FIFO_DEPTH);
    return l;
  end function width;
  function vectorify(x: data_node_grt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.DATA_WIDTH)-1), vectorify(x.DATA_WIDTH, y(left to left+len(x.DATA_WIDTH)-1)));
      left := left + len(x.DATA_WIDTH);
      assign(y(left to left+len(x.COUNTER_WIDTH)-1), vectorify(x.COUNTER_WIDTH, y(left to left+len(x.COUNTER_WIDTH)-1)));
      left := left + len(x.COUNTER_WIDTH);
      assign(y(left to left+len(x.FIFO_DEPTH)-1), vectorify(x.FIFO_DEPTH, y(left to left+len(x.FIFO_DEPTH)-1)));
    else
      assign(y(left downto left-len(x.DATA_WIDTH)+1), vectorify(x.DATA_WIDTH, y(left downto left-len(x.DATA_WIDTH)+1)));
      left := left - len(x.DATA_WIDTH);
      assign(y(left downto left-len(x.COUNTER_WIDTH)+1), vectorify(x.COUNTER_WIDTH, y(left downto left-len(x.COUNTER_WIDTH)+1)));
      left := left - len(x.COUNTER_WIDTH);
      assign(y(left downto left-len(x.FIFO_DEPTH)+1), vectorify(x.FIFO_DEPTH, y(left downto left-len(x.FIFO_DEPTH)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: data_node_grt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.DATA_WIDTH)-1), convert(x.DATA_WIDTH, y(left to left+len(x.DATA_WIDTH)-1)));
      left := left + len(x.DATA_WIDTH);
      assign(y(left to left+len(x.COUNTER_WIDTH)-1), convert(x.COUNTER_WIDTH, y(left to left+len(x.COUNTER_WIDTH)-1)));
      left := left + len(x.COUNTER_WIDTH);
      assign(y(left to left+len(x.FIFO_DEPTH)-1), convert(x.FIFO_DEPTH, y(left to left+len(x.FIFO_DEPTH)-1)));
    else
      assign(y(left downto left-len(x.DATA_WIDTH)+1), convert(x.DATA_WIDTH, y(left downto left-len(x.DATA_WIDTH)+1)));
      left := left - len(x.DATA_WIDTH);
      assign(y(left downto left-len(x.COUNTER_WIDTH)+1), convert(x.COUNTER_WIDTH, y(left downto left-len(x.COUNTER_WIDTH)+1)));
      left := left - len(x.COUNTER_WIDTH);
      assign(y(left downto left-len(x.FIFO_DEPTH)+1), convert(x.FIFO_DEPTH, y(left downto left-len(x.FIFO_DEPTH)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: data_node_grt) return data_node_grt is
    variable y: data_node_grt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.DATA_WIDTH := structify(x(left to left+len(y.DATA_WIDTH)-1), y.DATA_WIDTH);
      left := left + len(y.DATA_WIDTH);
      y.COUNTER_WIDTH := structify(x(left to left+len(y.COUNTER_WIDTH)-1), y.COUNTER_WIDTH);
      left := left + len(y.COUNTER_WIDTH);
      y.FIFO_DEPTH := structify(x(left to left+len(y.FIFO_DEPTH)-1), y.FIFO_DEPTH);
    else
      y.DATA_WIDTH := structify(x(left downto left-len(y.DATA_WIDTH)+1), y.DATA_WIDTH);
      left := left - len(y.DATA_WIDTH);
      y.COUNTER_WIDTH := structify(x(left downto left-len(y.COUNTER_WIDTH)+1), y.COUNTER_WIDTH);
      left := left - len(y.COUNTER_WIDTH);
      y.FIFO_DEPTH := structify(x(left downto left-len(y.FIFO_DEPTH)+1), y.FIFO_DEPTH);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: data_node_grt) return data_node_grt is
    variable y: data_node_grt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.DATA_WIDTH := convert(x(left to left+len(y.DATA_WIDTH)-1), y.DATA_WIDTH);
      left := left + len(y.DATA_WIDTH);
      y.COUNTER_WIDTH := convert(x(left to left+len(y.COUNTER_WIDTH)-1), y.COUNTER_WIDTH);
      left := left + len(y.COUNTER_WIDTH);
      y.FIFO_DEPTH := convert(x(left to left+len(y.FIFO_DEPTH)-1), y.FIFO_DEPTH);
    else
      y.DATA_WIDTH := convert(x(left downto left-len(y.DATA_WIDTH)+1), y.DATA_WIDTH);
      left := left - len(y.DATA_WIDTH);
      y.COUNTER_WIDTH := convert(x(left downto left-len(y.COUNTER_WIDTH)+1), y.COUNTER_WIDTH);
      left := left - len(y.COUNTER_WIDTH);
      y.FIFO_DEPTH := convert(x(left downto left-len(y.FIFO_DEPTH)+1), y.FIFO_DEPTH);
    end if;
    return y;
  end function convert;
  function nullify(t: data_node_grt) return data_node_grt is
  variable y: data_node_grt;
  begin
    y.DATA_WIDTH := nullify(t.DATA_WIDTH);
    y.COUNTER_WIDTH := nullify(t.COUNTER_WIDTH);
    y.FIFO_DEPTH := nullify(t.FIFO_DEPTH);
    return y;
  end function nullify;
  function zeroed(t: data_node_grt) return data_node_grt is
  variable y: data_node_grt;
  begin
    y.DATA_WIDTH := zeroed(t.DATA_WIDTH);
    y.COUNTER_WIDTH := zeroed(t.COUNTER_WIDTH);
    y.FIFO_DEPTH := zeroed(t.FIFO_DEPTH);
    return y;
  end function zeroed;

  function len(x: data_node_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.mngt);
    l := l + len(x.req);
    l := l + len(x.stream);
    l := l + len(x.bconv);
    return l;
  end function len;
  function width(x: data_node_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.mngt);
    l := l + width(x.req);
    l := l + width(x.stream);
    l := l + width(x.bconv);
    return l;
  end function width;
  function vectorify(x: data_node_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), vectorify(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.req)-1), vectorify(x.req, y(left to left+len(x.req)-1)));
      left := left + len(x.req);
      assign(y(left to left+len(x.stream)-1), vectorify(x.stream, y(left to left+len(x.stream)-1)));
      left := left + len(x.stream);
      assign(y(left to left+len(x.bconv)-1), vectorify(x.bconv, y(left to left+len(x.bconv)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), vectorify(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.req)+1), vectorify(x.req, y(left downto left-len(x.req)+1)));
      left := left - len(x.req);
      assign(y(left downto left-len(x.stream)+1), vectorify(x.stream, y(left downto left-len(x.stream)+1)));
      left := left - len(x.stream);
      assign(y(left downto left-len(x.bconv)+1), vectorify(x.bconv, y(left downto left-len(x.bconv)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: data_node_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), convert(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.req)-1), convert(x.req, y(left to left+len(x.req)-1)));
      left := left + len(x.req);
      assign(y(left to left+len(x.stream)-1), convert(x.stream, y(left to left+len(x.stream)-1)));
      left := left + len(x.stream);
      assign(y(left to left+len(x.bconv)-1), convert(x.bconv, y(left to left+len(x.bconv)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), convert(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.req)+1), convert(x.req, y(left downto left-len(x.req)+1)));
      left := left - len(x.req);
      assign(y(left downto left-len(x.stream)+1), convert(x.stream, y(left downto left-len(x.stream)+1)));
      left := left - len(x.stream);
      assign(y(left downto left-len(x.bconv)+1), convert(x.bconv, y(left downto left-len(x.bconv)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: data_node_irt) return data_node_irt is
    variable y: data_node_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := structify(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.req := structify(x(left to left+len(y.req)-1), y.req);
      left := left + len(y.req);
      y.stream := structify(x(left to left+len(y.stream)-1), y.stream);
      left := left + len(y.stream);
      y.bconv := structify(x(left to left+len(y.bconv)-1), y.bconv);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := structify(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.req := structify(x(left downto left-len(y.req)+1), y.req);
      left := left - len(y.req);
      y.stream := structify(x(left downto left-len(y.stream)+1), y.stream);
      left := left - len(y.stream);
      y.bconv := structify(x(left downto left-len(y.bconv)+1), y.bconv);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: data_node_irt) return data_node_irt is
    variable y: data_node_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := convert(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.req := convert(x(left to left+len(y.req)-1), y.req);
      left := left + len(y.req);
      y.stream := convert(x(left to left+len(y.stream)-1), y.stream);
      left := left + len(y.stream);
      y.bconv := convert(x(left to left+len(y.bconv)-1), y.bconv);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := convert(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.req := convert(x(left downto left-len(y.req)+1), y.req);
      left := left - len(y.req);
      y.stream := convert(x(left downto left-len(y.stream)+1), y.stream);
      left := left - len(y.stream);
      y.bconv := convert(x(left downto left-len(y.bconv)+1), y.bconv);
    end if;
    return y;
  end function convert;
  function nullify(t: data_node_irt) return data_node_irt is
  variable y: data_node_irt;
  begin
    y.sys := nullify(t.sys);
    y.mngt := nullify(t.mngt);
    y.req := nullify(t.req);
    y.stream := nullify(t.stream);
    y.bconv := nullify(t.bconv);
    return y;
  end function nullify;
  function zeroed(t: data_node_irt) return data_node_irt is
  variable y: data_node_irt;
  begin
    y.sys := zeroed(t.sys);
    y.mngt := zeroed(t.mngt);
    y.req := zeroed(t.req);
    y.stream := zeroed(t.stream);
    y.bconv := zeroed(t.bconv);
    return y;
  end function zeroed;

  function len(x: data_node_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: data_node_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: data_node_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: data_node_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: data_node_ert) return data_node_ert is
    variable y: data_node_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: data_node_ert) return data_node_ert is
    variable y: data_node_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: data_node_ert) return data_node_ert is
  variable y: data_node_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: data_node_ert) return data_node_ert is
  variable y: data_node_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: header_node_grt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.COUNTER_WIDTH);
    return l;
  end function len;
  function width(x: header_node_grt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.COUNTER_WIDTH);
    return l;
  end function width;
  function vectorify(x: header_node_grt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.COUNTER_WIDTH)-1), vectorify(x.COUNTER_WIDTH, y(left to left+len(x.COUNTER_WIDTH)-1)));
    else
      assign(y(left downto left-len(x.COUNTER_WIDTH)+1), vectorify(x.COUNTER_WIDTH, y(left downto left-len(x.COUNTER_WIDTH)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: header_node_grt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.COUNTER_WIDTH)-1), convert(x.COUNTER_WIDTH, y(left to left+len(x.COUNTER_WIDTH)-1)));
    else
      assign(y(left downto left-len(x.COUNTER_WIDTH)+1), convert(x.COUNTER_WIDTH, y(left downto left-len(x.COUNTER_WIDTH)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: header_node_grt) return header_node_grt is
    variable y: header_node_grt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.COUNTER_WIDTH := structify(x(left to left+len(y.COUNTER_WIDTH)-1), y.COUNTER_WIDTH);
    else
      y.COUNTER_WIDTH := structify(x(left downto left-len(y.COUNTER_WIDTH)+1), y.COUNTER_WIDTH);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: header_node_grt) return header_node_grt is
    variable y: header_node_grt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.COUNTER_WIDTH := convert(x(left to left+len(y.COUNTER_WIDTH)-1), y.COUNTER_WIDTH);
    else
      y.COUNTER_WIDTH := convert(x(left downto left-len(y.COUNTER_WIDTH)+1), y.COUNTER_WIDTH);
    end if;
    return y;
  end function convert;
  function nullify(t: header_node_grt) return header_node_grt is
  variable y: header_node_grt;
  begin
    y.COUNTER_WIDTH := nullify(t.COUNTER_WIDTH);
    return y;
  end function nullify;
  function zeroed(t: header_node_grt) return header_node_grt is
  variable y: header_node_grt;
  begin
    y.COUNTER_WIDTH := zeroed(t.COUNTER_WIDTH);
    return y;
  end function zeroed;

  function len(x: header_node_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.mngt);
    l := l + len(x.req);
    l := l + len(x.bconv);
    return l;
  end function len;
  function width(x: header_node_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.mngt);
    l := l + width(x.req);
    l := l + width(x.bconv);
    return l;
  end function width;
  function vectorify(x: header_node_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), vectorify(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.req)-1), vectorify(x.req, y(left to left+len(x.req)-1)));
      left := left + len(x.req);
      assign(y(left to left+len(x.bconv)-1), vectorify(x.bconv, y(left to left+len(x.bconv)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), vectorify(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.req)+1), vectorify(x.req, y(left downto left-len(x.req)+1)));
      left := left - len(x.req);
      assign(y(left downto left-len(x.bconv)+1), vectorify(x.bconv, y(left downto left-len(x.bconv)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: header_node_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), convert(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.req)-1), convert(x.req, y(left to left+len(x.req)-1)));
      left := left + len(x.req);
      assign(y(left to left+len(x.bconv)-1), convert(x.bconv, y(left to left+len(x.bconv)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), convert(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.req)+1), convert(x.req, y(left downto left-len(x.req)+1)));
      left := left - len(x.req);
      assign(y(left downto left-len(x.bconv)+1), convert(x.bconv, y(left downto left-len(x.bconv)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: header_node_irt) return header_node_irt is
    variable y: header_node_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := structify(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.req := structify(x(left to left+len(y.req)-1), y.req);
      left := left + len(y.req);
      y.bconv := structify(x(left to left+len(y.bconv)-1), y.bconv);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := structify(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.req := structify(x(left downto left-len(y.req)+1), y.req);
      left := left - len(y.req);
      y.bconv := structify(x(left downto left-len(y.bconv)+1), y.bconv);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: header_node_irt) return header_node_irt is
    variable y: header_node_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := convert(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.req := convert(x(left to left+len(y.req)-1), y.req);
      left := left + len(y.req);
      y.bconv := convert(x(left to left+len(y.bconv)-1), y.bconv);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := convert(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.req := convert(x(left downto left-len(y.req)+1), y.req);
      left := left - len(y.req);
      y.bconv := convert(x(left downto left-len(y.bconv)+1), y.bconv);
    end if;
    return y;
  end function convert;
  function nullify(t: header_node_irt) return header_node_irt is
  variable y: header_node_irt;
  begin
    y.sys := nullify(t.sys);
    y.mngt := nullify(t.mngt);
    y.req := nullify(t.req);
    y.bconv := nullify(t.bconv);
    return y;
  end function nullify;
  function zeroed(t: header_node_irt) return header_node_irt is
  variable y: header_node_irt;
  begin
    y.sys := zeroed(t.sys);
    y.mngt := zeroed(t.mngt);
    y.req := zeroed(t.req);
    y.bconv := zeroed(t.bconv);
    return y;
  end function zeroed;

  function len(x: header_node_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: header_node_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: header_node_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: header_node_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: header_node_ert) return header_node_ert is
    variable y: header_node_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: header_node_ert) return header_node_ert is
    variable y: header_node_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: header_node_ert) return header_node_ert is
  variable y: header_node_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: header_node_ert) return header_node_ert is
  variable y: header_node_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: bconv_grt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.INPUT_DATA_WIDTH);
    l := l + len(x.OUTPUT_DATA_WIDTH);
    return l;
  end function len;
  function width(x: bconv_grt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.INPUT_DATA_WIDTH);
    l := l + width(x.OUTPUT_DATA_WIDTH);
    return l;
  end function width;
  function vectorify(x: bconv_grt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.INPUT_DATA_WIDTH)-1), vectorify(x.INPUT_DATA_WIDTH, y(left to left+len(x.INPUT_DATA_WIDTH)-1)));
      left := left + len(x.INPUT_DATA_WIDTH);
      assign(y(left to left+len(x.OUTPUT_DATA_WIDTH)-1), vectorify(x.OUTPUT_DATA_WIDTH, y(left to left+len(x.OUTPUT_DATA_WIDTH)-1)));
    else
      assign(y(left downto left-len(x.INPUT_DATA_WIDTH)+1), vectorify(x.INPUT_DATA_WIDTH, y(left downto left-len(x.INPUT_DATA_WIDTH)+1)));
      left := left - len(x.INPUT_DATA_WIDTH);
      assign(y(left downto left-len(x.OUTPUT_DATA_WIDTH)+1), vectorify(x.OUTPUT_DATA_WIDTH, y(left downto left-len(x.OUTPUT_DATA_WIDTH)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: bconv_grt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.INPUT_DATA_WIDTH)-1), convert(x.INPUT_DATA_WIDTH, y(left to left+len(x.INPUT_DATA_WIDTH)-1)));
      left := left + len(x.INPUT_DATA_WIDTH);
      assign(y(left to left+len(x.OUTPUT_DATA_WIDTH)-1), convert(x.OUTPUT_DATA_WIDTH, y(left to left+len(x.OUTPUT_DATA_WIDTH)-1)));
    else
      assign(y(left downto left-len(x.INPUT_DATA_WIDTH)+1), convert(x.INPUT_DATA_WIDTH, y(left downto left-len(x.INPUT_DATA_WIDTH)+1)));
      left := left - len(x.INPUT_DATA_WIDTH);
      assign(y(left downto left-len(x.OUTPUT_DATA_WIDTH)+1), convert(x.OUTPUT_DATA_WIDTH, y(left downto left-len(x.OUTPUT_DATA_WIDTH)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: bconv_grt) return bconv_grt is
    variable y: bconv_grt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.INPUT_DATA_WIDTH := structify(x(left to left+len(y.INPUT_DATA_WIDTH)-1), y.INPUT_DATA_WIDTH);
      left := left + len(y.INPUT_DATA_WIDTH);
      y.OUTPUT_DATA_WIDTH := structify(x(left to left+len(y.OUTPUT_DATA_WIDTH)-1), y.OUTPUT_DATA_WIDTH);
    else
      y.INPUT_DATA_WIDTH := structify(x(left downto left-len(y.INPUT_DATA_WIDTH)+1), y.INPUT_DATA_WIDTH);
      left := left - len(y.INPUT_DATA_WIDTH);
      y.OUTPUT_DATA_WIDTH := structify(x(left downto left-len(y.OUTPUT_DATA_WIDTH)+1), y.OUTPUT_DATA_WIDTH);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: bconv_grt) return bconv_grt is
    variable y: bconv_grt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.INPUT_DATA_WIDTH := convert(x(left to left+len(y.INPUT_DATA_WIDTH)-1), y.INPUT_DATA_WIDTH);
      left := left + len(y.INPUT_DATA_WIDTH);
      y.OUTPUT_DATA_WIDTH := convert(x(left to left+len(y.OUTPUT_DATA_WIDTH)-1), y.OUTPUT_DATA_WIDTH);
    else
      y.INPUT_DATA_WIDTH := convert(x(left downto left-len(y.INPUT_DATA_WIDTH)+1), y.INPUT_DATA_WIDTH);
      left := left - len(y.INPUT_DATA_WIDTH);
      y.OUTPUT_DATA_WIDTH := convert(x(left downto left-len(y.OUTPUT_DATA_WIDTH)+1), y.OUTPUT_DATA_WIDTH);
    end if;
    return y;
  end function convert;
  function nullify(t: bconv_grt) return bconv_grt is
  variable y: bconv_grt;
  begin
    y.INPUT_DATA_WIDTH := nullify(t.INPUT_DATA_WIDTH);
    y.OUTPUT_DATA_WIDTH := nullify(t.OUTPUT_DATA_WIDTH);
    return y;
  end function nullify;
  function zeroed(t: bconv_grt) return bconv_grt is
  variable y: bconv_grt;
  begin
    y.INPUT_DATA_WIDTH := zeroed(t.INPUT_DATA_WIDTH);
    y.OUTPUT_DATA_WIDTH := zeroed(t.OUTPUT_DATA_WIDTH);
    return y;
  end function zeroed;

  function len(x: bconv_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.node);
    l := l + len(x.pbldr);
    return l;
  end function len;
  function width(x: bconv_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.node);
    l := l + width(x.pbldr);
    return l;
  end function width;
  function vectorify(x: bconv_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.node)-1), vectorify(x.node, y(left to left+len(x.node)-1)));
      left := left + len(x.node);
      assign(y(left to left+len(x.pbldr)-1), vectorify(x.pbldr, y(left to left+len(x.pbldr)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.node)+1), vectorify(x.node, y(left downto left-len(x.node)+1)));
      left := left - len(x.node);
      assign(y(left downto left-len(x.pbldr)+1), vectorify(x.pbldr, y(left downto left-len(x.pbldr)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: bconv_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.node)-1), convert(x.node, y(left to left+len(x.node)-1)));
      left := left + len(x.node);
      assign(y(left to left+len(x.pbldr)-1), convert(x.pbldr, y(left to left+len(x.pbldr)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.node)+1), convert(x.node, y(left downto left-len(x.node)+1)));
      left := left - len(x.node);
      assign(y(left downto left-len(x.pbldr)+1), convert(x.pbldr, y(left downto left-len(x.pbldr)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: bconv_irt) return bconv_irt is
    variable y: bconv_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.node := structify(x(left to left+len(y.node)-1), y.node);
      left := left + len(y.node);
      y.pbldr := structify(x(left to left+len(y.pbldr)-1), y.pbldr);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.node := structify(x(left downto left-len(y.node)+1), y.node);
      left := left - len(y.node);
      y.pbldr := structify(x(left downto left-len(y.pbldr)+1), y.pbldr);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: bconv_irt) return bconv_irt is
    variable y: bconv_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.node := convert(x(left to left+len(y.node)-1), y.node);
      left := left + len(y.node);
      y.pbldr := convert(x(left to left+len(y.pbldr)-1), y.pbldr);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.node := convert(x(left downto left-len(y.node)+1), y.node);
      left := left - len(y.node);
      y.pbldr := convert(x(left downto left-len(y.pbldr)+1), y.pbldr);
    end if;
    return y;
  end function convert;
  function nullify(t: bconv_irt) return bconv_irt is
  variable y: bconv_irt;
  begin
    y.sys := nullify(t.sys);
    y.node := nullify(t.node);
    y.pbldr := nullify(t.pbldr);
    return y;
  end function nullify;
  function zeroed(t: bconv_irt) return bconv_irt is
  variable y: bconv_irt;
  begin
    y.sys := zeroed(t.sys);
    y.node := zeroed(t.node);
    y.pbldr := zeroed(t.pbldr);
    return y;
  end function zeroed;

  function len(x: bconv_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.node);
    l := l + len(x.pbldr);
    return l;
  end function len;
  function width(x: bconv_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.node);
    l := l + width(x.pbldr);
    return l;
  end function width;
  function vectorify(x: bconv_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.node)-1), vectorify(x.node, y(left to left+len(x.node)-1)));
      left := left + len(x.node);
      assign(y(left to left+len(x.pbldr)-1), vectorify(x.pbldr, y(left to left+len(x.pbldr)-1)));
    else
      assign(y(left downto left-len(x.node)+1), vectorify(x.node, y(left downto left-len(x.node)+1)));
      left := left - len(x.node);
      assign(y(left downto left-len(x.pbldr)+1), vectorify(x.pbldr, y(left downto left-len(x.pbldr)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: bconv_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.node)-1), convert(x.node, y(left to left+len(x.node)-1)));
      left := left + len(x.node);
      assign(y(left to left+len(x.pbldr)-1), convert(x.pbldr, y(left to left+len(x.pbldr)-1)));
    else
      assign(y(left downto left-len(x.node)+1), convert(x.node, y(left downto left-len(x.node)+1)));
      left := left - len(x.node);
      assign(y(left downto left-len(x.pbldr)+1), convert(x.pbldr, y(left downto left-len(x.pbldr)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: bconv_ort) return bconv_ort is
    variable y: bconv_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.node := structify(x(left to left+len(y.node)-1), y.node);
      left := left + len(y.node);
      y.pbldr := structify(x(left to left+len(y.pbldr)-1), y.pbldr);
    else
      y.node := structify(x(left downto left-len(y.node)+1), y.node);
      left := left - len(y.node);
      y.pbldr := structify(x(left downto left-len(y.pbldr)+1), y.pbldr);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: bconv_ort) return bconv_ort is
    variable y: bconv_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.node := convert(x(left to left+len(y.node)-1), y.node);
      left := left + len(y.node);
      y.pbldr := convert(x(left to left+len(y.pbldr)-1), y.pbldr);
    else
      y.node := convert(x(left downto left-len(y.node)+1), y.node);
      left := left - len(y.node);
      y.pbldr := convert(x(left downto left-len(y.pbldr)+1), y.pbldr);
    end if;
    return y;
  end function convert;
  function nullify(t: bconv_ort) return bconv_ort is
  variable y: bconv_ort;
  begin
    y.node := nullify(t.node);
    y.pbldr := nullify(t.pbldr);
    return y;
  end function nullify;
  function zeroed(t: bconv_ort) return bconv_ort is
  variable y: bconv_ort;
  begin
    y.node := zeroed(t.node);
    y.pbldr := zeroed(t.pbldr);
    return y;
  end function zeroed;

  function len(x: bconv_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: bconv_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: bconv_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: bconv_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: bconv_ert) return bconv_ert is
    variable y: bconv_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: bconv_ert) return bconv_ert is
    variable y: bconv_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: bconv_ert) return bconv_ert is
  variable y: bconv_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: bconv_ert) return bconv_ert is
  variable y: bconv_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: hub_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.cnt);
    l := l + len(x.pld);
    l := l + len(x.dst);
    return l;
  end function len;
  function width(x: hub_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.cnt);
    l := l + width(x.pld);
    l := l + width(x.dst);
    return l;
  end function width;
  function vectorify(x: hub_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.cnt)-1), vectorify(x.cnt, y(left to left+len(x.cnt)-1)));
      left := left + len(x.cnt);
      assign(y(left to left+len(x.pld)-1), vectorify(x.pld, y(left to left+len(x.pld)-1)));
      left := left + len(x.pld);
      assign(y(left to left+len(x.dst)-1), vectorify(x.dst, y(left to left+len(x.dst)-1)));
    else
      assign(y(left downto left-len(x.cnt)+1), vectorify(x.cnt, y(left downto left-len(x.cnt)+1)));
      left := left - len(x.cnt);
      assign(y(left downto left-len(x.pld)+1), vectorify(x.pld, y(left downto left-len(x.pld)+1)));
      left := left - len(x.pld);
      assign(y(left downto left-len(x.dst)+1), vectorify(x.dst, y(left downto left-len(x.dst)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hub_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.cnt)-1), convert(x.cnt, y(left to left+len(x.cnt)-1)));
      left := left + len(x.cnt);
      assign(y(left to left+len(x.pld)-1), convert(x.pld, y(left to left+len(x.pld)-1)));
      left := left + len(x.pld);
      assign(y(left to left+len(x.dst)-1), convert(x.dst, y(left to left+len(x.dst)-1)));
    else
      assign(y(left downto left-len(x.cnt)+1), convert(x.cnt, y(left downto left-len(x.cnt)+1)));
      left := left - len(x.cnt);
      assign(y(left downto left-len(x.pld)+1), convert(x.pld, y(left downto left-len(x.pld)+1)));
      left := left - len(x.pld);
      assign(y(left downto left-len(x.dst)+1), convert(x.dst, y(left downto left-len(x.dst)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hub_irt) return hub_irt is
    variable y: hub_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.cnt := structify(x(left to left+len(y.cnt)-1), y.cnt);
      left := left + len(y.cnt);
      y.pld := structify(x(left to left+len(y.pld)-1), y.pld);
      left := left + len(y.pld);
      y.dst := structify(x(left to left+len(y.dst)-1), y.dst);
    else
      y.cnt := structify(x(left downto left-len(y.cnt)+1), y.cnt);
      left := left - len(y.cnt);
      y.pld := structify(x(left downto left-len(y.pld)+1), y.pld);
      left := left - len(y.pld);
      y.dst := structify(x(left downto left-len(y.dst)+1), y.dst);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hub_irt) return hub_irt is
    variable y: hub_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.cnt := convert(x(left to left+len(y.cnt)-1), y.cnt);
      left := left + len(y.cnt);
      y.pld := convert(x(left to left+len(y.pld)-1), y.pld);
      left := left + len(y.pld);
      y.dst := convert(x(left to left+len(y.dst)-1), y.dst);
    else
      y.cnt := convert(x(left downto left-len(y.cnt)+1), y.cnt);
      left := left - len(y.cnt);
      y.pld := convert(x(left downto left-len(y.pld)+1), y.pld);
      left := left - len(y.pld);
      y.dst := convert(x(left downto left-len(y.dst)+1), y.dst);
    end if;
    return y;
  end function convert;
  function nullify(t: hub_irt) return hub_irt is
  variable y: hub_irt;
  begin
    y.cnt := nullify(t.cnt);
    y.pld := nullify(t.pld);
    y.dst := nullify(t.dst);
    return y;
  end function nullify;
  function zeroed(t: hub_irt) return hub_irt is
  variable y: hub_irt;
  begin
    y.cnt := zeroed(t.cnt);
    y.pld := zeroed(t.pld);
    y.dst := zeroed(t.dst);
    return y;
  end function zeroed;

  function len(x: hub_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.cnt);
    l := l + len(x.pld);
    l := l + len(x.dst);
    return l;
  end function len;
  function width(x: hub_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.cnt);
    l := l + width(x.pld);
    l := l + width(x.dst);
    return l;
  end function width;
  function vectorify(x: hub_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.cnt)-1), vectorify(x.cnt, y(left to left+len(x.cnt)-1)));
      left := left + len(x.cnt);
      assign(y(left to left+len(x.pld)-1), vectorify(x.pld, y(left to left+len(x.pld)-1)));
      left := left + len(x.pld);
      assign(y(left to left+len(x.dst)-1), vectorify(x.dst, y(left to left+len(x.dst)-1)));
    else
      assign(y(left downto left-len(x.cnt)+1), vectorify(x.cnt, y(left downto left-len(x.cnt)+1)));
      left := left - len(x.cnt);
      assign(y(left downto left-len(x.pld)+1), vectorify(x.pld, y(left downto left-len(x.pld)+1)));
      left := left - len(x.pld);
      assign(y(left downto left-len(x.dst)+1), vectorify(x.dst, y(left downto left-len(x.dst)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hub_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.cnt)-1), convert(x.cnt, y(left to left+len(x.cnt)-1)));
      left := left + len(x.cnt);
      assign(y(left to left+len(x.pld)-1), convert(x.pld, y(left to left+len(x.pld)-1)));
      left := left + len(x.pld);
      assign(y(left to left+len(x.dst)-1), convert(x.dst, y(left to left+len(x.dst)-1)));
    else
      assign(y(left downto left-len(x.cnt)+1), convert(x.cnt, y(left downto left-len(x.cnt)+1)));
      left := left - len(x.cnt);
      assign(y(left downto left-len(x.pld)+1), convert(x.pld, y(left downto left-len(x.pld)+1)));
      left := left - len(x.pld);
      assign(y(left downto left-len(x.dst)+1), convert(x.dst, y(left downto left-len(x.dst)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hub_ort) return hub_ort is
    variable y: hub_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.cnt := structify(x(left to left+len(y.cnt)-1), y.cnt);
      left := left + len(y.cnt);
      y.pld := structify(x(left to left+len(y.pld)-1), y.pld);
      left := left + len(y.pld);
      y.dst := structify(x(left to left+len(y.dst)-1), y.dst);
    else
      y.cnt := structify(x(left downto left-len(y.cnt)+1), y.cnt);
      left := left - len(y.cnt);
      y.pld := structify(x(left downto left-len(y.pld)+1), y.pld);
      left := left - len(y.pld);
      y.dst := structify(x(left downto left-len(y.dst)+1), y.dst);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hub_ort) return hub_ort is
    variable y: hub_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.cnt := convert(x(left to left+len(y.cnt)-1), y.cnt);
      left := left + len(y.cnt);
      y.pld := convert(x(left to left+len(y.pld)-1), y.pld);
      left := left + len(y.pld);
      y.dst := convert(x(left to left+len(y.dst)-1), y.dst);
    else
      y.cnt := convert(x(left downto left-len(y.cnt)+1), y.cnt);
      left := left - len(y.cnt);
      y.pld := convert(x(left downto left-len(y.pld)+1), y.pld);
      left := left - len(y.pld);
      y.dst := convert(x(left downto left-len(y.dst)+1), y.dst);
    end if;
    return y;
  end function convert;
  function nullify(t: hub_ort) return hub_ort is
  variable y: hub_ort;
  begin
    y.cnt := nullify(t.cnt);
    y.pld := nullify(t.pld);
    y.dst := nullify(t.dst);
    return y;
  end function nullify;
  function zeroed(t: hub_ort) return hub_ort is
  variable y: hub_ort;
  begin
    y.cnt := zeroed(t.cnt);
    y.pld := zeroed(t.pld);
    y.dst := zeroed(t.dst);
    return y;
  end function zeroed;

  function len(x: hub_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: hub_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: hub_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hub_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hub_ert) return hub_ert is
    variable y: hub_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hub_ert) return hub_ert is
    variable y: hub_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: hub_ert) return hub_ert is
  variable y: hub_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: hub_ert) return hub_ert is
  variable y: hub_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

end package body daq_row_defs;
