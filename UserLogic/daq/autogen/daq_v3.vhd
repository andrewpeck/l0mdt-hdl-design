-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library daq_core;
use daq_core.yml2hdl.all;

package daq_v3 is

   -- Custom types and functions --

   constant DAQ_DEFAULT_OPENING_OFFSET : integer := 2;
   attribute w of DAQ_DEFAULT_OPENING_OFFSET : constant is 32;

   constant DAQ_DEFAULT_REQUEST_OFFSET : integer := 3;
   attribute w of DAQ_DEFAULT_REQUEST_OFFSET : constant is 32;

   constant DAQ_DEFAULT_CLOSING_OFFSET : integer := 4;
   attribute w of DAQ_DEFAULT_CLOSING_OFFSET : constant is 32;

   constant DAQ_DEFAULT_TIMEOUT_WINDOW : integer := 1;
   attribute w of DAQ_DEFAULT_TIMEOUT_WINDOW : constant is 32;

   -- daq_info_rt: Header information with generated in daq module
   type daq_info_rt is record
      event_id : unsigned(31 downto 0);
      wm_opening : unsigned(11 downto 0);
      wm_request : unsigned(11 downto 0);
      wm_closing : unsigned(11 downto 0);
      wm_overflow : unsigned(11 downto 0);
      wm_snapshot : std_logic_vector(31 downto 0);
      win_opening_offset : unsigned(11 downto 0);
      win_request_offset : unsigned(11 downto 0);
      win_closing_offset : unsigned(11 downto 0);
      win_timeout_window : unsigned(11 downto 0);
   end record daq_info_rt;
   attribute w of daq_info_rt : type is 160;
   function width(x: daq_info_rt) return natural;
   function convert(x: daq_info_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: daq_info_rt) return daq_info_rt;
   function zero(tpl: daq_info_rt) return daq_info_rt;

   subtype daq_info_vt is std_logic_vector(daq_info_rt'w-1 downto 0);
   attribute w of daq_info_vt : subtype is 160;

   type bcid_array_t is array(integer range <>) of unsigned(11 downto 0);
   function width(x: bcid_array_t) return integer;
   function convert(x: bcid_array_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: bcid_array_t) return bcid_array_t;
   function zero(tpl: bcid_array_t) return bcid_array_t;
   function convert(x: bcid_array_t; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: bcid_array_t) return bcid_array_t;

end package daq_v3;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library daq_core;
use daq_core.yml2hdl.all;

package body daq_v3 is

   -- Custom types and functions --

   function width(x: daq_info_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.event_id);
      w := w + width(x.wm_opening);
      w := w + width(x.wm_request);
      w := w + width(x.wm_closing);
      w := w + width(x.wm_overflow);
      w := w + width(x.wm_snapshot);
      w := w + width(x.win_opening_offset);
      w := w + width(x.win_request_offset);
      w := w + width(x.win_closing_offset);
      w := w + width(x.win_timeout_window);
      return w;
   end function width;
   function convert(x: daq_info_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.event_id);
         y(u to u+w-1) := convert(x.event_id, y(u to u+w-1));
         u := u + w;
         w := width(x.wm_opening);
         y(u to u+w-1) := convert(x.wm_opening, y(u to u+w-1));
         u := u + w;
         w := width(x.wm_request);
         y(u to u+w-1) := convert(x.wm_request, y(u to u+w-1));
         u := u + w;
         w := width(x.wm_closing);
         y(u to u+w-1) := convert(x.wm_closing, y(u to u+w-1));
         u := u + w;
         w := width(x.wm_overflow);
         y(u to u+w-1) := convert(x.wm_overflow, y(u to u+w-1));
         u := u + w;
         w := width(x.wm_snapshot);
         y(u to u+w-1) := convert(x.wm_snapshot, y(u to u+w-1));
         u := u + w;
         w := width(x.win_opening_offset);
         y(u to u+w-1) := convert(x.win_opening_offset, y(u to u+w-1));
         u := u + w;
         w := width(x.win_request_offset);
         y(u to u+w-1) := convert(x.win_request_offset, y(u to u+w-1));
         u := u + w;
         w := width(x.win_closing_offset);
         y(u to u+w-1) := convert(x.win_closing_offset, y(u to u+w-1));
         u := u + w;
         w := width(x.win_timeout_window);
         y(u to u+w-1) := convert(x.win_timeout_window, y(u to u+w-1));
      else
         w := width(x.event_id);
         y(u downto u-w+1) := convert(x.event_id, y(u downto u-w+1));
         u := u - w;
         w := width(x.wm_opening);
         y(u downto u-w+1) := convert(x.wm_opening, y(u downto u-w+1));
         u := u - w;
         w := width(x.wm_request);
         y(u downto u-w+1) := convert(x.wm_request, y(u downto u-w+1));
         u := u - w;
         w := width(x.wm_closing);
         y(u downto u-w+1) := convert(x.wm_closing, y(u downto u-w+1));
         u := u - w;
         w := width(x.wm_overflow);
         y(u downto u-w+1) := convert(x.wm_overflow, y(u downto u-w+1));
         u := u - w;
         w := width(x.wm_snapshot);
         y(u downto u-w+1) := convert(x.wm_snapshot, y(u downto u-w+1));
         u := u - w;
         w := width(x.win_opening_offset);
         y(u downto u-w+1) := convert(x.win_opening_offset, y(u downto u-w+1));
         u := u - w;
         w := width(x.win_request_offset);
         y(u downto u-w+1) := convert(x.win_request_offset, y(u downto u-w+1));
         u := u - w;
         w := width(x.win_closing_offset);
         y(u downto u-w+1) := convert(x.win_closing_offset, y(u downto u-w+1));
         u := u - w;
         w := width(x.win_timeout_window);
         y(u downto u-w+1) := convert(x.win_timeout_window, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: daq_info_rt) return daq_info_rt is
      variable y : daq_info_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.event_id);
         y.event_id := convert(x(u to u+w-1), tpl.event_id);
         u := u + w;
         w := width(tpl.wm_opening);
         y.wm_opening := convert(x(u to u+w-1), tpl.wm_opening);
         u := u + w;
         w := width(tpl.wm_request);
         y.wm_request := convert(x(u to u+w-1), tpl.wm_request);
         u := u + w;
         w := width(tpl.wm_closing);
         y.wm_closing := convert(x(u to u+w-1), tpl.wm_closing);
         u := u + w;
         w := width(tpl.wm_overflow);
         y.wm_overflow := convert(x(u to u+w-1), tpl.wm_overflow);
         u := u + w;
         w := width(tpl.wm_snapshot);
         y.wm_snapshot := convert(x(u to u+w-1), tpl.wm_snapshot);
         u := u + w;
         w := width(tpl.win_opening_offset);
         y.win_opening_offset := convert(x(u to u+w-1), tpl.win_opening_offset);
         u := u + w;
         w := width(tpl.win_request_offset);
         y.win_request_offset := convert(x(u to u+w-1), tpl.win_request_offset);
         u := u + w;
         w := width(tpl.win_closing_offset);
         y.win_closing_offset := convert(x(u to u+w-1), tpl.win_closing_offset);
         u := u + w;
         w := width(tpl.win_timeout_window);
         y.win_timeout_window := convert(x(u to u+w-1), tpl.win_timeout_window);
      else
         w := width(tpl.event_id);
         y.event_id := convert(x(u downto u-w+1), tpl.event_id);
         u := u - w;
         w := width(tpl.wm_opening);
         y.wm_opening := convert(x(u downto u-w+1), tpl.wm_opening);
         u := u - w;
         w := width(tpl.wm_request);
         y.wm_request := convert(x(u downto u-w+1), tpl.wm_request);
         u := u - w;
         w := width(tpl.wm_closing);
         y.wm_closing := convert(x(u downto u-w+1), tpl.wm_closing);
         u := u - w;
         w := width(tpl.wm_overflow);
         y.wm_overflow := convert(x(u downto u-w+1), tpl.wm_overflow);
         u := u - w;
         w := width(tpl.wm_snapshot);
         y.wm_snapshot := convert(x(u downto u-w+1), tpl.wm_snapshot);
         u := u - w;
         w := width(tpl.win_opening_offset);
         y.win_opening_offset := convert(x(u downto u-w+1), tpl.win_opening_offset);
         u := u - w;
         w := width(tpl.win_request_offset);
         y.win_request_offset := convert(x(u downto u-w+1), tpl.win_request_offset);
         u := u - w;
         w := width(tpl.win_closing_offset);
         y.win_closing_offset := convert(x(u downto u-w+1), tpl.win_closing_offset);
         u := u - w;
         w := width(tpl.win_timeout_window);
         y.win_timeout_window := convert(x(u downto u-w+1), tpl.win_timeout_window);
      end if;
      return y;
   end function convert;
   function zero(tpl: daq_info_rt) return daq_info_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: bcid_array_t) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: bcid_array_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: bcid_array_t) return bcid_array_t is
      variable y : bcid_array_t(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: bcid_array_t) return bcid_array_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: bcid_array_t; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: bcid_array_t) return bcid_array_t is
      variable y : bcid_array_t(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

end package body daq_v3;
