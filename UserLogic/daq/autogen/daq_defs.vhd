-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.math_real.all;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

library ttc_def;
use ttc_def.ttc_defs.all;

library daq_def;
use daq_def.daq_config_defs.all;

package daq_defs is

  subtype daq_bcid_t is unsigned(12-1 downto 0);

  constant DAQ_MAX_ROWS : integer := DAQ_MAX_STREAMS + 1;

  subtype daq_stream_data_t is std_logic_vector(DAQ_MAX_DATA_WIDTH-1 downto 0);

  type daq_stream_rt is record
    bcid : daq_bcid_t;
    valid : std_logic;
    data : daq_stream_data_t;
    enable : std_logic;
  end record daq_stream_rt;
  function len(x: daq_stream_rt) return natural;
  function width(x: daq_stream_rt) return natural;
  function vectorify(x: daq_stream_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_stream_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_stream_rt) return daq_stream_rt;
  function convert(x: in std_logic_vector; t: daq_stream_rt) return daq_stream_rt;
  function nullify(t: daq_stream_rt) return daq_stream_rt;
  function zeroed(t: daq_stream_rt) return daq_stream_rt;

  type daq_branch_t is array(DAQ_MAX_STREAMS-1 downto 0) of daq_stream_rt;
  function len(x: daq_branch_t) return natural;
  function width(x: daq_branch_t) return natural;
  function vectorify(x: daq_branch_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_branch_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: daq_branch_t) return daq_branch_t;
  function convert(x: std_logic_vector; t: daq_branch_t) return daq_branch_t;
  function nullify(x: daq_branch_t) return daq_branch_t;
  function zeroed(x: daq_branch_t) return daq_branch_t;

  type daq_stream_struct_t is record
    WIDTH : integer;
    DEPTH : integer;
  end record daq_stream_struct_t;
  function len(x: daq_stream_struct_t) return natural;
  function width(x: daq_stream_struct_t) return natural;
  function vectorify(x: daq_stream_struct_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_stream_struct_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_stream_struct_t) return daq_stream_struct_t;
  function convert(x: in std_logic_vector; t: daq_stream_struct_t) return daq_stream_struct_t;
  function nullify(t: daq_stream_struct_t) return daq_stream_struct_t;
  function zeroed(t: daq_stream_struct_t) return daq_stream_struct_t;

  type daq_branch_struct_at is array(0 to DAQ_MAX_STREAMS-1) of daq_stream_struct_t;
  function len(x: daq_branch_struct_at) return natural;
  function width(x: daq_branch_struct_at) return natural;
  function vectorify(x: daq_branch_struct_at; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_branch_struct_at; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: daq_branch_struct_at) return daq_branch_struct_at;
  function convert(x: std_logic_vector; t: daq_branch_struct_at) return daq_branch_struct_at;
  function nullify(x: daq_branch_struct_at) return daq_branch_struct_at;
  function zeroed(x: daq_branch_struct_at) return daq_branch_struct_at;

  type daq_branches_t is array(DAQ_MAX_BRANCHES-1 downto 0) of daq_branch_t;
  function len(x: daq_branches_t) return natural;
  function width(x: daq_branches_t) return natural;
  function vectorify(x: daq_branches_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_branches_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: daq_branches_t) return daq_branches_t;
  function convert(x: std_logic_vector; t: daq_branches_t) return daq_branches_t;
  function nullify(x: daq_branches_t) return daq_branches_t;
  function zeroed(x: daq_branches_t) return daq_branches_t;

  type daq_branches_mask_at is array(0 to DAQ_MAX_BRANCHES-1) of integer;
  function len(x: daq_branches_mask_at) return natural;
  function width(x: daq_branches_mask_at) return natural;
  function vectorify(x: daq_branches_mask_at; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_branches_mask_at; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: daq_branches_mask_at) return daq_branches_mask_at;
  function convert(x: std_logic_vector; t: daq_branches_mask_at) return daq_branches_mask_at;
  function nullify(x: daq_branches_mask_at) return daq_branches_mask_at;
  function zeroed(x: daq_branches_mask_at) return daq_branches_mask_at;

  type daq_branches_map_at is array(0 to DAQ_MAX_BRANCHES-1) of daq_branch_struct_at;
  function len(x: daq_branches_map_at) return natural;
  function width(x: daq_branches_map_at) return natural;
  function vectorify(x: daq_branches_map_at; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_branches_map_at; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: daq_branches_map_at) return daq_branches_map_at;
  function convert(x: std_logic_vector; t: daq_branches_map_at) return daq_branches_map_at;
  function nullify(x: daq_branches_map_at) return daq_branches_map_at;
  function zeroed(x: daq_branches_map_at) return daq_branches_map_at;

  type daq_sys_rt is record
    clk320 : std_logic;
    rst : std_logic;
  end record daq_sys_rt;
  function len(x: daq_sys_rt) return natural;
  function width(x: daq_sys_rt) return natural;
  function vectorify(x: daq_sys_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_sys_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_sys_rt) return daq_sys_rt;
  function convert(x: in std_logic_vector; t: daq_sys_rt) return daq_sys_rt;
  function nullify(t: daq_sys_rt) return daq_sys_rt;
  function zeroed(t: daq_sys_rt) return daq_sys_rt;

  -- daq_hdr_swrod_rt:
  -- Fields required by swROD
  type daq_hdr_swrod_rt is record
    -- flag_0: example of flag from swROD
    flag_0 : std_logic_vector(8-1 downto 0);
    flag_1 : std_logic_vector(8-1 downto 0);
    flag_2 : std_logic_vector(16-1 downto 0);
    evid : ttc_evid_t;
  end record daq_hdr_swrod_rt;
  function len(x: daq_hdr_swrod_rt) return natural;
  function width(x: daq_hdr_swrod_rt) return natural;
  function vectorify(x: daq_hdr_swrod_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_hdr_swrod_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_hdr_swrod_rt) return daq_hdr_swrod_rt;
  function convert(x: in std_logic_vector; t: daq_hdr_swrod_rt) return daq_hdr_swrod_rt;
  function nullify(t: daq_hdr_swrod_rt) return daq_hdr_swrod_rt;
  function zeroed(t: daq_hdr_swrod_rt) return daq_hdr_swrod_rt;

  type daq_hdr_extra_rt is record
    daq_bcid : daq_bcid_t;
    window_start : daq_bcid_t;
    window_width : daq_bcid_t;
    window_latency : daq_bcid_t;
    lower_window_size : daq_bcid_t;
    upper_window_size : daq_bcid_t;
    sys_bcid : daq_bcid_t;
  end record daq_hdr_extra_rt;
  function len(x: daq_hdr_extra_rt) return natural;
  function width(x: daq_hdr_extra_rt) return natural;
  function vectorify(x: daq_hdr_extra_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_hdr_extra_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_hdr_extra_rt) return daq_hdr_extra_rt;
  function convert(x: in std_logic_vector; t: daq_hdr_extra_rt) return daq_hdr_extra_rt;
  function nullify(t: daq_hdr_extra_rt) return daq_hdr_extra_rt;
  function zeroed(t: daq_hdr_extra_rt) return daq_hdr_extra_rt;

  type daq_hdr_rt is record
    swrod : daq_hdr_swrod_rt;
    extra : daq_hdr_extra_rt;
  end record daq_hdr_rt;
  function len(x: daq_hdr_rt) return natural;
  function width(x: daq_hdr_rt) return natural;
  function vectorify(x: daq_hdr_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_hdr_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_hdr_rt) return daq_hdr_rt;
  function convert(x: in std_logic_vector; t: daq_hdr_rt) return daq_hdr_rt;
  function nullify(t: daq_hdr_rt) return daq_hdr_rt;
  function zeroed(t: daq_hdr_rt) return daq_hdr_rt;

  subtype daq_hdr_vt is std_logic_vector(148-1 downto 0);

  type daq_counters_rt is record
    daq_bcid : daq_bcid_t;
    sys_bcid : daq_bcid_t;
    lower_window_limit : daq_bcid_t;
    upper_window_limit : daq_bcid_t;
  end record daq_counters_rt;
  function len(x: daq_counters_rt) return natural;
  function width(x: daq_counters_rt) return natural;
  function vectorify(x: daq_counters_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_counters_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_counters_rt) return daq_counters_rt;
  function convert(x: in std_logic_vector; t: daq_counters_rt) return daq_counters_rt;
  function nullify(t: daq_counters_rt) return daq_counters_rt;
  function zeroed(t: daq_counters_rt) return daq_counters_rt;

  type daq_window_params_rt is record
    lower_size : daq_bcid_t;
    upper_size : daq_bcid_t;
    latency : daq_bcid_t;
  end record daq_window_params_rt;
  function len(x: daq_window_params_rt) return natural;
  function width(x: daq_window_params_rt) return natural;
  function vectorify(x: daq_window_params_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_window_params_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_window_params_rt) return daq_window_params_rt;
  function convert(x: in std_logic_vector; t: daq_window_params_rt) return daq_window_params_rt;
  function nullify(t: daq_window_params_rt) return daq_window_params_rt;
  function zeroed(t: daq_window_params_rt) return daq_window_params_rt;

  type stability_rt is record
    upper_window_limit : std_logic;
    lower_window_limit : std_logic;
    daq_bcid : std_logic;
  end record stability_rt;
  function len(x: stability_rt) return natural;
  function width(x: stability_rt) return natural;
  function vectorify(x: stability_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: stability_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: stability_rt) return stability_rt;
  function convert(x: in std_logic_vector; t: stability_rt) return stability_rt;
  function nullify(t: stability_rt) return stability_rt;
  function zeroed(t: stability_rt) return stability_rt;

  subtype stability_vt is std_logic_vector(3-1 downto 0);

  type forward_rt is record
    nempty : std_logic;
    data : std_logic_vector(DAQ_MAX_DATA_WIDTH-1 downto 0);
  end record forward_rt;
  function len(x: forward_rt) return natural;
  function width(x: forward_rt) return natural;
  function vectorify(x: forward_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: forward_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: forward_rt) return forward_rt;
  function convert(x: in std_logic_vector; t: forward_rt) return forward_rt;
  function nullify(t: forward_rt) return forward_rt;
  function zeroed(t: forward_rt) return forward_rt;

  type backward_rt is record
    rd_strb : std_logic;
  end record backward_rt;
  function len(x: backward_rt) return natural;
  function width(x: backward_rt) return natural;
  function vectorify(x: backward_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: backward_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: backward_rt) return backward_rt;
  function convert(x: in std_logic_vector; t: backward_rt) return backward_rt;
  function nullify(t: backward_rt) return backward_rt;
  function zeroed(t: backward_rt) return backward_rt;

  type row_to_mngt_rt is record
    data_ready : std_logic_vector(DAQ_MAX_PIPELINES-1 downto 0);
    nempty : std_logic_vector(DAQ_MAX_PIPELINES-1 downto 0);
    err : std_logic_vector(DAQ_MAX_PIPELINES-1 downto 0);
  end record row_to_mngt_rt;
  function len(x: row_to_mngt_rt) return natural;
  function width(x: row_to_mngt_rt) return natural;
  function vectorify(x: row_to_mngt_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: row_to_mngt_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: row_to_mngt_rt) return row_to_mngt_rt;
  function convert(x: in std_logic_vector; t: row_to_mngt_rt) return row_to_mngt_rt;
  function nullify(t: row_to_mngt_rt) return row_to_mngt_rt;
  function zeroed(t: row_to_mngt_rt) return row_to_mngt_rt;

  type mngt_to_row_rt is record
    en : std_logic_vector(0 to DAQ_MAX_PIPELINES-1);
    rd_en : natural;
  end record mngt_to_row_rt;
  function len(x: mngt_to_row_rt) return natural;
  function width(x: mngt_to_row_rt) return natural;
  function vectorify(x: mngt_to_row_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: mngt_to_row_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: mngt_to_row_rt) return mngt_to_row_rt;
  function convert(x: in std_logic_vector; t: mngt_to_row_rt) return mngt_to_row_rt;
  function nullify(t: mngt_to_row_rt) return mngt_to_row_rt;
  function zeroed(t: mngt_to_row_rt) return mngt_to_row_rt;

  type mngt_to_pbldr_rt is record
    en : std_logic;
  end record mngt_to_pbldr_rt;
  function len(x: mngt_to_pbldr_rt) return natural;
  function width(x: mngt_to_pbldr_rt) return natural;
  function vectorify(x: mngt_to_pbldr_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: mngt_to_pbldr_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: mngt_to_pbldr_rt) return mngt_to_pbldr_rt;
  function convert(x: in std_logic_vector; t: mngt_to_pbldr_rt) return mngt_to_pbldr_rt;
  function nullify(t: mngt_to_pbldr_rt) return mngt_to_pbldr_rt;
  function zeroed(t: mngt_to_pbldr_rt) return mngt_to_pbldr_rt;

  type pbldr_to_mngt_rt is record
    done : std_logic;
  end record pbldr_to_mngt_rt;
  function len(x: pbldr_to_mngt_rt) return natural;
  function width(x: pbldr_to_mngt_rt) return natural;
  function vectorify(x: pbldr_to_mngt_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: pbldr_to_mngt_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: pbldr_to_mngt_rt) return pbldr_to_mngt_rt;
  function convert(x: in std_logic_vector; t: pbldr_to_mngt_rt) return pbldr_to_mngt_rt;
  function nullify(t: pbldr_to_mngt_rt) return pbldr_to_mngt_rt;
  function zeroed(t: pbldr_to_mngt_rt) return pbldr_to_mngt_rt;

  subtype row_to_pbldr_rt is forward_rt;

  type rows_to_pbldr_at is array(DAQ_MAX_ROWS-1 downto 0) of row_to_pbldr_rt;
  function len(x: rows_to_pbldr_at) return natural;
  function width(x: rows_to_pbldr_at) return natural;
  function vectorify(x: rows_to_pbldr_at; t: std_logic_vector) return std_logic_vector;
  function convert(x: rows_to_pbldr_at; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: rows_to_pbldr_at) return rows_to_pbldr_at;
  function convert(x: std_logic_vector; t: rows_to_pbldr_at) return rows_to_pbldr_at;
  function nullify(x: rows_to_pbldr_at) return rows_to_pbldr_at;
  function zeroed(x: rows_to_pbldr_at) return rows_to_pbldr_at;

  subtype pbldr_to_row_rt is backward_rt;

  type pbldr_to_rows_at is array(DAQ_MAX_ROWS-1 downto 0) of pbldr_to_row_rt;
  function len(x: pbldr_to_rows_at) return natural;
  function width(x: pbldr_to_rows_at) return natural;
  function vectorify(x: pbldr_to_rows_at; t: std_logic_vector) return std_logic_vector;
  function convert(x: pbldr_to_rows_at; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: pbldr_to_rows_at) return pbldr_to_rows_at;
  function convert(x: std_logic_vector; t: pbldr_to_rows_at) return pbldr_to_rows_at;
  function nullify(x: pbldr_to_rows_at) return pbldr_to_rows_at;
  function zeroed(x: pbldr_to_rows_at) return pbldr_to_rows_at;

  type req_to_row_common_rt is record
    req_strb : std_logic;
    window_start : daq_bcid_t;
    window_width : daq_bcid_t;
  end record req_to_row_common_rt;
  function len(x: req_to_row_common_rt) return natural;
  function width(x: req_to_row_common_rt) return natural;
  function vectorify(x: req_to_row_common_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: req_to_row_common_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: req_to_row_common_rt) return req_to_row_common_rt;
  function convert(x: in std_logic_vector; t: req_to_row_common_rt) return req_to_row_common_rt;
  function nullify(t: req_to_row_common_rt) return req_to_row_common_rt;
  function zeroed(t: req_to_row_common_rt) return req_to_row_common_rt;

  type req_to_row_extra_rt is record
    window_latency : daq_bcid_t;
    lower_window_size : daq_bcid_t;
    upper_window_size : daq_bcid_t;
    daq_bcid : daq_bcid_t;
    sys_bcid : daq_bcid_t;
    evid : ttc_evid_t;
  end record req_to_row_extra_rt;
  function len(x: req_to_row_extra_rt) return natural;
  function width(x: req_to_row_extra_rt) return natural;
  function vectorify(x: req_to_row_extra_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: req_to_row_extra_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: req_to_row_extra_rt) return req_to_row_extra_rt;
  function convert(x: in std_logic_vector; t: req_to_row_extra_rt) return req_to_row_extra_rt;
  function nullify(t: req_to_row_extra_rt) return req_to_row_extra_rt;
  function zeroed(t: req_to_row_extra_rt) return req_to_row_extra_rt;

  type req_to_row_rt is record
    common : req_to_row_common_rt;
    extra : req_to_row_extra_rt;
  end record req_to_row_rt;
  function len(x: req_to_row_rt) return natural;
  function width(x: req_to_row_rt) return natural;
  function vectorify(x: req_to_row_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: req_to_row_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: req_to_row_rt) return req_to_row_rt;
  function convert(x: in std_logic_vector; t: req_to_row_rt) return req_to_row_rt;
  function nullify(t: req_to_row_rt) return req_to_row_rt;
  function zeroed(t: req_to_row_rt) return req_to_row_rt;

  type felix_to_daq_rt is record
    hfull : std_logic;
  end record felix_to_daq_rt;
  function len(x: felix_to_daq_rt) return natural;
  function width(x: felix_to_daq_rt) return natural;
  function vectorify(x: felix_to_daq_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: felix_to_daq_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: felix_to_daq_rt) return felix_to_daq_rt;
  function convert(x: in std_logic_vector; t: felix_to_daq_rt) return felix_to_daq_rt;
  function nullify(t: felix_to_daq_rt) return felix_to_daq_rt;
  function zeroed(t: felix_to_daq_rt) return felix_to_daq_rt;

  type daq_to_felix_rt is record
    wr_en : std_logic;
    data : std_logic_vector(DAQ_MAX_DATA_WIDTH-1 downto 0);
  end record daq_to_felix_rt;
  function len(x: daq_to_felix_rt) return natural;
  function width(x: daq_to_felix_rt) return natural;
  function vectorify(x: daq_to_felix_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_to_felix_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_to_felix_rt) return daq_to_felix_rt;
  function convert(x: in std_logic_vector; t: daq_to_felix_rt) return daq_to_felix_rt;
  function nullify(t: daq_to_felix_rt) return daq_to_felix_rt;
  function zeroed(t: daq_to_felix_rt) return daq_to_felix_rt;

  type ctrl_to_daq_rt is record
    wr_en : std_logic;
    window_latency : daq_bcid_t;
    lower_window_size : daq_bcid_t;
    upper_window_size : daq_bcid_t;
  end record ctrl_to_daq_rt;
  function len(x: ctrl_to_daq_rt) return natural;
  function width(x: ctrl_to_daq_rt) return natural;
  function vectorify(x: ctrl_to_daq_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ctrl_to_daq_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ctrl_to_daq_rt) return ctrl_to_daq_rt;
  function convert(x: in std_logic_vector; t: ctrl_to_daq_rt) return ctrl_to_daq_rt;
  function nullify(t: ctrl_to_daq_rt) return ctrl_to_daq_rt;
  function zeroed(t: ctrl_to_daq_rt) return ctrl_to_daq_rt;

  type daq_to_status_rt is record
    stability : stability_rt;
  end record daq_to_status_rt;
  function len(x: daq_to_status_rt) return natural;
  function width(x: daq_to_status_rt) return natural;
  function vectorify(x: daq_to_status_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_to_status_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_to_status_rt) return daq_to_status_rt;
  function convert(x: in std_logic_vector; t: daq_to_status_rt) return daq_to_status_rt;
  function nullify(t: daq_to_status_rt) return daq_to_status_rt;
  function zeroed(t: daq_to_status_rt) return daq_to_status_rt;

  type daq_req_status_rt is record
    stability : stability_rt;
  end record daq_req_status_rt;
  function len(x: daq_req_status_rt) return natural;
  function width(x: daq_req_status_rt) return natural;
  function vectorify(x: daq_req_status_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_req_status_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_req_status_rt) return daq_req_status_rt;
  function convert(x: in std_logic_vector; t: daq_req_status_rt) return daq_req_status_rt;
  function nullify(t: daq_req_status_rt) return daq_req_status_rt;
  function zeroed(t: daq_req_status_rt) return daq_req_status_rt;

  type daq_req_irt is record
    sys : daq_sys_rt;
    ttc : ttc_ort;
    ctrl : ctrl_to_daq_rt;
  end record daq_req_irt;
  function len(x: daq_req_irt) return natural;
  function width(x: daq_req_irt) return natural;
  function vectorify(x: daq_req_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_req_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_req_irt) return daq_req_irt;
  function convert(x: in std_logic_vector; t: daq_req_irt) return daq_req_irt;
  function nullify(t: daq_req_irt) return daq_req_irt;
  function zeroed(t: daq_req_irt) return daq_req_irt;

  type daq_req_ort is record
    status : daq_req_status_rt;
    row : req_to_row_rt;
  end record daq_req_ort;
  function len(x: daq_req_ort) return natural;
  function width(x: daq_req_ort) return natural;
  function vectorify(x: daq_req_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_req_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_req_ort) return daq_req_ort;
  function convert(x: in std_logic_vector; t: daq_req_ort) return daq_req_ort;
  function nullify(t: daq_req_ort) return daq_req_ort;
  function zeroed(t: daq_req_ort) return daq_req_ort;

  type daq_req_ert is record
    i : daq_req_irt;
    o : daq_req_ort;
  end record daq_req_ert;
  function len(x: daq_req_ert) return natural;
  function width(x: daq_req_ert) return natural;
  function vectorify(x: daq_req_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_req_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_req_ert) return daq_req_ert;
  function convert(x: in std_logic_vector; t: daq_req_ert) return daq_req_ert;
  function nullify(t: daq_req_ert) return daq_req_ert;
  function zeroed(t: daq_req_ert) return daq_req_ert;

  subtype daq_req_ivt is std_logic_vector(120-1 downto 0);

  subtype daq_req_ovt is std_logic_vector(120-1 downto 0);

  type daq_row_ort is record
    mngt : row_to_mngt_rt;
    pbldr : row_to_pbldr_rt;
    debug : std_logic;
  end record daq_row_ort;
  function len(x: daq_row_ort) return natural;
  function width(x: daq_row_ort) return natural;
  function vectorify(x: daq_row_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_row_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_row_ort) return daq_row_ort;
  function convert(x: in std_logic_vector; t: daq_row_ort) return daq_row_ort;
  function nullify(t: daq_row_ort) return daq_row_ort;
  function zeroed(t: daq_row_ort) return daq_row_ort;

  type daq_header_row_irt is record
    sys : daq_sys_rt;
    mngt : mngt_to_row_rt;
    req : req_to_row_rt;
    pbldr : pbldr_to_row_rt;
  end record daq_header_row_irt;
  function len(x: daq_header_row_irt) return natural;
  function width(x: daq_header_row_irt) return natural;
  function vectorify(x: daq_header_row_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_header_row_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_header_row_irt) return daq_header_row_irt;
  function convert(x: in std_logic_vector; t: daq_header_row_irt) return daq_header_row_irt;
  function nullify(t: daq_header_row_irt) return daq_header_row_irt;
  function zeroed(t: daq_header_row_irt) return daq_header_row_irt;

  subtype daq_header_row_ort is daq_row_ort;

  type daq_header_row_ert is record
    i : daq_header_row_irt;
    o : daq_header_row_ort;
  end record daq_header_row_ert;
  function len(x: daq_header_row_ert) return natural;
  function width(x: daq_header_row_ert) return natural;
  function vectorify(x: daq_header_row_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_header_row_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_header_row_ert) return daq_header_row_ert;
  function convert(x: in std_logic_vector; t: daq_header_row_ert) return daq_header_row_ert;
  function nullify(t: daq_header_row_ert) return daq_header_row_ert;
  function zeroed(t: daq_header_row_ert) return daq_header_row_ert;

  type daq_data_row_irt is record
    sys : daq_sys_rt;
    mngt : mngt_to_row_rt;
    req : req_to_row_common_rt;
    stream : daq_stream_rt;
    pbldr : pbldr_to_row_rt;
  end record daq_data_row_irt;
  function len(x: daq_data_row_irt) return natural;
  function width(x: daq_data_row_irt) return natural;
  function vectorify(x: daq_data_row_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_data_row_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_data_row_irt) return daq_data_row_irt;
  function convert(x: in std_logic_vector; t: daq_data_row_irt) return daq_data_row_irt;
  function nullify(t: daq_data_row_irt) return daq_data_row_irt;
  function zeroed(t: daq_data_row_irt) return daq_data_row_irt;

  subtype daq_data_row_ort is daq_row_ort;

  type daq_data_row_ert is record
    i : daq_data_row_irt;
    o : daq_data_row_ort;
  end record daq_data_row_ert;
  function len(x: daq_data_row_ert) return natural;
  function width(x: daq_data_row_ert) return natural;
  function vectorify(x: daq_data_row_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_data_row_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_data_row_ert) return daq_data_row_ert;
  function convert(x: in std_logic_vector; t: daq_data_row_ert) return daq_data_row_ert;
  function nullify(t: daq_data_row_ert) return daq_data_row_ert;
  function zeroed(t: daq_data_row_ert) return daq_data_row_ert;

  subtype daq_header_row_ivt is std_logic_vector(192-1 downto 0);

  subtype daq_data_row_ivt is std_logic_vector(370-1 downto 0);

  subtype daq_row_ovt is std_logic_vector(378-1 downto 0);

  type daq_pbldr_irt is record
    sys : daq_sys_rt;
    mngt : mngt_to_pbldr_rt;
    rows : rows_to_pbldr_at;
    f2e : felix_to_daq_rt;
  end record daq_pbldr_irt;
  function len(x: daq_pbldr_irt) return natural;
  function width(x: daq_pbldr_irt) return natural;
  function vectorify(x: daq_pbldr_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_pbldr_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_pbldr_irt) return daq_pbldr_irt;
  function convert(x: in std_logic_vector; t: daq_pbldr_irt) return daq_pbldr_irt;
  function nullify(t: daq_pbldr_irt) return daq_pbldr_irt;
  function zeroed(t: daq_pbldr_irt) return daq_pbldr_irt;

  type daq_pbldr_ort is record
    rows : pbldr_to_rows_at;
    f2e : daq_to_felix_rt;
  end record daq_pbldr_ort;
  function len(x: daq_pbldr_ort) return natural;
  function width(x: daq_pbldr_ort) return natural;
  function vectorify(x: daq_pbldr_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_pbldr_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_pbldr_ort) return daq_pbldr_ort;
  function convert(x: in std_logic_vector; t: daq_pbldr_ort) return daq_pbldr_ort;
  function nullify(t: daq_pbldr_ort) return daq_pbldr_ort;
  function zeroed(t: daq_pbldr_ort) return daq_pbldr_ort;

  type daq_pbldr_ert is record
    i : daq_pbldr_irt;
    o : daq_pbldr_ort;
  end record daq_pbldr_ert;
  function len(x: daq_pbldr_ert) return natural;
  function width(x: daq_pbldr_ert) return natural;
  function vectorify(x: daq_pbldr_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_pbldr_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_pbldr_ert) return daq_pbldr_ert;
  function convert(x: in std_logic_vector; t: daq_pbldr_ert) return daq_pbldr_ert;
  function nullify(t: daq_pbldr_ert) return daq_pbldr_ert;
  function zeroed(t: daq_pbldr_ert) return daq_pbldr_ert;

  subtype daq_pbldr_ivt is std_logic_vector(1803-1 downto 0);

  subtype daq_pbldr_ovt is std_logic_vector(264-1 downto 0);

  type rows_to_mngt_rt is array(DAQ_MAX_STREAMS+1-1 downto 0) of row_to_mngt_rt;
  function len(x: rows_to_mngt_rt) return natural;
  function width(x: rows_to_mngt_rt) return natural;
  function vectorify(x: rows_to_mngt_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: rows_to_mngt_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: rows_to_mngt_rt) return rows_to_mngt_rt;
  function convert(x: std_logic_vector; t: rows_to_mngt_rt) return rows_to_mngt_rt;
  function nullify(x: rows_to_mngt_rt) return rows_to_mngt_rt;
  function zeroed(x: rows_to_mngt_rt) return rows_to_mngt_rt;

  type daq_mngt_irt is record
    sys : daq_sys_rt;
    ttc : ttc_ort;
    rows : rows_to_mngt_rt;
  end record daq_mngt_irt;
  function len(x: daq_mngt_irt) return natural;
  function width(x: daq_mngt_irt) return natural;
  function vectorify(x: daq_mngt_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_mngt_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_mngt_irt) return daq_mngt_irt;
  function convert(x: in std_logic_vector; t: daq_mngt_irt) return daq_mngt_irt;
  function nullify(t: daq_mngt_irt) return daq_mngt_irt;
  function zeroed(t: daq_mngt_irt) return daq_mngt_irt;

  type daq_mngt_ort is record
    row : mngt_to_row_rt;
    pbldr : mngt_to_pbldr_rt;
    err : std_logic_vector(DAQ_MAX_PIPELINES-1 downto 0);
    debug : std_logic_vector(2-1 downto 0);
  end record daq_mngt_ort;
  function len(x: daq_mngt_ort) return natural;
  function width(x: daq_mngt_ort) return natural;
  function vectorify(x: daq_mngt_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_mngt_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_mngt_ort) return daq_mngt_ort;
  function convert(x: in std_logic_vector; t: daq_mngt_ort) return daq_mngt_ort;
  function nullify(t: daq_mngt_ort) return daq_mngt_ort;
  function zeroed(t: daq_mngt_ort) return daq_mngt_ort;

  type daq_mngt_ert is record
    i : daq_mngt_irt;
    o : daq_mngt_ort;
  end record daq_mngt_ert;
  function len(x: daq_mngt_ert) return natural;
  function width(x: daq_mngt_ert) return natural;
  function vectorify(x: daq_mngt_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_mngt_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_mngt_ert) return daq_mngt_ert;
  function convert(x: in std_logic_vector; t: daq_mngt_ert) return daq_mngt_ert;
  function nullify(t: daq_mngt_ert) return daq_mngt_ert;
  function zeroed(t: daq_mngt_ert) return daq_mngt_ert;

  subtype daq_mngt_ivt is std_logic_vector(923-1 downto 0);

  subtype daq_mngt_ovt is std_logic_vector(115-1 downto 0);

  type daq_algo_irt is record
    sys : daq_sys_rt;
    ttc : ttc_ort;
    ctrl : ctrl_to_daq_rt;
    branch : daq_branch_t;
    f2e : felix_to_daq_rt;
  end record daq_algo_irt;
  function len(x: daq_algo_irt) return natural;
  function width(x: daq_algo_irt) return natural;
  function vectorify(x: daq_algo_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_algo_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_algo_irt) return daq_algo_irt;
  function convert(x: in std_logic_vector; t: daq_algo_irt) return daq_algo_irt;
  function nullify(t: daq_algo_irt) return daq_algo_irt;
  function zeroed(t: daq_algo_irt) return daq_algo_irt;

  type daq_algo_ort is record
    status : daq_to_status_rt;
    f2e : daq_to_felix_rt;
  end record daq_algo_ort;
  function len(x: daq_algo_ort) return natural;
  function width(x: daq_algo_ort) return natural;
  function vectorify(x: daq_algo_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_algo_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_algo_ort) return daq_algo_ort;
  function convert(x: in std_logic_vector; t: daq_algo_ort) return daq_algo_ort;
  function nullify(t: daq_algo_ort) return daq_algo_ort;
  function zeroed(t: daq_algo_ort) return daq_algo_ort;

  type daq_algo_ert is record
    i : daq_algo_irt;
    o : daq_algo_ort;
  end record daq_algo_ert;
  function len(x: daq_algo_ert) return natural;
  function width(x: daq_algo_ert) return natural;
  function vectorify(x: daq_algo_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_algo_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_algo_ert) return daq_algo_ert;
  function convert(x: in std_logic_vector; t: daq_algo_ert) return daq_algo_ert;
  function nullify(t: daq_algo_ert) return daq_algo_ert;
  function zeroed(t: daq_algo_ert) return daq_algo_ert;

  subtype daq_algo_ivt is std_logic_vector(1741-1 downto 0);

  subtype daq_algo_ovt is std_logic_vector(260-1 downto 0);

  type mfelix_to_branch_at is array(0 to DAQ_MAX_BRANCHES-1) of felix_to_daq_rt;
  function len(x: mfelix_to_branch_at) return natural;
  function width(x: mfelix_to_branch_at) return natural;
  function vectorify(x: mfelix_to_branch_at; t: std_logic_vector) return std_logic_vector;
  function convert(x: mfelix_to_branch_at; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: mfelix_to_branch_at) return mfelix_to_branch_at;
  function convert(x: std_logic_vector; t: mfelix_to_branch_at) return mfelix_to_branch_at;
  function nullify(x: mfelix_to_branch_at) return mfelix_to_branch_at;
  function zeroed(x: mfelix_to_branch_at) return mfelix_to_branch_at;

  type top_to_mfelix_at is array(0 to DAQ_MAX_BRANCHES-1) of daq_to_felix_rt;
  function len(x: top_to_mfelix_at) return natural;
  function width(x: top_to_mfelix_at) return natural;
  function vectorify(x: top_to_mfelix_at; t: std_logic_vector) return std_logic_vector;
  function convert(x: top_to_mfelix_at; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: top_to_mfelix_at) return top_to_mfelix_at;
  function convert(x: std_logic_vector; t: top_to_mfelix_at) return top_to_mfelix_at;
  function nullify(x: top_to_mfelix_at) return top_to_mfelix_at;
  function zeroed(x: top_to_mfelix_at) return top_to_mfelix_at;

  type top_to_status_at is array(DAQ_MAX_BRANCHES-1 downto 0) of daq_to_status_rt;
  function len(x: top_to_status_at) return natural;
  function width(x: top_to_status_at) return natural;
  function vectorify(x: top_to_status_at; t: std_logic_vector) return std_logic_vector;
  function convert(x: top_to_status_at; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: top_to_status_at) return top_to_status_at;
  function convert(x: std_logic_vector; t: top_to_status_at) return top_to_status_at;
  function nullify(x: top_to_status_at) return top_to_status_at;
  function zeroed(x: top_to_status_at) return top_to_status_at;

  type daq_branch_irt is record
    sys : daq_sys_rt;
    ttc : ttc_ort;
    ctrl : ctrl_to_daq_rt;
    branches : daq_branches_t;
    f2e_bus : mfelix_to_branch_at;
  end record daq_branch_irt;
  function len(x: daq_branch_irt) return natural;
  function width(x: daq_branch_irt) return natural;
  function vectorify(x: daq_branch_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_branch_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_branch_irt) return daq_branch_irt;
  function convert(x: in std_logic_vector; t: daq_branch_irt) return daq_branch_irt;
  function nullify(t: daq_branch_irt) return daq_branch_irt;
  function zeroed(t: daq_branch_irt) return daq_branch_irt;

  type daq_branch_ort is record
    status_bus : top_to_status_at;
    f2e_bus : top_to_mfelix_at;
  end record daq_branch_ort;
  function len(x: daq_branch_ort) return natural;
  function width(x: daq_branch_ort) return natural;
  function vectorify(x: daq_branch_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_branch_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_branch_ort) return daq_branch_ort;
  function convert(x: in std_logic_vector; t: daq_branch_ort) return daq_branch_ort;
  function nullify(t: daq_branch_ort) return daq_branch_ort;
  function zeroed(t: daq_branch_ort) return daq_branch_ort;

  type daq_branch_ert is record
    i : daq_branch_irt;
    o : daq_branch_ort;
  end record daq_branch_ert;
  function len(x: daq_branch_ert) return natural;
  function width(x: daq_branch_ert) return natural;
  function vectorify(x: daq_branch_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: daq_branch_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: daq_branch_ert) return daq_branch_ert;
  function convert(x: in std_logic_vector; t: daq_branch_ert) return daq_branch_ert;
  function nullify(t: daq_branch_ert) return daq_branch_ert;
  function zeroed(t: daq_branch_ert) return daq_branch_ert;

  subtype daq_branch_ivt is std_logic_vector(9846-1 downto 0);

  subtype daq_branch_ovt is std_logic_vector(1560-1 downto 0);

end package daq_defs;

------------------------------------------------------------

package body daq_defs is

  function len(x: daq_stream_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.bcid);
    l := l + len(x.valid);
    l := l + len(x.data);
    l := l + len(x.enable);
    return l;
  end function len;
  function width(x: daq_stream_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.bcid);
    l := l + width(x.valid);
    l := l + width(x.data);
    l := l + width(x.enable);
    return l;
  end function width;
  function vectorify(x: daq_stream_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcid)-1), vectorify(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.valid)-1), vectorify(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
      left := left + len(x.data);
      assign(y(left to left+len(x.enable)-1), vectorify(x.enable, y(left to left+len(x.enable)-1)));
    else
      assign(y(left downto left-len(x.bcid)+1), vectorify(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.valid)+1), vectorify(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
      left := left - len(x.data);
      assign(y(left downto left-len(x.enable)+1), vectorify(x.enable, y(left downto left-len(x.enable)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_stream_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcid)-1), convert(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.valid)-1), convert(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
      left := left + len(x.data);
      assign(y(left to left+len(x.enable)-1), convert(x.enable, y(left to left+len(x.enable)-1)));
    else
      assign(y(left downto left-len(x.bcid)+1), convert(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.valid)+1), convert(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
      left := left - len(x.data);
      assign(y(left downto left-len(x.enable)+1), convert(x.enable, y(left downto left-len(x.enable)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_stream_rt) return daq_stream_rt is
    variable y: daq_stream_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcid := structify(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.valid := structify(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.enable := structify(x(left to left+len(y.enable)-1), y.enable);
    else
      y.bcid := structify(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.valid := structify(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.enable := structify(x(left downto left-len(y.enable)+1), y.enable);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_stream_rt) return daq_stream_rt is
    variable y: daq_stream_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcid := convert(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.valid := convert(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.enable := convert(x(left to left+len(y.enable)-1), y.enable);
    else
      y.bcid := convert(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.valid := convert(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.enable := convert(x(left downto left-len(y.enable)+1), y.enable);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_stream_rt) return daq_stream_rt is
  variable y: daq_stream_rt;
  begin
    y.bcid := nullify(t.bcid);
    y.valid := nullify(t.valid);
    y.data := nullify(t.data);
    y.enable := nullify(t.enable);
    return y;
  end function nullify;
  function zeroed(t: daq_stream_rt) return daq_stream_rt is
  variable y: daq_stream_rt;
  begin
    y.bcid := zeroed(t.bcid);
    y.valid := zeroed(t.valid);
    y.data := zeroed(t.data);
    y.enable := zeroed(t.enable);
    return y;
  end function zeroed;

  function len(x: daq_branch_t) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: daq_branch_t) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: daq_branch_t; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_branch_t; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: daq_branch_t) return daq_branch_t is
    variable y : daq_branch_t;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: daq_branch_t) return daq_branch_t is
    variable y : daq_branch_t;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: daq_branch_t) return daq_branch_t is
    variable y : daq_branch_t;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: daq_branch_t) return daq_branch_t is
    variable y : daq_branch_t;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: daq_stream_struct_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.WIDTH);
    l := l + len(x.DEPTH);
    return l;
  end function len;
  function width(x: daq_stream_struct_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.WIDTH);
    l := l + width(x.DEPTH);
    return l;
  end function width;
  function vectorify(x: daq_stream_struct_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.WIDTH)-1), vectorify(x.WIDTH, y(left to left+len(x.WIDTH)-1)));
      left := left + len(x.WIDTH);
      assign(y(left to left+len(x.DEPTH)-1), vectorify(x.DEPTH, y(left to left+len(x.DEPTH)-1)));
    else
      assign(y(left downto left-len(x.WIDTH)+1), vectorify(x.WIDTH, y(left downto left-len(x.WIDTH)+1)));
      left := left - len(x.WIDTH);
      assign(y(left downto left-len(x.DEPTH)+1), vectorify(x.DEPTH, y(left downto left-len(x.DEPTH)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_stream_struct_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.WIDTH)-1), convert(x.WIDTH, y(left to left+len(x.WIDTH)-1)));
      left := left + len(x.WIDTH);
      assign(y(left to left+len(x.DEPTH)-1), convert(x.DEPTH, y(left to left+len(x.DEPTH)-1)));
    else
      assign(y(left downto left-len(x.WIDTH)+1), convert(x.WIDTH, y(left downto left-len(x.WIDTH)+1)));
      left := left - len(x.WIDTH);
      assign(y(left downto left-len(x.DEPTH)+1), convert(x.DEPTH, y(left downto left-len(x.DEPTH)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_stream_struct_t) return daq_stream_struct_t is
    variable y: daq_stream_struct_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.WIDTH := structify(x(left to left+len(y.WIDTH)-1), y.WIDTH);
      left := left + len(y.WIDTH);
      y.DEPTH := structify(x(left to left+len(y.DEPTH)-1), y.DEPTH);
    else
      y.WIDTH := structify(x(left downto left-len(y.WIDTH)+1), y.WIDTH);
      left := left - len(y.WIDTH);
      y.DEPTH := structify(x(left downto left-len(y.DEPTH)+1), y.DEPTH);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_stream_struct_t) return daq_stream_struct_t is
    variable y: daq_stream_struct_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.WIDTH := convert(x(left to left+len(y.WIDTH)-1), y.WIDTH);
      left := left + len(y.WIDTH);
      y.DEPTH := convert(x(left to left+len(y.DEPTH)-1), y.DEPTH);
    else
      y.WIDTH := convert(x(left downto left-len(y.WIDTH)+1), y.WIDTH);
      left := left - len(y.WIDTH);
      y.DEPTH := convert(x(left downto left-len(y.DEPTH)+1), y.DEPTH);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_stream_struct_t) return daq_stream_struct_t is
  variable y: daq_stream_struct_t;
  begin
    y.WIDTH := nullify(t.WIDTH);
    y.DEPTH := nullify(t.DEPTH);
    return y;
  end function nullify;
  function zeroed(t: daq_stream_struct_t) return daq_stream_struct_t is
  variable y: daq_stream_struct_t;
  begin
    y.WIDTH := zeroed(t.WIDTH);
    y.DEPTH := zeroed(t.DEPTH);
    return y;
  end function zeroed;

  function len(x: daq_branch_struct_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: daq_branch_struct_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: daq_branch_struct_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_branch_struct_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: daq_branch_struct_at) return daq_branch_struct_at is
    variable y : daq_branch_struct_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: daq_branch_struct_at) return daq_branch_struct_at is
    variable y : daq_branch_struct_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: daq_branch_struct_at) return daq_branch_struct_at is
    variable y : daq_branch_struct_at;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: daq_branch_struct_at) return daq_branch_struct_at is
    variable y : daq_branch_struct_at;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: daq_branches_t) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: daq_branches_t) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: daq_branches_t; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_branches_t; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: daq_branches_t) return daq_branches_t is
    variable y : daq_branches_t;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: daq_branches_t) return daq_branches_t is
    variable y : daq_branches_t;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: daq_branches_t) return daq_branches_t is
    variable y : daq_branches_t;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: daq_branches_t) return daq_branches_t is
    variable y : daq_branches_t;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: daq_branches_mask_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * 32;
    return l;
  end function len;
  function width(x: daq_branches_mask_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * 32;
    return l;
  end function width;
  function vectorify(x: daq_branches_mask_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_branches_mask_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: daq_branches_mask_at) return daq_branches_mask_at is
    variable y : daq_branches_mask_at;
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: daq_branches_mask_at) return daq_branches_mask_at is
    variable y : daq_branches_mask_at;
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: daq_branches_mask_at) return daq_branches_mask_at is
    variable y : daq_branches_mask_at;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: daq_branches_mask_at) return daq_branches_mask_at is
    variable y : daq_branches_mask_at;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: daq_branches_map_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: daq_branches_map_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: daq_branches_map_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_branches_map_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: daq_branches_map_at) return daq_branches_map_at is
    variable y : daq_branches_map_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: daq_branches_map_at) return daq_branches_map_at is
    variable y : daq_branches_map_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: daq_branches_map_at) return daq_branches_map_at is
    variable y : daq_branches_map_at;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: daq_branches_map_at) return daq_branches_map_at is
    variable y : daq_branches_map_at;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: daq_sys_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.clk320);
    l := l + len(x.rst);
    return l;
  end function len;
  function width(x: daq_sys_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.clk320);
    l := l + width(x.rst);
    return l;
  end function width;
  function vectorify(x: daq_sys_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.clk320)-1), vectorify(x.clk320, y(left to left+len(x.clk320)-1)));
      left := left + len(x.clk320);
      assign(y(left to left+len(x.rst)-1), vectorify(x.rst, y(left to left+len(x.rst)-1)));
    else
      assign(y(left downto left-len(x.clk320)+1), vectorify(x.clk320, y(left downto left-len(x.clk320)+1)));
      left := left - len(x.clk320);
      assign(y(left downto left-len(x.rst)+1), vectorify(x.rst, y(left downto left-len(x.rst)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_sys_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.clk320)-1), convert(x.clk320, y(left to left+len(x.clk320)-1)));
      left := left + len(x.clk320);
      assign(y(left to left+len(x.rst)-1), convert(x.rst, y(left to left+len(x.rst)-1)));
    else
      assign(y(left downto left-len(x.clk320)+1), convert(x.clk320, y(left downto left-len(x.clk320)+1)));
      left := left - len(x.clk320);
      assign(y(left downto left-len(x.rst)+1), convert(x.rst, y(left downto left-len(x.rst)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_sys_rt) return daq_sys_rt is
    variable y: daq_sys_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.clk320 := structify(x(left to left+len(y.clk320)-1), y.clk320);
      left := left + len(y.clk320);
      y.rst := structify(x(left to left+len(y.rst)-1), y.rst);
    else
      y.clk320 := structify(x(left downto left-len(y.clk320)+1), y.clk320);
      left := left - len(y.clk320);
      y.rst := structify(x(left downto left-len(y.rst)+1), y.rst);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_sys_rt) return daq_sys_rt is
    variable y: daq_sys_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.clk320 := convert(x(left to left+len(y.clk320)-1), y.clk320);
      left := left + len(y.clk320);
      y.rst := convert(x(left to left+len(y.rst)-1), y.rst);
    else
      y.clk320 := convert(x(left downto left-len(y.clk320)+1), y.clk320);
      left := left - len(y.clk320);
      y.rst := convert(x(left downto left-len(y.rst)+1), y.rst);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_sys_rt) return daq_sys_rt is
  variable y: daq_sys_rt;
  begin
    y.clk320 := nullify(t.clk320);
    y.rst := nullify(t.rst);
    return y;
  end function nullify;
  function zeroed(t: daq_sys_rt) return daq_sys_rt is
  variable y: daq_sys_rt;
  begin
    y.clk320 := zeroed(t.clk320);
    y.rst := zeroed(t.rst);
    return y;
  end function zeroed;

  function len(x: daq_hdr_swrod_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.flag_0);
    l := l + len(x.flag_1);
    l := l + len(x.flag_2);
    l := l + len(x.evid);
    return l;
  end function len;
  function width(x: daq_hdr_swrod_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.flag_0);
    l := l + width(x.flag_1);
    l := l + width(x.flag_2);
    l := l + width(x.evid);
    return l;
  end function width;
  function vectorify(x: daq_hdr_swrod_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.flag_0)-1), vectorify(x.flag_0, y(left to left+len(x.flag_0)-1)));
      left := left + len(x.flag_0);
      assign(y(left to left+len(x.flag_1)-1), vectorify(x.flag_1, y(left to left+len(x.flag_1)-1)));
      left := left + len(x.flag_1);
      assign(y(left to left+len(x.flag_2)-1), vectorify(x.flag_2, y(left to left+len(x.flag_2)-1)));
      left := left + len(x.flag_2);
      assign(y(left to left+len(x.evid)-1), vectorify(x.evid, y(left to left+len(x.evid)-1)));
    else
      assign(y(left downto left-len(x.flag_0)+1), vectorify(x.flag_0, y(left downto left-len(x.flag_0)+1)));
      left := left - len(x.flag_0);
      assign(y(left downto left-len(x.flag_1)+1), vectorify(x.flag_1, y(left downto left-len(x.flag_1)+1)));
      left := left - len(x.flag_1);
      assign(y(left downto left-len(x.flag_2)+1), vectorify(x.flag_2, y(left downto left-len(x.flag_2)+1)));
      left := left - len(x.flag_2);
      assign(y(left downto left-len(x.evid)+1), vectorify(x.evid, y(left downto left-len(x.evid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_hdr_swrod_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.flag_0)-1), convert(x.flag_0, y(left to left+len(x.flag_0)-1)));
      left := left + len(x.flag_0);
      assign(y(left to left+len(x.flag_1)-1), convert(x.flag_1, y(left to left+len(x.flag_1)-1)));
      left := left + len(x.flag_1);
      assign(y(left to left+len(x.flag_2)-1), convert(x.flag_2, y(left to left+len(x.flag_2)-1)));
      left := left + len(x.flag_2);
      assign(y(left to left+len(x.evid)-1), convert(x.evid, y(left to left+len(x.evid)-1)));
    else
      assign(y(left downto left-len(x.flag_0)+1), convert(x.flag_0, y(left downto left-len(x.flag_0)+1)));
      left := left - len(x.flag_0);
      assign(y(left downto left-len(x.flag_1)+1), convert(x.flag_1, y(left downto left-len(x.flag_1)+1)));
      left := left - len(x.flag_1);
      assign(y(left downto left-len(x.flag_2)+1), convert(x.flag_2, y(left downto left-len(x.flag_2)+1)));
      left := left - len(x.flag_2);
      assign(y(left downto left-len(x.evid)+1), convert(x.evid, y(left downto left-len(x.evid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_hdr_swrod_rt) return daq_hdr_swrod_rt is
    variable y: daq_hdr_swrod_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.flag_0 := structify(x(left to left+len(y.flag_0)-1), y.flag_0);
      left := left + len(y.flag_0);
      y.flag_1 := structify(x(left to left+len(y.flag_1)-1), y.flag_1);
      left := left + len(y.flag_1);
      y.flag_2 := structify(x(left to left+len(y.flag_2)-1), y.flag_2);
      left := left + len(y.flag_2);
      y.evid := structify(x(left to left+len(y.evid)-1), y.evid);
    else
      y.flag_0 := structify(x(left downto left-len(y.flag_0)+1), y.flag_0);
      left := left - len(y.flag_0);
      y.flag_1 := structify(x(left downto left-len(y.flag_1)+1), y.flag_1);
      left := left - len(y.flag_1);
      y.flag_2 := structify(x(left downto left-len(y.flag_2)+1), y.flag_2);
      left := left - len(y.flag_2);
      y.evid := structify(x(left downto left-len(y.evid)+1), y.evid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_hdr_swrod_rt) return daq_hdr_swrod_rt is
    variable y: daq_hdr_swrod_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.flag_0 := convert(x(left to left+len(y.flag_0)-1), y.flag_0);
      left := left + len(y.flag_0);
      y.flag_1 := convert(x(left to left+len(y.flag_1)-1), y.flag_1);
      left := left + len(y.flag_1);
      y.flag_2 := convert(x(left to left+len(y.flag_2)-1), y.flag_2);
      left := left + len(y.flag_2);
      y.evid := convert(x(left to left+len(y.evid)-1), y.evid);
    else
      y.flag_0 := convert(x(left downto left-len(y.flag_0)+1), y.flag_0);
      left := left - len(y.flag_0);
      y.flag_1 := convert(x(left downto left-len(y.flag_1)+1), y.flag_1);
      left := left - len(y.flag_1);
      y.flag_2 := convert(x(left downto left-len(y.flag_2)+1), y.flag_2);
      left := left - len(y.flag_2);
      y.evid := convert(x(left downto left-len(y.evid)+1), y.evid);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_hdr_swrod_rt) return daq_hdr_swrod_rt is
  variable y: daq_hdr_swrod_rt;
  begin
    y.flag_0 := nullify(t.flag_0);
    y.flag_1 := nullify(t.flag_1);
    y.flag_2 := nullify(t.flag_2);
    y.evid := nullify(t.evid);
    return y;
  end function nullify;
  function zeroed(t: daq_hdr_swrod_rt) return daq_hdr_swrod_rt is
  variable y: daq_hdr_swrod_rt;
  begin
    y.flag_0 := zeroed(t.flag_0);
    y.flag_1 := zeroed(t.flag_1);
    y.flag_2 := zeroed(t.flag_2);
    y.evid := zeroed(t.evid);
    return y;
  end function zeroed;

  function len(x: daq_hdr_extra_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.daq_bcid);
    l := l + len(x.window_start);
    l := l + len(x.window_width);
    l := l + len(x.window_latency);
    l := l + len(x.lower_window_size);
    l := l + len(x.upper_window_size);
    l := l + len(x.sys_bcid);
    return l;
  end function len;
  function width(x: daq_hdr_extra_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.daq_bcid);
    l := l + width(x.window_start);
    l := l + width(x.window_width);
    l := l + width(x.window_latency);
    l := l + width(x.lower_window_size);
    l := l + width(x.upper_window_size);
    l := l + width(x.sys_bcid);
    return l;
  end function width;
  function vectorify(x: daq_hdr_extra_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.daq_bcid)-1), vectorify(x.daq_bcid, y(left to left+len(x.daq_bcid)-1)));
      left := left + len(x.daq_bcid);
      assign(y(left to left+len(x.window_start)-1), vectorify(x.window_start, y(left to left+len(x.window_start)-1)));
      left := left + len(x.window_start);
      assign(y(left to left+len(x.window_width)-1), vectorify(x.window_width, y(left to left+len(x.window_width)-1)));
      left := left + len(x.window_width);
      assign(y(left to left+len(x.window_latency)-1), vectorify(x.window_latency, y(left to left+len(x.window_latency)-1)));
      left := left + len(x.window_latency);
      assign(y(left to left+len(x.lower_window_size)-1), vectorify(x.lower_window_size, y(left to left+len(x.lower_window_size)-1)));
      left := left + len(x.lower_window_size);
      assign(y(left to left+len(x.upper_window_size)-1), vectorify(x.upper_window_size, y(left to left+len(x.upper_window_size)-1)));
      left := left + len(x.upper_window_size);
      assign(y(left to left+len(x.sys_bcid)-1), vectorify(x.sys_bcid, y(left to left+len(x.sys_bcid)-1)));
    else
      assign(y(left downto left-len(x.daq_bcid)+1), vectorify(x.daq_bcid, y(left downto left-len(x.daq_bcid)+1)));
      left := left - len(x.daq_bcid);
      assign(y(left downto left-len(x.window_start)+1), vectorify(x.window_start, y(left downto left-len(x.window_start)+1)));
      left := left - len(x.window_start);
      assign(y(left downto left-len(x.window_width)+1), vectorify(x.window_width, y(left downto left-len(x.window_width)+1)));
      left := left - len(x.window_width);
      assign(y(left downto left-len(x.window_latency)+1), vectorify(x.window_latency, y(left downto left-len(x.window_latency)+1)));
      left := left - len(x.window_latency);
      assign(y(left downto left-len(x.lower_window_size)+1), vectorify(x.lower_window_size, y(left downto left-len(x.lower_window_size)+1)));
      left := left - len(x.lower_window_size);
      assign(y(left downto left-len(x.upper_window_size)+1), vectorify(x.upper_window_size, y(left downto left-len(x.upper_window_size)+1)));
      left := left - len(x.upper_window_size);
      assign(y(left downto left-len(x.sys_bcid)+1), vectorify(x.sys_bcid, y(left downto left-len(x.sys_bcid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_hdr_extra_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.daq_bcid)-1), convert(x.daq_bcid, y(left to left+len(x.daq_bcid)-1)));
      left := left + len(x.daq_bcid);
      assign(y(left to left+len(x.window_start)-1), convert(x.window_start, y(left to left+len(x.window_start)-1)));
      left := left + len(x.window_start);
      assign(y(left to left+len(x.window_width)-1), convert(x.window_width, y(left to left+len(x.window_width)-1)));
      left := left + len(x.window_width);
      assign(y(left to left+len(x.window_latency)-1), convert(x.window_latency, y(left to left+len(x.window_latency)-1)));
      left := left + len(x.window_latency);
      assign(y(left to left+len(x.lower_window_size)-1), convert(x.lower_window_size, y(left to left+len(x.lower_window_size)-1)));
      left := left + len(x.lower_window_size);
      assign(y(left to left+len(x.upper_window_size)-1), convert(x.upper_window_size, y(left to left+len(x.upper_window_size)-1)));
      left := left + len(x.upper_window_size);
      assign(y(left to left+len(x.sys_bcid)-1), convert(x.sys_bcid, y(left to left+len(x.sys_bcid)-1)));
    else
      assign(y(left downto left-len(x.daq_bcid)+1), convert(x.daq_bcid, y(left downto left-len(x.daq_bcid)+1)));
      left := left - len(x.daq_bcid);
      assign(y(left downto left-len(x.window_start)+1), convert(x.window_start, y(left downto left-len(x.window_start)+1)));
      left := left - len(x.window_start);
      assign(y(left downto left-len(x.window_width)+1), convert(x.window_width, y(left downto left-len(x.window_width)+1)));
      left := left - len(x.window_width);
      assign(y(left downto left-len(x.window_latency)+1), convert(x.window_latency, y(left downto left-len(x.window_latency)+1)));
      left := left - len(x.window_latency);
      assign(y(left downto left-len(x.lower_window_size)+1), convert(x.lower_window_size, y(left downto left-len(x.lower_window_size)+1)));
      left := left - len(x.lower_window_size);
      assign(y(left downto left-len(x.upper_window_size)+1), convert(x.upper_window_size, y(left downto left-len(x.upper_window_size)+1)));
      left := left - len(x.upper_window_size);
      assign(y(left downto left-len(x.sys_bcid)+1), convert(x.sys_bcid, y(left downto left-len(x.sys_bcid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_hdr_extra_rt) return daq_hdr_extra_rt is
    variable y: daq_hdr_extra_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.daq_bcid := structify(x(left to left+len(y.daq_bcid)-1), y.daq_bcid);
      left := left + len(y.daq_bcid);
      y.window_start := structify(x(left to left+len(y.window_start)-1), y.window_start);
      left := left + len(y.window_start);
      y.window_width := structify(x(left to left+len(y.window_width)-1), y.window_width);
      left := left + len(y.window_width);
      y.window_latency := structify(x(left to left+len(y.window_latency)-1), y.window_latency);
      left := left + len(y.window_latency);
      y.lower_window_size := structify(x(left to left+len(y.lower_window_size)-1), y.lower_window_size);
      left := left + len(y.lower_window_size);
      y.upper_window_size := structify(x(left to left+len(y.upper_window_size)-1), y.upper_window_size);
      left := left + len(y.upper_window_size);
      y.sys_bcid := structify(x(left to left+len(y.sys_bcid)-1), y.sys_bcid);
    else
      y.daq_bcid := structify(x(left downto left-len(y.daq_bcid)+1), y.daq_bcid);
      left := left - len(y.daq_bcid);
      y.window_start := structify(x(left downto left-len(y.window_start)+1), y.window_start);
      left := left - len(y.window_start);
      y.window_width := structify(x(left downto left-len(y.window_width)+1), y.window_width);
      left := left - len(y.window_width);
      y.window_latency := structify(x(left downto left-len(y.window_latency)+1), y.window_latency);
      left := left - len(y.window_latency);
      y.lower_window_size := structify(x(left downto left-len(y.lower_window_size)+1), y.lower_window_size);
      left := left - len(y.lower_window_size);
      y.upper_window_size := structify(x(left downto left-len(y.upper_window_size)+1), y.upper_window_size);
      left := left - len(y.upper_window_size);
      y.sys_bcid := structify(x(left downto left-len(y.sys_bcid)+1), y.sys_bcid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_hdr_extra_rt) return daq_hdr_extra_rt is
    variable y: daq_hdr_extra_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.daq_bcid := convert(x(left to left+len(y.daq_bcid)-1), y.daq_bcid);
      left := left + len(y.daq_bcid);
      y.window_start := convert(x(left to left+len(y.window_start)-1), y.window_start);
      left := left + len(y.window_start);
      y.window_width := convert(x(left to left+len(y.window_width)-1), y.window_width);
      left := left + len(y.window_width);
      y.window_latency := convert(x(left to left+len(y.window_latency)-1), y.window_latency);
      left := left + len(y.window_latency);
      y.lower_window_size := convert(x(left to left+len(y.lower_window_size)-1), y.lower_window_size);
      left := left + len(y.lower_window_size);
      y.upper_window_size := convert(x(left to left+len(y.upper_window_size)-1), y.upper_window_size);
      left := left + len(y.upper_window_size);
      y.sys_bcid := convert(x(left to left+len(y.sys_bcid)-1), y.sys_bcid);
    else
      y.daq_bcid := convert(x(left downto left-len(y.daq_bcid)+1), y.daq_bcid);
      left := left - len(y.daq_bcid);
      y.window_start := convert(x(left downto left-len(y.window_start)+1), y.window_start);
      left := left - len(y.window_start);
      y.window_width := convert(x(left downto left-len(y.window_width)+1), y.window_width);
      left := left - len(y.window_width);
      y.window_latency := convert(x(left downto left-len(y.window_latency)+1), y.window_latency);
      left := left - len(y.window_latency);
      y.lower_window_size := convert(x(left downto left-len(y.lower_window_size)+1), y.lower_window_size);
      left := left - len(y.lower_window_size);
      y.upper_window_size := convert(x(left downto left-len(y.upper_window_size)+1), y.upper_window_size);
      left := left - len(y.upper_window_size);
      y.sys_bcid := convert(x(left downto left-len(y.sys_bcid)+1), y.sys_bcid);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_hdr_extra_rt) return daq_hdr_extra_rt is
  variable y: daq_hdr_extra_rt;
  begin
    y.daq_bcid := nullify(t.daq_bcid);
    y.window_start := nullify(t.window_start);
    y.window_width := nullify(t.window_width);
    y.window_latency := nullify(t.window_latency);
    y.lower_window_size := nullify(t.lower_window_size);
    y.upper_window_size := nullify(t.upper_window_size);
    y.sys_bcid := nullify(t.sys_bcid);
    return y;
  end function nullify;
  function zeroed(t: daq_hdr_extra_rt) return daq_hdr_extra_rt is
  variable y: daq_hdr_extra_rt;
  begin
    y.daq_bcid := zeroed(t.daq_bcid);
    y.window_start := zeroed(t.window_start);
    y.window_width := zeroed(t.window_width);
    y.window_latency := zeroed(t.window_latency);
    y.lower_window_size := zeroed(t.lower_window_size);
    y.upper_window_size := zeroed(t.upper_window_size);
    y.sys_bcid := zeroed(t.sys_bcid);
    return y;
  end function zeroed;

  function len(x: daq_hdr_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.swrod);
    l := l + len(x.extra);
    return l;
  end function len;
  function width(x: daq_hdr_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.swrod);
    l := l + width(x.extra);
    return l;
  end function width;
  function vectorify(x: daq_hdr_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.swrod)-1), vectorify(x.swrod, y(left to left+len(x.swrod)-1)));
      left := left + len(x.swrod);
      assign(y(left to left+len(x.extra)-1), vectorify(x.extra, y(left to left+len(x.extra)-1)));
    else
      assign(y(left downto left-len(x.swrod)+1), vectorify(x.swrod, y(left downto left-len(x.swrod)+1)));
      left := left - len(x.swrod);
      assign(y(left downto left-len(x.extra)+1), vectorify(x.extra, y(left downto left-len(x.extra)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_hdr_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.swrod)-1), convert(x.swrod, y(left to left+len(x.swrod)-1)));
      left := left + len(x.swrod);
      assign(y(left to left+len(x.extra)-1), convert(x.extra, y(left to left+len(x.extra)-1)));
    else
      assign(y(left downto left-len(x.swrod)+1), convert(x.swrod, y(left downto left-len(x.swrod)+1)));
      left := left - len(x.swrod);
      assign(y(left downto left-len(x.extra)+1), convert(x.extra, y(left downto left-len(x.extra)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_hdr_rt) return daq_hdr_rt is
    variable y: daq_hdr_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.swrod := structify(x(left to left+len(y.swrod)-1), y.swrod);
      left := left + len(y.swrod);
      y.extra := structify(x(left to left+len(y.extra)-1), y.extra);
    else
      y.swrod := structify(x(left downto left-len(y.swrod)+1), y.swrod);
      left := left - len(y.swrod);
      y.extra := structify(x(left downto left-len(y.extra)+1), y.extra);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_hdr_rt) return daq_hdr_rt is
    variable y: daq_hdr_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.swrod := convert(x(left to left+len(y.swrod)-1), y.swrod);
      left := left + len(y.swrod);
      y.extra := convert(x(left to left+len(y.extra)-1), y.extra);
    else
      y.swrod := convert(x(left downto left-len(y.swrod)+1), y.swrod);
      left := left - len(y.swrod);
      y.extra := convert(x(left downto left-len(y.extra)+1), y.extra);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_hdr_rt) return daq_hdr_rt is
  variable y: daq_hdr_rt;
  begin
    y.swrod := nullify(t.swrod);
    y.extra := nullify(t.extra);
    return y;
  end function nullify;
  function zeroed(t: daq_hdr_rt) return daq_hdr_rt is
  variable y: daq_hdr_rt;
  begin
    y.swrod := zeroed(t.swrod);
    y.extra := zeroed(t.extra);
    return y;
  end function zeroed;

  function len(x: daq_counters_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.daq_bcid);
    l := l + len(x.sys_bcid);
    l := l + len(x.lower_window_limit);
    l := l + len(x.upper_window_limit);
    return l;
  end function len;
  function width(x: daq_counters_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.daq_bcid);
    l := l + width(x.sys_bcid);
    l := l + width(x.lower_window_limit);
    l := l + width(x.upper_window_limit);
    return l;
  end function width;
  function vectorify(x: daq_counters_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.daq_bcid)-1), vectorify(x.daq_bcid, y(left to left+len(x.daq_bcid)-1)));
      left := left + len(x.daq_bcid);
      assign(y(left to left+len(x.sys_bcid)-1), vectorify(x.sys_bcid, y(left to left+len(x.sys_bcid)-1)));
      left := left + len(x.sys_bcid);
      assign(y(left to left+len(x.lower_window_limit)-1), vectorify(x.lower_window_limit, y(left to left+len(x.lower_window_limit)-1)));
      left := left + len(x.lower_window_limit);
      assign(y(left to left+len(x.upper_window_limit)-1), vectorify(x.upper_window_limit, y(left to left+len(x.upper_window_limit)-1)));
    else
      assign(y(left downto left-len(x.daq_bcid)+1), vectorify(x.daq_bcid, y(left downto left-len(x.daq_bcid)+1)));
      left := left - len(x.daq_bcid);
      assign(y(left downto left-len(x.sys_bcid)+1), vectorify(x.sys_bcid, y(left downto left-len(x.sys_bcid)+1)));
      left := left - len(x.sys_bcid);
      assign(y(left downto left-len(x.lower_window_limit)+1), vectorify(x.lower_window_limit, y(left downto left-len(x.lower_window_limit)+1)));
      left := left - len(x.lower_window_limit);
      assign(y(left downto left-len(x.upper_window_limit)+1), vectorify(x.upper_window_limit, y(left downto left-len(x.upper_window_limit)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_counters_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.daq_bcid)-1), convert(x.daq_bcid, y(left to left+len(x.daq_bcid)-1)));
      left := left + len(x.daq_bcid);
      assign(y(left to left+len(x.sys_bcid)-1), convert(x.sys_bcid, y(left to left+len(x.sys_bcid)-1)));
      left := left + len(x.sys_bcid);
      assign(y(left to left+len(x.lower_window_limit)-1), convert(x.lower_window_limit, y(left to left+len(x.lower_window_limit)-1)));
      left := left + len(x.lower_window_limit);
      assign(y(left to left+len(x.upper_window_limit)-1), convert(x.upper_window_limit, y(left to left+len(x.upper_window_limit)-1)));
    else
      assign(y(left downto left-len(x.daq_bcid)+1), convert(x.daq_bcid, y(left downto left-len(x.daq_bcid)+1)));
      left := left - len(x.daq_bcid);
      assign(y(left downto left-len(x.sys_bcid)+1), convert(x.sys_bcid, y(left downto left-len(x.sys_bcid)+1)));
      left := left - len(x.sys_bcid);
      assign(y(left downto left-len(x.lower_window_limit)+1), convert(x.lower_window_limit, y(left downto left-len(x.lower_window_limit)+1)));
      left := left - len(x.lower_window_limit);
      assign(y(left downto left-len(x.upper_window_limit)+1), convert(x.upper_window_limit, y(left downto left-len(x.upper_window_limit)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_counters_rt) return daq_counters_rt is
    variable y: daq_counters_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.daq_bcid := structify(x(left to left+len(y.daq_bcid)-1), y.daq_bcid);
      left := left + len(y.daq_bcid);
      y.sys_bcid := structify(x(left to left+len(y.sys_bcid)-1), y.sys_bcid);
      left := left + len(y.sys_bcid);
      y.lower_window_limit := structify(x(left to left+len(y.lower_window_limit)-1), y.lower_window_limit);
      left := left + len(y.lower_window_limit);
      y.upper_window_limit := structify(x(left to left+len(y.upper_window_limit)-1), y.upper_window_limit);
    else
      y.daq_bcid := structify(x(left downto left-len(y.daq_bcid)+1), y.daq_bcid);
      left := left - len(y.daq_bcid);
      y.sys_bcid := structify(x(left downto left-len(y.sys_bcid)+1), y.sys_bcid);
      left := left - len(y.sys_bcid);
      y.lower_window_limit := structify(x(left downto left-len(y.lower_window_limit)+1), y.lower_window_limit);
      left := left - len(y.lower_window_limit);
      y.upper_window_limit := structify(x(left downto left-len(y.upper_window_limit)+1), y.upper_window_limit);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_counters_rt) return daq_counters_rt is
    variable y: daq_counters_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.daq_bcid := convert(x(left to left+len(y.daq_bcid)-1), y.daq_bcid);
      left := left + len(y.daq_bcid);
      y.sys_bcid := convert(x(left to left+len(y.sys_bcid)-1), y.sys_bcid);
      left := left + len(y.sys_bcid);
      y.lower_window_limit := convert(x(left to left+len(y.lower_window_limit)-1), y.lower_window_limit);
      left := left + len(y.lower_window_limit);
      y.upper_window_limit := convert(x(left to left+len(y.upper_window_limit)-1), y.upper_window_limit);
    else
      y.daq_bcid := convert(x(left downto left-len(y.daq_bcid)+1), y.daq_bcid);
      left := left - len(y.daq_bcid);
      y.sys_bcid := convert(x(left downto left-len(y.sys_bcid)+1), y.sys_bcid);
      left := left - len(y.sys_bcid);
      y.lower_window_limit := convert(x(left downto left-len(y.lower_window_limit)+1), y.lower_window_limit);
      left := left - len(y.lower_window_limit);
      y.upper_window_limit := convert(x(left downto left-len(y.upper_window_limit)+1), y.upper_window_limit);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_counters_rt) return daq_counters_rt is
  variable y: daq_counters_rt;
  begin
    y.daq_bcid := nullify(t.daq_bcid);
    y.sys_bcid := nullify(t.sys_bcid);
    y.lower_window_limit := nullify(t.lower_window_limit);
    y.upper_window_limit := nullify(t.upper_window_limit);
    return y;
  end function nullify;
  function zeroed(t: daq_counters_rt) return daq_counters_rt is
  variable y: daq_counters_rt;
  begin
    y.daq_bcid := zeroed(t.daq_bcid);
    y.sys_bcid := zeroed(t.sys_bcid);
    y.lower_window_limit := zeroed(t.lower_window_limit);
    y.upper_window_limit := zeroed(t.upper_window_limit);
    return y;
  end function zeroed;

  function len(x: daq_window_params_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.lower_size);
    l := l + len(x.upper_size);
    l := l + len(x.latency);
    return l;
  end function len;
  function width(x: daq_window_params_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.lower_size);
    l := l + width(x.upper_size);
    l := l + width(x.latency);
    return l;
  end function width;
  function vectorify(x: daq_window_params_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.lower_size)-1), vectorify(x.lower_size, y(left to left+len(x.lower_size)-1)));
      left := left + len(x.lower_size);
      assign(y(left to left+len(x.upper_size)-1), vectorify(x.upper_size, y(left to left+len(x.upper_size)-1)));
      left := left + len(x.upper_size);
      assign(y(left to left+len(x.latency)-1), vectorify(x.latency, y(left to left+len(x.latency)-1)));
    else
      assign(y(left downto left-len(x.lower_size)+1), vectorify(x.lower_size, y(left downto left-len(x.lower_size)+1)));
      left := left - len(x.lower_size);
      assign(y(left downto left-len(x.upper_size)+1), vectorify(x.upper_size, y(left downto left-len(x.upper_size)+1)));
      left := left - len(x.upper_size);
      assign(y(left downto left-len(x.latency)+1), vectorify(x.latency, y(left downto left-len(x.latency)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_window_params_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.lower_size)-1), convert(x.lower_size, y(left to left+len(x.lower_size)-1)));
      left := left + len(x.lower_size);
      assign(y(left to left+len(x.upper_size)-1), convert(x.upper_size, y(left to left+len(x.upper_size)-1)));
      left := left + len(x.upper_size);
      assign(y(left to left+len(x.latency)-1), convert(x.latency, y(left to left+len(x.latency)-1)));
    else
      assign(y(left downto left-len(x.lower_size)+1), convert(x.lower_size, y(left downto left-len(x.lower_size)+1)));
      left := left - len(x.lower_size);
      assign(y(left downto left-len(x.upper_size)+1), convert(x.upper_size, y(left downto left-len(x.upper_size)+1)));
      left := left - len(x.upper_size);
      assign(y(left downto left-len(x.latency)+1), convert(x.latency, y(left downto left-len(x.latency)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_window_params_rt) return daq_window_params_rt is
    variable y: daq_window_params_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.lower_size := structify(x(left to left+len(y.lower_size)-1), y.lower_size);
      left := left + len(y.lower_size);
      y.upper_size := structify(x(left to left+len(y.upper_size)-1), y.upper_size);
      left := left + len(y.upper_size);
      y.latency := structify(x(left to left+len(y.latency)-1), y.latency);
    else
      y.lower_size := structify(x(left downto left-len(y.lower_size)+1), y.lower_size);
      left := left - len(y.lower_size);
      y.upper_size := structify(x(left downto left-len(y.upper_size)+1), y.upper_size);
      left := left - len(y.upper_size);
      y.latency := structify(x(left downto left-len(y.latency)+1), y.latency);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_window_params_rt) return daq_window_params_rt is
    variable y: daq_window_params_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.lower_size := convert(x(left to left+len(y.lower_size)-1), y.lower_size);
      left := left + len(y.lower_size);
      y.upper_size := convert(x(left to left+len(y.upper_size)-1), y.upper_size);
      left := left + len(y.upper_size);
      y.latency := convert(x(left to left+len(y.latency)-1), y.latency);
    else
      y.lower_size := convert(x(left downto left-len(y.lower_size)+1), y.lower_size);
      left := left - len(y.lower_size);
      y.upper_size := convert(x(left downto left-len(y.upper_size)+1), y.upper_size);
      left := left - len(y.upper_size);
      y.latency := convert(x(left downto left-len(y.latency)+1), y.latency);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_window_params_rt) return daq_window_params_rt is
  variable y: daq_window_params_rt;
  begin
    y.lower_size := nullify(t.lower_size);
    y.upper_size := nullify(t.upper_size);
    y.latency := nullify(t.latency);
    return y;
  end function nullify;
  function zeroed(t: daq_window_params_rt) return daq_window_params_rt is
  variable y: daq_window_params_rt;
  begin
    y.lower_size := zeroed(t.lower_size);
    y.upper_size := zeroed(t.upper_size);
    y.latency := zeroed(t.latency);
    return y;
  end function zeroed;

  function len(x: stability_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.upper_window_limit);
    l := l + len(x.lower_window_limit);
    l := l + len(x.daq_bcid);
    return l;
  end function len;
  function width(x: stability_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.upper_window_limit);
    l := l + width(x.lower_window_limit);
    l := l + width(x.daq_bcid);
    return l;
  end function width;
  function vectorify(x: stability_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.upper_window_limit)-1), vectorify(x.upper_window_limit, y(left to left+len(x.upper_window_limit)-1)));
      left := left + len(x.upper_window_limit);
      assign(y(left to left+len(x.lower_window_limit)-1), vectorify(x.lower_window_limit, y(left to left+len(x.lower_window_limit)-1)));
      left := left + len(x.lower_window_limit);
      assign(y(left to left+len(x.daq_bcid)-1), vectorify(x.daq_bcid, y(left to left+len(x.daq_bcid)-1)));
    else
      assign(y(left downto left-len(x.upper_window_limit)+1), vectorify(x.upper_window_limit, y(left downto left-len(x.upper_window_limit)+1)));
      left := left - len(x.upper_window_limit);
      assign(y(left downto left-len(x.lower_window_limit)+1), vectorify(x.lower_window_limit, y(left downto left-len(x.lower_window_limit)+1)));
      left := left - len(x.lower_window_limit);
      assign(y(left downto left-len(x.daq_bcid)+1), vectorify(x.daq_bcid, y(left downto left-len(x.daq_bcid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: stability_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.upper_window_limit)-1), convert(x.upper_window_limit, y(left to left+len(x.upper_window_limit)-1)));
      left := left + len(x.upper_window_limit);
      assign(y(left to left+len(x.lower_window_limit)-1), convert(x.lower_window_limit, y(left to left+len(x.lower_window_limit)-1)));
      left := left + len(x.lower_window_limit);
      assign(y(left to left+len(x.daq_bcid)-1), convert(x.daq_bcid, y(left to left+len(x.daq_bcid)-1)));
    else
      assign(y(left downto left-len(x.upper_window_limit)+1), convert(x.upper_window_limit, y(left downto left-len(x.upper_window_limit)+1)));
      left := left - len(x.upper_window_limit);
      assign(y(left downto left-len(x.lower_window_limit)+1), convert(x.lower_window_limit, y(left downto left-len(x.lower_window_limit)+1)));
      left := left - len(x.lower_window_limit);
      assign(y(left downto left-len(x.daq_bcid)+1), convert(x.daq_bcid, y(left downto left-len(x.daq_bcid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: stability_rt) return stability_rt is
    variable y: stability_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.upper_window_limit := structify(x(left to left+len(y.upper_window_limit)-1), y.upper_window_limit);
      left := left + len(y.upper_window_limit);
      y.lower_window_limit := structify(x(left to left+len(y.lower_window_limit)-1), y.lower_window_limit);
      left := left + len(y.lower_window_limit);
      y.daq_bcid := structify(x(left to left+len(y.daq_bcid)-1), y.daq_bcid);
    else
      y.upper_window_limit := structify(x(left downto left-len(y.upper_window_limit)+1), y.upper_window_limit);
      left := left - len(y.upper_window_limit);
      y.lower_window_limit := structify(x(left downto left-len(y.lower_window_limit)+1), y.lower_window_limit);
      left := left - len(y.lower_window_limit);
      y.daq_bcid := structify(x(left downto left-len(y.daq_bcid)+1), y.daq_bcid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: stability_rt) return stability_rt is
    variable y: stability_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.upper_window_limit := convert(x(left to left+len(y.upper_window_limit)-1), y.upper_window_limit);
      left := left + len(y.upper_window_limit);
      y.lower_window_limit := convert(x(left to left+len(y.lower_window_limit)-1), y.lower_window_limit);
      left := left + len(y.lower_window_limit);
      y.daq_bcid := convert(x(left to left+len(y.daq_bcid)-1), y.daq_bcid);
    else
      y.upper_window_limit := convert(x(left downto left-len(y.upper_window_limit)+1), y.upper_window_limit);
      left := left - len(y.upper_window_limit);
      y.lower_window_limit := convert(x(left downto left-len(y.lower_window_limit)+1), y.lower_window_limit);
      left := left - len(y.lower_window_limit);
      y.daq_bcid := convert(x(left downto left-len(y.daq_bcid)+1), y.daq_bcid);
    end if;
    return y;
  end function convert;
  function nullify(t: stability_rt) return stability_rt is
  variable y: stability_rt;
  begin
    y.upper_window_limit := nullify(t.upper_window_limit);
    y.lower_window_limit := nullify(t.lower_window_limit);
    y.daq_bcid := nullify(t.daq_bcid);
    return y;
  end function nullify;
  function zeroed(t: stability_rt) return stability_rt is
  variable y: stability_rt;
  begin
    y.upper_window_limit := zeroed(t.upper_window_limit);
    y.lower_window_limit := zeroed(t.lower_window_limit);
    y.daq_bcid := zeroed(t.daq_bcid);
    return y;
  end function zeroed;

  function len(x: forward_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.nempty);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: forward_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.nempty);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: forward_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.nempty)-1), vectorify(x.nempty, y(left to left+len(x.nempty)-1)));
      left := left + len(x.nempty);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.nempty)+1), vectorify(x.nempty, y(left downto left-len(x.nempty)+1)));
      left := left - len(x.nempty);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: forward_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.nempty)-1), convert(x.nempty, y(left to left+len(x.nempty)-1)));
      left := left + len(x.nempty);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.nempty)+1), convert(x.nempty, y(left downto left-len(x.nempty)+1)));
      left := left - len(x.nempty);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: forward_rt) return forward_rt is
    variable y: forward_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.nempty := structify(x(left to left+len(y.nempty)-1), y.nempty);
      left := left + len(y.nempty);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.nempty := structify(x(left downto left-len(y.nempty)+1), y.nempty);
      left := left - len(y.nempty);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: forward_rt) return forward_rt is
    variable y: forward_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.nempty := convert(x(left to left+len(y.nempty)-1), y.nempty);
      left := left + len(y.nempty);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.nempty := convert(x(left downto left-len(y.nempty)+1), y.nempty);
      left := left - len(y.nempty);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: forward_rt) return forward_rt is
  variable y: forward_rt;
  begin
    y.nempty := nullify(t.nempty);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: forward_rt) return forward_rt is
  variable y: forward_rt;
  begin
    y.nempty := zeroed(t.nempty);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: backward_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_strb);
    return l;
  end function len;
  function width(x: backward_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_strb);
    return l;
  end function width;
  function vectorify(x: backward_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_strb)-1), vectorify(x.rd_strb, y(left to left+len(x.rd_strb)-1)));
    else
      assign(y(left downto left-len(x.rd_strb)+1), vectorify(x.rd_strb, y(left downto left-len(x.rd_strb)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: backward_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_strb)-1), convert(x.rd_strb, y(left to left+len(x.rd_strb)-1)));
    else
      assign(y(left downto left-len(x.rd_strb)+1), convert(x.rd_strb, y(left downto left-len(x.rd_strb)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: backward_rt) return backward_rt is
    variable y: backward_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_strb := structify(x(left to left+len(y.rd_strb)-1), y.rd_strb);
    else
      y.rd_strb := structify(x(left downto left-len(y.rd_strb)+1), y.rd_strb);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: backward_rt) return backward_rt is
    variable y: backward_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_strb := convert(x(left to left+len(y.rd_strb)-1), y.rd_strb);
    else
      y.rd_strb := convert(x(left downto left-len(y.rd_strb)+1), y.rd_strb);
    end if;
    return y;
  end function convert;
  function nullify(t: backward_rt) return backward_rt is
  variable y: backward_rt;
  begin
    y.rd_strb := nullify(t.rd_strb);
    return y;
  end function nullify;
  function zeroed(t: backward_rt) return backward_rt is
  variable y: backward_rt;
  begin
    y.rd_strb := zeroed(t.rd_strb);
    return y;
  end function zeroed;

  function len(x: row_to_mngt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_ready);
    l := l + len(x.nempty);
    l := l + len(x.err);
    return l;
  end function len;
  function width(x: row_to_mngt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_ready);
    l := l + width(x.nempty);
    l := l + width(x.err);
    return l;
  end function width;
  function vectorify(x: row_to_mngt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_ready)-1), vectorify(x.data_ready, y(left to left+len(x.data_ready)-1)));
      left := left + len(x.data_ready);
      assign(y(left to left+len(x.nempty)-1), vectorify(x.nempty, y(left to left+len(x.nempty)-1)));
      left := left + len(x.nempty);
      assign(y(left to left+len(x.err)-1), vectorify(x.err, y(left to left+len(x.err)-1)));
    else
      assign(y(left downto left-len(x.data_ready)+1), vectorify(x.data_ready, y(left downto left-len(x.data_ready)+1)));
      left := left - len(x.data_ready);
      assign(y(left downto left-len(x.nempty)+1), vectorify(x.nempty, y(left downto left-len(x.nempty)+1)));
      left := left - len(x.nempty);
      assign(y(left downto left-len(x.err)+1), vectorify(x.err, y(left downto left-len(x.err)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: row_to_mngt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_ready)-1), convert(x.data_ready, y(left to left+len(x.data_ready)-1)));
      left := left + len(x.data_ready);
      assign(y(left to left+len(x.nempty)-1), convert(x.nempty, y(left to left+len(x.nempty)-1)));
      left := left + len(x.nempty);
      assign(y(left to left+len(x.err)-1), convert(x.err, y(left to left+len(x.err)-1)));
    else
      assign(y(left downto left-len(x.data_ready)+1), convert(x.data_ready, y(left downto left-len(x.data_ready)+1)));
      left := left - len(x.data_ready);
      assign(y(left downto left-len(x.nempty)+1), convert(x.nempty, y(left downto left-len(x.nempty)+1)));
      left := left - len(x.nempty);
      assign(y(left downto left-len(x.err)+1), convert(x.err, y(left downto left-len(x.err)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: row_to_mngt_rt) return row_to_mngt_rt is
    variable y: row_to_mngt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_ready := structify(x(left to left+len(y.data_ready)-1), y.data_ready);
      left := left + len(y.data_ready);
      y.nempty := structify(x(left to left+len(y.nempty)-1), y.nempty);
      left := left + len(y.nempty);
      y.err := structify(x(left to left+len(y.err)-1), y.err);
    else
      y.data_ready := structify(x(left downto left-len(y.data_ready)+1), y.data_ready);
      left := left - len(y.data_ready);
      y.nempty := structify(x(left downto left-len(y.nempty)+1), y.nempty);
      left := left - len(y.nempty);
      y.err := structify(x(left downto left-len(y.err)+1), y.err);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: row_to_mngt_rt) return row_to_mngt_rt is
    variable y: row_to_mngt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_ready := convert(x(left to left+len(y.data_ready)-1), y.data_ready);
      left := left + len(y.data_ready);
      y.nempty := convert(x(left to left+len(y.nempty)-1), y.nempty);
      left := left + len(y.nempty);
      y.err := convert(x(left to left+len(y.err)-1), y.err);
    else
      y.data_ready := convert(x(left downto left-len(y.data_ready)+1), y.data_ready);
      left := left - len(y.data_ready);
      y.nempty := convert(x(left downto left-len(y.nempty)+1), y.nempty);
      left := left - len(y.nempty);
      y.err := convert(x(left downto left-len(y.err)+1), y.err);
    end if;
    return y;
  end function convert;
  function nullify(t: row_to_mngt_rt) return row_to_mngt_rt is
  variable y: row_to_mngt_rt;
  begin
    y.data_ready := nullify(t.data_ready);
    y.nempty := nullify(t.nempty);
    y.err := nullify(t.err);
    return y;
  end function nullify;
  function zeroed(t: row_to_mngt_rt) return row_to_mngt_rt is
  variable y: row_to_mngt_rt;
  begin
    y.data_ready := zeroed(t.data_ready);
    y.nempty := zeroed(t.nempty);
    y.err := zeroed(t.err);
    return y;
  end function zeroed;

  function len(x: mngt_to_row_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.en);
    l := l + len(x.rd_en);
    return l;
  end function len;
  function width(x: mngt_to_row_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.en);
    l := l + width(x.rd_en);
    return l;
  end function width;
  function vectorify(x: mngt_to_row_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.en)-1), vectorify(x.en, y(left to left+len(x.en)-1)));
      left := left + len(x.en);
      assign(y(left to left+len(x.rd_en)-1), vectorify(x.rd_en, y(left to left+len(x.rd_en)-1)));
    else
      assign(y(left downto left-len(x.en)+1), vectorify(x.en, y(left downto left-len(x.en)+1)));
      left := left - len(x.en);
      assign(y(left downto left-len(x.rd_en)+1), vectorify(x.rd_en, y(left downto left-len(x.rd_en)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: mngt_to_row_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.en)-1), convert(x.en, y(left to left+len(x.en)-1)));
      left := left + len(x.en);
      assign(y(left to left+len(x.rd_en)-1), convert(x.rd_en, y(left to left+len(x.rd_en)-1)));
    else
      assign(y(left downto left-len(x.en)+1), convert(x.en, y(left downto left-len(x.en)+1)));
      left := left - len(x.en);
      assign(y(left downto left-len(x.rd_en)+1), convert(x.rd_en, y(left downto left-len(x.rd_en)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: mngt_to_row_rt) return mngt_to_row_rt is
    variable y: mngt_to_row_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.en := structify(x(left to left+len(y.en)-1), y.en);
      left := left + len(y.en);
      y.rd_en := structify(x(left to left+len(y.rd_en)-1), y.rd_en);
    else
      y.en := structify(x(left downto left-len(y.en)+1), y.en);
      left := left - len(y.en);
      y.rd_en := structify(x(left downto left-len(y.rd_en)+1), y.rd_en);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: mngt_to_row_rt) return mngt_to_row_rt is
    variable y: mngt_to_row_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.en := convert(x(left to left+len(y.en)-1), y.en);
      left := left + len(y.en);
      y.rd_en := convert(x(left to left+len(y.rd_en)-1), y.rd_en);
    else
      y.en := convert(x(left downto left-len(y.en)+1), y.en);
      left := left - len(y.en);
      y.rd_en := convert(x(left downto left-len(y.rd_en)+1), y.rd_en);
    end if;
    return y;
  end function convert;
  function nullify(t: mngt_to_row_rt) return mngt_to_row_rt is
  variable y: mngt_to_row_rt;
  begin
    y.en := nullify(t.en);
    y.rd_en := nullify(t.rd_en);
    return y;
  end function nullify;
  function zeroed(t: mngt_to_row_rt) return mngt_to_row_rt is
  variable y: mngt_to_row_rt;
  begin
    y.en := zeroed(t.en);
    y.rd_en := zeroed(t.rd_en);
    return y;
  end function zeroed;

  function len(x: mngt_to_pbldr_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.en);
    return l;
  end function len;
  function width(x: mngt_to_pbldr_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.en);
    return l;
  end function width;
  function vectorify(x: mngt_to_pbldr_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.en)-1), vectorify(x.en, y(left to left+len(x.en)-1)));
    else
      assign(y(left downto left-len(x.en)+1), vectorify(x.en, y(left downto left-len(x.en)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: mngt_to_pbldr_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.en)-1), convert(x.en, y(left to left+len(x.en)-1)));
    else
      assign(y(left downto left-len(x.en)+1), convert(x.en, y(left downto left-len(x.en)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: mngt_to_pbldr_rt) return mngt_to_pbldr_rt is
    variable y: mngt_to_pbldr_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.en := structify(x(left to left+len(y.en)-1), y.en);
    else
      y.en := structify(x(left downto left-len(y.en)+1), y.en);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: mngt_to_pbldr_rt) return mngt_to_pbldr_rt is
    variable y: mngt_to_pbldr_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.en := convert(x(left to left+len(y.en)-1), y.en);
    else
      y.en := convert(x(left downto left-len(y.en)+1), y.en);
    end if;
    return y;
  end function convert;
  function nullify(t: mngt_to_pbldr_rt) return mngt_to_pbldr_rt is
  variable y: mngt_to_pbldr_rt;
  begin
    y.en := nullify(t.en);
    return y;
  end function nullify;
  function zeroed(t: mngt_to_pbldr_rt) return mngt_to_pbldr_rt is
  variable y: mngt_to_pbldr_rt;
  begin
    y.en := zeroed(t.en);
    return y;
  end function zeroed;

  function len(x: pbldr_to_mngt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.done);
    return l;
  end function len;
  function width(x: pbldr_to_mngt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.done);
    return l;
  end function width;
  function vectorify(x: pbldr_to_mngt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.done)-1), vectorify(x.done, y(left to left+len(x.done)-1)));
    else
      assign(y(left downto left-len(x.done)+1), vectorify(x.done, y(left downto left-len(x.done)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: pbldr_to_mngt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.done)-1), convert(x.done, y(left to left+len(x.done)-1)));
    else
      assign(y(left downto left-len(x.done)+1), convert(x.done, y(left downto left-len(x.done)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: pbldr_to_mngt_rt) return pbldr_to_mngt_rt is
    variable y: pbldr_to_mngt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.done := structify(x(left to left+len(y.done)-1), y.done);
    else
      y.done := structify(x(left downto left-len(y.done)+1), y.done);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: pbldr_to_mngt_rt) return pbldr_to_mngt_rt is
    variable y: pbldr_to_mngt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.done := convert(x(left to left+len(y.done)-1), y.done);
    else
      y.done := convert(x(left downto left-len(y.done)+1), y.done);
    end if;
    return y;
  end function convert;
  function nullify(t: pbldr_to_mngt_rt) return pbldr_to_mngt_rt is
  variable y: pbldr_to_mngt_rt;
  begin
    y.done := nullify(t.done);
    return y;
  end function nullify;
  function zeroed(t: pbldr_to_mngt_rt) return pbldr_to_mngt_rt is
  variable y: pbldr_to_mngt_rt;
  begin
    y.done := zeroed(t.done);
    return y;
  end function zeroed;

  function len(x: rows_to_pbldr_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: rows_to_pbldr_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: rows_to_pbldr_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: rows_to_pbldr_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: rows_to_pbldr_at) return rows_to_pbldr_at is
    variable y : rows_to_pbldr_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: rows_to_pbldr_at) return rows_to_pbldr_at is
    variable y : rows_to_pbldr_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: rows_to_pbldr_at) return rows_to_pbldr_at is
    variable y : rows_to_pbldr_at;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: rows_to_pbldr_at) return rows_to_pbldr_at is
    variable y : rows_to_pbldr_at;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: pbldr_to_rows_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: pbldr_to_rows_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: pbldr_to_rows_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: pbldr_to_rows_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: pbldr_to_rows_at) return pbldr_to_rows_at is
    variable y : pbldr_to_rows_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: pbldr_to_rows_at) return pbldr_to_rows_at is
    variable y : pbldr_to_rows_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: pbldr_to_rows_at) return pbldr_to_rows_at is
    variable y : pbldr_to_rows_at;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: pbldr_to_rows_at) return pbldr_to_rows_at is
    variable y : pbldr_to_rows_at;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: req_to_row_common_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.req_strb);
    l := l + len(x.window_start);
    l := l + len(x.window_width);
    return l;
  end function len;
  function width(x: req_to_row_common_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.req_strb);
    l := l + width(x.window_start);
    l := l + width(x.window_width);
    return l;
  end function width;
  function vectorify(x: req_to_row_common_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.req_strb)-1), vectorify(x.req_strb, y(left to left+len(x.req_strb)-1)));
      left := left + len(x.req_strb);
      assign(y(left to left+len(x.window_start)-1), vectorify(x.window_start, y(left to left+len(x.window_start)-1)));
      left := left + len(x.window_start);
      assign(y(left to left+len(x.window_width)-1), vectorify(x.window_width, y(left to left+len(x.window_width)-1)));
    else
      assign(y(left downto left-len(x.req_strb)+1), vectorify(x.req_strb, y(left downto left-len(x.req_strb)+1)));
      left := left - len(x.req_strb);
      assign(y(left downto left-len(x.window_start)+1), vectorify(x.window_start, y(left downto left-len(x.window_start)+1)));
      left := left - len(x.window_start);
      assign(y(left downto left-len(x.window_width)+1), vectorify(x.window_width, y(left downto left-len(x.window_width)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: req_to_row_common_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.req_strb)-1), convert(x.req_strb, y(left to left+len(x.req_strb)-1)));
      left := left + len(x.req_strb);
      assign(y(left to left+len(x.window_start)-1), convert(x.window_start, y(left to left+len(x.window_start)-1)));
      left := left + len(x.window_start);
      assign(y(left to left+len(x.window_width)-1), convert(x.window_width, y(left to left+len(x.window_width)-1)));
    else
      assign(y(left downto left-len(x.req_strb)+1), convert(x.req_strb, y(left downto left-len(x.req_strb)+1)));
      left := left - len(x.req_strb);
      assign(y(left downto left-len(x.window_start)+1), convert(x.window_start, y(left downto left-len(x.window_start)+1)));
      left := left - len(x.window_start);
      assign(y(left downto left-len(x.window_width)+1), convert(x.window_width, y(left downto left-len(x.window_width)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: req_to_row_common_rt) return req_to_row_common_rt is
    variable y: req_to_row_common_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.req_strb := structify(x(left to left+len(y.req_strb)-1), y.req_strb);
      left := left + len(y.req_strb);
      y.window_start := structify(x(left to left+len(y.window_start)-1), y.window_start);
      left := left + len(y.window_start);
      y.window_width := structify(x(left to left+len(y.window_width)-1), y.window_width);
    else
      y.req_strb := structify(x(left downto left-len(y.req_strb)+1), y.req_strb);
      left := left - len(y.req_strb);
      y.window_start := structify(x(left downto left-len(y.window_start)+1), y.window_start);
      left := left - len(y.window_start);
      y.window_width := structify(x(left downto left-len(y.window_width)+1), y.window_width);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: req_to_row_common_rt) return req_to_row_common_rt is
    variable y: req_to_row_common_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.req_strb := convert(x(left to left+len(y.req_strb)-1), y.req_strb);
      left := left + len(y.req_strb);
      y.window_start := convert(x(left to left+len(y.window_start)-1), y.window_start);
      left := left + len(y.window_start);
      y.window_width := convert(x(left to left+len(y.window_width)-1), y.window_width);
    else
      y.req_strb := convert(x(left downto left-len(y.req_strb)+1), y.req_strb);
      left := left - len(y.req_strb);
      y.window_start := convert(x(left downto left-len(y.window_start)+1), y.window_start);
      left := left - len(y.window_start);
      y.window_width := convert(x(left downto left-len(y.window_width)+1), y.window_width);
    end if;
    return y;
  end function convert;
  function nullify(t: req_to_row_common_rt) return req_to_row_common_rt is
  variable y: req_to_row_common_rt;
  begin
    y.req_strb := nullify(t.req_strb);
    y.window_start := nullify(t.window_start);
    y.window_width := nullify(t.window_width);
    return y;
  end function nullify;
  function zeroed(t: req_to_row_common_rt) return req_to_row_common_rt is
  variable y: req_to_row_common_rt;
  begin
    y.req_strb := zeroed(t.req_strb);
    y.window_start := zeroed(t.window_start);
    y.window_width := zeroed(t.window_width);
    return y;
  end function zeroed;

  function len(x: req_to_row_extra_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.window_latency);
    l := l + len(x.lower_window_size);
    l := l + len(x.upper_window_size);
    l := l + len(x.daq_bcid);
    l := l + len(x.sys_bcid);
    l := l + len(x.evid);
    return l;
  end function len;
  function width(x: req_to_row_extra_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.window_latency);
    l := l + width(x.lower_window_size);
    l := l + width(x.upper_window_size);
    l := l + width(x.daq_bcid);
    l := l + width(x.sys_bcid);
    l := l + width(x.evid);
    return l;
  end function width;
  function vectorify(x: req_to_row_extra_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.window_latency)-1), vectorify(x.window_latency, y(left to left+len(x.window_latency)-1)));
      left := left + len(x.window_latency);
      assign(y(left to left+len(x.lower_window_size)-1), vectorify(x.lower_window_size, y(left to left+len(x.lower_window_size)-1)));
      left := left + len(x.lower_window_size);
      assign(y(left to left+len(x.upper_window_size)-1), vectorify(x.upper_window_size, y(left to left+len(x.upper_window_size)-1)));
      left := left + len(x.upper_window_size);
      assign(y(left to left+len(x.daq_bcid)-1), vectorify(x.daq_bcid, y(left to left+len(x.daq_bcid)-1)));
      left := left + len(x.daq_bcid);
      assign(y(left to left+len(x.sys_bcid)-1), vectorify(x.sys_bcid, y(left to left+len(x.sys_bcid)-1)));
      left := left + len(x.sys_bcid);
      assign(y(left to left+len(x.evid)-1), vectorify(x.evid, y(left to left+len(x.evid)-1)));
    else
      assign(y(left downto left-len(x.window_latency)+1), vectorify(x.window_latency, y(left downto left-len(x.window_latency)+1)));
      left := left - len(x.window_latency);
      assign(y(left downto left-len(x.lower_window_size)+1), vectorify(x.lower_window_size, y(left downto left-len(x.lower_window_size)+1)));
      left := left - len(x.lower_window_size);
      assign(y(left downto left-len(x.upper_window_size)+1), vectorify(x.upper_window_size, y(left downto left-len(x.upper_window_size)+1)));
      left := left - len(x.upper_window_size);
      assign(y(left downto left-len(x.daq_bcid)+1), vectorify(x.daq_bcid, y(left downto left-len(x.daq_bcid)+1)));
      left := left - len(x.daq_bcid);
      assign(y(left downto left-len(x.sys_bcid)+1), vectorify(x.sys_bcid, y(left downto left-len(x.sys_bcid)+1)));
      left := left - len(x.sys_bcid);
      assign(y(left downto left-len(x.evid)+1), vectorify(x.evid, y(left downto left-len(x.evid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: req_to_row_extra_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.window_latency)-1), convert(x.window_latency, y(left to left+len(x.window_latency)-1)));
      left := left + len(x.window_latency);
      assign(y(left to left+len(x.lower_window_size)-1), convert(x.lower_window_size, y(left to left+len(x.lower_window_size)-1)));
      left := left + len(x.lower_window_size);
      assign(y(left to left+len(x.upper_window_size)-1), convert(x.upper_window_size, y(left to left+len(x.upper_window_size)-1)));
      left := left + len(x.upper_window_size);
      assign(y(left to left+len(x.daq_bcid)-1), convert(x.daq_bcid, y(left to left+len(x.daq_bcid)-1)));
      left := left + len(x.daq_bcid);
      assign(y(left to left+len(x.sys_bcid)-1), convert(x.sys_bcid, y(left to left+len(x.sys_bcid)-1)));
      left := left + len(x.sys_bcid);
      assign(y(left to left+len(x.evid)-1), convert(x.evid, y(left to left+len(x.evid)-1)));
    else
      assign(y(left downto left-len(x.window_latency)+1), convert(x.window_latency, y(left downto left-len(x.window_latency)+1)));
      left := left - len(x.window_latency);
      assign(y(left downto left-len(x.lower_window_size)+1), convert(x.lower_window_size, y(left downto left-len(x.lower_window_size)+1)));
      left := left - len(x.lower_window_size);
      assign(y(left downto left-len(x.upper_window_size)+1), convert(x.upper_window_size, y(left downto left-len(x.upper_window_size)+1)));
      left := left - len(x.upper_window_size);
      assign(y(left downto left-len(x.daq_bcid)+1), convert(x.daq_bcid, y(left downto left-len(x.daq_bcid)+1)));
      left := left - len(x.daq_bcid);
      assign(y(left downto left-len(x.sys_bcid)+1), convert(x.sys_bcid, y(left downto left-len(x.sys_bcid)+1)));
      left := left - len(x.sys_bcid);
      assign(y(left downto left-len(x.evid)+1), convert(x.evid, y(left downto left-len(x.evid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: req_to_row_extra_rt) return req_to_row_extra_rt is
    variable y: req_to_row_extra_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.window_latency := structify(x(left to left+len(y.window_latency)-1), y.window_latency);
      left := left + len(y.window_latency);
      y.lower_window_size := structify(x(left to left+len(y.lower_window_size)-1), y.lower_window_size);
      left := left + len(y.lower_window_size);
      y.upper_window_size := structify(x(left to left+len(y.upper_window_size)-1), y.upper_window_size);
      left := left + len(y.upper_window_size);
      y.daq_bcid := structify(x(left to left+len(y.daq_bcid)-1), y.daq_bcid);
      left := left + len(y.daq_bcid);
      y.sys_bcid := structify(x(left to left+len(y.sys_bcid)-1), y.sys_bcid);
      left := left + len(y.sys_bcid);
      y.evid := structify(x(left to left+len(y.evid)-1), y.evid);
    else
      y.window_latency := structify(x(left downto left-len(y.window_latency)+1), y.window_latency);
      left := left - len(y.window_latency);
      y.lower_window_size := structify(x(left downto left-len(y.lower_window_size)+1), y.lower_window_size);
      left := left - len(y.lower_window_size);
      y.upper_window_size := structify(x(left downto left-len(y.upper_window_size)+1), y.upper_window_size);
      left := left - len(y.upper_window_size);
      y.daq_bcid := structify(x(left downto left-len(y.daq_bcid)+1), y.daq_bcid);
      left := left - len(y.daq_bcid);
      y.sys_bcid := structify(x(left downto left-len(y.sys_bcid)+1), y.sys_bcid);
      left := left - len(y.sys_bcid);
      y.evid := structify(x(left downto left-len(y.evid)+1), y.evid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: req_to_row_extra_rt) return req_to_row_extra_rt is
    variable y: req_to_row_extra_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.window_latency := convert(x(left to left+len(y.window_latency)-1), y.window_latency);
      left := left + len(y.window_latency);
      y.lower_window_size := convert(x(left to left+len(y.lower_window_size)-1), y.lower_window_size);
      left := left + len(y.lower_window_size);
      y.upper_window_size := convert(x(left to left+len(y.upper_window_size)-1), y.upper_window_size);
      left := left + len(y.upper_window_size);
      y.daq_bcid := convert(x(left to left+len(y.daq_bcid)-1), y.daq_bcid);
      left := left + len(y.daq_bcid);
      y.sys_bcid := convert(x(left to left+len(y.sys_bcid)-1), y.sys_bcid);
      left := left + len(y.sys_bcid);
      y.evid := convert(x(left to left+len(y.evid)-1), y.evid);
    else
      y.window_latency := convert(x(left downto left-len(y.window_latency)+1), y.window_latency);
      left := left - len(y.window_latency);
      y.lower_window_size := convert(x(left downto left-len(y.lower_window_size)+1), y.lower_window_size);
      left := left - len(y.lower_window_size);
      y.upper_window_size := convert(x(left downto left-len(y.upper_window_size)+1), y.upper_window_size);
      left := left - len(y.upper_window_size);
      y.daq_bcid := convert(x(left downto left-len(y.daq_bcid)+1), y.daq_bcid);
      left := left - len(y.daq_bcid);
      y.sys_bcid := convert(x(left downto left-len(y.sys_bcid)+1), y.sys_bcid);
      left := left - len(y.sys_bcid);
      y.evid := convert(x(left downto left-len(y.evid)+1), y.evid);
    end if;
    return y;
  end function convert;
  function nullify(t: req_to_row_extra_rt) return req_to_row_extra_rt is
  variable y: req_to_row_extra_rt;
  begin
    y.window_latency := nullify(t.window_latency);
    y.lower_window_size := nullify(t.lower_window_size);
    y.upper_window_size := nullify(t.upper_window_size);
    y.daq_bcid := nullify(t.daq_bcid);
    y.sys_bcid := nullify(t.sys_bcid);
    y.evid := nullify(t.evid);
    return y;
  end function nullify;
  function zeroed(t: req_to_row_extra_rt) return req_to_row_extra_rt is
  variable y: req_to_row_extra_rt;
  begin
    y.window_latency := zeroed(t.window_latency);
    y.lower_window_size := zeroed(t.lower_window_size);
    y.upper_window_size := zeroed(t.upper_window_size);
    y.daq_bcid := zeroed(t.daq_bcid);
    y.sys_bcid := zeroed(t.sys_bcid);
    y.evid := zeroed(t.evid);
    return y;
  end function zeroed;

  function len(x: req_to_row_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.common);
    l := l + len(x.extra);
    return l;
  end function len;
  function width(x: req_to_row_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.common);
    l := l + width(x.extra);
    return l;
  end function width;
  function vectorify(x: req_to_row_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.common)-1), vectorify(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.extra)-1), vectorify(x.extra, y(left to left+len(x.extra)-1)));
    else
      assign(y(left downto left-len(x.common)+1), vectorify(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.extra)+1), vectorify(x.extra, y(left downto left-len(x.extra)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: req_to_row_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.common)-1), convert(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.extra)-1), convert(x.extra, y(left to left+len(x.extra)-1)));
    else
      assign(y(left downto left-len(x.common)+1), convert(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.extra)+1), convert(x.extra, y(left downto left-len(x.extra)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: req_to_row_rt) return req_to_row_rt is
    variable y: req_to_row_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.common := structify(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.extra := structify(x(left to left+len(y.extra)-1), y.extra);
    else
      y.common := structify(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.extra := structify(x(left downto left-len(y.extra)+1), y.extra);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: req_to_row_rt) return req_to_row_rt is
    variable y: req_to_row_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.common := convert(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.extra := convert(x(left to left+len(y.extra)-1), y.extra);
    else
      y.common := convert(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.extra := convert(x(left downto left-len(y.extra)+1), y.extra);
    end if;
    return y;
  end function convert;
  function nullify(t: req_to_row_rt) return req_to_row_rt is
  variable y: req_to_row_rt;
  begin
    y.common := nullify(t.common);
    y.extra := nullify(t.extra);
    return y;
  end function nullify;
  function zeroed(t: req_to_row_rt) return req_to_row_rt is
  variable y: req_to_row_rt;
  begin
    y.common := zeroed(t.common);
    y.extra := zeroed(t.extra);
    return y;
  end function zeroed;

  function len(x: felix_to_daq_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.hfull);
    return l;
  end function len;
  function width(x: felix_to_daq_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.hfull);
    return l;
  end function width;
  function vectorify(x: felix_to_daq_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.hfull)-1), vectorify(x.hfull, y(left to left+len(x.hfull)-1)));
    else
      assign(y(left downto left-len(x.hfull)+1), vectorify(x.hfull, y(left downto left-len(x.hfull)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: felix_to_daq_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.hfull)-1), convert(x.hfull, y(left to left+len(x.hfull)-1)));
    else
      assign(y(left downto left-len(x.hfull)+1), convert(x.hfull, y(left downto left-len(x.hfull)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: felix_to_daq_rt) return felix_to_daq_rt is
    variable y: felix_to_daq_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.hfull := structify(x(left to left+len(y.hfull)-1), y.hfull);
    else
      y.hfull := structify(x(left downto left-len(y.hfull)+1), y.hfull);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: felix_to_daq_rt) return felix_to_daq_rt is
    variable y: felix_to_daq_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.hfull := convert(x(left to left+len(y.hfull)-1), y.hfull);
    else
      y.hfull := convert(x(left downto left-len(y.hfull)+1), y.hfull);
    end if;
    return y;
  end function convert;
  function nullify(t: felix_to_daq_rt) return felix_to_daq_rt is
  variable y: felix_to_daq_rt;
  begin
    y.hfull := nullify(t.hfull);
    return y;
  end function nullify;
  function zeroed(t: felix_to_daq_rt) return felix_to_daq_rt is
  variable y: felix_to_daq_rt;
  begin
    y.hfull := zeroed(t.hfull);
    return y;
  end function zeroed;

  function len(x: daq_to_felix_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_en);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: daq_to_felix_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_en);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: daq_to_felix_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_en)-1), vectorify(x.wr_en, y(left to left+len(x.wr_en)-1)));
      left := left + len(x.wr_en);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.wr_en)+1), vectorify(x.wr_en, y(left downto left-len(x.wr_en)+1)));
      left := left - len(x.wr_en);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_to_felix_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_en)-1), convert(x.wr_en, y(left to left+len(x.wr_en)-1)));
      left := left + len(x.wr_en);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.wr_en)+1), convert(x.wr_en, y(left downto left-len(x.wr_en)+1)));
      left := left - len(x.wr_en);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_to_felix_rt) return daq_to_felix_rt is
    variable y: daq_to_felix_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_en := structify(x(left to left+len(y.wr_en)-1), y.wr_en);
      left := left + len(y.wr_en);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.wr_en := structify(x(left downto left-len(y.wr_en)+1), y.wr_en);
      left := left - len(y.wr_en);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_to_felix_rt) return daq_to_felix_rt is
    variable y: daq_to_felix_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_en := convert(x(left to left+len(y.wr_en)-1), y.wr_en);
      left := left + len(y.wr_en);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.wr_en := convert(x(left downto left-len(y.wr_en)+1), y.wr_en);
      left := left - len(y.wr_en);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_to_felix_rt) return daq_to_felix_rt is
  variable y: daq_to_felix_rt;
  begin
    y.wr_en := nullify(t.wr_en);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: daq_to_felix_rt) return daq_to_felix_rt is
  variable y: daq_to_felix_rt;
  begin
    y.wr_en := zeroed(t.wr_en);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: ctrl_to_daq_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_en);
    l := l + len(x.window_latency);
    l := l + len(x.lower_window_size);
    l := l + len(x.upper_window_size);
    return l;
  end function len;
  function width(x: ctrl_to_daq_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_en);
    l := l + width(x.window_latency);
    l := l + width(x.lower_window_size);
    l := l + width(x.upper_window_size);
    return l;
  end function width;
  function vectorify(x: ctrl_to_daq_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_en)-1), vectorify(x.wr_en, y(left to left+len(x.wr_en)-1)));
      left := left + len(x.wr_en);
      assign(y(left to left+len(x.window_latency)-1), vectorify(x.window_latency, y(left to left+len(x.window_latency)-1)));
      left := left + len(x.window_latency);
      assign(y(left to left+len(x.lower_window_size)-1), vectorify(x.lower_window_size, y(left to left+len(x.lower_window_size)-1)));
      left := left + len(x.lower_window_size);
      assign(y(left to left+len(x.upper_window_size)-1), vectorify(x.upper_window_size, y(left to left+len(x.upper_window_size)-1)));
    else
      assign(y(left downto left-len(x.wr_en)+1), vectorify(x.wr_en, y(left downto left-len(x.wr_en)+1)));
      left := left - len(x.wr_en);
      assign(y(left downto left-len(x.window_latency)+1), vectorify(x.window_latency, y(left downto left-len(x.window_latency)+1)));
      left := left - len(x.window_latency);
      assign(y(left downto left-len(x.lower_window_size)+1), vectorify(x.lower_window_size, y(left downto left-len(x.lower_window_size)+1)));
      left := left - len(x.lower_window_size);
      assign(y(left downto left-len(x.upper_window_size)+1), vectorify(x.upper_window_size, y(left downto left-len(x.upper_window_size)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ctrl_to_daq_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_en)-1), convert(x.wr_en, y(left to left+len(x.wr_en)-1)));
      left := left + len(x.wr_en);
      assign(y(left to left+len(x.window_latency)-1), convert(x.window_latency, y(left to left+len(x.window_latency)-1)));
      left := left + len(x.window_latency);
      assign(y(left to left+len(x.lower_window_size)-1), convert(x.lower_window_size, y(left to left+len(x.lower_window_size)-1)));
      left := left + len(x.lower_window_size);
      assign(y(left to left+len(x.upper_window_size)-1), convert(x.upper_window_size, y(left to left+len(x.upper_window_size)-1)));
    else
      assign(y(left downto left-len(x.wr_en)+1), convert(x.wr_en, y(left downto left-len(x.wr_en)+1)));
      left := left - len(x.wr_en);
      assign(y(left downto left-len(x.window_latency)+1), convert(x.window_latency, y(left downto left-len(x.window_latency)+1)));
      left := left - len(x.window_latency);
      assign(y(left downto left-len(x.lower_window_size)+1), convert(x.lower_window_size, y(left downto left-len(x.lower_window_size)+1)));
      left := left - len(x.lower_window_size);
      assign(y(left downto left-len(x.upper_window_size)+1), convert(x.upper_window_size, y(left downto left-len(x.upper_window_size)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ctrl_to_daq_rt) return ctrl_to_daq_rt is
    variable y: ctrl_to_daq_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_en := structify(x(left to left+len(y.wr_en)-1), y.wr_en);
      left := left + len(y.wr_en);
      y.window_latency := structify(x(left to left+len(y.window_latency)-1), y.window_latency);
      left := left + len(y.window_latency);
      y.lower_window_size := structify(x(left to left+len(y.lower_window_size)-1), y.lower_window_size);
      left := left + len(y.lower_window_size);
      y.upper_window_size := structify(x(left to left+len(y.upper_window_size)-1), y.upper_window_size);
    else
      y.wr_en := structify(x(left downto left-len(y.wr_en)+1), y.wr_en);
      left := left - len(y.wr_en);
      y.window_latency := structify(x(left downto left-len(y.window_latency)+1), y.window_latency);
      left := left - len(y.window_latency);
      y.lower_window_size := structify(x(left downto left-len(y.lower_window_size)+1), y.lower_window_size);
      left := left - len(y.lower_window_size);
      y.upper_window_size := structify(x(left downto left-len(y.upper_window_size)+1), y.upper_window_size);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ctrl_to_daq_rt) return ctrl_to_daq_rt is
    variable y: ctrl_to_daq_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_en := convert(x(left to left+len(y.wr_en)-1), y.wr_en);
      left := left + len(y.wr_en);
      y.window_latency := convert(x(left to left+len(y.window_latency)-1), y.window_latency);
      left := left + len(y.window_latency);
      y.lower_window_size := convert(x(left to left+len(y.lower_window_size)-1), y.lower_window_size);
      left := left + len(y.lower_window_size);
      y.upper_window_size := convert(x(left to left+len(y.upper_window_size)-1), y.upper_window_size);
    else
      y.wr_en := convert(x(left downto left-len(y.wr_en)+1), y.wr_en);
      left := left - len(y.wr_en);
      y.window_latency := convert(x(left downto left-len(y.window_latency)+1), y.window_latency);
      left := left - len(y.window_latency);
      y.lower_window_size := convert(x(left downto left-len(y.lower_window_size)+1), y.lower_window_size);
      left := left - len(y.lower_window_size);
      y.upper_window_size := convert(x(left downto left-len(y.upper_window_size)+1), y.upper_window_size);
    end if;
    return y;
  end function convert;
  function nullify(t: ctrl_to_daq_rt) return ctrl_to_daq_rt is
  variable y: ctrl_to_daq_rt;
  begin
    y.wr_en := nullify(t.wr_en);
    y.window_latency := nullify(t.window_latency);
    y.lower_window_size := nullify(t.lower_window_size);
    y.upper_window_size := nullify(t.upper_window_size);
    return y;
  end function nullify;
  function zeroed(t: ctrl_to_daq_rt) return ctrl_to_daq_rt is
  variable y: ctrl_to_daq_rt;
  begin
    y.wr_en := zeroed(t.wr_en);
    y.window_latency := zeroed(t.window_latency);
    y.lower_window_size := zeroed(t.lower_window_size);
    y.upper_window_size := zeroed(t.upper_window_size);
    return y;
  end function zeroed;

  function len(x: daq_to_status_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.stability);
    return l;
  end function len;
  function width(x: daq_to_status_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.stability);
    return l;
  end function width;
  function vectorify(x: daq_to_status_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.stability)-1), vectorify(x.stability, y(left to left+len(x.stability)-1)));
    else
      assign(y(left downto left-len(x.stability)+1), vectorify(x.stability, y(left downto left-len(x.stability)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_to_status_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.stability)-1), convert(x.stability, y(left to left+len(x.stability)-1)));
    else
      assign(y(left downto left-len(x.stability)+1), convert(x.stability, y(left downto left-len(x.stability)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_to_status_rt) return daq_to_status_rt is
    variable y: daq_to_status_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.stability := structify(x(left to left+len(y.stability)-1), y.stability);
    else
      y.stability := structify(x(left downto left-len(y.stability)+1), y.stability);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_to_status_rt) return daq_to_status_rt is
    variable y: daq_to_status_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.stability := convert(x(left to left+len(y.stability)-1), y.stability);
    else
      y.stability := convert(x(left downto left-len(y.stability)+1), y.stability);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_to_status_rt) return daq_to_status_rt is
  variable y: daq_to_status_rt;
  begin
    y.stability := nullify(t.stability);
    return y;
  end function nullify;
  function zeroed(t: daq_to_status_rt) return daq_to_status_rt is
  variable y: daq_to_status_rt;
  begin
    y.stability := zeroed(t.stability);
    return y;
  end function zeroed;

  function len(x: daq_req_status_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.stability);
    return l;
  end function len;
  function width(x: daq_req_status_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.stability);
    return l;
  end function width;
  function vectorify(x: daq_req_status_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.stability)-1), vectorify(x.stability, y(left to left+len(x.stability)-1)));
    else
      assign(y(left downto left-len(x.stability)+1), vectorify(x.stability, y(left downto left-len(x.stability)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_req_status_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.stability)-1), convert(x.stability, y(left to left+len(x.stability)-1)));
    else
      assign(y(left downto left-len(x.stability)+1), convert(x.stability, y(left downto left-len(x.stability)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_req_status_rt) return daq_req_status_rt is
    variable y: daq_req_status_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.stability := structify(x(left to left+len(y.stability)-1), y.stability);
    else
      y.stability := structify(x(left downto left-len(y.stability)+1), y.stability);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_req_status_rt) return daq_req_status_rt is
    variable y: daq_req_status_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.stability := convert(x(left to left+len(y.stability)-1), y.stability);
    else
      y.stability := convert(x(left downto left-len(y.stability)+1), y.stability);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_req_status_rt) return daq_req_status_rt is
  variable y: daq_req_status_rt;
  begin
    y.stability := nullify(t.stability);
    return y;
  end function nullify;
  function zeroed(t: daq_req_status_rt) return daq_req_status_rt is
  variable y: daq_req_status_rt;
  begin
    y.stability := zeroed(t.stability);
    return y;
  end function zeroed;

  function len(x: daq_req_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.ttc);
    l := l + len(x.ctrl);
    return l;
  end function len;
  function width(x: daq_req_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.ttc);
    l := l + width(x.ctrl);
    return l;
  end function width;
  function vectorify(x: daq_req_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.ttc)-1), vectorify(x.ttc, y(left to left+len(x.ttc)-1)));
      left := left + len(x.ttc);
      assign(y(left to left+len(x.ctrl)-1), vectorify(x.ctrl, y(left to left+len(x.ctrl)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.ttc)+1), vectorify(x.ttc, y(left downto left-len(x.ttc)+1)));
      left := left - len(x.ttc);
      assign(y(left downto left-len(x.ctrl)+1), vectorify(x.ctrl, y(left downto left-len(x.ctrl)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_req_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.ttc)-1), convert(x.ttc, y(left to left+len(x.ttc)-1)));
      left := left + len(x.ttc);
      assign(y(left to left+len(x.ctrl)-1), convert(x.ctrl, y(left to left+len(x.ctrl)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.ttc)+1), convert(x.ttc, y(left downto left-len(x.ttc)+1)));
      left := left - len(x.ttc);
      assign(y(left downto left-len(x.ctrl)+1), convert(x.ctrl, y(left downto left-len(x.ctrl)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_req_irt) return daq_req_irt is
    variable y: daq_req_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.ttc := structify(x(left to left+len(y.ttc)-1), y.ttc);
      left := left + len(y.ttc);
      y.ctrl := structify(x(left to left+len(y.ctrl)-1), y.ctrl);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.ttc := structify(x(left downto left-len(y.ttc)+1), y.ttc);
      left := left - len(y.ttc);
      y.ctrl := structify(x(left downto left-len(y.ctrl)+1), y.ctrl);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_req_irt) return daq_req_irt is
    variable y: daq_req_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.ttc := convert(x(left to left+len(y.ttc)-1), y.ttc);
      left := left + len(y.ttc);
      y.ctrl := convert(x(left to left+len(y.ctrl)-1), y.ctrl);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.ttc := convert(x(left downto left-len(y.ttc)+1), y.ttc);
      left := left - len(y.ttc);
      y.ctrl := convert(x(left downto left-len(y.ctrl)+1), y.ctrl);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_req_irt) return daq_req_irt is
  variable y: daq_req_irt;
  begin
    y.sys := nullify(t.sys);
    y.ttc := nullify(t.ttc);
    y.ctrl := nullify(t.ctrl);
    return y;
  end function nullify;
  function zeroed(t: daq_req_irt) return daq_req_irt is
  variable y: daq_req_irt;
  begin
    y.sys := zeroed(t.sys);
    y.ttc := zeroed(t.ttc);
    y.ctrl := zeroed(t.ctrl);
    return y;
  end function zeroed;

  function len(x: daq_req_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.status);
    l := l + len(x.row);
    return l;
  end function len;
  function width(x: daq_req_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.status);
    l := l + width(x.row);
    return l;
  end function width;
  function vectorify(x: daq_req_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.status)-1), vectorify(x.status, y(left to left+len(x.status)-1)));
      left := left + len(x.status);
      assign(y(left to left+len(x.row)-1), vectorify(x.row, y(left to left+len(x.row)-1)));
    else
      assign(y(left downto left-len(x.status)+1), vectorify(x.status, y(left downto left-len(x.status)+1)));
      left := left - len(x.status);
      assign(y(left downto left-len(x.row)+1), vectorify(x.row, y(left downto left-len(x.row)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_req_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.status)-1), convert(x.status, y(left to left+len(x.status)-1)));
      left := left + len(x.status);
      assign(y(left to left+len(x.row)-1), convert(x.row, y(left to left+len(x.row)-1)));
    else
      assign(y(left downto left-len(x.status)+1), convert(x.status, y(left downto left-len(x.status)+1)));
      left := left - len(x.status);
      assign(y(left downto left-len(x.row)+1), convert(x.row, y(left downto left-len(x.row)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_req_ort) return daq_req_ort is
    variable y: daq_req_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.status := structify(x(left to left+len(y.status)-1), y.status);
      left := left + len(y.status);
      y.row := structify(x(left to left+len(y.row)-1), y.row);
    else
      y.status := structify(x(left downto left-len(y.status)+1), y.status);
      left := left - len(y.status);
      y.row := structify(x(left downto left-len(y.row)+1), y.row);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_req_ort) return daq_req_ort is
    variable y: daq_req_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.status := convert(x(left to left+len(y.status)-1), y.status);
      left := left + len(y.status);
      y.row := convert(x(left to left+len(y.row)-1), y.row);
    else
      y.status := convert(x(left downto left-len(y.status)+1), y.status);
      left := left - len(y.status);
      y.row := convert(x(left downto left-len(y.row)+1), y.row);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_req_ort) return daq_req_ort is
  variable y: daq_req_ort;
  begin
    y.status := nullify(t.status);
    y.row := nullify(t.row);
    return y;
  end function nullify;
  function zeroed(t: daq_req_ort) return daq_req_ort is
  variable y: daq_req_ort;
  begin
    y.status := zeroed(t.status);
    y.row := zeroed(t.row);
    return y;
  end function zeroed;

  function len(x: daq_req_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: daq_req_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: daq_req_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_req_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_req_ert) return daq_req_ert is
    variable y: daq_req_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_req_ert) return daq_req_ert is
    variable y: daq_req_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_req_ert) return daq_req_ert is
  variable y: daq_req_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: daq_req_ert) return daq_req_ert is
  variable y: daq_req_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: daq_row_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.mngt);
    l := l + len(x.pbldr);
    l := l + len(x.debug);
    return l;
  end function len;
  function width(x: daq_row_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.mngt);
    l := l + width(x.pbldr);
    l := l + width(x.debug);
    return l;
  end function width;
  function vectorify(x: daq_row_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.mngt)-1), vectorify(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.pbldr)-1), vectorify(x.pbldr, y(left to left+len(x.pbldr)-1)));
      left := left + len(x.pbldr);
      assign(y(left to left+len(x.debug)-1), vectorify(x.debug, y(left to left+len(x.debug)-1)));
    else
      assign(y(left downto left-len(x.mngt)+1), vectorify(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.pbldr)+1), vectorify(x.pbldr, y(left downto left-len(x.pbldr)+1)));
      left := left - len(x.pbldr);
      assign(y(left downto left-len(x.debug)+1), vectorify(x.debug, y(left downto left-len(x.debug)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_row_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.mngt)-1), convert(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.pbldr)-1), convert(x.pbldr, y(left to left+len(x.pbldr)-1)));
      left := left + len(x.pbldr);
      assign(y(left to left+len(x.debug)-1), convert(x.debug, y(left to left+len(x.debug)-1)));
    else
      assign(y(left downto left-len(x.mngt)+1), convert(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.pbldr)+1), convert(x.pbldr, y(left downto left-len(x.pbldr)+1)));
      left := left - len(x.pbldr);
      assign(y(left downto left-len(x.debug)+1), convert(x.debug, y(left downto left-len(x.debug)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_row_ort) return daq_row_ort is
    variable y: daq_row_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.mngt := structify(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.pbldr := structify(x(left to left+len(y.pbldr)-1), y.pbldr);
      left := left + len(y.pbldr);
      y.debug := structify(x(left to left+len(y.debug)-1), y.debug);
    else
      y.mngt := structify(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.pbldr := structify(x(left downto left-len(y.pbldr)+1), y.pbldr);
      left := left - len(y.pbldr);
      y.debug := structify(x(left downto left-len(y.debug)+1), y.debug);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_row_ort) return daq_row_ort is
    variable y: daq_row_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.mngt := convert(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.pbldr := convert(x(left to left+len(y.pbldr)-1), y.pbldr);
      left := left + len(y.pbldr);
      y.debug := convert(x(left to left+len(y.debug)-1), y.debug);
    else
      y.mngt := convert(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.pbldr := convert(x(left downto left-len(y.pbldr)+1), y.pbldr);
      left := left - len(y.pbldr);
      y.debug := convert(x(left downto left-len(y.debug)+1), y.debug);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_row_ort) return daq_row_ort is
  variable y: daq_row_ort;
  begin
    y.mngt := nullify(t.mngt);
    y.pbldr := nullify(t.pbldr);
    y.debug := nullify(t.debug);
    return y;
  end function nullify;
  function zeroed(t: daq_row_ort) return daq_row_ort is
  variable y: daq_row_ort;
  begin
    y.mngt := zeroed(t.mngt);
    y.pbldr := zeroed(t.pbldr);
    y.debug := zeroed(t.debug);
    return y;
  end function zeroed;

  function len(x: daq_header_row_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.mngt);
    l := l + len(x.req);
    l := l + len(x.pbldr);
    return l;
  end function len;
  function width(x: daq_header_row_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.mngt);
    l := l + width(x.req);
    l := l + width(x.pbldr);
    return l;
  end function width;
  function vectorify(x: daq_header_row_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), vectorify(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.req)-1), vectorify(x.req, y(left to left+len(x.req)-1)));
      left := left + len(x.req);
      assign(y(left to left+len(x.pbldr)-1), vectorify(x.pbldr, y(left to left+len(x.pbldr)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), vectorify(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.req)+1), vectorify(x.req, y(left downto left-len(x.req)+1)));
      left := left - len(x.req);
      assign(y(left downto left-len(x.pbldr)+1), vectorify(x.pbldr, y(left downto left-len(x.pbldr)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_header_row_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), convert(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.req)-1), convert(x.req, y(left to left+len(x.req)-1)));
      left := left + len(x.req);
      assign(y(left to left+len(x.pbldr)-1), convert(x.pbldr, y(left to left+len(x.pbldr)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), convert(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.req)+1), convert(x.req, y(left downto left-len(x.req)+1)));
      left := left - len(x.req);
      assign(y(left downto left-len(x.pbldr)+1), convert(x.pbldr, y(left downto left-len(x.pbldr)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_header_row_irt) return daq_header_row_irt is
    variable y: daq_header_row_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := structify(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.req := structify(x(left to left+len(y.req)-1), y.req);
      left := left + len(y.req);
      y.pbldr := structify(x(left to left+len(y.pbldr)-1), y.pbldr);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := structify(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.req := structify(x(left downto left-len(y.req)+1), y.req);
      left := left - len(y.req);
      y.pbldr := structify(x(left downto left-len(y.pbldr)+1), y.pbldr);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_header_row_irt) return daq_header_row_irt is
    variable y: daq_header_row_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := convert(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.req := convert(x(left to left+len(y.req)-1), y.req);
      left := left + len(y.req);
      y.pbldr := convert(x(left to left+len(y.pbldr)-1), y.pbldr);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := convert(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.req := convert(x(left downto left-len(y.req)+1), y.req);
      left := left - len(y.req);
      y.pbldr := convert(x(left downto left-len(y.pbldr)+1), y.pbldr);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_header_row_irt) return daq_header_row_irt is
  variable y: daq_header_row_irt;
  begin
    y.sys := nullify(t.sys);
    y.mngt := nullify(t.mngt);
    y.req := nullify(t.req);
    y.pbldr := nullify(t.pbldr);
    return y;
  end function nullify;
  function zeroed(t: daq_header_row_irt) return daq_header_row_irt is
  variable y: daq_header_row_irt;
  begin
    y.sys := zeroed(t.sys);
    y.mngt := zeroed(t.mngt);
    y.req := zeroed(t.req);
    y.pbldr := zeroed(t.pbldr);
    return y;
  end function zeroed;

  function len(x: daq_header_row_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: daq_header_row_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: daq_header_row_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_header_row_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_header_row_ert) return daq_header_row_ert is
    variable y: daq_header_row_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_header_row_ert) return daq_header_row_ert is
    variable y: daq_header_row_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_header_row_ert) return daq_header_row_ert is
  variable y: daq_header_row_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: daq_header_row_ert) return daq_header_row_ert is
  variable y: daq_header_row_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: daq_data_row_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.mngt);
    l := l + len(x.req);
    l := l + len(x.stream);
    l := l + len(x.pbldr);
    return l;
  end function len;
  function width(x: daq_data_row_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.mngt);
    l := l + width(x.req);
    l := l + width(x.stream);
    l := l + width(x.pbldr);
    return l;
  end function width;
  function vectorify(x: daq_data_row_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), vectorify(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.req)-1), vectorify(x.req, y(left to left+len(x.req)-1)));
      left := left + len(x.req);
      assign(y(left to left+len(x.stream)-1), vectorify(x.stream, y(left to left+len(x.stream)-1)));
      left := left + len(x.stream);
      assign(y(left to left+len(x.pbldr)-1), vectorify(x.pbldr, y(left to left+len(x.pbldr)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), vectorify(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.req)+1), vectorify(x.req, y(left downto left-len(x.req)+1)));
      left := left - len(x.req);
      assign(y(left downto left-len(x.stream)+1), vectorify(x.stream, y(left downto left-len(x.stream)+1)));
      left := left - len(x.stream);
      assign(y(left downto left-len(x.pbldr)+1), vectorify(x.pbldr, y(left downto left-len(x.pbldr)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_data_row_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), convert(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.req)-1), convert(x.req, y(left to left+len(x.req)-1)));
      left := left + len(x.req);
      assign(y(left to left+len(x.stream)-1), convert(x.stream, y(left to left+len(x.stream)-1)));
      left := left + len(x.stream);
      assign(y(left to left+len(x.pbldr)-1), convert(x.pbldr, y(left to left+len(x.pbldr)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), convert(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.req)+1), convert(x.req, y(left downto left-len(x.req)+1)));
      left := left - len(x.req);
      assign(y(left downto left-len(x.stream)+1), convert(x.stream, y(left downto left-len(x.stream)+1)));
      left := left - len(x.stream);
      assign(y(left downto left-len(x.pbldr)+1), convert(x.pbldr, y(left downto left-len(x.pbldr)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_data_row_irt) return daq_data_row_irt is
    variable y: daq_data_row_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := structify(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.req := structify(x(left to left+len(y.req)-1), y.req);
      left := left + len(y.req);
      y.stream := structify(x(left to left+len(y.stream)-1), y.stream);
      left := left + len(y.stream);
      y.pbldr := structify(x(left to left+len(y.pbldr)-1), y.pbldr);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := structify(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.req := structify(x(left downto left-len(y.req)+1), y.req);
      left := left - len(y.req);
      y.stream := structify(x(left downto left-len(y.stream)+1), y.stream);
      left := left - len(y.stream);
      y.pbldr := structify(x(left downto left-len(y.pbldr)+1), y.pbldr);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_data_row_irt) return daq_data_row_irt is
    variable y: daq_data_row_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := convert(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.req := convert(x(left to left+len(y.req)-1), y.req);
      left := left + len(y.req);
      y.stream := convert(x(left to left+len(y.stream)-1), y.stream);
      left := left + len(y.stream);
      y.pbldr := convert(x(left to left+len(y.pbldr)-1), y.pbldr);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := convert(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.req := convert(x(left downto left-len(y.req)+1), y.req);
      left := left - len(y.req);
      y.stream := convert(x(left downto left-len(y.stream)+1), y.stream);
      left := left - len(y.stream);
      y.pbldr := convert(x(left downto left-len(y.pbldr)+1), y.pbldr);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_data_row_irt) return daq_data_row_irt is
  variable y: daq_data_row_irt;
  begin
    y.sys := nullify(t.sys);
    y.mngt := nullify(t.mngt);
    y.req := nullify(t.req);
    y.stream := nullify(t.stream);
    y.pbldr := nullify(t.pbldr);
    return y;
  end function nullify;
  function zeroed(t: daq_data_row_irt) return daq_data_row_irt is
  variable y: daq_data_row_irt;
  begin
    y.sys := zeroed(t.sys);
    y.mngt := zeroed(t.mngt);
    y.req := zeroed(t.req);
    y.stream := zeroed(t.stream);
    y.pbldr := zeroed(t.pbldr);
    return y;
  end function zeroed;

  function len(x: daq_data_row_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: daq_data_row_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: daq_data_row_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_data_row_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_data_row_ert) return daq_data_row_ert is
    variable y: daq_data_row_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_data_row_ert) return daq_data_row_ert is
    variable y: daq_data_row_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_data_row_ert) return daq_data_row_ert is
  variable y: daq_data_row_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: daq_data_row_ert) return daq_data_row_ert is
  variable y: daq_data_row_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: daq_pbldr_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.mngt);
    l := l + len(x.rows);
    l := l + len(x.f2e);
    return l;
  end function len;
  function width(x: daq_pbldr_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.mngt);
    l := l + width(x.rows);
    l := l + width(x.f2e);
    return l;
  end function width;
  function vectorify(x: daq_pbldr_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), vectorify(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.rows)-1), vectorify(x.rows, y(left to left+len(x.rows)-1)));
      left := left + len(x.rows);
      assign(y(left to left+len(x.f2e)-1), vectorify(x.f2e, y(left to left+len(x.f2e)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), vectorify(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.rows)+1), vectorify(x.rows, y(left downto left-len(x.rows)+1)));
      left := left - len(x.rows);
      assign(y(left downto left-len(x.f2e)+1), vectorify(x.f2e, y(left downto left-len(x.f2e)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_pbldr_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.mngt)-1), convert(x.mngt, y(left to left+len(x.mngt)-1)));
      left := left + len(x.mngt);
      assign(y(left to left+len(x.rows)-1), convert(x.rows, y(left to left+len(x.rows)-1)));
      left := left + len(x.rows);
      assign(y(left to left+len(x.f2e)-1), convert(x.f2e, y(left to left+len(x.f2e)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.mngt)+1), convert(x.mngt, y(left downto left-len(x.mngt)+1)));
      left := left - len(x.mngt);
      assign(y(left downto left-len(x.rows)+1), convert(x.rows, y(left downto left-len(x.rows)+1)));
      left := left - len(x.rows);
      assign(y(left downto left-len(x.f2e)+1), convert(x.f2e, y(left downto left-len(x.f2e)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_pbldr_irt) return daq_pbldr_irt is
    variable y: daq_pbldr_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := structify(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.rows := structify(x(left to left+len(y.rows)-1), y.rows);
      left := left + len(y.rows);
      y.f2e := structify(x(left to left+len(y.f2e)-1), y.f2e);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := structify(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.rows := structify(x(left downto left-len(y.rows)+1), y.rows);
      left := left - len(y.rows);
      y.f2e := structify(x(left downto left-len(y.f2e)+1), y.f2e);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_pbldr_irt) return daq_pbldr_irt is
    variable y: daq_pbldr_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.mngt := convert(x(left to left+len(y.mngt)-1), y.mngt);
      left := left + len(y.mngt);
      y.rows := convert(x(left to left+len(y.rows)-1), y.rows);
      left := left + len(y.rows);
      y.f2e := convert(x(left to left+len(y.f2e)-1), y.f2e);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.mngt := convert(x(left downto left-len(y.mngt)+1), y.mngt);
      left := left - len(y.mngt);
      y.rows := convert(x(left downto left-len(y.rows)+1), y.rows);
      left := left - len(y.rows);
      y.f2e := convert(x(left downto left-len(y.f2e)+1), y.f2e);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_pbldr_irt) return daq_pbldr_irt is
  variable y: daq_pbldr_irt;
  begin
    y.sys := nullify(t.sys);
    y.mngt := nullify(t.mngt);
    y.rows := nullify(t.rows);
    y.f2e := nullify(t.f2e);
    return y;
  end function nullify;
  function zeroed(t: daq_pbldr_irt) return daq_pbldr_irt is
  variable y: daq_pbldr_irt;
  begin
    y.sys := zeroed(t.sys);
    y.mngt := zeroed(t.mngt);
    y.rows := zeroed(t.rows);
    y.f2e := zeroed(t.f2e);
    return y;
  end function zeroed;

  function len(x: daq_pbldr_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rows);
    l := l + len(x.f2e);
    return l;
  end function len;
  function width(x: daq_pbldr_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rows);
    l := l + width(x.f2e);
    return l;
  end function width;
  function vectorify(x: daq_pbldr_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rows)-1), vectorify(x.rows, y(left to left+len(x.rows)-1)));
      left := left + len(x.rows);
      assign(y(left to left+len(x.f2e)-1), vectorify(x.f2e, y(left to left+len(x.f2e)-1)));
    else
      assign(y(left downto left-len(x.rows)+1), vectorify(x.rows, y(left downto left-len(x.rows)+1)));
      left := left - len(x.rows);
      assign(y(left downto left-len(x.f2e)+1), vectorify(x.f2e, y(left downto left-len(x.f2e)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_pbldr_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rows)-1), convert(x.rows, y(left to left+len(x.rows)-1)));
      left := left + len(x.rows);
      assign(y(left to left+len(x.f2e)-1), convert(x.f2e, y(left to left+len(x.f2e)-1)));
    else
      assign(y(left downto left-len(x.rows)+1), convert(x.rows, y(left downto left-len(x.rows)+1)));
      left := left - len(x.rows);
      assign(y(left downto left-len(x.f2e)+1), convert(x.f2e, y(left downto left-len(x.f2e)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_pbldr_ort) return daq_pbldr_ort is
    variable y: daq_pbldr_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rows := structify(x(left to left+len(y.rows)-1), y.rows);
      left := left + len(y.rows);
      y.f2e := structify(x(left to left+len(y.f2e)-1), y.f2e);
    else
      y.rows := structify(x(left downto left-len(y.rows)+1), y.rows);
      left := left - len(y.rows);
      y.f2e := structify(x(left downto left-len(y.f2e)+1), y.f2e);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_pbldr_ort) return daq_pbldr_ort is
    variable y: daq_pbldr_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rows := convert(x(left to left+len(y.rows)-1), y.rows);
      left := left + len(y.rows);
      y.f2e := convert(x(left to left+len(y.f2e)-1), y.f2e);
    else
      y.rows := convert(x(left downto left-len(y.rows)+1), y.rows);
      left := left - len(y.rows);
      y.f2e := convert(x(left downto left-len(y.f2e)+1), y.f2e);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_pbldr_ort) return daq_pbldr_ort is
  variable y: daq_pbldr_ort;
  begin
    y.rows := nullify(t.rows);
    y.f2e := nullify(t.f2e);
    return y;
  end function nullify;
  function zeroed(t: daq_pbldr_ort) return daq_pbldr_ort is
  variable y: daq_pbldr_ort;
  begin
    y.rows := zeroed(t.rows);
    y.f2e := zeroed(t.f2e);
    return y;
  end function zeroed;

  function len(x: daq_pbldr_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: daq_pbldr_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: daq_pbldr_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_pbldr_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_pbldr_ert) return daq_pbldr_ert is
    variable y: daq_pbldr_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_pbldr_ert) return daq_pbldr_ert is
    variable y: daq_pbldr_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_pbldr_ert) return daq_pbldr_ert is
  variable y: daq_pbldr_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: daq_pbldr_ert) return daq_pbldr_ert is
  variable y: daq_pbldr_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: rows_to_mngt_rt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: rows_to_mngt_rt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: rows_to_mngt_rt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: rows_to_mngt_rt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: rows_to_mngt_rt) return rows_to_mngt_rt is
    variable y : rows_to_mngt_rt;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: rows_to_mngt_rt) return rows_to_mngt_rt is
    variable y : rows_to_mngt_rt;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: rows_to_mngt_rt) return rows_to_mngt_rt is
    variable y : rows_to_mngt_rt;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: rows_to_mngt_rt) return rows_to_mngt_rt is
    variable y : rows_to_mngt_rt;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: daq_mngt_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.ttc);
    l := l + len(x.rows);
    return l;
  end function len;
  function width(x: daq_mngt_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.ttc);
    l := l + width(x.rows);
    return l;
  end function width;
  function vectorify(x: daq_mngt_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.ttc)-1), vectorify(x.ttc, y(left to left+len(x.ttc)-1)));
      left := left + len(x.ttc);
      assign(y(left to left+len(x.rows)-1), vectorify(x.rows, y(left to left+len(x.rows)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.ttc)+1), vectorify(x.ttc, y(left downto left-len(x.ttc)+1)));
      left := left - len(x.ttc);
      assign(y(left downto left-len(x.rows)+1), vectorify(x.rows, y(left downto left-len(x.rows)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_mngt_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.ttc)-1), convert(x.ttc, y(left to left+len(x.ttc)-1)));
      left := left + len(x.ttc);
      assign(y(left to left+len(x.rows)-1), convert(x.rows, y(left to left+len(x.rows)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.ttc)+1), convert(x.ttc, y(left downto left-len(x.ttc)+1)));
      left := left - len(x.ttc);
      assign(y(left downto left-len(x.rows)+1), convert(x.rows, y(left downto left-len(x.rows)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_mngt_irt) return daq_mngt_irt is
    variable y: daq_mngt_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.ttc := structify(x(left to left+len(y.ttc)-1), y.ttc);
      left := left + len(y.ttc);
      y.rows := structify(x(left to left+len(y.rows)-1), y.rows);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.ttc := structify(x(left downto left-len(y.ttc)+1), y.ttc);
      left := left - len(y.ttc);
      y.rows := structify(x(left downto left-len(y.rows)+1), y.rows);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_mngt_irt) return daq_mngt_irt is
    variable y: daq_mngt_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.ttc := convert(x(left to left+len(y.ttc)-1), y.ttc);
      left := left + len(y.ttc);
      y.rows := convert(x(left to left+len(y.rows)-1), y.rows);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.ttc := convert(x(left downto left-len(y.ttc)+1), y.ttc);
      left := left - len(y.ttc);
      y.rows := convert(x(left downto left-len(y.rows)+1), y.rows);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_mngt_irt) return daq_mngt_irt is
  variable y: daq_mngt_irt;
  begin
    y.sys := nullify(t.sys);
    y.ttc := nullify(t.ttc);
    y.rows := nullify(t.rows);
    return y;
  end function nullify;
  function zeroed(t: daq_mngt_irt) return daq_mngt_irt is
  variable y: daq_mngt_irt;
  begin
    y.sys := zeroed(t.sys);
    y.ttc := zeroed(t.ttc);
    y.rows := zeroed(t.rows);
    return y;
  end function zeroed;

  function len(x: daq_mngt_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.row);
    l := l + len(x.pbldr);
    l := l + len(x.err);
    l := l + len(x.debug);
    return l;
  end function len;
  function width(x: daq_mngt_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.row);
    l := l + width(x.pbldr);
    l := l + width(x.err);
    l := l + width(x.debug);
    return l;
  end function width;
  function vectorify(x: daq_mngt_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.row)-1), vectorify(x.row, y(left to left+len(x.row)-1)));
      left := left + len(x.row);
      assign(y(left to left+len(x.pbldr)-1), vectorify(x.pbldr, y(left to left+len(x.pbldr)-1)));
      left := left + len(x.pbldr);
      assign(y(left to left+len(x.err)-1), vectorify(x.err, y(left to left+len(x.err)-1)));
      left := left + len(x.err);
      assign(y(left to left+len(x.debug)-1), vectorify(x.debug, y(left to left+len(x.debug)-1)));
    else
      assign(y(left downto left-len(x.row)+1), vectorify(x.row, y(left downto left-len(x.row)+1)));
      left := left - len(x.row);
      assign(y(left downto left-len(x.pbldr)+1), vectorify(x.pbldr, y(left downto left-len(x.pbldr)+1)));
      left := left - len(x.pbldr);
      assign(y(left downto left-len(x.err)+1), vectorify(x.err, y(left downto left-len(x.err)+1)));
      left := left - len(x.err);
      assign(y(left downto left-len(x.debug)+1), vectorify(x.debug, y(left downto left-len(x.debug)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_mngt_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.row)-1), convert(x.row, y(left to left+len(x.row)-1)));
      left := left + len(x.row);
      assign(y(left to left+len(x.pbldr)-1), convert(x.pbldr, y(left to left+len(x.pbldr)-1)));
      left := left + len(x.pbldr);
      assign(y(left to left+len(x.err)-1), convert(x.err, y(left to left+len(x.err)-1)));
      left := left + len(x.err);
      assign(y(left to left+len(x.debug)-1), convert(x.debug, y(left to left+len(x.debug)-1)));
    else
      assign(y(left downto left-len(x.row)+1), convert(x.row, y(left downto left-len(x.row)+1)));
      left := left - len(x.row);
      assign(y(left downto left-len(x.pbldr)+1), convert(x.pbldr, y(left downto left-len(x.pbldr)+1)));
      left := left - len(x.pbldr);
      assign(y(left downto left-len(x.err)+1), convert(x.err, y(left downto left-len(x.err)+1)));
      left := left - len(x.err);
      assign(y(left downto left-len(x.debug)+1), convert(x.debug, y(left downto left-len(x.debug)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_mngt_ort) return daq_mngt_ort is
    variable y: daq_mngt_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.row := structify(x(left to left+len(y.row)-1), y.row);
      left := left + len(y.row);
      y.pbldr := structify(x(left to left+len(y.pbldr)-1), y.pbldr);
      left := left + len(y.pbldr);
      y.err := structify(x(left to left+len(y.err)-1), y.err);
      left := left + len(y.err);
      y.debug := structify(x(left to left+len(y.debug)-1), y.debug);
    else
      y.row := structify(x(left downto left-len(y.row)+1), y.row);
      left := left - len(y.row);
      y.pbldr := structify(x(left downto left-len(y.pbldr)+1), y.pbldr);
      left := left - len(y.pbldr);
      y.err := structify(x(left downto left-len(y.err)+1), y.err);
      left := left - len(y.err);
      y.debug := structify(x(left downto left-len(y.debug)+1), y.debug);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_mngt_ort) return daq_mngt_ort is
    variable y: daq_mngt_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.row := convert(x(left to left+len(y.row)-1), y.row);
      left := left + len(y.row);
      y.pbldr := convert(x(left to left+len(y.pbldr)-1), y.pbldr);
      left := left + len(y.pbldr);
      y.err := convert(x(left to left+len(y.err)-1), y.err);
      left := left + len(y.err);
      y.debug := convert(x(left to left+len(y.debug)-1), y.debug);
    else
      y.row := convert(x(left downto left-len(y.row)+1), y.row);
      left := left - len(y.row);
      y.pbldr := convert(x(left downto left-len(y.pbldr)+1), y.pbldr);
      left := left - len(y.pbldr);
      y.err := convert(x(left downto left-len(y.err)+1), y.err);
      left := left - len(y.err);
      y.debug := convert(x(left downto left-len(y.debug)+1), y.debug);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_mngt_ort) return daq_mngt_ort is
  variable y: daq_mngt_ort;
  begin
    y.row := nullify(t.row);
    y.pbldr := nullify(t.pbldr);
    y.err := nullify(t.err);
    y.debug := nullify(t.debug);
    return y;
  end function nullify;
  function zeroed(t: daq_mngt_ort) return daq_mngt_ort is
  variable y: daq_mngt_ort;
  begin
    y.row := zeroed(t.row);
    y.pbldr := zeroed(t.pbldr);
    y.err := zeroed(t.err);
    y.debug := zeroed(t.debug);
    return y;
  end function zeroed;

  function len(x: daq_mngt_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: daq_mngt_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: daq_mngt_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_mngt_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_mngt_ert) return daq_mngt_ert is
    variable y: daq_mngt_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_mngt_ert) return daq_mngt_ert is
    variable y: daq_mngt_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_mngt_ert) return daq_mngt_ert is
  variable y: daq_mngt_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: daq_mngt_ert) return daq_mngt_ert is
  variable y: daq_mngt_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: daq_algo_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.ttc);
    l := l + len(x.ctrl);
    l := l + len(x.branch);
    l := l + len(x.f2e);
    return l;
  end function len;
  function width(x: daq_algo_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.ttc);
    l := l + width(x.ctrl);
    l := l + width(x.branch);
    l := l + width(x.f2e);
    return l;
  end function width;
  function vectorify(x: daq_algo_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.ttc)-1), vectorify(x.ttc, y(left to left+len(x.ttc)-1)));
      left := left + len(x.ttc);
      assign(y(left to left+len(x.ctrl)-1), vectorify(x.ctrl, y(left to left+len(x.ctrl)-1)));
      left := left + len(x.ctrl);
      assign(y(left to left+len(x.branch)-1), vectorify(x.branch, y(left to left+len(x.branch)-1)));
      left := left + len(x.branch);
      assign(y(left to left+len(x.f2e)-1), vectorify(x.f2e, y(left to left+len(x.f2e)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.ttc)+1), vectorify(x.ttc, y(left downto left-len(x.ttc)+1)));
      left := left - len(x.ttc);
      assign(y(left downto left-len(x.ctrl)+1), vectorify(x.ctrl, y(left downto left-len(x.ctrl)+1)));
      left := left - len(x.ctrl);
      assign(y(left downto left-len(x.branch)+1), vectorify(x.branch, y(left downto left-len(x.branch)+1)));
      left := left - len(x.branch);
      assign(y(left downto left-len(x.f2e)+1), vectorify(x.f2e, y(left downto left-len(x.f2e)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_algo_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.ttc)-1), convert(x.ttc, y(left to left+len(x.ttc)-1)));
      left := left + len(x.ttc);
      assign(y(left to left+len(x.ctrl)-1), convert(x.ctrl, y(left to left+len(x.ctrl)-1)));
      left := left + len(x.ctrl);
      assign(y(left to left+len(x.branch)-1), convert(x.branch, y(left to left+len(x.branch)-1)));
      left := left + len(x.branch);
      assign(y(left to left+len(x.f2e)-1), convert(x.f2e, y(left to left+len(x.f2e)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.ttc)+1), convert(x.ttc, y(left downto left-len(x.ttc)+1)));
      left := left - len(x.ttc);
      assign(y(left downto left-len(x.ctrl)+1), convert(x.ctrl, y(left downto left-len(x.ctrl)+1)));
      left := left - len(x.ctrl);
      assign(y(left downto left-len(x.branch)+1), convert(x.branch, y(left downto left-len(x.branch)+1)));
      left := left - len(x.branch);
      assign(y(left downto left-len(x.f2e)+1), convert(x.f2e, y(left downto left-len(x.f2e)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_algo_irt) return daq_algo_irt is
    variable y: daq_algo_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.ttc := structify(x(left to left+len(y.ttc)-1), y.ttc);
      left := left + len(y.ttc);
      y.ctrl := structify(x(left to left+len(y.ctrl)-1), y.ctrl);
      left := left + len(y.ctrl);
      y.branch := structify(x(left to left+len(y.branch)-1), y.branch);
      left := left + len(y.branch);
      y.f2e := structify(x(left to left+len(y.f2e)-1), y.f2e);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.ttc := structify(x(left downto left-len(y.ttc)+1), y.ttc);
      left := left - len(y.ttc);
      y.ctrl := structify(x(left downto left-len(y.ctrl)+1), y.ctrl);
      left := left - len(y.ctrl);
      y.branch := structify(x(left downto left-len(y.branch)+1), y.branch);
      left := left - len(y.branch);
      y.f2e := structify(x(left downto left-len(y.f2e)+1), y.f2e);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_algo_irt) return daq_algo_irt is
    variable y: daq_algo_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.ttc := convert(x(left to left+len(y.ttc)-1), y.ttc);
      left := left + len(y.ttc);
      y.ctrl := convert(x(left to left+len(y.ctrl)-1), y.ctrl);
      left := left + len(y.ctrl);
      y.branch := convert(x(left to left+len(y.branch)-1), y.branch);
      left := left + len(y.branch);
      y.f2e := convert(x(left to left+len(y.f2e)-1), y.f2e);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.ttc := convert(x(left downto left-len(y.ttc)+1), y.ttc);
      left := left - len(y.ttc);
      y.ctrl := convert(x(left downto left-len(y.ctrl)+1), y.ctrl);
      left := left - len(y.ctrl);
      y.branch := convert(x(left downto left-len(y.branch)+1), y.branch);
      left := left - len(y.branch);
      y.f2e := convert(x(left downto left-len(y.f2e)+1), y.f2e);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_algo_irt) return daq_algo_irt is
  variable y: daq_algo_irt;
  begin
    y.sys := nullify(t.sys);
    y.ttc := nullify(t.ttc);
    y.ctrl := nullify(t.ctrl);
    y.branch := nullify(t.branch);
    y.f2e := nullify(t.f2e);
    return y;
  end function nullify;
  function zeroed(t: daq_algo_irt) return daq_algo_irt is
  variable y: daq_algo_irt;
  begin
    y.sys := zeroed(t.sys);
    y.ttc := zeroed(t.ttc);
    y.ctrl := zeroed(t.ctrl);
    y.branch := zeroed(t.branch);
    y.f2e := zeroed(t.f2e);
    return y;
  end function zeroed;

  function len(x: daq_algo_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.status);
    l := l + len(x.f2e);
    return l;
  end function len;
  function width(x: daq_algo_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.status);
    l := l + width(x.f2e);
    return l;
  end function width;
  function vectorify(x: daq_algo_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.status)-1), vectorify(x.status, y(left to left+len(x.status)-1)));
      left := left + len(x.status);
      assign(y(left to left+len(x.f2e)-1), vectorify(x.f2e, y(left to left+len(x.f2e)-1)));
    else
      assign(y(left downto left-len(x.status)+1), vectorify(x.status, y(left downto left-len(x.status)+1)));
      left := left - len(x.status);
      assign(y(left downto left-len(x.f2e)+1), vectorify(x.f2e, y(left downto left-len(x.f2e)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_algo_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.status)-1), convert(x.status, y(left to left+len(x.status)-1)));
      left := left + len(x.status);
      assign(y(left to left+len(x.f2e)-1), convert(x.f2e, y(left to left+len(x.f2e)-1)));
    else
      assign(y(left downto left-len(x.status)+1), convert(x.status, y(left downto left-len(x.status)+1)));
      left := left - len(x.status);
      assign(y(left downto left-len(x.f2e)+1), convert(x.f2e, y(left downto left-len(x.f2e)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_algo_ort) return daq_algo_ort is
    variable y: daq_algo_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.status := structify(x(left to left+len(y.status)-1), y.status);
      left := left + len(y.status);
      y.f2e := structify(x(left to left+len(y.f2e)-1), y.f2e);
    else
      y.status := structify(x(left downto left-len(y.status)+1), y.status);
      left := left - len(y.status);
      y.f2e := structify(x(left downto left-len(y.f2e)+1), y.f2e);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_algo_ort) return daq_algo_ort is
    variable y: daq_algo_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.status := convert(x(left to left+len(y.status)-1), y.status);
      left := left + len(y.status);
      y.f2e := convert(x(left to left+len(y.f2e)-1), y.f2e);
    else
      y.status := convert(x(left downto left-len(y.status)+1), y.status);
      left := left - len(y.status);
      y.f2e := convert(x(left downto left-len(y.f2e)+1), y.f2e);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_algo_ort) return daq_algo_ort is
  variable y: daq_algo_ort;
  begin
    y.status := nullify(t.status);
    y.f2e := nullify(t.f2e);
    return y;
  end function nullify;
  function zeroed(t: daq_algo_ort) return daq_algo_ort is
  variable y: daq_algo_ort;
  begin
    y.status := zeroed(t.status);
    y.f2e := zeroed(t.f2e);
    return y;
  end function zeroed;

  function len(x: daq_algo_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: daq_algo_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: daq_algo_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_algo_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_algo_ert) return daq_algo_ert is
    variable y: daq_algo_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_algo_ert) return daq_algo_ert is
    variable y: daq_algo_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_algo_ert) return daq_algo_ert is
  variable y: daq_algo_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: daq_algo_ert) return daq_algo_ert is
  variable y: daq_algo_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

  function len(x: mfelix_to_branch_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: mfelix_to_branch_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: mfelix_to_branch_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: mfelix_to_branch_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: mfelix_to_branch_at) return mfelix_to_branch_at is
    variable y : mfelix_to_branch_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: mfelix_to_branch_at) return mfelix_to_branch_at is
    variable y : mfelix_to_branch_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: mfelix_to_branch_at) return mfelix_to_branch_at is
    variable y : mfelix_to_branch_at;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: mfelix_to_branch_at) return mfelix_to_branch_at is
    variable y : mfelix_to_branch_at;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: top_to_mfelix_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: top_to_mfelix_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: top_to_mfelix_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: top_to_mfelix_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: top_to_mfelix_at) return top_to_mfelix_at is
    variable y : top_to_mfelix_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: top_to_mfelix_at) return top_to_mfelix_at is
    variable y : top_to_mfelix_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: top_to_mfelix_at) return top_to_mfelix_at is
    variable y : top_to_mfelix_at;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: top_to_mfelix_at) return top_to_mfelix_at is
    variable y : top_to_mfelix_at;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: top_to_status_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: top_to_status_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: top_to_status_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: top_to_status_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: top_to_status_at) return top_to_status_at is
    variable y : top_to_status_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: top_to_status_at) return top_to_status_at is
    variable y : top_to_status_at;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: top_to_status_at) return top_to_status_at is
    variable y : top_to_status_at;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: top_to_status_at) return top_to_status_at is
    variable y : top_to_status_at;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: daq_branch_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.ttc);
    l := l + len(x.ctrl);
    l := l + len(x.branches);
    l := l + len(x.f2e_bus);
    return l;
  end function len;
  function width(x: daq_branch_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.ttc);
    l := l + width(x.ctrl);
    l := l + width(x.branches);
    l := l + width(x.f2e_bus);
    return l;
  end function width;
  function vectorify(x: daq_branch_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.ttc)-1), vectorify(x.ttc, y(left to left+len(x.ttc)-1)));
      left := left + len(x.ttc);
      assign(y(left to left+len(x.ctrl)-1), vectorify(x.ctrl, y(left to left+len(x.ctrl)-1)));
      left := left + len(x.ctrl);
      assign(y(left to left+len(x.branches)-1), vectorify(x.branches, y(left to left+len(x.branches)-1)));
      left := left + len(x.branches);
      assign(y(left to left+len(x.f2e_bus)-1), vectorify(x.f2e_bus, y(left to left+len(x.f2e_bus)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.ttc)+1), vectorify(x.ttc, y(left downto left-len(x.ttc)+1)));
      left := left - len(x.ttc);
      assign(y(left downto left-len(x.ctrl)+1), vectorify(x.ctrl, y(left downto left-len(x.ctrl)+1)));
      left := left - len(x.ctrl);
      assign(y(left downto left-len(x.branches)+1), vectorify(x.branches, y(left downto left-len(x.branches)+1)));
      left := left - len(x.branches);
      assign(y(left downto left-len(x.f2e_bus)+1), vectorify(x.f2e_bus, y(left downto left-len(x.f2e_bus)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_branch_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.ttc)-1), convert(x.ttc, y(left to left+len(x.ttc)-1)));
      left := left + len(x.ttc);
      assign(y(left to left+len(x.ctrl)-1), convert(x.ctrl, y(left to left+len(x.ctrl)-1)));
      left := left + len(x.ctrl);
      assign(y(left to left+len(x.branches)-1), convert(x.branches, y(left to left+len(x.branches)-1)));
      left := left + len(x.branches);
      assign(y(left to left+len(x.f2e_bus)-1), convert(x.f2e_bus, y(left to left+len(x.f2e_bus)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.ttc)+1), convert(x.ttc, y(left downto left-len(x.ttc)+1)));
      left := left - len(x.ttc);
      assign(y(left downto left-len(x.ctrl)+1), convert(x.ctrl, y(left downto left-len(x.ctrl)+1)));
      left := left - len(x.ctrl);
      assign(y(left downto left-len(x.branches)+1), convert(x.branches, y(left downto left-len(x.branches)+1)));
      left := left - len(x.branches);
      assign(y(left downto left-len(x.f2e_bus)+1), convert(x.f2e_bus, y(left downto left-len(x.f2e_bus)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_branch_irt) return daq_branch_irt is
    variable y: daq_branch_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.ttc := structify(x(left to left+len(y.ttc)-1), y.ttc);
      left := left + len(y.ttc);
      y.ctrl := structify(x(left to left+len(y.ctrl)-1), y.ctrl);
      left := left + len(y.ctrl);
      y.branches := structify(x(left to left+len(y.branches)-1), y.branches);
      left := left + len(y.branches);
      y.f2e_bus := structify(x(left to left+len(y.f2e_bus)-1), y.f2e_bus);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.ttc := structify(x(left downto left-len(y.ttc)+1), y.ttc);
      left := left - len(y.ttc);
      y.ctrl := structify(x(left downto left-len(y.ctrl)+1), y.ctrl);
      left := left - len(y.ctrl);
      y.branches := structify(x(left downto left-len(y.branches)+1), y.branches);
      left := left - len(y.branches);
      y.f2e_bus := structify(x(left downto left-len(y.f2e_bus)+1), y.f2e_bus);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_branch_irt) return daq_branch_irt is
    variable y: daq_branch_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.ttc := convert(x(left to left+len(y.ttc)-1), y.ttc);
      left := left + len(y.ttc);
      y.ctrl := convert(x(left to left+len(y.ctrl)-1), y.ctrl);
      left := left + len(y.ctrl);
      y.branches := convert(x(left to left+len(y.branches)-1), y.branches);
      left := left + len(y.branches);
      y.f2e_bus := convert(x(left to left+len(y.f2e_bus)-1), y.f2e_bus);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.ttc := convert(x(left downto left-len(y.ttc)+1), y.ttc);
      left := left - len(y.ttc);
      y.ctrl := convert(x(left downto left-len(y.ctrl)+1), y.ctrl);
      left := left - len(y.ctrl);
      y.branches := convert(x(left downto left-len(y.branches)+1), y.branches);
      left := left - len(y.branches);
      y.f2e_bus := convert(x(left downto left-len(y.f2e_bus)+1), y.f2e_bus);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_branch_irt) return daq_branch_irt is
  variable y: daq_branch_irt;
  begin
    y.sys := nullify(t.sys);
    y.ttc := nullify(t.ttc);
    y.ctrl := nullify(t.ctrl);
    y.branches := nullify(t.branches);
    y.f2e_bus := nullify(t.f2e_bus);
    return y;
  end function nullify;
  function zeroed(t: daq_branch_irt) return daq_branch_irt is
  variable y: daq_branch_irt;
  begin
    y.sys := zeroed(t.sys);
    y.ttc := zeroed(t.ttc);
    y.ctrl := zeroed(t.ctrl);
    y.branches := zeroed(t.branches);
    y.f2e_bus := zeroed(t.f2e_bus);
    return y;
  end function zeroed;

  function len(x: daq_branch_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.status_bus);
    l := l + len(x.f2e_bus);
    return l;
  end function len;
  function width(x: daq_branch_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.status_bus);
    l := l + width(x.f2e_bus);
    return l;
  end function width;
  function vectorify(x: daq_branch_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.status_bus)-1), vectorify(x.status_bus, y(left to left+len(x.status_bus)-1)));
      left := left + len(x.status_bus);
      assign(y(left to left+len(x.f2e_bus)-1), vectorify(x.f2e_bus, y(left to left+len(x.f2e_bus)-1)));
    else
      assign(y(left downto left-len(x.status_bus)+1), vectorify(x.status_bus, y(left downto left-len(x.status_bus)+1)));
      left := left - len(x.status_bus);
      assign(y(left downto left-len(x.f2e_bus)+1), vectorify(x.f2e_bus, y(left downto left-len(x.f2e_bus)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_branch_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.status_bus)-1), convert(x.status_bus, y(left to left+len(x.status_bus)-1)));
      left := left + len(x.status_bus);
      assign(y(left to left+len(x.f2e_bus)-1), convert(x.f2e_bus, y(left to left+len(x.f2e_bus)-1)));
    else
      assign(y(left downto left-len(x.status_bus)+1), convert(x.status_bus, y(left downto left-len(x.status_bus)+1)));
      left := left - len(x.status_bus);
      assign(y(left downto left-len(x.f2e_bus)+1), convert(x.f2e_bus, y(left downto left-len(x.f2e_bus)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_branch_ort) return daq_branch_ort is
    variable y: daq_branch_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.status_bus := structify(x(left to left+len(y.status_bus)-1), y.status_bus);
      left := left + len(y.status_bus);
      y.f2e_bus := structify(x(left to left+len(y.f2e_bus)-1), y.f2e_bus);
    else
      y.status_bus := structify(x(left downto left-len(y.status_bus)+1), y.status_bus);
      left := left - len(y.status_bus);
      y.f2e_bus := structify(x(left downto left-len(y.f2e_bus)+1), y.f2e_bus);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_branch_ort) return daq_branch_ort is
    variable y: daq_branch_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.status_bus := convert(x(left to left+len(y.status_bus)-1), y.status_bus);
      left := left + len(y.status_bus);
      y.f2e_bus := convert(x(left to left+len(y.f2e_bus)-1), y.f2e_bus);
    else
      y.status_bus := convert(x(left downto left-len(y.status_bus)+1), y.status_bus);
      left := left - len(y.status_bus);
      y.f2e_bus := convert(x(left downto left-len(y.f2e_bus)+1), y.f2e_bus);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_branch_ort) return daq_branch_ort is
  variable y: daq_branch_ort;
  begin
    y.status_bus := nullify(t.status_bus);
    y.f2e_bus := nullify(t.f2e_bus);
    return y;
  end function nullify;
  function zeroed(t: daq_branch_ort) return daq_branch_ort is
  variable y: daq_branch_ort;
  begin
    y.status_bus := zeroed(t.status_bus);
    y.f2e_bus := zeroed(t.f2e_bus);
    return y;
  end function zeroed;

  function len(x: daq_branch_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: daq_branch_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: daq_branch_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: daq_branch_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: daq_branch_ert) return daq_branch_ert is
    variable y: daq_branch_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: daq_branch_ert) return daq_branch_ert is
    variable y: daq_branch_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: daq_branch_ert) return daq_branch_ert is
  variable y: daq_branch_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: daq_branch_ert) return daq_branch_ert is
  variable y: daq_branch_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

end package body daq_defs;
