-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl
-- 2022-03-18 13:35:14

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

library hp_lib;
use hp_lib.hp_pkg.all;

package heg_pkg is

   -- Custom types and functions --

   type heg_pc2heg_art is array(integer range <>) of hp_hpsPc2hp_rt;
   function width(x: heg_pc2heg_art) return integer;
   function convert(x: heg_pc2heg_art; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: heg_pc2heg_art) return heg_pc2heg_art;
   function convert(x: heg_pc2heg_art; t: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; t: heg_pc2heg_art) return heg_pc2heg_art;

   subtype heg_roi_center_ut is unsigned(MDT_TUBE_LEN-1 downto 0);

   type heg_roi_center_aut is array(integer range <>) of heg_roi_center_ut;
   function width(x: heg_roi_center_aut) return integer;
   function convert(x: heg_roi_center_aut; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: heg_roi_center_aut) return heg_roi_center_aut;
   function convert(x: heg_roi_center_aut; t: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; t: heg_roi_center_aut) return heg_roi_center_aut;

   type heg_ctrl2hp_rt is record
      rst : std_logic;
      enable : std_logic;
   end record heg_ctrl2hp_rt;
   function width(x: heg_ctrl2hp_rt) return natural;
   function convert(x: heg_ctrl2hp_rt; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt;

   type heg_ctrl2hp_art is array(integer range <>) of heg_ctrl2hp_rt;
   function width(x: heg_ctrl2hp_art) return integer;
   function convert(x: heg_ctrl2hp_art; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: heg_ctrl2hp_art) return heg_ctrl2hp_art;
   function convert(x: heg_ctrl2hp_art; t: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; t: heg_ctrl2hp_art) return heg_ctrl2hp_art;

   type heg_ctrl2hp_all is record
      window_valid : std_logic;
   end record heg_ctrl2hp_all;
   function width(x: heg_ctrl2hp_all) return natural;
   function convert(x: heg_ctrl2hp_all; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: heg_ctrl2hp_all) return heg_ctrl2hp_all;

   constant CSF_SLOPE_LEN : integer := 11;

   type heg_ctrl2sf_rt is record
      rst : std_logic;
      eof : std_logic;
      enable : std_logic;
   end record heg_ctrl2sf_rt;
   function width(x: heg_ctrl2sf_rt) return natural;
   function convert(x: heg_ctrl2sf_rt; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt;

   type heg_hp2bm_art is array(integer range <>) of hp_hp2bm_rt;
   function width(x: heg_hp2bm_art) return integer;
   function convert(x: heg_hp2bm_art; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: heg_hp2bm_art) return heg_hp2bm_art;
   function convert(x: heg_hp2bm_art; t: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; t: heg_hp2bm_art) return heg_hp2bm_art;

   type heg_bm2sf_rt is record
      data : hp_hp2sf_data_rt;
      data_valid : std_logic;
   end record heg_bm2sf_rt;
   function width(x: heg_bm2sf_rt) return natural;
   function convert(x: heg_bm2sf_rt; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: heg_bm2sf_rt) return heg_bm2sf_rt;

   type heg_hp2bm_data_art is array(integer range <>) of hp_hp2sf_data_rt;
   function width(x: heg_hp2bm_data_art) return integer;
   function convert(x: heg_hp2bm_data_art; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: heg_hp2bm_data_art) return heg_hp2bm_data_art;
   function convert(x: heg_hp2bm_data_art; t: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; t: heg_hp2bm_data_art) return heg_hp2bm_data_art;

end package heg_pkg;

------------------------------------------------------------

package body heg_pkg is

   -- Custom types and functions --

   function width(x: heg_pc2heg_art) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: heg_pc2heg_art; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: heg_pc2heg_art) return heg_pc2heg_art is
      variable y : heg_pc2heg_art(t'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: heg_pc2heg_art; t: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(t'range)(t(t'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; t: heg_pc2heg_art) return heg_pc2heg_art is
      variable y : heg_pc2heg_art(t'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: heg_roi_center_aut) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: heg_roi_center_aut; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: heg_roi_center_aut) return heg_roi_center_aut is
      variable y : heg_roi_center_aut(t'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: heg_roi_center_aut; t: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(t'range)(t(t'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; t: heg_roi_center_aut) return heg_roi_center_aut is
      variable y : heg_roi_center_aut(t'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: heg_ctrl2hp_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rst);
      w := w + width(x.enable);
      return w;
   end function width;
   function convert(x: heg_ctrl2hp_rt; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.rst);
         y(u to u+w-1) := convert(x.rst, y(u to u+w-1));
         u := u + w;
         w := width(x.enable);
         y(u to u+w-1) := convert(x.enable, y(u to u+w-1));
      else
         w := width(x.rst);
         y(u downto u-w+1) := convert(x.rst, y(u downto u-w+1));
         u := u - w;
         w := width(x.enable);
         y(u downto u-w+1) := convert(x.enable, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt is
      variable y : heg_ctrl2hp_rt := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.rst);
         y.rst := convert(x(u to u+w-1), t.rst);
         u := u + w;
         w := width(t.enable);
         y.enable := convert(x(u to u+w-1), t.enable);
      else
         w := width(t.rst);
         y.rst := convert(x(u downto u-w+1), t.rst);
         u := u - w;
         w := width(t.enable);
         y.enable := convert(x(u downto u-w+1), t.enable);
      end if;
      return y;
   end function convert;

   function width(x: heg_ctrl2hp_art) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: heg_ctrl2hp_art; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: heg_ctrl2hp_art) return heg_ctrl2hp_art is
      variable y : heg_ctrl2hp_art(t'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: heg_ctrl2hp_art; t: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(t'range)(t(t'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; t: heg_ctrl2hp_art) return heg_ctrl2hp_art is
      variable y : heg_ctrl2hp_art(t'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: heg_ctrl2hp_all) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.window_valid);
      return w;
   end function width;
   function convert(x: heg_ctrl2hp_all; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.window_valid);
         y(u to u+w-1) := convert(x.window_valid, y(u to u+w-1));
      else
         w := width(x.window_valid);
         y(u downto u-w+1) := convert(x.window_valid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: heg_ctrl2hp_all) return heg_ctrl2hp_all is
      variable y : heg_ctrl2hp_all := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.window_valid);
         y.window_valid := convert(x(u to u+w-1), t.window_valid);
      else
         w := width(t.window_valid);
         y.window_valid := convert(x(u downto u-w+1), t.window_valid);
      end if;
      return y;
   end function convert;

   function width(x: heg_ctrl2sf_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rst);
      w := w + width(x.eof);
      w := w + width(x.enable);
      return w;
   end function width;
   function convert(x: heg_ctrl2sf_rt; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.rst);
         y(u to u+w-1) := convert(x.rst, y(u to u+w-1));
         u := u + w;
         w := width(x.eof);
         y(u to u+w-1) := convert(x.eof, y(u to u+w-1));
         u := u + w;
         w := width(x.enable);
         y(u to u+w-1) := convert(x.enable, y(u to u+w-1));
      else
         w := width(x.rst);
         y(u downto u-w+1) := convert(x.rst, y(u downto u-w+1));
         u := u - w;
         w := width(x.eof);
         y(u downto u-w+1) := convert(x.eof, y(u downto u-w+1));
         u := u - w;
         w := width(x.enable);
         y(u downto u-w+1) := convert(x.enable, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt is
      variable y : heg_ctrl2sf_rt := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.rst);
         y.rst := convert(x(u to u+w-1), t.rst);
         u := u + w;
         w := width(t.eof);
         y.eof := convert(x(u to u+w-1), t.eof);
         u := u + w;
         w := width(t.enable);
         y.enable := convert(x(u to u+w-1), t.enable);
      else
         w := width(t.rst);
         y.rst := convert(x(u downto u-w+1), t.rst);
         u := u - w;
         w := width(t.eof);
         y.eof := convert(x(u downto u-w+1), t.eof);
         u := u - w;
         w := width(t.enable);
         y.enable := convert(x(u downto u-w+1), t.enable);
      end if;
      return y;
   end function convert;

   function width(x: heg_hp2bm_art) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: heg_hp2bm_art; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: heg_hp2bm_art) return heg_hp2bm_art is
      variable y : heg_hp2bm_art(t'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: heg_hp2bm_art; t: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(t'range)(t(t'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; t: heg_hp2bm_art) return heg_hp2bm_art is
      variable y : heg_hp2bm_art(t'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: heg_bm2sf_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data);
      w := w + width(x.data_valid);
      return w;
   end function width;
   function convert(x: heg_bm2sf_rt; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
         u := u + w;
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
      else
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
         u := u - w;
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: heg_bm2sf_rt) return heg_bm2sf_rt is
      variable y : heg_bm2sf_rt := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.data);
         y.data := convert(x(u to u+w-1), t.data);
         u := u + w;
         w := width(t.data_valid);
         y.data_valid := convert(x(u to u+w-1), t.data_valid);
      else
         w := width(t.data);
         y.data := convert(x(u downto u-w+1), t.data);
         u := u - w;
         w := width(t.data_valid);
         y.data_valid := convert(x(u downto u-w+1), t.data_valid);
      end if;
      return y;
   end function convert;

   function width(x: heg_hp2bm_data_art) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: heg_hp2bm_data_art; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: heg_hp2bm_data_art) return heg_hp2bm_data_art is
      variable y : heg_hp2bm_data_art(t'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: heg_hp2bm_data_art; t: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(t'range)(t(t'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; t: heg_hp2bm_data_art) return heg_hp2bm_data_art is
      variable y : heg_hp2bm_data_art(t'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

end package body heg_pkg;
