-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;

library hp_lib;
use hp_lib.hp_pkg.all;

package heg_pkg is

  subtype heg_pc2heg_vt is std_logic_vector(70-1 downto 0);

  type heg_pc2heg_art is array(integer range <>) of hp_hpsPc2hp_rt;
  function len(x: heg_pc2heg_art) return natural;
  function width(x: heg_pc2heg_art) return natural;
  function vectorify(x: heg_pc2heg_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_pc2heg_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg_pc2heg_art) return heg_pc2heg_art;
  function convert(x: std_logic_vector; t: heg_pc2heg_art) return heg_pc2heg_art;
  function nullify(x: heg_pc2heg_art) return heg_pc2heg_art;
  function zeroed(x: heg_pc2heg_art) return heg_pc2heg_art;

  type heg_pc2heg_avt is array(integer range <>) of heg_pc2heg_vt;
  function len(x: heg_pc2heg_avt) return natural;
  function width(x: heg_pc2heg_avt) return natural;
  function vectorify(x: heg_pc2heg_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_pc2heg_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg_pc2heg_avt) return heg_pc2heg_avt;
  function convert(x: std_logic_vector; t: heg_pc2heg_avt) return heg_pc2heg_avt;
  function nullify(x: heg_pc2heg_avt) return heg_pc2heg_avt;
  function zeroed(x: heg_pc2heg_avt) return heg_pc2heg_avt;

  subtype heg_roi_center_ut is unsigned(MDT_TUBE_LEN-1 downto 0);

  type heg_roi_center_aut is array(integer range <>) of heg_roi_center_ut;
  function len(x: heg_roi_center_aut) return natural;
  function width(x: heg_roi_center_aut) return natural;
  function vectorify(x: heg_roi_center_aut; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_roi_center_aut; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg_roi_center_aut) return heg_roi_center_aut;
  function convert(x: std_logic_vector; t: heg_roi_center_aut) return heg_roi_center_aut;
  function nullify(x: heg_roi_center_aut) return heg_roi_center_aut;
  function zeroed(x: heg_roi_center_aut) return heg_roi_center_aut;

  type heg_ctrl2hp_rt is record
    rst : std_logic;
    enable : std_logic;
  end record heg_ctrl2hp_rt;
  function len(x: heg_ctrl2hp_rt) return natural;
  function width(x: heg_ctrl2hp_rt) return natural;
  function vectorify(x: heg_ctrl2hp_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_ctrl2hp_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt;
  function convert(x: in std_logic_vector; t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt;
  function nullify(t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt;
  function zeroed(t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt;

  subtype heg_ctrl2hp_vt is std_logic_vector(2-1 downto 0);

  type heg_ctrl2hp_art is array(integer range <>) of heg_ctrl2hp_rt;
  function len(x: heg_ctrl2hp_art) return natural;
  function width(x: heg_ctrl2hp_art) return natural;
  function vectorify(x: heg_ctrl2hp_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_ctrl2hp_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg_ctrl2hp_art) return heg_ctrl2hp_art;
  function convert(x: std_logic_vector; t: heg_ctrl2hp_art) return heg_ctrl2hp_art;
  function nullify(x: heg_ctrl2hp_art) return heg_ctrl2hp_art;
  function zeroed(x: heg_ctrl2hp_art) return heg_ctrl2hp_art;

  type heg_ctrl2hp_avt is array(integer range <>) of heg_ctrl2hp_vt;
  function len(x: heg_ctrl2hp_avt) return natural;
  function width(x: heg_ctrl2hp_avt) return natural;
  function vectorify(x: heg_ctrl2hp_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_ctrl2hp_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg_ctrl2hp_avt) return heg_ctrl2hp_avt;
  function convert(x: std_logic_vector; t: heg_ctrl2hp_avt) return heg_ctrl2hp_avt;
  function nullify(x: heg_ctrl2hp_avt) return heg_ctrl2hp_avt;
  function zeroed(x: heg_ctrl2hp_avt) return heg_ctrl2hp_avt;

  type heg_ctrl2hp_all is record
    window_valid : std_logic;
  end record heg_ctrl2hp_all;
  function len(x: heg_ctrl2hp_all) return natural;
  function width(x: heg_ctrl2hp_all) return natural;
  function vectorify(x: heg_ctrl2hp_all; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_ctrl2hp_all; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: heg_ctrl2hp_all) return heg_ctrl2hp_all;
  function convert(x: in std_logic_vector; t: heg_ctrl2hp_all) return heg_ctrl2hp_all;
  function nullify(t: heg_ctrl2hp_all) return heg_ctrl2hp_all;
  function zeroed(t: heg_ctrl2hp_all) return heg_ctrl2hp_all;

  constant CSF_SLOPE_LEN : integer := 11;

  type heg_ctrl2sf_rt is record
    rst : std_logic;
    eof : std_logic;
    enable : std_logic;
  end record heg_ctrl2sf_rt;
  function len(x: heg_ctrl2sf_rt) return natural;
  function width(x: heg_ctrl2sf_rt) return natural;
  function vectorify(x: heg_ctrl2sf_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_ctrl2sf_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt;
  function convert(x: in std_logic_vector; t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt;
  function nullify(t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt;
  function zeroed(t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt;

  subtype heg_ctrl2sf_vt is std_logic_vector(3-1 downto 0);

  subtype heg_hp2bm_vt is std_logic_vector(42-1 downto 0);

  type heg_hp2bm_art is array(integer range <>) of hp_hp2bm_rt;
  function len(x: heg_hp2bm_art) return natural;
  function width(x: heg_hp2bm_art) return natural;
  function vectorify(x: heg_hp2bm_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_hp2bm_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg_hp2bm_art) return heg_hp2bm_art;
  function convert(x: std_logic_vector; t: heg_hp2bm_art) return heg_hp2bm_art;
  function nullify(x: heg_hp2bm_art) return heg_hp2bm_art;
  function zeroed(x: heg_hp2bm_art) return heg_hp2bm_art;

  type heg_hp2bm_avt is array(integer range <>) of heg_hp2bm_vt;
  function len(x: heg_hp2bm_avt) return natural;
  function width(x: heg_hp2bm_avt) return natural;
  function vectorify(x: heg_hp2bm_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_hp2bm_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg_hp2bm_avt) return heg_hp2bm_avt;
  function convert(x: std_logic_vector; t: heg_hp2bm_avt) return heg_hp2bm_avt;
  function nullify(x: heg_hp2bm_avt) return heg_hp2bm_avt;
  function zeroed(x: heg_hp2bm_avt) return heg_hp2bm_avt;

  type heg_bm2sf_rt is record
    data : hp_hp2sf_data_rt;
    data_valid : std_logic;
  end record heg_bm2sf_rt;
  function len(x: heg_bm2sf_rt) return natural;
  function width(x: heg_bm2sf_rt) return natural;
  function vectorify(x: heg_bm2sf_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_bm2sf_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: heg_bm2sf_rt) return heg_bm2sf_rt;
  function convert(x: in std_logic_vector; t: heg_bm2sf_rt) return heg_bm2sf_rt;
  function nullify(t: heg_bm2sf_rt) return heg_bm2sf_rt;
  function zeroed(t: heg_bm2sf_rt) return heg_bm2sf_rt;

  subtype heg_hp2bm_data_vt is std_logic_vector(40-1 downto 0);

  type heg_hp2bm_data_art is array(integer range <>) of hp_hp2sf_data_rt;
  function len(x: heg_hp2bm_data_art) return natural;
  function width(x: heg_hp2bm_data_art) return natural;
  function vectorify(x: heg_hp2bm_data_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_hp2bm_data_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg_hp2bm_data_art) return heg_hp2bm_data_art;
  function convert(x: std_logic_vector; t: heg_hp2bm_data_art) return heg_hp2bm_data_art;
  function nullify(x: heg_hp2bm_data_art) return heg_hp2bm_data_art;
  function zeroed(x: heg_hp2bm_data_art) return heg_hp2bm_data_art;

  type heg_hp2bm_data_avt is array(integer range <>) of heg_hp2bm_data_vt;
  function len(x: heg_hp2bm_data_avt) return natural;
  function width(x: heg_hp2bm_data_avt) return natural;
  function vectorify(x: heg_hp2bm_data_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg_hp2bm_data_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg_hp2bm_data_avt) return heg_hp2bm_data_avt;
  function convert(x: std_logic_vector; t: heg_hp2bm_data_avt) return heg_hp2bm_data_avt;
  function nullify(x: heg_hp2bm_data_avt) return heg_hp2bm_data_avt;
  function zeroed(x: heg_hp2bm_data_avt) return heg_hp2bm_data_avt;

end package heg_pkg;

------------------------------------------------------------

package body heg_pkg is

  function len(x: heg_pc2heg_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg_pc2heg_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg_pc2heg_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_pc2heg_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg_pc2heg_art) return heg_pc2heg_art is
    variable y : heg_pc2heg_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg_pc2heg_art) return heg_pc2heg_art is
    variable y : heg_pc2heg_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg_pc2heg_art) return heg_pc2heg_art is
    variable y : heg_pc2heg_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg_pc2heg_art) return heg_pc2heg_art is
    variable y : heg_pc2heg_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg_pc2heg_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg_pc2heg_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg_pc2heg_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_pc2heg_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg_pc2heg_avt) return heg_pc2heg_avt is
    variable y : heg_pc2heg_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg_pc2heg_avt) return heg_pc2heg_avt is
    variable y : heg_pc2heg_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg_pc2heg_avt) return heg_pc2heg_avt is
    variable y : heg_pc2heg_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg_pc2heg_avt) return heg_pc2heg_avt is
    variable y : heg_pc2heg_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg_roi_center_aut) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg_roi_center_aut) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg_roi_center_aut; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_roi_center_aut; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg_roi_center_aut) return heg_roi_center_aut is
    variable y : heg_roi_center_aut(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg_roi_center_aut) return heg_roi_center_aut is
    variable y : heg_roi_center_aut(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg_roi_center_aut) return heg_roi_center_aut is
    variable y : heg_roi_center_aut(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg_roi_center_aut) return heg_roi_center_aut is
    variable y : heg_roi_center_aut(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg_ctrl2hp_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rst);
    l := l + len(x.enable);
    return l;
  end function len;
  function width(x: heg_ctrl2hp_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rst);
    l := l + width(x.enable);
    return l;
  end function width;
  function vectorify(x: heg_ctrl2hp_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rst)-1), vectorify(x.rst, y(left to left+len(x.rst)-1)));
      left := left + len(x.rst);
      assign(y(left to left+len(x.enable)-1), vectorify(x.enable, y(left to left+len(x.enable)-1)));
    else
      assign(y(left downto left-len(x.rst)+1), vectorify(x.rst, y(left downto left-len(x.rst)+1)));
      left := left - len(x.rst);
      assign(y(left downto left-len(x.enable)+1), vectorify(x.enable, y(left downto left-len(x.enable)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_ctrl2hp_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rst)-1), convert(x.rst, y(left to left+len(x.rst)-1)));
      left := left + len(x.rst);
      assign(y(left to left+len(x.enable)-1), convert(x.enable, y(left to left+len(x.enable)-1)));
    else
      assign(y(left downto left-len(x.rst)+1), convert(x.rst, y(left downto left-len(x.rst)+1)));
      left := left - len(x.rst);
      assign(y(left downto left-len(x.enable)+1), convert(x.enable, y(left downto left-len(x.enable)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt is
    variable y: heg_ctrl2hp_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rst := structify(x(left to left+len(y.rst)-1), y.rst);
      left := left + len(y.rst);
      y.enable := structify(x(left to left+len(y.enable)-1), y.enable);
    else
      y.rst := structify(x(left downto left-len(y.rst)+1), y.rst);
      left := left - len(y.rst);
      y.enable := structify(x(left downto left-len(y.enable)+1), y.enable);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt is
    variable y: heg_ctrl2hp_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rst := convert(x(left to left+len(y.rst)-1), y.rst);
      left := left + len(y.rst);
      y.enable := convert(x(left to left+len(y.enable)-1), y.enable);
    else
      y.rst := convert(x(left downto left-len(y.rst)+1), y.rst);
      left := left - len(y.rst);
      y.enable := convert(x(left downto left-len(y.enable)+1), y.enable);
    end if;
    return y;
  end function convert;
  function nullify(t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt is
  variable y: heg_ctrl2hp_rt;
  begin
    y.rst := nullify(t.rst);
    y.enable := nullify(t.enable);
    return y;
  end function nullify;
  function zeroed(t: heg_ctrl2hp_rt) return heg_ctrl2hp_rt is
  variable y: heg_ctrl2hp_rt;
  begin
    y.rst := zeroed(t.rst);
    y.enable := zeroed(t.enable);
    return y;
  end function zeroed;

  function len(x: heg_ctrl2hp_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg_ctrl2hp_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg_ctrl2hp_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_ctrl2hp_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg_ctrl2hp_art) return heg_ctrl2hp_art is
    variable y : heg_ctrl2hp_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg_ctrl2hp_art) return heg_ctrl2hp_art is
    variable y : heg_ctrl2hp_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg_ctrl2hp_art) return heg_ctrl2hp_art is
    variable y : heg_ctrl2hp_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg_ctrl2hp_art) return heg_ctrl2hp_art is
    variable y : heg_ctrl2hp_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg_ctrl2hp_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg_ctrl2hp_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg_ctrl2hp_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_ctrl2hp_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg_ctrl2hp_avt) return heg_ctrl2hp_avt is
    variable y : heg_ctrl2hp_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg_ctrl2hp_avt) return heg_ctrl2hp_avt is
    variable y : heg_ctrl2hp_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg_ctrl2hp_avt) return heg_ctrl2hp_avt is
    variable y : heg_ctrl2hp_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg_ctrl2hp_avt) return heg_ctrl2hp_avt is
    variable y : heg_ctrl2hp_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg_ctrl2hp_all) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.window_valid);
    return l;
  end function len;
  function width(x: heg_ctrl2hp_all) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.window_valid);
    return l;
  end function width;
  function vectorify(x: heg_ctrl2hp_all; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.window_valid)-1), vectorify(x.window_valid, y(left to left+len(x.window_valid)-1)));
    else
      assign(y(left downto left-len(x.window_valid)+1), vectorify(x.window_valid, y(left downto left-len(x.window_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_ctrl2hp_all; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.window_valid)-1), convert(x.window_valid, y(left to left+len(x.window_valid)-1)));
    else
      assign(y(left downto left-len(x.window_valid)+1), convert(x.window_valid, y(left downto left-len(x.window_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: heg_ctrl2hp_all) return heg_ctrl2hp_all is
    variable y: heg_ctrl2hp_all;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.window_valid := structify(x(left to left+len(y.window_valid)-1), y.window_valid);
    else
      y.window_valid := structify(x(left downto left-len(y.window_valid)+1), y.window_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: heg_ctrl2hp_all) return heg_ctrl2hp_all is
    variable y: heg_ctrl2hp_all;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.window_valid := convert(x(left to left+len(y.window_valid)-1), y.window_valid);
    else
      y.window_valid := convert(x(left downto left-len(y.window_valid)+1), y.window_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: heg_ctrl2hp_all) return heg_ctrl2hp_all is
  variable y: heg_ctrl2hp_all;
  begin
    y.window_valid := nullify(t.window_valid);
    return y;
  end function nullify;
  function zeroed(t: heg_ctrl2hp_all) return heg_ctrl2hp_all is
  variable y: heg_ctrl2hp_all;
  begin
    y.window_valid := zeroed(t.window_valid);
    return y;
  end function zeroed;

  function len(x: heg_ctrl2sf_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rst);
    l := l + len(x.eof);
    l := l + len(x.enable);
    return l;
  end function len;
  function width(x: heg_ctrl2sf_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rst);
    l := l + width(x.eof);
    l := l + width(x.enable);
    return l;
  end function width;
  function vectorify(x: heg_ctrl2sf_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rst)-1), vectorify(x.rst, y(left to left+len(x.rst)-1)));
      left := left + len(x.rst);
      assign(y(left to left+len(x.eof)-1), vectorify(x.eof, y(left to left+len(x.eof)-1)));
      left := left + len(x.eof);
      assign(y(left to left+len(x.enable)-1), vectorify(x.enable, y(left to left+len(x.enable)-1)));
    else
      assign(y(left downto left-len(x.rst)+1), vectorify(x.rst, y(left downto left-len(x.rst)+1)));
      left := left - len(x.rst);
      assign(y(left downto left-len(x.eof)+1), vectorify(x.eof, y(left downto left-len(x.eof)+1)));
      left := left - len(x.eof);
      assign(y(left downto left-len(x.enable)+1), vectorify(x.enable, y(left downto left-len(x.enable)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_ctrl2sf_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rst)-1), convert(x.rst, y(left to left+len(x.rst)-1)));
      left := left + len(x.rst);
      assign(y(left to left+len(x.eof)-1), convert(x.eof, y(left to left+len(x.eof)-1)));
      left := left + len(x.eof);
      assign(y(left to left+len(x.enable)-1), convert(x.enable, y(left to left+len(x.enable)-1)));
    else
      assign(y(left downto left-len(x.rst)+1), convert(x.rst, y(left downto left-len(x.rst)+1)));
      left := left - len(x.rst);
      assign(y(left downto left-len(x.eof)+1), convert(x.eof, y(left downto left-len(x.eof)+1)));
      left := left - len(x.eof);
      assign(y(left downto left-len(x.enable)+1), convert(x.enable, y(left downto left-len(x.enable)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt is
    variable y: heg_ctrl2sf_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rst := structify(x(left to left+len(y.rst)-1), y.rst);
      left := left + len(y.rst);
      y.eof := structify(x(left to left+len(y.eof)-1), y.eof);
      left := left + len(y.eof);
      y.enable := structify(x(left to left+len(y.enable)-1), y.enable);
    else
      y.rst := structify(x(left downto left-len(y.rst)+1), y.rst);
      left := left - len(y.rst);
      y.eof := structify(x(left downto left-len(y.eof)+1), y.eof);
      left := left - len(y.eof);
      y.enable := structify(x(left downto left-len(y.enable)+1), y.enable);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt is
    variable y: heg_ctrl2sf_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rst := convert(x(left to left+len(y.rst)-1), y.rst);
      left := left + len(y.rst);
      y.eof := convert(x(left to left+len(y.eof)-1), y.eof);
      left := left + len(y.eof);
      y.enable := convert(x(left to left+len(y.enable)-1), y.enable);
    else
      y.rst := convert(x(left downto left-len(y.rst)+1), y.rst);
      left := left - len(y.rst);
      y.eof := convert(x(left downto left-len(y.eof)+1), y.eof);
      left := left - len(y.eof);
      y.enable := convert(x(left downto left-len(y.enable)+1), y.enable);
    end if;
    return y;
  end function convert;
  function nullify(t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt is
  variable y: heg_ctrl2sf_rt;
  begin
    y.rst := nullify(t.rst);
    y.eof := nullify(t.eof);
    y.enable := nullify(t.enable);
    return y;
  end function nullify;
  function zeroed(t: heg_ctrl2sf_rt) return heg_ctrl2sf_rt is
  variable y: heg_ctrl2sf_rt;
  begin
    y.rst := zeroed(t.rst);
    y.eof := zeroed(t.eof);
    y.enable := zeroed(t.enable);
    return y;
  end function zeroed;

  function len(x: heg_hp2bm_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg_hp2bm_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg_hp2bm_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_hp2bm_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg_hp2bm_art) return heg_hp2bm_art is
    variable y : heg_hp2bm_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg_hp2bm_art) return heg_hp2bm_art is
    variable y : heg_hp2bm_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg_hp2bm_art) return heg_hp2bm_art is
    variable y : heg_hp2bm_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg_hp2bm_art) return heg_hp2bm_art is
    variable y : heg_hp2bm_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg_hp2bm_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg_hp2bm_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg_hp2bm_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_hp2bm_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg_hp2bm_avt) return heg_hp2bm_avt is
    variable y : heg_hp2bm_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg_hp2bm_avt) return heg_hp2bm_avt is
    variable y : heg_hp2bm_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg_hp2bm_avt) return heg_hp2bm_avt is
    variable y : heg_hp2bm_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg_hp2bm_avt) return heg_hp2bm_avt is
    variable y : heg_hp2bm_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg_bm2sf_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data);
    l := l + len(x.data_valid);
    return l;
  end function len;
  function width(x: heg_bm2sf_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data);
    l := l + width(x.data_valid);
    return l;
  end function width;
  function vectorify(x: heg_bm2sf_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
      left := left + len(x.data);
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
      left := left - len(x.data);
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_bm2sf_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
      left := left + len(x.data);
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
      left := left - len(x.data);
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: heg_bm2sf_rt) return heg_bm2sf_rt is
    variable y: heg_bm2sf_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data := structify(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: heg_bm2sf_rt) return heg_bm2sf_rt is
    variable y: heg_bm2sf_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data := convert(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: heg_bm2sf_rt) return heg_bm2sf_rt is
  variable y: heg_bm2sf_rt;
  begin
    y.data := nullify(t.data);
    y.data_valid := nullify(t.data_valid);
    return y;
  end function nullify;
  function zeroed(t: heg_bm2sf_rt) return heg_bm2sf_rt is
  variable y: heg_bm2sf_rt;
  begin
    y.data := zeroed(t.data);
    y.data_valid := zeroed(t.data_valid);
    return y;
  end function zeroed;

  function len(x: heg_hp2bm_data_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg_hp2bm_data_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg_hp2bm_data_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_hp2bm_data_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg_hp2bm_data_art) return heg_hp2bm_data_art is
    variable y : heg_hp2bm_data_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg_hp2bm_data_art) return heg_hp2bm_data_art is
    variable y : heg_hp2bm_data_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg_hp2bm_data_art) return heg_hp2bm_data_art is
    variable y : heg_hp2bm_data_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg_hp2bm_data_art) return heg_hp2bm_data_art is
    variable y : heg_hp2bm_data_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg_hp2bm_data_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg_hp2bm_data_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg_hp2bm_data_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg_hp2bm_data_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg_hp2bm_data_avt) return heg_hp2bm_data_avt is
    variable y : heg_hp2bm_data_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg_hp2bm_data_avt) return heg_hp2bm_data_avt is
    variable y : heg_hp2bm_data_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg_hp2bm_data_avt) return heg_hp2bm_data_avt is
    variable y : heg_hp2bm_data_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg_hp2bm_data_avt) return heg_hp2bm_data_avt is
    variable y : heg_hp2bm_data_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

end package body heg_pkg;
