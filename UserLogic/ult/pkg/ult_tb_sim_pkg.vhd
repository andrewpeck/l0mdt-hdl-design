-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

library hp_lib;
use hp_lib.hp_pkg.all;

library heg_lib;
use heg_lib.heg_pkg.all;

library hps_lib;
use hps_lib.hps_pkg.all;

package ult_tb_sim_pkg is

   -- Custom types and functions --

   type input_mdt_rt is record
      ToA : unsigned(64-1 downto 0);
      station : unsigned(8-1 downto 0);
      chamber : unsigned(SLC_CHAMBER_LEN-1 downto 0);
      event : unsigned(32-1 downto 0);
      tdc : tdcpolmux2tar_rt;
   end record input_mdt_rt;
   attribute w of input_mdt_rt : type is 150;
   function width(x: input_mdt_rt) return natural;
   function convert(x: input_mdt_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: input_mdt_rt) return input_mdt_rt;
   function zero(tpl: input_mdt_rt) return input_mdt_rt;

   constant TB_TAR_FIFO_WIDTH : integer := 32;
   attribute w of TB_TAR_FIFO_WIDTH : constant is 32;

   type input_mdt_art is array(TB_TAR_FIFO_WIDTH-1 downto 0) of input_mdt_rt;
   attribute w of input_mdt_art : type is 4800;
   function width(x: input_mdt_art) return integer;
   function convert(x: input_mdt_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: input_mdt_art) return input_mdt_art;
   function zero(tpl: input_mdt_art) return input_mdt_art;
   function convert(x: input_mdt_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: input_mdt_art) return input_mdt_art;

   type tar2hps_tb is array(TB_TAR_FIFO_WIDTH-1 downto 0) of tar2hps_rt;
   attribute w of tar2hps_tb : type is 1152;
   function width(x: tar2hps_tb) return integer;
   function convert(x: tar2hps_tb; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: tar2hps_tb) return tar2hps_tb;
   function zero(tpl: tar2hps_tb) return tar2hps_tb;
   function convert(x: tar2hps_tb; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: tar2hps_tb) return tar2hps_tb;

   type pol2tar_tb is array(TB_TAR_FIFO_WIDTH-1 downto 0) of tdcpolmux2tar_rt;
   attribute w of pol2tar_tb : type is 1344;
   function width(x: pol2tar_tb) return integer;
   function convert(x: pol2tar_tb; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: pol2tar_tb) return pol2tar_tb;
   function zero(tpl: pol2tar_tb) return pol2tar_tb;
   function convert(x: pol2tar_tb; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: pol2tar_tb) return pol2tar_tb;

   type input_slc_rt is record
      ToA : unsigned(64-1 downto 0);
      event : unsigned(32-1 downto 0);
      slc : slc_rx_rt;
   end record input_slc_rt;
   attribute w of input_slc_rt : type is 252;
   function width(x: input_slc_rt) return natural;
   function convert(x: input_slc_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: input_slc_rt) return input_slc_rt;
   function zero(tpl: input_slc_rt) return input_slc_rt;

   constant TB_SLC_FIFO_WIDTH : integer := 32;
   attribute w of TB_SLC_FIFO_WIDTH : constant is 32;

   type input_slc_art is array(TB_SLC_FIFO_WIDTH-1 downto 0) of input_slc_rt;
   attribute w of input_slc_art : type is 8064;
   function width(x: input_slc_art) return integer;
   function convert(x: input_slc_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: input_slc_art) return input_slc_art;
   function zero(tpl: input_slc_art) return input_slc_art;
   function convert(x: input_slc_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: input_slc_art) return input_slc_art;

   type slc_tb_art is array(TB_SLC_FIFO_WIDTH-1 downto 0) of slc_rx_rt;
   attribute w of slc_tb_art : type is 4992;
   function width(x: slc_tb_art) return integer;
   function convert(x: slc_tb_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_tb_art) return slc_tb_art;
   function zero(tpl: slc_tb_art) return slc_tb_art;
   function convert(x: slc_tb_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: slc_tb_art) return slc_tb_art;

   type out_heg_bm_hit_sim_rt is record
      ToA : unsigned(64-1 downto 0);
      station : unsigned(4-1 downto 0);
      thread : unsigned(4-1 downto 0);
      data : heg2sfhit_rt;
   end record out_heg_bm_hit_sim_rt;
   attribute w of out_heg_bm_hit_sim_rt : type is 113;
   function width(x: out_heg_bm_hit_sim_rt) return natural;
   function convert(x: out_heg_bm_hit_sim_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt;
   function zero(tpl: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt;

   type out_heg_bm_slc_sim_rt is record
      ToA : unsigned(64-1 downto 0);
      station : unsigned(4-1 downto 0);
      thread : unsigned(4-1 downto 0);
      data : heg2sfslc_rt;
   end record out_heg_bm_slc_sim_rt;
   attribute w of out_heg_bm_slc_sim_rt : type is 149;
   function width(x: out_heg_bm_slc_sim_rt) return natural;
   function convert(x: out_heg_bm_slc_sim_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt;
   function zero(tpl: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt;

   type out_heg_bm_ctrl_sim_rt is record
      ToA : unsigned(64-1 downto 0);
      station : unsigned(4-1 downto 0);
      thread : unsigned(4-1 downto 0);
      heg_ctrl : heg_ctrl2sf_rt;
      data : heg2sfslc_rt;
   end record out_heg_bm_ctrl_sim_rt;
   attribute w of out_heg_bm_ctrl_sim_rt : type is 152;
   function width(x: out_heg_bm_ctrl_sim_rt) return natural;
   function convert(x: out_heg_bm_ctrl_sim_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt;
   function zero(tpl: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt;

   type in_pt_pt2sf_sim_rt is record
      ToA : unsigned(64-1 downto 0);
      station : unsigned(4-1 downto 0);
      thread : unsigned(4-1 downto 0);
      data : sf2ptcalc_rt;
   end record in_pt_pt2sf_sim_rt;
   attribute w of in_pt_pt2sf_sim_rt : type is 136;
   function width(x: in_pt_pt2sf_sim_rt) return natural;
   function convert(x: in_pt_pt2sf_sim_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt;
   function zero(tpl: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt;

   type in_pt_mpl_sim_rt is record
      ToA : unsigned(64-1 downto 0);
      thread : unsigned(4-1 downto 0);
      data : pl2ptcalc_rt;
   end record in_pt_mpl_sim_rt;
   attribute w of in_pt_mpl_sim_rt : type is 125;
   function width(x: in_pt_mpl_sim_rt) return natural;
   function convert(x: in_pt_mpl_sim_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt;
   function zero(tpl: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt;

   type in_mtc_pt_sim_rt is record
      ToA : unsigned(64-1 downto 0);
      thread : unsigned(4-1 downto 0);
      data : ptcalc2mtc_rt;
   end record in_mtc_pt_sim_rt;
   attribute w of in_mtc_pt_sim_rt : type is 122;
   function width(x: in_mtc_pt_sim_rt) return natural;
   function convert(x: in_mtc_pt_sim_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt;
   function zero(tpl: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt;

   type in_mtc_mpl_sim_rt is record
      ToA : unsigned(64-1 downto 0);
      thread : unsigned(4-1 downto 0);
      data : pl2mtc_rt;
   end record in_mtc_mpl_sim_rt;
   attribute w of in_mtc_mpl_sim_rt : type is 181;
   function width(x: in_mtc_mpl_sim_rt) return natural;
   function convert(x: in_mtc_mpl_sim_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt;
   function zero(tpl: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt;

end package ult_tb_sim_pkg;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

library hp_lib;
use hp_lib.hp_pkg.all;

library heg_lib;
use heg_lib.heg_pkg.all;

library hps_lib;
use hps_lib.hps_pkg.all;

package body ult_tb_sim_pkg is

   -- Custom types and functions --

   function width(x: input_mdt_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ToA);
      w := w + width(x.station);
      w := w + width(x.chamber);
      w := w + width(x.event);
      w := w + width(x.tdc);
      return w;
   end function width;
   function convert(x: input_mdt_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ToA);
         y(u to u+w-1) := convert(x.ToA, y(u to u+w-1));
         u := u + w;
         w := width(x.station);
         y(u to u+w-1) := convert(x.station, y(u to u+w-1));
         u := u + w;
         w := width(x.chamber);
         y(u to u+w-1) := convert(x.chamber, y(u to u+w-1));
         u := u + w;
         w := width(x.event);
         y(u to u+w-1) := convert(x.event, y(u to u+w-1));
         u := u + w;
         w := width(x.tdc);
         y(u to u+w-1) := convert(x.tdc, y(u to u+w-1));
      else
         w := width(x.ToA);
         y(u downto u-w+1) := convert(x.ToA, y(u downto u-w+1));
         u := u - w;
         w := width(x.station);
         y(u downto u-w+1) := convert(x.station, y(u downto u-w+1));
         u := u - w;
         w := width(x.chamber);
         y(u downto u-w+1) := convert(x.chamber, y(u downto u-w+1));
         u := u - w;
         w := width(x.event);
         y(u downto u-w+1) := convert(x.event, y(u downto u-w+1));
         u := u - w;
         w := width(x.tdc);
         y(u downto u-w+1) := convert(x.tdc, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: input_mdt_rt) return input_mdt_rt is
      variable y : input_mdt_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ToA);
         y.ToA := convert(x(u to u+w-1), tpl.ToA);
         u := u + w;
         w := width(tpl.station);
         y.station := convert(x(u to u+w-1), tpl.station);
         u := u + w;
         w := width(tpl.chamber);
         y.chamber := convert(x(u to u+w-1), tpl.chamber);
         u := u + w;
         w := width(tpl.event);
         y.event := convert(x(u to u+w-1), tpl.event);
         u := u + w;
         w := width(tpl.tdc);
         y.tdc := convert(x(u to u+w-1), tpl.tdc);
      else
         w := width(tpl.ToA);
         y.ToA := convert(x(u downto u-w+1), tpl.ToA);
         u := u - w;
         w := width(tpl.station);
         y.station := convert(x(u downto u-w+1), tpl.station);
         u := u - w;
         w := width(tpl.chamber);
         y.chamber := convert(x(u downto u-w+1), tpl.chamber);
         u := u - w;
         w := width(tpl.event);
         y.event := convert(x(u downto u-w+1), tpl.event);
         u := u - w;
         w := width(tpl.tdc);
         y.tdc := convert(x(u downto u-w+1), tpl.tdc);
      end if;
      return y;
   end function convert;
   function zero(tpl: input_mdt_rt) return input_mdt_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: input_mdt_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: input_mdt_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: input_mdt_art) return input_mdt_art is
      variable y : input_mdt_art;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: input_mdt_art) return input_mdt_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: input_mdt_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: input_mdt_art) return input_mdt_art is
      variable y : input_mdt_art;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: tar2hps_tb) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: tar2hps_tb; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: tar2hps_tb) return tar2hps_tb is
      variable y : tar2hps_tb;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: tar2hps_tb) return tar2hps_tb is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: tar2hps_tb; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: tar2hps_tb) return tar2hps_tb is
      variable y : tar2hps_tb;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: pol2tar_tb) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: pol2tar_tb; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: pol2tar_tb) return pol2tar_tb is
      variable y : pol2tar_tb;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: pol2tar_tb) return pol2tar_tb is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: pol2tar_tb; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: pol2tar_tb) return pol2tar_tb is
      variable y : pol2tar_tb;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: input_slc_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ToA);
      w := w + width(x.event);
      w := w + width(x.slc);
      return w;
   end function width;
   function convert(x: input_slc_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ToA);
         y(u to u+w-1) := convert(x.ToA, y(u to u+w-1));
         u := u + w;
         w := width(x.event);
         y(u to u+w-1) := convert(x.event, y(u to u+w-1));
         u := u + w;
         w := width(x.slc);
         y(u to u+w-1) := convert(x.slc, y(u to u+w-1));
      else
         w := width(x.ToA);
         y(u downto u-w+1) := convert(x.ToA, y(u downto u-w+1));
         u := u - w;
         w := width(x.event);
         y(u downto u-w+1) := convert(x.event, y(u downto u-w+1));
         u := u - w;
         w := width(x.slc);
         y(u downto u-w+1) := convert(x.slc, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: input_slc_rt) return input_slc_rt is
      variable y : input_slc_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ToA);
         y.ToA := convert(x(u to u+w-1), tpl.ToA);
         u := u + w;
         w := width(tpl.event);
         y.event := convert(x(u to u+w-1), tpl.event);
         u := u + w;
         w := width(tpl.slc);
         y.slc := convert(x(u to u+w-1), tpl.slc);
      else
         w := width(tpl.ToA);
         y.ToA := convert(x(u downto u-w+1), tpl.ToA);
         u := u - w;
         w := width(tpl.event);
         y.event := convert(x(u downto u-w+1), tpl.event);
         u := u - w;
         w := width(tpl.slc);
         y.slc := convert(x(u downto u-w+1), tpl.slc);
      end if;
      return y;
   end function convert;
   function zero(tpl: input_slc_rt) return input_slc_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: input_slc_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: input_slc_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: input_slc_art) return input_slc_art is
      variable y : input_slc_art;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: input_slc_art) return input_slc_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: input_slc_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: input_slc_art) return input_slc_art is
      variable y : input_slc_art;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: slc_tb_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: slc_tb_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_tb_art) return slc_tb_art is
      variable y : slc_tb_art;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_tb_art) return slc_tb_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: slc_tb_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: slc_tb_art) return slc_tb_art is
      variable y : slc_tb_art;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: out_heg_bm_hit_sim_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ToA);
      w := w + width(x.station);
      w := w + width(x.thread);
      w := w + width(x.data);
      return w;
   end function width;
   function convert(x: out_heg_bm_hit_sim_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ToA);
         y(u to u+w-1) := convert(x.ToA, y(u to u+w-1));
         u := u + w;
         w := width(x.station);
         y(u to u+w-1) := convert(x.station, y(u to u+w-1));
         u := u + w;
         w := width(x.thread);
         y(u to u+w-1) := convert(x.thread, y(u to u+w-1));
         u := u + w;
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
      else
         w := width(x.ToA);
         y(u downto u-w+1) := convert(x.ToA, y(u downto u-w+1));
         u := u - w;
         w := width(x.station);
         y(u downto u-w+1) := convert(x.station, y(u downto u-w+1));
         u := u - w;
         w := width(x.thread);
         y(u downto u-w+1) := convert(x.thread, y(u downto u-w+1));
         u := u - w;
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt is
      variable y : out_heg_bm_hit_sim_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ToA);
         y.ToA := convert(x(u to u+w-1), tpl.ToA);
         u := u + w;
         w := width(tpl.station);
         y.station := convert(x(u to u+w-1), tpl.station);
         u := u + w;
         w := width(tpl.thread);
         y.thread := convert(x(u to u+w-1), tpl.thread);
         u := u + w;
         w := width(tpl.data);
         y.data := convert(x(u to u+w-1), tpl.data);
      else
         w := width(tpl.ToA);
         y.ToA := convert(x(u downto u-w+1), tpl.ToA);
         u := u - w;
         w := width(tpl.station);
         y.station := convert(x(u downto u-w+1), tpl.station);
         u := u - w;
         w := width(tpl.thread);
         y.thread := convert(x(u downto u-w+1), tpl.thread);
         u := u - w;
         w := width(tpl.data);
         y.data := convert(x(u downto u-w+1), tpl.data);
      end if;
      return y;
   end function convert;
   function zero(tpl: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: out_heg_bm_slc_sim_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ToA);
      w := w + width(x.station);
      w := w + width(x.thread);
      w := w + width(x.data);
      return w;
   end function width;
   function convert(x: out_heg_bm_slc_sim_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ToA);
         y(u to u+w-1) := convert(x.ToA, y(u to u+w-1));
         u := u + w;
         w := width(x.station);
         y(u to u+w-1) := convert(x.station, y(u to u+w-1));
         u := u + w;
         w := width(x.thread);
         y(u to u+w-1) := convert(x.thread, y(u to u+w-1));
         u := u + w;
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
      else
         w := width(x.ToA);
         y(u downto u-w+1) := convert(x.ToA, y(u downto u-w+1));
         u := u - w;
         w := width(x.station);
         y(u downto u-w+1) := convert(x.station, y(u downto u-w+1));
         u := u - w;
         w := width(x.thread);
         y(u downto u-w+1) := convert(x.thread, y(u downto u-w+1));
         u := u - w;
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt is
      variable y : out_heg_bm_slc_sim_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ToA);
         y.ToA := convert(x(u to u+w-1), tpl.ToA);
         u := u + w;
         w := width(tpl.station);
         y.station := convert(x(u to u+w-1), tpl.station);
         u := u + w;
         w := width(tpl.thread);
         y.thread := convert(x(u to u+w-1), tpl.thread);
         u := u + w;
         w := width(tpl.data);
         y.data := convert(x(u to u+w-1), tpl.data);
      else
         w := width(tpl.ToA);
         y.ToA := convert(x(u downto u-w+1), tpl.ToA);
         u := u - w;
         w := width(tpl.station);
         y.station := convert(x(u downto u-w+1), tpl.station);
         u := u - w;
         w := width(tpl.thread);
         y.thread := convert(x(u downto u-w+1), tpl.thread);
         u := u - w;
         w := width(tpl.data);
         y.data := convert(x(u downto u-w+1), tpl.data);
      end if;
      return y;
   end function convert;
   function zero(tpl: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: out_heg_bm_ctrl_sim_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ToA);
      w := w + width(x.station);
      w := w + width(x.thread);
      w := w + width(x.heg_ctrl);
      w := w + width(x.data);
      return w;
   end function width;
   function convert(x: out_heg_bm_ctrl_sim_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ToA);
         y(u to u+w-1) := convert(x.ToA, y(u to u+w-1));
         u := u + w;
         w := width(x.station);
         y(u to u+w-1) := convert(x.station, y(u to u+w-1));
         u := u + w;
         w := width(x.thread);
         y(u to u+w-1) := convert(x.thread, y(u to u+w-1));
         u := u + w;
         w := width(x.heg_ctrl);
         y(u to u+w-1) := convert(x.heg_ctrl, y(u to u+w-1));
         u := u + w;
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
      else
         w := width(x.ToA);
         y(u downto u-w+1) := convert(x.ToA, y(u downto u-w+1));
         u := u - w;
         w := width(x.station);
         y(u downto u-w+1) := convert(x.station, y(u downto u-w+1));
         u := u - w;
         w := width(x.thread);
         y(u downto u-w+1) := convert(x.thread, y(u downto u-w+1));
         u := u - w;
         w := width(x.heg_ctrl);
         y(u downto u-w+1) := convert(x.heg_ctrl, y(u downto u-w+1));
         u := u - w;
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt is
      variable y : out_heg_bm_ctrl_sim_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ToA);
         y.ToA := convert(x(u to u+w-1), tpl.ToA);
         u := u + w;
         w := width(tpl.station);
         y.station := convert(x(u to u+w-1), tpl.station);
         u := u + w;
         w := width(tpl.thread);
         y.thread := convert(x(u to u+w-1), tpl.thread);
         u := u + w;
         w := width(tpl.heg_ctrl);
         y.heg_ctrl := convert(x(u to u+w-1), tpl.heg_ctrl);
         u := u + w;
         w := width(tpl.data);
         y.data := convert(x(u to u+w-1), tpl.data);
      else
         w := width(tpl.ToA);
         y.ToA := convert(x(u downto u-w+1), tpl.ToA);
         u := u - w;
         w := width(tpl.station);
         y.station := convert(x(u downto u-w+1), tpl.station);
         u := u - w;
         w := width(tpl.thread);
         y.thread := convert(x(u downto u-w+1), tpl.thread);
         u := u - w;
         w := width(tpl.heg_ctrl);
         y.heg_ctrl := convert(x(u downto u-w+1), tpl.heg_ctrl);
         u := u - w;
         w := width(tpl.data);
         y.data := convert(x(u downto u-w+1), tpl.data);
      end if;
      return y;
   end function convert;
   function zero(tpl: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: in_pt_pt2sf_sim_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ToA);
      w := w + width(x.station);
      w := w + width(x.thread);
      w := w + width(x.data);
      return w;
   end function width;
   function convert(x: in_pt_pt2sf_sim_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ToA);
         y(u to u+w-1) := convert(x.ToA, y(u to u+w-1));
         u := u + w;
         w := width(x.station);
         y(u to u+w-1) := convert(x.station, y(u to u+w-1));
         u := u + w;
         w := width(x.thread);
         y(u to u+w-1) := convert(x.thread, y(u to u+w-1));
         u := u + w;
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
      else
         w := width(x.ToA);
         y(u downto u-w+1) := convert(x.ToA, y(u downto u-w+1));
         u := u - w;
         w := width(x.station);
         y(u downto u-w+1) := convert(x.station, y(u downto u-w+1));
         u := u - w;
         w := width(x.thread);
         y(u downto u-w+1) := convert(x.thread, y(u downto u-w+1));
         u := u - w;
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt is
      variable y : in_pt_pt2sf_sim_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ToA);
         y.ToA := convert(x(u to u+w-1), tpl.ToA);
         u := u + w;
         w := width(tpl.station);
         y.station := convert(x(u to u+w-1), tpl.station);
         u := u + w;
         w := width(tpl.thread);
         y.thread := convert(x(u to u+w-1), tpl.thread);
         u := u + w;
         w := width(tpl.data);
         y.data := convert(x(u to u+w-1), tpl.data);
      else
         w := width(tpl.ToA);
         y.ToA := convert(x(u downto u-w+1), tpl.ToA);
         u := u - w;
         w := width(tpl.station);
         y.station := convert(x(u downto u-w+1), tpl.station);
         u := u - w;
         w := width(tpl.thread);
         y.thread := convert(x(u downto u-w+1), tpl.thread);
         u := u - w;
         w := width(tpl.data);
         y.data := convert(x(u downto u-w+1), tpl.data);
      end if;
      return y;
   end function convert;
   function zero(tpl: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: in_pt_mpl_sim_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ToA);
      w := w + width(x.thread);
      w := w + width(x.data);
      return w;
   end function width;
   function convert(x: in_pt_mpl_sim_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ToA);
         y(u to u+w-1) := convert(x.ToA, y(u to u+w-1));
         u := u + w;
         w := width(x.thread);
         y(u to u+w-1) := convert(x.thread, y(u to u+w-1));
         u := u + w;
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
      else
         w := width(x.ToA);
         y(u downto u-w+1) := convert(x.ToA, y(u downto u-w+1));
         u := u - w;
         w := width(x.thread);
         y(u downto u-w+1) := convert(x.thread, y(u downto u-w+1));
         u := u - w;
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt is
      variable y : in_pt_mpl_sim_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ToA);
         y.ToA := convert(x(u to u+w-1), tpl.ToA);
         u := u + w;
         w := width(tpl.thread);
         y.thread := convert(x(u to u+w-1), tpl.thread);
         u := u + w;
         w := width(tpl.data);
         y.data := convert(x(u to u+w-1), tpl.data);
      else
         w := width(tpl.ToA);
         y.ToA := convert(x(u downto u-w+1), tpl.ToA);
         u := u - w;
         w := width(tpl.thread);
         y.thread := convert(x(u downto u-w+1), tpl.thread);
         u := u - w;
         w := width(tpl.data);
         y.data := convert(x(u downto u-w+1), tpl.data);
      end if;
      return y;
   end function convert;
   function zero(tpl: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: in_mtc_pt_sim_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ToA);
      w := w + width(x.thread);
      w := w + width(x.data);
      return w;
   end function width;
   function convert(x: in_mtc_pt_sim_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ToA);
         y(u to u+w-1) := convert(x.ToA, y(u to u+w-1));
         u := u + w;
         w := width(x.thread);
         y(u to u+w-1) := convert(x.thread, y(u to u+w-1));
         u := u + w;
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
      else
         w := width(x.ToA);
         y(u downto u-w+1) := convert(x.ToA, y(u downto u-w+1));
         u := u - w;
         w := width(x.thread);
         y(u downto u-w+1) := convert(x.thread, y(u downto u-w+1));
         u := u - w;
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt is
      variable y : in_mtc_pt_sim_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ToA);
         y.ToA := convert(x(u to u+w-1), tpl.ToA);
         u := u + w;
         w := width(tpl.thread);
         y.thread := convert(x(u to u+w-1), tpl.thread);
         u := u + w;
         w := width(tpl.data);
         y.data := convert(x(u to u+w-1), tpl.data);
      else
         w := width(tpl.ToA);
         y.ToA := convert(x(u downto u-w+1), tpl.ToA);
         u := u - w;
         w := width(tpl.thread);
         y.thread := convert(x(u downto u-w+1), tpl.thread);
         u := u - w;
         w := width(tpl.data);
         y.data := convert(x(u downto u-w+1), tpl.data);
      end if;
      return y;
   end function convert;
   function zero(tpl: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: in_mtc_mpl_sim_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ToA);
      w := w + width(x.thread);
      w := w + width(x.data);
      return w;
   end function width;
   function convert(x: in_mtc_mpl_sim_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ToA);
         y(u to u+w-1) := convert(x.ToA, y(u to u+w-1));
         u := u + w;
         w := width(x.thread);
         y(u to u+w-1) := convert(x.thread, y(u to u+w-1));
         u := u + w;
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
      else
         w := width(x.ToA);
         y(u downto u-w+1) := convert(x.ToA, y(u downto u-w+1));
         u := u - w;
         w := width(x.thread);
         y(u downto u-w+1) := convert(x.thread, y(u downto u-w+1));
         u := u - w;
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt is
      variable y : in_mtc_mpl_sim_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ToA);
         y.ToA := convert(x(u to u+w-1), tpl.ToA);
         u := u + w;
         w := width(tpl.thread);
         y.thread := convert(x(u to u+w-1), tpl.thread);
         u := u + w;
         w := width(tpl.data);
         y.data := convert(x(u to u+w-1), tpl.data);
      else
         w := width(tpl.ToA);
         y.ToA := convert(x(u downto u-w+1), tpl.ToA);
         u := u - w;
         w := width(tpl.thread);
         y.thread := convert(x(u downto u-w+1), tpl.thread);
         u := u - w;
         w := width(tpl.data);
         y.data := convert(x(u downto u-w+1), tpl.data);
      end if;
      return y;
   end function convert;
   function zero(tpl: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

end package body ult_tb_sim_pkg;
