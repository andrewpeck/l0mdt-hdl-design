-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;

library heg_lib;
use heg_lib.heg_pkg.all;

package ult_tb_sim_pkg is

  type input_mdt_rt is record
    ToA : unsigned(64-1 downto 0);
    station : unsigned(8-1 downto 0);
    chamber : unsigned(SLC_CHAMBER_LEN-1 downto 0);
    event : unsigned(32-1 downto 0);
    tdc : tdcpolmux2tar_rt;
  end record input_mdt_rt;
  function len(x: input_mdt_rt) return natural;
  function width(x: input_mdt_rt) return natural;
  function vectorify(x: input_mdt_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: input_mdt_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: input_mdt_rt) return input_mdt_rt;
  function convert(x: in std_logic_vector; t: input_mdt_rt) return input_mdt_rt;
  function nullify(t: input_mdt_rt) return input_mdt_rt;
  function zeroed(t: input_mdt_rt) return input_mdt_rt;

  constant TB_TAR_FIFO_WIDTH : integer := 32;

  type input_mdt_art is array(TB_TAR_FIFO_WIDTH-1 downto 0) of input_mdt_rt;
  function len(x: input_mdt_art) return natural;
  function width(x: input_mdt_art) return natural;
  function vectorify(x: input_mdt_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: input_mdt_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: input_mdt_art) return input_mdt_art;
  function convert(x: std_logic_vector; t: input_mdt_art) return input_mdt_art;
  function nullify(x: input_mdt_art) return input_mdt_art;
  function zeroed(x: input_mdt_art) return input_mdt_art;

  type tar2hps_tb is array(TB_TAR_FIFO_WIDTH-1 downto 0) of tar2hps_rt;
  function len(x: tar2hps_tb) return natural;
  function width(x: tar2hps_tb) return natural;
  function vectorify(x: tar2hps_tb; t: std_logic_vector) return std_logic_vector;
  function convert(x: tar2hps_tb; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: tar2hps_tb) return tar2hps_tb;
  function convert(x: std_logic_vector; t: tar2hps_tb) return tar2hps_tb;
  function nullify(x: tar2hps_tb) return tar2hps_tb;
  function zeroed(x: tar2hps_tb) return tar2hps_tb;

  type pol2tar_tb is array(TB_TAR_FIFO_WIDTH-1 downto 0) of tdcpolmux2tar_rt;
  function len(x: pol2tar_tb) return natural;
  function width(x: pol2tar_tb) return natural;
  function vectorify(x: pol2tar_tb; t: std_logic_vector) return std_logic_vector;
  function convert(x: pol2tar_tb; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: pol2tar_tb) return pol2tar_tb;
  function convert(x: std_logic_vector; t: pol2tar_tb) return pol2tar_tb;
  function nullify(x: pol2tar_tb) return pol2tar_tb;
  function zeroed(x: pol2tar_tb) return pol2tar_tb;

  type input_slc_rt is record
    ToA : unsigned(64-1 downto 0);
    event : unsigned(32-1 downto 0);
    slc : slc_rx_rt;
  end record input_slc_rt;
  function len(x: input_slc_rt) return natural;
  function width(x: input_slc_rt) return natural;
  function vectorify(x: input_slc_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: input_slc_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: input_slc_rt) return input_slc_rt;
  function convert(x: in std_logic_vector; t: input_slc_rt) return input_slc_rt;
  function nullify(t: input_slc_rt) return input_slc_rt;
  function zeroed(t: input_slc_rt) return input_slc_rt;

  constant TB_SLC_FIFO_WIDTH : integer := 32;

  type input_slc_art is array(TB_SLC_FIFO_WIDTH-1 downto 0) of input_slc_rt;
  function len(x: input_slc_art) return natural;
  function width(x: input_slc_art) return natural;
  function vectorify(x: input_slc_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: input_slc_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: input_slc_art) return input_slc_art;
  function convert(x: std_logic_vector; t: input_slc_art) return input_slc_art;
  function nullify(x: input_slc_art) return input_slc_art;
  function zeroed(x: input_slc_art) return input_slc_art;

  type slc_tb_art is array(TB_SLC_FIFO_WIDTH-1 downto 0) of slc_rx_rt;
  function len(x: slc_tb_art) return natural;
  function width(x: slc_tb_art) return natural;
  function vectorify(x: slc_tb_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_tb_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: slc_tb_art) return slc_tb_art;
  function convert(x: std_logic_vector; t: slc_tb_art) return slc_tb_art;
  function nullify(x: slc_tb_art) return slc_tb_art;
  function zeroed(x: slc_tb_art) return slc_tb_art;

  type out_heg_bm_hit_sim_rt is record
    ToA : unsigned(64-1 downto 0);
    station : unsigned(4-1 downto 0);
    thread : unsigned(4-1 downto 0);
    data : heg2sfhit_rt;
  end record out_heg_bm_hit_sim_rt;
  function len(x: out_heg_bm_hit_sim_rt) return natural;
  function width(x: out_heg_bm_hit_sim_rt) return natural;
  function vectorify(x: out_heg_bm_hit_sim_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: out_heg_bm_hit_sim_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt;
  function convert(x: in std_logic_vector; t: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt;
  function nullify(t: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt;
  function zeroed(t: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt;

  type out_heg_bm_slc_sim_rt is record
    ToA : unsigned(64-1 downto 0);
    station : unsigned(4-1 downto 0);
    thread : unsigned(4-1 downto 0);
    data : heg2sfslc_rt;
  end record out_heg_bm_slc_sim_rt;
  function len(x: out_heg_bm_slc_sim_rt) return natural;
  function width(x: out_heg_bm_slc_sim_rt) return natural;
  function vectorify(x: out_heg_bm_slc_sim_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: out_heg_bm_slc_sim_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt;
  function convert(x: in std_logic_vector; t: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt;
  function nullify(t: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt;
  function zeroed(t: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt;

  type out_heg_bm_ctrl_sim_rt is record
    ToA : unsigned(64-1 downto 0);
    station : unsigned(4-1 downto 0);
    thread : unsigned(4-1 downto 0);
    heg_ctrl : heg_ctrl2sf_rt;
    data : heg2sfslc_rt;
  end record out_heg_bm_ctrl_sim_rt;
  function len(x: out_heg_bm_ctrl_sim_rt) return natural;
  function width(x: out_heg_bm_ctrl_sim_rt) return natural;
  function vectorify(x: out_heg_bm_ctrl_sim_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: out_heg_bm_ctrl_sim_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt;
  function convert(x: in std_logic_vector; t: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt;
  function nullify(t: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt;
  function zeroed(t: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt;

  type in_pt_pt2sf_sim_rt is record
    ToA : unsigned(64-1 downto 0);
    station : unsigned(4-1 downto 0);
    thread : unsigned(4-1 downto 0);
    data : sf2ptcalc_rt;
  end record in_pt_pt2sf_sim_rt;
  function len(x: in_pt_pt2sf_sim_rt) return natural;
  function width(x: in_pt_pt2sf_sim_rt) return natural;
  function vectorify(x: in_pt_pt2sf_sim_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: in_pt_pt2sf_sim_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt;
  function convert(x: in std_logic_vector; t: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt;
  function nullify(t: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt;
  function zeroed(t: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt;

  type in_pt_mpl_sim_rt is record
    ToA : unsigned(64-1 downto 0);
    thread : unsigned(4-1 downto 0);
    data : pl2ptcalc_rt;
  end record in_pt_mpl_sim_rt;
  function len(x: in_pt_mpl_sim_rt) return natural;
  function width(x: in_pt_mpl_sim_rt) return natural;
  function vectorify(x: in_pt_mpl_sim_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: in_pt_mpl_sim_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt;
  function convert(x: in std_logic_vector; t: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt;
  function nullify(t: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt;
  function zeroed(t: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt;

  type in_mtc_pt_sim_rt is record
    ToA : unsigned(64-1 downto 0);
    thread : unsigned(4-1 downto 0);
    data : ptcalc2mtc_rt;
  end record in_mtc_pt_sim_rt;
  function len(x: in_mtc_pt_sim_rt) return natural;
  function width(x: in_mtc_pt_sim_rt) return natural;
  function vectorify(x: in_mtc_pt_sim_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: in_mtc_pt_sim_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt;
  function convert(x: in std_logic_vector; t: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt;
  function nullify(t: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt;
  function zeroed(t: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt;

  type in_mtc_mpl_sim_rt is record
    ToA : unsigned(64-1 downto 0);
    thread : unsigned(4-1 downto 0);
    data : pl2mtc_rt;
  end record in_mtc_mpl_sim_rt;
  function len(x: in_mtc_mpl_sim_rt) return natural;
  function width(x: in_mtc_mpl_sim_rt) return natural;
  function vectorify(x: in_mtc_mpl_sim_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: in_mtc_mpl_sim_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt;
  function convert(x: in std_logic_vector; t: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt;
  function nullify(t: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt;
  function zeroed(t: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt;

end package ult_tb_sim_pkg;

------------------------------------------------------------

package body ult_tb_sim_pkg is

  function len(x: input_mdt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ToA);
    l := l + len(x.station);
    l := l + len(x.chamber);
    l := l + len(x.event);
    l := l + len(x.tdc);
    return l;
  end function len;
  function width(x: input_mdt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ToA);
    l := l + width(x.station);
    l := l + width(x.chamber);
    l := l + width(x.event);
    l := l + width(x.tdc);
    return l;
  end function width;
  function vectorify(x: input_mdt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), vectorify(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), vectorify(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.chamber)-1), vectorify(x.chamber, y(left to left+len(x.chamber)-1)));
      left := left + len(x.chamber);
      assign(y(left to left+len(x.event)-1), vectorify(x.event, y(left to left+len(x.event)-1)));
      left := left + len(x.event);
      assign(y(left to left+len(x.tdc)-1), vectorify(x.tdc, y(left to left+len(x.tdc)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), vectorify(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), vectorify(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.chamber)+1), vectorify(x.chamber, y(left downto left-len(x.chamber)+1)));
      left := left - len(x.chamber);
      assign(y(left downto left-len(x.event)+1), vectorify(x.event, y(left downto left-len(x.event)+1)));
      left := left - len(x.event);
      assign(y(left downto left-len(x.tdc)+1), vectorify(x.tdc, y(left downto left-len(x.tdc)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: input_mdt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), convert(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), convert(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.chamber)-1), convert(x.chamber, y(left to left+len(x.chamber)-1)));
      left := left + len(x.chamber);
      assign(y(left to left+len(x.event)-1), convert(x.event, y(left to left+len(x.event)-1)));
      left := left + len(x.event);
      assign(y(left to left+len(x.tdc)-1), convert(x.tdc, y(left to left+len(x.tdc)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), convert(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), convert(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.chamber)+1), convert(x.chamber, y(left downto left-len(x.chamber)+1)));
      left := left - len(x.chamber);
      assign(y(left downto left-len(x.event)+1), convert(x.event, y(left downto left-len(x.event)+1)));
      left := left - len(x.event);
      assign(y(left downto left-len(x.tdc)+1), convert(x.tdc, y(left downto left-len(x.tdc)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: input_mdt_rt) return input_mdt_rt is
    variable y: input_mdt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := structify(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := structify(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.chamber := structify(x(left to left+len(y.chamber)-1), y.chamber);
      left := left + len(y.chamber);
      y.event := structify(x(left to left+len(y.event)-1), y.event);
      left := left + len(y.event);
      y.tdc := structify(x(left to left+len(y.tdc)-1), y.tdc);
    else
      y.ToA := structify(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := structify(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.chamber := structify(x(left downto left-len(y.chamber)+1), y.chamber);
      left := left - len(y.chamber);
      y.event := structify(x(left downto left-len(y.event)+1), y.event);
      left := left - len(y.event);
      y.tdc := structify(x(left downto left-len(y.tdc)+1), y.tdc);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: input_mdt_rt) return input_mdt_rt is
    variable y: input_mdt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := convert(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := convert(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.chamber := convert(x(left to left+len(y.chamber)-1), y.chamber);
      left := left + len(y.chamber);
      y.event := convert(x(left to left+len(y.event)-1), y.event);
      left := left + len(y.event);
      y.tdc := convert(x(left to left+len(y.tdc)-1), y.tdc);
    else
      y.ToA := convert(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := convert(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.chamber := convert(x(left downto left-len(y.chamber)+1), y.chamber);
      left := left - len(y.chamber);
      y.event := convert(x(left downto left-len(y.event)+1), y.event);
      left := left - len(y.event);
      y.tdc := convert(x(left downto left-len(y.tdc)+1), y.tdc);
    end if;
    return y;
  end function convert;
  function nullify(t: input_mdt_rt) return input_mdt_rt is
  variable y: input_mdt_rt;
  begin
    y.ToA := nullify(t.ToA);
    y.station := nullify(t.station);
    y.chamber := nullify(t.chamber);
    y.event := nullify(t.event);
    y.tdc := nullify(t.tdc);
    return y;
  end function nullify;
  function zeroed(t: input_mdt_rt) return input_mdt_rt is
  variable y: input_mdt_rt;
  begin
    y.ToA := zeroed(t.ToA);
    y.station := zeroed(t.station);
    y.chamber := zeroed(t.chamber);
    y.event := zeroed(t.event);
    y.tdc := zeroed(t.tdc);
    return y;
  end function zeroed;

  function len(x: input_mdt_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: input_mdt_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: input_mdt_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: input_mdt_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: input_mdt_art) return input_mdt_art is
    variable y : input_mdt_art;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: input_mdt_art) return input_mdt_art is
    variable y : input_mdt_art;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: input_mdt_art) return input_mdt_art is
    variable y : input_mdt_art;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: input_mdt_art) return input_mdt_art is
    variable y : input_mdt_art;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: tar2hps_tb) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: tar2hps_tb) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: tar2hps_tb; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: tar2hps_tb; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: tar2hps_tb) return tar2hps_tb is
    variable y : tar2hps_tb;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: tar2hps_tb) return tar2hps_tb is
    variable y : tar2hps_tb;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: tar2hps_tb) return tar2hps_tb is
    variable y : tar2hps_tb;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: tar2hps_tb) return tar2hps_tb is
    variable y : tar2hps_tb;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: pol2tar_tb) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: pol2tar_tb) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: pol2tar_tb; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: pol2tar_tb; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: pol2tar_tb) return pol2tar_tb is
    variable y : pol2tar_tb;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: pol2tar_tb) return pol2tar_tb is
    variable y : pol2tar_tb;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: pol2tar_tb) return pol2tar_tb is
    variable y : pol2tar_tb;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: pol2tar_tb) return pol2tar_tb is
    variable y : pol2tar_tb;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: input_slc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ToA);
    l := l + len(x.event);
    l := l + len(x.slc);
    return l;
  end function len;
  function width(x: input_slc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ToA);
    l := l + width(x.event);
    l := l + width(x.slc);
    return l;
  end function width;
  function vectorify(x: input_slc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), vectorify(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.event)-1), vectorify(x.event, y(left to left+len(x.event)-1)));
      left := left + len(x.event);
      assign(y(left to left+len(x.slc)-1), vectorify(x.slc, y(left to left+len(x.slc)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), vectorify(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.event)+1), vectorify(x.event, y(left downto left-len(x.event)+1)));
      left := left - len(x.event);
      assign(y(left downto left-len(x.slc)+1), vectorify(x.slc, y(left downto left-len(x.slc)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: input_slc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), convert(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.event)-1), convert(x.event, y(left to left+len(x.event)-1)));
      left := left + len(x.event);
      assign(y(left to left+len(x.slc)-1), convert(x.slc, y(left to left+len(x.slc)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), convert(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.event)+1), convert(x.event, y(left downto left-len(x.event)+1)));
      left := left - len(x.event);
      assign(y(left downto left-len(x.slc)+1), convert(x.slc, y(left downto left-len(x.slc)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: input_slc_rt) return input_slc_rt is
    variable y: input_slc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := structify(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.event := structify(x(left to left+len(y.event)-1), y.event);
      left := left + len(y.event);
      y.slc := structify(x(left to left+len(y.slc)-1), y.slc);
    else
      y.ToA := structify(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.event := structify(x(left downto left-len(y.event)+1), y.event);
      left := left - len(y.event);
      y.slc := structify(x(left downto left-len(y.slc)+1), y.slc);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: input_slc_rt) return input_slc_rt is
    variable y: input_slc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := convert(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.event := convert(x(left to left+len(y.event)-1), y.event);
      left := left + len(y.event);
      y.slc := convert(x(left to left+len(y.slc)-1), y.slc);
    else
      y.ToA := convert(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.event := convert(x(left downto left-len(y.event)+1), y.event);
      left := left - len(y.event);
      y.slc := convert(x(left downto left-len(y.slc)+1), y.slc);
    end if;
    return y;
  end function convert;
  function nullify(t: input_slc_rt) return input_slc_rt is
  variable y: input_slc_rt;
  begin
    y.ToA := nullify(t.ToA);
    y.event := nullify(t.event);
    y.slc := nullify(t.slc);
    return y;
  end function nullify;
  function zeroed(t: input_slc_rt) return input_slc_rt is
  variable y: input_slc_rt;
  begin
    y.ToA := zeroed(t.ToA);
    y.event := zeroed(t.event);
    y.slc := zeroed(t.slc);
    return y;
  end function zeroed;

  function len(x: input_slc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: input_slc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: input_slc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: input_slc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: input_slc_art) return input_slc_art is
    variable y : input_slc_art;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: input_slc_art) return input_slc_art is
    variable y : input_slc_art;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: input_slc_art) return input_slc_art is
    variable y : input_slc_art;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: input_slc_art) return input_slc_art is
    variable y : input_slc_art;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: slc_tb_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: slc_tb_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: slc_tb_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_tb_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: slc_tb_art) return slc_tb_art is
    variable y : slc_tb_art;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: slc_tb_art) return slc_tb_art is
    variable y : slc_tb_art;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: slc_tb_art) return slc_tb_art is
    variable y : slc_tb_art;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: slc_tb_art) return slc_tb_art is
    variable y : slc_tb_art;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: out_heg_bm_hit_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ToA);
    l := l + len(x.station);
    l := l + len(x.thread);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: out_heg_bm_hit_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ToA);
    l := l + width(x.station);
    l := l + width(x.thread);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: out_heg_bm_hit_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), vectorify(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), vectorify(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.thread)-1), vectorify(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), vectorify(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), vectorify(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.thread)+1), vectorify(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: out_heg_bm_hit_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), convert(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), convert(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.thread)-1), convert(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), convert(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), convert(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.thread)+1), convert(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt is
    variable y: out_heg_bm_hit_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := structify(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := structify(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.thread := structify(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := structify(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := structify(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.thread := structify(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt is
    variable y: out_heg_bm_hit_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := convert(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := convert(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.thread := convert(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := convert(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := convert(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.thread := convert(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt is
  variable y: out_heg_bm_hit_sim_rt;
  begin
    y.ToA := nullify(t.ToA);
    y.station := nullify(t.station);
    y.thread := nullify(t.thread);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: out_heg_bm_hit_sim_rt) return out_heg_bm_hit_sim_rt is
  variable y: out_heg_bm_hit_sim_rt;
  begin
    y.ToA := zeroed(t.ToA);
    y.station := zeroed(t.station);
    y.thread := zeroed(t.thread);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: out_heg_bm_slc_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ToA);
    l := l + len(x.station);
    l := l + len(x.thread);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: out_heg_bm_slc_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ToA);
    l := l + width(x.station);
    l := l + width(x.thread);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: out_heg_bm_slc_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), vectorify(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), vectorify(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.thread)-1), vectorify(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), vectorify(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), vectorify(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.thread)+1), vectorify(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: out_heg_bm_slc_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), convert(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), convert(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.thread)-1), convert(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), convert(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), convert(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.thread)+1), convert(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt is
    variable y: out_heg_bm_slc_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := structify(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := structify(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.thread := structify(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := structify(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := structify(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.thread := structify(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt is
    variable y: out_heg_bm_slc_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := convert(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := convert(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.thread := convert(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := convert(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := convert(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.thread := convert(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt is
  variable y: out_heg_bm_slc_sim_rt;
  begin
    y.ToA := nullify(t.ToA);
    y.station := nullify(t.station);
    y.thread := nullify(t.thread);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: out_heg_bm_slc_sim_rt) return out_heg_bm_slc_sim_rt is
  variable y: out_heg_bm_slc_sim_rt;
  begin
    y.ToA := zeroed(t.ToA);
    y.station := zeroed(t.station);
    y.thread := zeroed(t.thread);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: out_heg_bm_ctrl_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ToA);
    l := l + len(x.station);
    l := l + len(x.thread);
    l := l + len(x.heg_ctrl);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: out_heg_bm_ctrl_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ToA);
    l := l + width(x.station);
    l := l + width(x.thread);
    l := l + width(x.heg_ctrl);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: out_heg_bm_ctrl_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), vectorify(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), vectorify(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.thread)-1), vectorify(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.heg_ctrl)-1), vectorify(x.heg_ctrl, y(left to left+len(x.heg_ctrl)-1)));
      left := left + len(x.heg_ctrl);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), vectorify(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), vectorify(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.thread)+1), vectorify(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.heg_ctrl)+1), vectorify(x.heg_ctrl, y(left downto left-len(x.heg_ctrl)+1)));
      left := left - len(x.heg_ctrl);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: out_heg_bm_ctrl_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), convert(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), convert(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.thread)-1), convert(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.heg_ctrl)-1), convert(x.heg_ctrl, y(left to left+len(x.heg_ctrl)-1)));
      left := left + len(x.heg_ctrl);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), convert(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), convert(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.thread)+1), convert(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.heg_ctrl)+1), convert(x.heg_ctrl, y(left downto left-len(x.heg_ctrl)+1)));
      left := left - len(x.heg_ctrl);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt is
    variable y: out_heg_bm_ctrl_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := structify(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := structify(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.thread := structify(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.heg_ctrl := structify(x(left to left+len(y.heg_ctrl)-1), y.heg_ctrl);
      left := left + len(y.heg_ctrl);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := structify(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := structify(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.thread := structify(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.heg_ctrl := structify(x(left downto left-len(y.heg_ctrl)+1), y.heg_ctrl);
      left := left - len(y.heg_ctrl);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt is
    variable y: out_heg_bm_ctrl_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := convert(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := convert(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.thread := convert(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.heg_ctrl := convert(x(left to left+len(y.heg_ctrl)-1), y.heg_ctrl);
      left := left + len(y.heg_ctrl);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := convert(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := convert(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.thread := convert(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.heg_ctrl := convert(x(left downto left-len(y.heg_ctrl)+1), y.heg_ctrl);
      left := left - len(y.heg_ctrl);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt is
  variable y: out_heg_bm_ctrl_sim_rt;
  begin
    y.ToA := nullify(t.ToA);
    y.station := nullify(t.station);
    y.thread := nullify(t.thread);
    y.heg_ctrl := nullify(t.heg_ctrl);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: out_heg_bm_ctrl_sim_rt) return out_heg_bm_ctrl_sim_rt is
  variable y: out_heg_bm_ctrl_sim_rt;
  begin
    y.ToA := zeroed(t.ToA);
    y.station := zeroed(t.station);
    y.thread := zeroed(t.thread);
    y.heg_ctrl := zeroed(t.heg_ctrl);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: in_pt_pt2sf_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ToA);
    l := l + len(x.station);
    l := l + len(x.thread);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: in_pt_pt2sf_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ToA);
    l := l + width(x.station);
    l := l + width(x.thread);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: in_pt_pt2sf_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), vectorify(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), vectorify(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.thread)-1), vectorify(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), vectorify(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), vectorify(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.thread)+1), vectorify(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: in_pt_pt2sf_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), convert(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.station)-1), convert(x.station, y(left to left+len(x.station)-1)));
      left := left + len(x.station);
      assign(y(left to left+len(x.thread)-1), convert(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), convert(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.station)+1), convert(x.station, y(left downto left-len(x.station)+1)));
      left := left - len(x.station);
      assign(y(left downto left-len(x.thread)+1), convert(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt is
    variable y: in_pt_pt2sf_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := structify(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := structify(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.thread := structify(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := structify(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := structify(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.thread := structify(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt is
    variable y: in_pt_pt2sf_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := convert(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.station := convert(x(left to left+len(y.station)-1), y.station);
      left := left + len(y.station);
      y.thread := convert(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := convert(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.station := convert(x(left downto left-len(y.station)+1), y.station);
      left := left - len(y.station);
      y.thread := convert(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt is
  variable y: in_pt_pt2sf_sim_rt;
  begin
    y.ToA := nullify(t.ToA);
    y.station := nullify(t.station);
    y.thread := nullify(t.thread);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: in_pt_pt2sf_sim_rt) return in_pt_pt2sf_sim_rt is
  variable y: in_pt_pt2sf_sim_rt;
  begin
    y.ToA := zeroed(t.ToA);
    y.station := zeroed(t.station);
    y.thread := zeroed(t.thread);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: in_pt_mpl_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ToA);
    l := l + len(x.thread);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: in_pt_mpl_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ToA);
    l := l + width(x.thread);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: in_pt_mpl_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), vectorify(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.thread)-1), vectorify(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), vectorify(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.thread)+1), vectorify(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: in_pt_mpl_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), convert(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.thread)-1), convert(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), convert(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.thread)+1), convert(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt is
    variable y: in_pt_mpl_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := structify(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.thread := structify(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := structify(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.thread := structify(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt is
    variable y: in_pt_mpl_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := convert(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.thread := convert(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := convert(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.thread := convert(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt is
  variable y: in_pt_mpl_sim_rt;
  begin
    y.ToA := nullify(t.ToA);
    y.thread := nullify(t.thread);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: in_pt_mpl_sim_rt) return in_pt_mpl_sim_rt is
  variable y: in_pt_mpl_sim_rt;
  begin
    y.ToA := zeroed(t.ToA);
    y.thread := zeroed(t.thread);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: in_mtc_pt_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ToA);
    l := l + len(x.thread);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: in_mtc_pt_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ToA);
    l := l + width(x.thread);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: in_mtc_pt_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), vectorify(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.thread)-1), vectorify(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), vectorify(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.thread)+1), vectorify(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: in_mtc_pt_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), convert(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.thread)-1), convert(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), convert(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.thread)+1), convert(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt is
    variable y: in_mtc_pt_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := structify(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.thread := structify(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := structify(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.thread := structify(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt is
    variable y: in_mtc_pt_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := convert(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.thread := convert(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := convert(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.thread := convert(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt is
  variable y: in_mtc_pt_sim_rt;
  begin
    y.ToA := nullify(t.ToA);
    y.thread := nullify(t.thread);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: in_mtc_pt_sim_rt) return in_mtc_pt_sim_rt is
  variable y: in_mtc_pt_sim_rt;
  begin
    y.ToA := zeroed(t.ToA);
    y.thread := zeroed(t.thread);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: in_mtc_mpl_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ToA);
    l := l + len(x.thread);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: in_mtc_mpl_sim_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ToA);
    l := l + width(x.thread);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: in_mtc_mpl_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), vectorify(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.thread)-1), vectorify(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), vectorify(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.thread)+1), vectorify(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: in_mtc_mpl_sim_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ToA)-1), convert(x.ToA, y(left to left+len(x.ToA)-1)));
      left := left + len(x.ToA);
      assign(y(left to left+len(x.thread)-1), convert(x.thread, y(left to left+len(x.thread)-1)));
      left := left + len(x.thread);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.ToA)+1), convert(x.ToA, y(left downto left-len(x.ToA)+1)));
      left := left - len(x.ToA);
      assign(y(left downto left-len(x.thread)+1), convert(x.thread, y(left downto left-len(x.thread)+1)));
      left := left - len(x.thread);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt is
    variable y: in_mtc_mpl_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := structify(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.thread := structify(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := structify(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.thread := structify(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt is
    variable y: in_mtc_mpl_sim_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ToA := convert(x(left to left+len(y.ToA)-1), y.ToA);
      left := left + len(y.ToA);
      y.thread := convert(x(left to left+len(y.thread)-1), y.thread);
      left := left + len(y.thread);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.ToA := convert(x(left downto left-len(y.ToA)+1), y.ToA);
      left := left - len(y.ToA);
      y.thread := convert(x(left downto left-len(y.thread)+1), y.thread);
      left := left - len(y.thread);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt is
  variable y: in_mtc_mpl_sim_rt;
  begin
    y.ToA := nullify(t.ToA);
    y.thread := nullify(t.thread);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: in_mtc_mpl_sim_rt) return in_mtc_mpl_sim_rt is
  variable y: in_mtc_mpl_sim_rt;
  begin
    y.ToA := zeroed(t.ToA);
    y.thread := zeroed(t.thread);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

end package body ult_tb_sim_pkg;
