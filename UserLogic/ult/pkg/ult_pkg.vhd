-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package ult_pkg is

   -- Custom types and functions --

   type ull_slow_rt is record
      global_ena : std_logic;
      global_rst : std_logic;
      global_freeze : std_logic;
   end record ull_slow_rt;
   attribute w of ull_slow_rt : type is 3;
   function width(x: ull_slow_rt) return natural;
   function convert(x: ull_slow_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ull_slow_rt) return ull_slow_rt;
   function zero(tpl: ull_slow_rt) return ull_slow_rt;

   subtype ull_slow_vt is std_logic_vector(ull_slow_rt'w-1 downto 0);
   attribute w of ull_slow_vt : subtype is 3;

end package ult_pkg;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package body ult_pkg is

   -- Custom types and functions --

   function width(x: ull_slow_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.global_ena);
      w := w + width(x.global_rst);
      w := w + width(x.global_freeze);
      return w;
   end function width;
   function convert(x: ull_slow_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.global_ena);
         y(u to u+w-1) := convert(x.global_ena, y(u to u+w-1));
         u := u + w;
         w := width(x.global_rst);
         y(u to u+w-1) := convert(x.global_rst, y(u to u+w-1));
         u := u + w;
         w := width(x.global_freeze);
         y(u to u+w-1) := convert(x.global_freeze, y(u to u+w-1));
      else
         w := width(x.global_ena);
         y(u downto u-w+1) := convert(x.global_ena, y(u downto u-w+1));
         u := u - w;
         w := width(x.global_rst);
         y(u downto u-w+1) := convert(x.global_rst, y(u downto u-w+1));
         u := u - w;
         w := width(x.global_freeze);
         y(u downto u-w+1) := convert(x.global_freeze, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ull_slow_rt) return ull_slow_rt is
      variable y : ull_slow_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.global_ena);
         y.global_ena := convert(x(u to u+w-1), tpl.global_ena);
         u := u + w;
         w := width(tpl.global_rst);
         y.global_rst := convert(x(u to u+w-1), tpl.global_rst);
         u := u + w;
         w := width(tpl.global_freeze);
         y.global_freeze := convert(x(u to u+w-1), tpl.global_freeze);
      else
         w := width(tpl.global_ena);
         y.global_ena := convert(x(u downto u-w+1), tpl.global_ena);
         u := u - w;
         w := width(tpl.global_rst);
         y.global_rst := convert(x(u downto u-w+1), tpl.global_rst);
         u := u - w;
         w := width(tpl.global_freeze);
         y.global_freeze := convert(x(u downto u-w+1), tpl.global_freeze);
      end if;
      return y;
   end function convert;
   function zero(tpl: ull_slow_rt) return ull_slow_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

end package body ult_pkg;
