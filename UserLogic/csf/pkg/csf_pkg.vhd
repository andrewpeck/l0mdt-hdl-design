-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;

package csf_pkg is

  constant UCM_MBAR_MULT : real := 1024.0;

  constant CSF_SEG_M_LEN : integer := 15;

  constant CSF_SEG_M_MULT : real := 4096.0;

  constant CSF_SEG_B_LEN : integer := 13;

  constant CSF_SEG_B_MULT : real := 16.0;

  constant CSF_SEG_CHI2_LEN : integer := 15;

  constant CSF_SEG_CHI2_MULT : real := 4.0;

  constant CSF_MAXHITS_SEG : integer := 16;

  constant CSF_MAXHITS_SEG_LEN : integer := 4;

  constant CSF_MAXHITS_ML_LEN : integer := 3;

  constant CSF_MAX_CLUSTERS : integer := 6;

  constant SUM_XY_LEN : integer := CSF_MAXHITS_SEG_LEN + MDT_LOCAL_Y_LEN * 2;

  constant SUM_Y_LEN : integer := CSF_MAXHITS_SEG_LEN + MDT_LOCAL_Y_LEN;

  constant SUM_X_LEN : integer := CSF_MAXHITS_SEG_LEN + MDT_LOCAL_X_LEN;

  constant SUM_X2_LEN : integer := CSF_MAXHITS_SEG_LEN + MDT_LOCAL_X_LEN*2;

  type csf_seed is record
    muid : slc_muid;
    mbar : unsigned(UCM_VEC_ANG_LEN-1 downto 0);
    pos : unsigned(UCM_Z_ROI_LEN-1 downto 0);
    ang : unsigned(UCM_Z_ROI_LEN-1 downto 0);
    mdtid : vec_mdtid;
    data_valid : std_logic;
  end record csf_seed;
  function len(x: csf_seed) return natural;
  function width(x: csf_seed) return natural;
  function vectorify(x: csf_seed; t: std_logic_vector) return std_logic_vector;
  function convert(x: csf_seed; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: csf_seed) return csf_seed;
  function convert(x: in std_logic_vector; t: csf_seed) return csf_seed;
  function nullify(t: csf_seed) return csf_seed;
  function zeroed(t: csf_seed) return csf_seed;

  type csf_hit is record
    valid : std_logic;
    x : unsigned(MDT_LOCAL_X_LEN-1 downto 0);
    y : unsigned(MDT_LOCAL_Y_LEN-1 downto 0);
  end record csf_hit;
  function len(x: csf_hit) return natural;
  function width(x: csf_hit) return natural;
  function vectorify(x: csf_hit; t: std_logic_vector) return std_logic_vector;
  function convert(x: csf_hit; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: csf_hit) return csf_hit;
  function convert(x: in std_logic_vector; t: csf_hit) return csf_hit;
  function nullify(t: csf_hit) return csf_hit;
  function zeroed(t: csf_hit) return csf_hit;

  type csf_hit_a is array(integer range <>) of csf_hit;
  function len(x: csf_hit_a) return natural;
  function width(x: csf_hit_a) return natural;
  function vectorify(x: csf_hit_a; t: std_logic_vector) return std_logic_vector;
  function convert(x: csf_hit_a; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: csf_hit_a) return csf_hit_a;
  function convert(x: std_logic_vector; t: csf_hit_a) return csf_hit_a;
  function nullify(x: csf_hit_a) return csf_hit_a;
  function zeroed(x: csf_hit_a) return csf_hit_a;

  type csf_locseg is record
    valid : std_logic;
    b : signed(CSF_SEG_B_LEN-1 downto 0);
    m : signed(CSF_SEG_M_LEN-1 downto 0);
    chi2 : unsigned(CSF_SEG_CHI2_LEN-1 downto 0);
    nhits : unsigned(CSF_MAXHITS_SEG_LEN-1 downto 0);
  end record csf_locseg;
  function len(x: csf_locseg) return natural;
  function width(x: csf_locseg) return natural;
  function vectorify(x: csf_locseg; t: std_logic_vector) return std_logic_vector;
  function convert(x: csf_locseg; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: csf_locseg) return csf_locseg;
  function convert(x: in std_logic_vector; t: csf_locseg) return csf_locseg;
  function nullify(t: csf_locseg) return csf_locseg;
  function zeroed(t: csf_locseg) return csf_locseg;

  type csf_locseg_a is array(integer range <>) of csf_locseg;
  function len(x: csf_locseg_a) return natural;
  function width(x: csf_locseg_a) return natural;
  function vectorify(x: csf_locseg_a; t: std_logic_vector) return std_logic_vector;
  function convert(x: csf_locseg_a; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: csf_locseg_a) return csf_locseg_a;
  function convert(x: std_logic_vector; t: csf_locseg_a) return csf_locseg_a;
  function nullify(x: csf_locseg_a) return csf_locseg_a;
  function zeroed(x: csf_locseg_a) return csf_locseg_a;

  type csf_sums is record
    valid : std_logic;
    xy : unsigned(SUM_XY_LEN-1 downto 0);
    y : unsigned(SUM_Y_LEN-1 downto 0);
    x : unsigned(SUM_X_LEN-1 downto 0);
    x2 : unsigned(SUM_X2_LEN-1 downto 0);
    n : unsigned(CSF_MAXHITS_SEG_LEN-1 downto 0);
  end record csf_sums;
  function len(x: csf_sums) return natural;
  function width(x: csf_sums) return natural;
  function vectorify(x: csf_sums; t: std_logic_vector) return std_logic_vector;
  function convert(x: csf_sums; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: csf_sums) return csf_sums;
  function convert(x: in std_logic_vector; t: csf_sums) return csf_sums;
  function nullify(t: csf_sums) return csf_sums;
  function zeroed(t: csf_sums) return csf_sums;

  type csf_sums_a is array(integer range <>) of csf_sums;
  function len(x: csf_sums_a) return natural;
  function width(x: csf_sums_a) return natural;
  function vectorify(x: csf_sums_a; t: std_logic_vector) return std_logic_vector;
  function convert(x: csf_sums_a; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: csf_sums_a) return csf_sums_a;
  function convert(x: std_logic_vector; t: csf_sums_a) return csf_sums_a;
  function nullify(x: csf_sums_a) return csf_sums_a;
  function zeroed(x: csf_sums_a) return csf_sums_a;

  type sf_seg_data_barrel is record
    data_valid : std_logic;
    muid : slc_muid;
    mdtid : vec_mdtid;
    pos : signed(SF_SEG_POS_LEN-1 downto 0);
    angle : signed(SF_SEG_ANG_LEN-1 downto 0);
    quality : std_logic;
  end record sf_seg_data_barrel;
  function len(x: sf_seg_data_barrel) return natural;
  function width(x: sf_seg_data_barrel) return natural;
  function vectorify(x: sf_seg_data_barrel; t: std_logic_vector) return std_logic_vector;
  function convert(x: sf_seg_data_barrel; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: sf_seg_data_barrel) return sf_seg_data_barrel;
  function convert(x: in std_logic_vector; t: sf_seg_data_barrel) return sf_seg_data_barrel;
  function nullify(t: sf_seg_data_barrel) return sf_seg_data_barrel;
  function zeroed(t: sf_seg_data_barrel) return sf_seg_data_barrel;

  type sf_seg_data_endcap is record
    data_valid : std_logic;
    muid : slc_muid;
    mdtid : vec_mdtid;
    pos : unsigned(SF_SEG_POS_LEN-1 downto 0);
    angle : signed(SF_SEG_ANG_LEN-1 downto 0);
    quality : std_logic;
  end record sf_seg_data_endcap;
  function len(x: sf_seg_data_endcap) return natural;
  function width(x: sf_seg_data_endcap) return natural;
  function vectorify(x: sf_seg_data_endcap; t: std_logic_vector) return std_logic_vector;
  function convert(x: sf_seg_data_endcap; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: sf_seg_data_endcap) return sf_seg_data_endcap;
  function convert(x: in std_logic_vector; t: sf_seg_data_endcap) return sf_seg_data_endcap;
  function nullify(t: sf_seg_data_endcap) return sf_seg_data_endcap;
  function zeroed(t: sf_seg_data_endcap) return sf_seg_data_endcap;

end package csf_pkg;

------------------------------------------------------------

package body csf_pkg is

  function len(x: csf_seed) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.muid);
    l := l + len(x.mbar);
    l := l + len(x.pos);
    l := l + len(x.ang);
    l := l + len(x.mdtid);
    l := l + len(x.data_valid);
    return l;
  end function len;
  function width(x: csf_seed) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.muid);
    l := l + width(x.mbar);
    l := l + width(x.pos);
    l := l + width(x.ang);
    l := l + width(x.mdtid);
    l := l + width(x.data_valid);
    return l;
  end function width;
  function vectorify(x: csf_seed; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mbar)-1), vectorify(x.mbar, y(left to left+len(x.mbar)-1)));
      left := left + len(x.mbar);
      assign(y(left to left+len(x.pos)-1), vectorify(x.pos, y(left to left+len(x.pos)-1)));
      left := left + len(x.pos);
      assign(y(left to left+len(x.ang)-1), vectorify(x.ang, y(left to left+len(x.ang)-1)));
      left := left + len(x.ang);
      assign(y(left to left+len(x.mdtid)-1), vectorify(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mbar)+1), vectorify(x.mbar, y(left downto left-len(x.mbar)+1)));
      left := left - len(x.mbar);
      assign(y(left downto left-len(x.pos)+1), vectorify(x.pos, y(left downto left-len(x.pos)+1)));
      left := left - len(x.pos);
      assign(y(left downto left-len(x.ang)+1), vectorify(x.ang, y(left downto left-len(x.ang)+1)));
      left := left - len(x.ang);
      assign(y(left downto left-len(x.mdtid)+1), vectorify(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: csf_seed; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mbar)-1), convert(x.mbar, y(left to left+len(x.mbar)-1)));
      left := left + len(x.mbar);
      assign(y(left to left+len(x.pos)-1), convert(x.pos, y(left to left+len(x.pos)-1)));
      left := left + len(x.pos);
      assign(y(left to left+len(x.ang)-1), convert(x.ang, y(left to left+len(x.ang)-1)));
      left := left + len(x.ang);
      assign(y(left to left+len(x.mdtid)-1), convert(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mbar)+1), convert(x.mbar, y(left downto left-len(x.mbar)+1)));
      left := left - len(x.mbar);
      assign(y(left downto left-len(x.pos)+1), convert(x.pos, y(left downto left-len(x.pos)+1)));
      left := left - len(x.pos);
      assign(y(left downto left-len(x.ang)+1), convert(x.ang, y(left downto left-len(x.ang)+1)));
      left := left - len(x.ang);
      assign(y(left downto left-len(x.mdtid)+1), convert(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: csf_seed) return csf_seed is
    variable y: csf_seed;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mbar := structify(x(left to left+len(y.mbar)-1), y.mbar);
      left := left + len(y.mbar);
      y.pos := structify(x(left to left+len(y.pos)-1), y.pos);
      left := left + len(y.pos);
      y.ang := structify(x(left to left+len(y.ang)-1), y.ang);
      left := left + len(y.ang);
      y.mdtid := structify(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mbar := structify(x(left downto left-len(y.mbar)+1), y.mbar);
      left := left - len(y.mbar);
      y.pos := structify(x(left downto left-len(y.pos)+1), y.pos);
      left := left - len(y.pos);
      y.ang := structify(x(left downto left-len(y.ang)+1), y.ang);
      left := left - len(y.ang);
      y.mdtid := structify(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: csf_seed) return csf_seed is
    variable y: csf_seed;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mbar := convert(x(left to left+len(y.mbar)-1), y.mbar);
      left := left + len(y.mbar);
      y.pos := convert(x(left to left+len(y.pos)-1), y.pos);
      left := left + len(y.pos);
      y.ang := convert(x(left to left+len(y.ang)-1), y.ang);
      left := left + len(y.ang);
      y.mdtid := convert(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mbar := convert(x(left downto left-len(y.mbar)+1), y.mbar);
      left := left - len(y.mbar);
      y.pos := convert(x(left downto left-len(y.pos)+1), y.pos);
      left := left - len(y.pos);
      y.ang := convert(x(left downto left-len(y.ang)+1), y.ang);
      left := left - len(y.ang);
      y.mdtid := convert(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: csf_seed) return csf_seed is
  variable y: csf_seed;
  begin
    y.muid := nullify(t.muid);
    y.mbar := nullify(t.mbar);
    y.pos := nullify(t.pos);
    y.ang := nullify(t.ang);
    y.mdtid := nullify(t.mdtid);
    y.data_valid := nullify(t.data_valid);
    return y;
  end function nullify;
  function zeroed(t: csf_seed) return csf_seed is
  variable y: csf_seed;
  begin
    y.muid := zeroed(t.muid);
    y.mbar := zeroed(t.mbar);
    y.pos := zeroed(t.pos);
    y.ang := zeroed(t.ang);
    y.mdtid := zeroed(t.mdtid);
    y.data_valid := zeroed(t.data_valid);
    return y;
  end function zeroed;

  function len(x: csf_hit) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.valid);
    l := l + len(x.x);
    l := l + len(x.y);
    return l;
  end function len;
  function width(x: csf_hit) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.valid);
    l := l + width(x.x);
    l := l + width(x.y);
    return l;
  end function width;
  function vectorify(x: csf_hit; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), vectorify(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.x)-1), vectorify(x.x, y(left to left+len(x.x)-1)));
      left := left + len(x.x);
      assign(y(left to left+len(x.y)-1), vectorify(x.y, y(left to left+len(x.y)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), vectorify(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.x)+1), vectorify(x.x, y(left downto left-len(x.x)+1)));
      left := left - len(x.x);
      assign(y(left downto left-len(x.y)+1), vectorify(x.y, y(left downto left-len(x.y)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: csf_hit; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), convert(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.x)-1), convert(x.x, y(left to left+len(x.x)-1)));
      left := left + len(x.x);
      assign(y(left to left+len(x.y)-1), convert(x.y, y(left to left+len(x.y)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), convert(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.x)+1), convert(x.x, y(left downto left-len(x.x)+1)));
      left := left - len(x.x);
      assign(y(left downto left-len(x.y)+1), convert(x.y, y(left downto left-len(x.y)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: csf_hit) return csf_hit is
    variable y: csf_hit;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := structify(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.x := structify(x(left to left+len(y.x)-1), y.x);
      left := left + len(y.x);
      y.y := structify(x(left to left+len(y.y)-1), y.y);
    else
      y.valid := structify(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.x := structify(x(left downto left-len(y.x)+1), y.x);
      left := left - len(y.x);
      y.y := structify(x(left downto left-len(y.y)+1), y.y);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: csf_hit) return csf_hit is
    variable y: csf_hit;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := convert(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.x := convert(x(left to left+len(y.x)-1), y.x);
      left := left + len(y.x);
      y.y := convert(x(left to left+len(y.y)-1), y.y);
    else
      y.valid := convert(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.x := convert(x(left downto left-len(y.x)+1), y.x);
      left := left - len(y.x);
      y.y := convert(x(left downto left-len(y.y)+1), y.y);
    end if;
    return y;
  end function convert;
  function nullify(t: csf_hit) return csf_hit is
  variable y: csf_hit;
  begin
    y.valid := nullify(t.valid);
    y.x := nullify(t.x);
    y.y := nullify(t.y);
    return y;
  end function nullify;
  function zeroed(t: csf_hit) return csf_hit is
  variable y: csf_hit;
  begin
    y.valid := zeroed(t.valid);
    y.x := zeroed(t.x);
    y.y := zeroed(t.y);
    return y;
  end function zeroed;

  function len(x: csf_hit_a) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: csf_hit_a) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: csf_hit_a; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: csf_hit_a; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: csf_hit_a) return csf_hit_a is
    variable y : csf_hit_a(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: csf_hit_a) return csf_hit_a is
    variable y : csf_hit_a(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: csf_hit_a) return csf_hit_a is
    variable y : csf_hit_a(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: csf_hit_a) return csf_hit_a is
    variable y : csf_hit_a(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: csf_locseg) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.valid);
    l := l + len(x.b);
    l := l + len(x.m);
    l := l + len(x.chi2);
    l := l + len(x.nhits);
    return l;
  end function len;
  function width(x: csf_locseg) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.valid);
    l := l + width(x.b);
    l := l + width(x.m);
    l := l + width(x.chi2);
    l := l + width(x.nhits);
    return l;
  end function width;
  function vectorify(x: csf_locseg; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), vectorify(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.b)-1), vectorify(x.b, y(left to left+len(x.b)-1)));
      left := left + len(x.b);
      assign(y(left to left+len(x.m)-1), vectorify(x.m, y(left to left+len(x.m)-1)));
      left := left + len(x.m);
      assign(y(left to left+len(x.chi2)-1), vectorify(x.chi2, y(left to left+len(x.chi2)-1)));
      left := left + len(x.chi2);
      assign(y(left to left+len(x.nhits)-1), vectorify(x.nhits, y(left to left+len(x.nhits)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), vectorify(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.b)+1), vectorify(x.b, y(left downto left-len(x.b)+1)));
      left := left - len(x.b);
      assign(y(left downto left-len(x.m)+1), vectorify(x.m, y(left downto left-len(x.m)+1)));
      left := left - len(x.m);
      assign(y(left downto left-len(x.chi2)+1), vectorify(x.chi2, y(left downto left-len(x.chi2)+1)));
      left := left - len(x.chi2);
      assign(y(left downto left-len(x.nhits)+1), vectorify(x.nhits, y(left downto left-len(x.nhits)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: csf_locseg; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), convert(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.b)-1), convert(x.b, y(left to left+len(x.b)-1)));
      left := left + len(x.b);
      assign(y(left to left+len(x.m)-1), convert(x.m, y(left to left+len(x.m)-1)));
      left := left + len(x.m);
      assign(y(left to left+len(x.chi2)-1), convert(x.chi2, y(left to left+len(x.chi2)-1)));
      left := left + len(x.chi2);
      assign(y(left to left+len(x.nhits)-1), convert(x.nhits, y(left to left+len(x.nhits)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), convert(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.b)+1), convert(x.b, y(left downto left-len(x.b)+1)));
      left := left - len(x.b);
      assign(y(left downto left-len(x.m)+1), convert(x.m, y(left downto left-len(x.m)+1)));
      left := left - len(x.m);
      assign(y(left downto left-len(x.chi2)+1), convert(x.chi2, y(left downto left-len(x.chi2)+1)));
      left := left - len(x.chi2);
      assign(y(left downto left-len(x.nhits)+1), convert(x.nhits, y(left downto left-len(x.nhits)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: csf_locseg) return csf_locseg is
    variable y: csf_locseg;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := structify(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.b := structify(x(left to left+len(y.b)-1), y.b);
      left := left + len(y.b);
      y.m := structify(x(left to left+len(y.m)-1), y.m);
      left := left + len(y.m);
      y.chi2 := structify(x(left to left+len(y.chi2)-1), y.chi2);
      left := left + len(y.chi2);
      y.nhits := structify(x(left to left+len(y.nhits)-1), y.nhits);
    else
      y.valid := structify(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.b := structify(x(left downto left-len(y.b)+1), y.b);
      left := left - len(y.b);
      y.m := structify(x(left downto left-len(y.m)+1), y.m);
      left := left - len(y.m);
      y.chi2 := structify(x(left downto left-len(y.chi2)+1), y.chi2);
      left := left - len(y.chi2);
      y.nhits := structify(x(left downto left-len(y.nhits)+1), y.nhits);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: csf_locseg) return csf_locseg is
    variable y: csf_locseg;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := convert(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.b := convert(x(left to left+len(y.b)-1), y.b);
      left := left + len(y.b);
      y.m := convert(x(left to left+len(y.m)-1), y.m);
      left := left + len(y.m);
      y.chi2 := convert(x(left to left+len(y.chi2)-1), y.chi2);
      left := left + len(y.chi2);
      y.nhits := convert(x(left to left+len(y.nhits)-1), y.nhits);
    else
      y.valid := convert(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.b := convert(x(left downto left-len(y.b)+1), y.b);
      left := left - len(y.b);
      y.m := convert(x(left downto left-len(y.m)+1), y.m);
      left := left - len(y.m);
      y.chi2 := convert(x(left downto left-len(y.chi2)+1), y.chi2);
      left := left - len(y.chi2);
      y.nhits := convert(x(left downto left-len(y.nhits)+1), y.nhits);
    end if;
    return y;
  end function convert;
  function nullify(t: csf_locseg) return csf_locseg is
  variable y: csf_locseg;
  begin
    y.valid := nullify(t.valid);
    y.b := nullify(t.b);
    y.m := nullify(t.m);
    y.chi2 := nullify(t.chi2);
    y.nhits := nullify(t.nhits);
    return y;
  end function nullify;
  function zeroed(t: csf_locseg) return csf_locseg is
  variable y: csf_locseg;
  begin
    y.valid := zeroed(t.valid);
    y.b := zeroed(t.b);
    y.m := zeroed(t.m);
    y.chi2 := zeroed(t.chi2);
    y.nhits := zeroed(t.nhits);
    return y;
  end function zeroed;

  function len(x: csf_locseg_a) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: csf_locseg_a) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: csf_locseg_a; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: csf_locseg_a; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: csf_locseg_a) return csf_locseg_a is
    variable y : csf_locseg_a(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: csf_locseg_a) return csf_locseg_a is
    variable y : csf_locseg_a(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: csf_locseg_a) return csf_locseg_a is
    variable y : csf_locseg_a(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: csf_locseg_a) return csf_locseg_a is
    variable y : csf_locseg_a(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: csf_sums) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.valid);
    l := l + len(x.xy);
    l := l + len(x.y);
    l := l + len(x.x);
    l := l + len(x.x2);
    l := l + len(x.n);
    return l;
  end function len;
  function width(x: csf_sums) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.valid);
    l := l + width(x.xy);
    l := l + width(x.y);
    l := l + width(x.x);
    l := l + width(x.x2);
    l := l + width(x.n);
    return l;
  end function width;
  function vectorify(x: csf_sums; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), vectorify(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.xy)-1), vectorify(x.xy, y(left to left+len(x.xy)-1)));
      left := left + len(x.xy);
      assign(y(left to left+len(x.y)-1), vectorify(x.y, y(left to left+len(x.y)-1)));
      left := left + len(x.y);
      assign(y(left to left+len(x.x)-1), vectorify(x.x, y(left to left+len(x.x)-1)));
      left := left + len(x.x);
      assign(y(left to left+len(x.x2)-1), vectorify(x.x2, y(left to left+len(x.x2)-1)));
      left := left + len(x.x2);
      assign(y(left to left+len(x.n)-1), vectorify(x.n, y(left to left+len(x.n)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), vectorify(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.xy)+1), vectorify(x.xy, y(left downto left-len(x.xy)+1)));
      left := left - len(x.xy);
      assign(y(left downto left-len(x.y)+1), vectorify(x.y, y(left downto left-len(x.y)+1)));
      left := left - len(x.y);
      assign(y(left downto left-len(x.x)+1), vectorify(x.x, y(left downto left-len(x.x)+1)));
      left := left - len(x.x);
      assign(y(left downto left-len(x.x2)+1), vectorify(x.x2, y(left downto left-len(x.x2)+1)));
      left := left - len(x.x2);
      assign(y(left downto left-len(x.n)+1), vectorify(x.n, y(left downto left-len(x.n)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: csf_sums; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), convert(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.xy)-1), convert(x.xy, y(left to left+len(x.xy)-1)));
      left := left + len(x.xy);
      assign(y(left to left+len(x.y)-1), convert(x.y, y(left to left+len(x.y)-1)));
      left := left + len(x.y);
      assign(y(left to left+len(x.x)-1), convert(x.x, y(left to left+len(x.x)-1)));
      left := left + len(x.x);
      assign(y(left to left+len(x.x2)-1), convert(x.x2, y(left to left+len(x.x2)-1)));
      left := left + len(x.x2);
      assign(y(left to left+len(x.n)-1), convert(x.n, y(left to left+len(x.n)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), convert(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.xy)+1), convert(x.xy, y(left downto left-len(x.xy)+1)));
      left := left - len(x.xy);
      assign(y(left downto left-len(x.y)+1), convert(x.y, y(left downto left-len(x.y)+1)));
      left := left - len(x.y);
      assign(y(left downto left-len(x.x)+1), convert(x.x, y(left downto left-len(x.x)+1)));
      left := left - len(x.x);
      assign(y(left downto left-len(x.x2)+1), convert(x.x2, y(left downto left-len(x.x2)+1)));
      left := left - len(x.x2);
      assign(y(left downto left-len(x.n)+1), convert(x.n, y(left downto left-len(x.n)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: csf_sums) return csf_sums is
    variable y: csf_sums;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := structify(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.xy := structify(x(left to left+len(y.xy)-1), y.xy);
      left := left + len(y.xy);
      y.y := structify(x(left to left+len(y.y)-1), y.y);
      left := left + len(y.y);
      y.x := structify(x(left to left+len(y.x)-1), y.x);
      left := left + len(y.x);
      y.x2 := structify(x(left to left+len(y.x2)-1), y.x2);
      left := left + len(y.x2);
      y.n := structify(x(left to left+len(y.n)-1), y.n);
    else
      y.valid := structify(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.xy := structify(x(left downto left-len(y.xy)+1), y.xy);
      left := left - len(y.xy);
      y.y := structify(x(left downto left-len(y.y)+1), y.y);
      left := left - len(y.y);
      y.x := structify(x(left downto left-len(y.x)+1), y.x);
      left := left - len(y.x);
      y.x2 := structify(x(left downto left-len(y.x2)+1), y.x2);
      left := left - len(y.x2);
      y.n := structify(x(left downto left-len(y.n)+1), y.n);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: csf_sums) return csf_sums is
    variable y: csf_sums;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := convert(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.xy := convert(x(left to left+len(y.xy)-1), y.xy);
      left := left + len(y.xy);
      y.y := convert(x(left to left+len(y.y)-1), y.y);
      left := left + len(y.y);
      y.x := convert(x(left to left+len(y.x)-1), y.x);
      left := left + len(y.x);
      y.x2 := convert(x(left to left+len(y.x2)-1), y.x2);
      left := left + len(y.x2);
      y.n := convert(x(left to left+len(y.n)-1), y.n);
    else
      y.valid := convert(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.xy := convert(x(left downto left-len(y.xy)+1), y.xy);
      left := left - len(y.xy);
      y.y := convert(x(left downto left-len(y.y)+1), y.y);
      left := left - len(y.y);
      y.x := convert(x(left downto left-len(y.x)+1), y.x);
      left := left - len(y.x);
      y.x2 := convert(x(left downto left-len(y.x2)+1), y.x2);
      left := left - len(y.x2);
      y.n := convert(x(left downto left-len(y.n)+1), y.n);
    end if;
    return y;
  end function convert;
  function nullify(t: csf_sums) return csf_sums is
  variable y: csf_sums;
  begin
    y.valid := nullify(t.valid);
    y.xy := nullify(t.xy);
    y.y := nullify(t.y);
    y.x := nullify(t.x);
    y.x2 := nullify(t.x2);
    y.n := nullify(t.n);
    return y;
  end function nullify;
  function zeroed(t: csf_sums) return csf_sums is
  variable y: csf_sums;
  begin
    y.valid := zeroed(t.valid);
    y.xy := zeroed(t.xy);
    y.y := zeroed(t.y);
    y.x := zeroed(t.x);
    y.x2 := zeroed(t.x2);
    y.n := zeroed(t.n);
    return y;
  end function zeroed;

  function len(x: csf_sums_a) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: csf_sums_a) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: csf_sums_a; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: csf_sums_a; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: csf_sums_a) return csf_sums_a is
    variable y : csf_sums_a(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: csf_sums_a) return csf_sums_a is
    variable y : csf_sums_a(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: csf_sums_a) return csf_sums_a is
    variable y : csf_sums_a(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: csf_sums_a) return csf_sums_a is
    variable y : csf_sums_a(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: sf_seg_data_barrel) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.muid);
    l := l + len(x.mdtid);
    l := l + len(x.pos);
    l := l + len(x.angle);
    l := l + len(x.quality);
    return l;
  end function len;
  function width(x: sf_seg_data_barrel) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.muid);
    l := l + width(x.mdtid);
    l := l + width(x.pos);
    l := l + width(x.angle);
    l := l + width(x.quality);
    return l;
  end function width;
  function vectorify(x: sf_seg_data_barrel; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdtid)-1), vectorify(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.pos)-1), vectorify(x.pos, y(left to left+len(x.pos)-1)));
      left := left + len(x.pos);
      assign(y(left to left+len(x.angle)-1), vectorify(x.angle, y(left to left+len(x.angle)-1)));
      left := left + len(x.angle);
      assign(y(left to left+len(x.quality)-1), vectorify(x.quality, y(left to left+len(x.quality)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdtid)+1), vectorify(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.pos)+1), vectorify(x.pos, y(left downto left-len(x.pos)+1)));
      left := left - len(x.pos);
      assign(y(left downto left-len(x.angle)+1), vectorify(x.angle, y(left downto left-len(x.angle)+1)));
      left := left - len(x.angle);
      assign(y(left downto left-len(x.quality)+1), vectorify(x.quality, y(left downto left-len(x.quality)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: sf_seg_data_barrel; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdtid)-1), convert(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.pos)-1), convert(x.pos, y(left to left+len(x.pos)-1)));
      left := left + len(x.pos);
      assign(y(left to left+len(x.angle)-1), convert(x.angle, y(left to left+len(x.angle)-1)));
      left := left + len(x.angle);
      assign(y(left to left+len(x.quality)-1), convert(x.quality, y(left to left+len(x.quality)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdtid)+1), convert(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.pos)+1), convert(x.pos, y(left downto left-len(x.pos)+1)));
      left := left - len(x.pos);
      assign(y(left downto left-len(x.angle)+1), convert(x.angle, y(left downto left-len(x.angle)+1)));
      left := left - len(x.angle);
      assign(y(left downto left-len(x.quality)+1), convert(x.quality, y(left downto left-len(x.quality)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: sf_seg_data_barrel) return sf_seg_data_barrel is
    variable y: sf_seg_data_barrel;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdtid := structify(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.pos := structify(x(left to left+len(y.pos)-1), y.pos);
      left := left + len(y.pos);
      y.angle := structify(x(left to left+len(y.angle)-1), y.angle);
      left := left + len(y.angle);
      y.quality := structify(x(left to left+len(y.quality)-1), y.quality);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdtid := structify(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.pos := structify(x(left downto left-len(y.pos)+1), y.pos);
      left := left - len(y.pos);
      y.angle := structify(x(left downto left-len(y.angle)+1), y.angle);
      left := left - len(y.angle);
      y.quality := structify(x(left downto left-len(y.quality)+1), y.quality);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: sf_seg_data_barrel) return sf_seg_data_barrel is
    variable y: sf_seg_data_barrel;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdtid := convert(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.pos := convert(x(left to left+len(y.pos)-1), y.pos);
      left := left + len(y.pos);
      y.angle := convert(x(left to left+len(y.angle)-1), y.angle);
      left := left + len(y.angle);
      y.quality := convert(x(left to left+len(y.quality)-1), y.quality);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdtid := convert(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.pos := convert(x(left downto left-len(y.pos)+1), y.pos);
      left := left - len(y.pos);
      y.angle := convert(x(left downto left-len(y.angle)+1), y.angle);
      left := left - len(y.angle);
      y.quality := convert(x(left downto left-len(y.quality)+1), y.quality);
    end if;
    return y;
  end function convert;
  function nullify(t: sf_seg_data_barrel) return sf_seg_data_barrel is
  variable y: sf_seg_data_barrel;
  begin
    y.data_valid := nullify(t.data_valid);
    y.muid := nullify(t.muid);
    y.mdtid := nullify(t.mdtid);
    y.pos := nullify(t.pos);
    y.angle := nullify(t.angle);
    y.quality := nullify(t.quality);
    return y;
  end function nullify;
  function zeroed(t: sf_seg_data_barrel) return sf_seg_data_barrel is
  variable y: sf_seg_data_barrel;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.muid := zeroed(t.muid);
    y.mdtid := zeroed(t.mdtid);
    y.pos := zeroed(t.pos);
    y.angle := zeroed(t.angle);
    y.quality := zeroed(t.quality);
    return y;
  end function zeroed;

  function len(x: sf_seg_data_endcap) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.muid);
    l := l + len(x.mdtid);
    l := l + len(x.pos);
    l := l + len(x.angle);
    l := l + len(x.quality);
    return l;
  end function len;
  function width(x: sf_seg_data_endcap) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.muid);
    l := l + width(x.mdtid);
    l := l + width(x.pos);
    l := l + width(x.angle);
    l := l + width(x.quality);
    return l;
  end function width;
  function vectorify(x: sf_seg_data_endcap; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdtid)-1), vectorify(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.pos)-1), vectorify(x.pos, y(left to left+len(x.pos)-1)));
      left := left + len(x.pos);
      assign(y(left to left+len(x.angle)-1), vectorify(x.angle, y(left to left+len(x.angle)-1)));
      left := left + len(x.angle);
      assign(y(left to left+len(x.quality)-1), vectorify(x.quality, y(left to left+len(x.quality)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdtid)+1), vectorify(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.pos)+1), vectorify(x.pos, y(left downto left-len(x.pos)+1)));
      left := left - len(x.pos);
      assign(y(left downto left-len(x.angle)+1), vectorify(x.angle, y(left downto left-len(x.angle)+1)));
      left := left - len(x.angle);
      assign(y(left downto left-len(x.quality)+1), vectorify(x.quality, y(left downto left-len(x.quality)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: sf_seg_data_endcap; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdtid)-1), convert(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.pos)-1), convert(x.pos, y(left to left+len(x.pos)-1)));
      left := left + len(x.pos);
      assign(y(left to left+len(x.angle)-1), convert(x.angle, y(left to left+len(x.angle)-1)));
      left := left + len(x.angle);
      assign(y(left to left+len(x.quality)-1), convert(x.quality, y(left to left+len(x.quality)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdtid)+1), convert(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.pos)+1), convert(x.pos, y(left downto left-len(x.pos)+1)));
      left := left - len(x.pos);
      assign(y(left downto left-len(x.angle)+1), convert(x.angle, y(left downto left-len(x.angle)+1)));
      left := left - len(x.angle);
      assign(y(left downto left-len(x.quality)+1), convert(x.quality, y(left downto left-len(x.quality)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: sf_seg_data_endcap) return sf_seg_data_endcap is
    variable y: sf_seg_data_endcap;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdtid := structify(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.pos := structify(x(left to left+len(y.pos)-1), y.pos);
      left := left + len(y.pos);
      y.angle := structify(x(left to left+len(y.angle)-1), y.angle);
      left := left + len(y.angle);
      y.quality := structify(x(left to left+len(y.quality)-1), y.quality);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdtid := structify(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.pos := structify(x(left downto left-len(y.pos)+1), y.pos);
      left := left - len(y.pos);
      y.angle := structify(x(left downto left-len(y.angle)+1), y.angle);
      left := left - len(y.angle);
      y.quality := structify(x(left downto left-len(y.quality)+1), y.quality);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: sf_seg_data_endcap) return sf_seg_data_endcap is
    variable y: sf_seg_data_endcap;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdtid := convert(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.pos := convert(x(left to left+len(y.pos)-1), y.pos);
      left := left + len(y.pos);
      y.angle := convert(x(left to left+len(y.angle)-1), y.angle);
      left := left + len(y.angle);
      y.quality := convert(x(left to left+len(y.quality)-1), y.quality);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdtid := convert(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.pos := convert(x(left downto left-len(y.pos)+1), y.pos);
      left := left - len(y.pos);
      y.angle := convert(x(left downto left-len(y.angle)+1), y.angle);
      left := left - len(y.angle);
      y.quality := convert(x(left downto left-len(y.quality)+1), y.quality);
    end if;
    return y;
  end function convert;
  function nullify(t: sf_seg_data_endcap) return sf_seg_data_endcap is
  variable y: sf_seg_data_endcap;
  begin
    y.data_valid := nullify(t.data_valid);
    y.muid := nullify(t.muid);
    y.mdtid := nullify(t.mdtid);
    y.pos := nullify(t.pos);
    y.angle := nullify(t.angle);
    y.quality := nullify(t.quality);
    return y;
  end function nullify;
  function zeroed(t: sf_seg_data_endcap) return sf_seg_data_endcap is
  variable y: sf_seg_data_endcap;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.muid := zeroed(t.muid);
    y.mdtid := zeroed(t.mdtid);
    y.pos := zeroed(t.pos);
    y.angle := zeroed(t.angle);
    y.quality := zeroed(t.quality);
    return y;
  end function zeroed;

end package body csf_pkg;
