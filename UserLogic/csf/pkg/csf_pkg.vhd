-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package csf_pkg is

   -- Custom types and functions --

   constant UCM_MBAR_MULT : real := 1024.0;
   attribute w of UCM_MBAR_MULT : constant is 32;

   constant CSF_SEG_M_LEN : integer := 15;
   attribute w of CSF_SEG_M_LEN : constant is 32;

   constant CSF_SEG_M_MULT : real := 4096.0;
   attribute w of CSF_SEG_M_MULT : constant is 32;

   constant CSF_SEG_B_LEN : integer := 13;
   attribute w of CSF_SEG_B_LEN : constant is 32;

   constant CSF_SEG_B_MULT : real := 16.0;
   attribute w of CSF_SEG_B_MULT : constant is 32;

   constant CSF_SEG_CHI2_LEN : integer := 15;
   attribute w of CSF_SEG_CHI2_LEN : constant is 32;

   constant CSF_SEG_CHI2_MULT : real := 4.0;
   attribute w of CSF_SEG_CHI2_MULT : constant is 32;

   constant CSF_MAXHITS_SEG : integer := 16;
   attribute w of CSF_MAXHITS_SEG : constant is 32;

   constant CSF_MAXHITS_SEG_LEN : integer := 4;
   attribute w of CSF_MAXHITS_SEG_LEN : constant is 32;

   constant CSF_MAXHITS_ML_LEN : integer := 3;
   attribute w of CSF_MAXHITS_ML_LEN : constant is 32;

   constant CSF_MAX_CLUSTERS : integer := 6;
   attribute w of CSF_MAX_CLUSTERS : constant is 32;

   constant SUM_XY_LEN : integer := 34; -- CSF_MAXHITS_SEG_LEN + MDT_LOCAL_Y_LEN * 2
   attribute w of SUM_XY_LEN : constant is 32;

   constant SUM_Y_LEN : integer := 19; -- CSF_MAXHITS_SEG_LEN + MDT_LOCAL_Y_LEN
   attribute w of SUM_Y_LEN : constant is 32;

   constant SUM_X_LEN : integer := 19; -- CSF_MAXHITS_SEG_LEN + MDT_LOCAL_X_LEN
   attribute w of SUM_X_LEN : constant is 32;

   constant SUM_X2_LEN : integer := 34; -- CSF_MAXHITS_SEG_LEN + MDT_LOCAL_X_LEN*2
   attribute w of SUM_X2_LEN : constant is 32;

   type csf_seed_rt is record
      muid : slc_muid_rt;
      mbar : unsigned(UCM_VEC_ANG_LEN-1 downto 0);
      pos : unsigned(UCM_Z_ROI_LEN-1 downto 0);
      ang : unsigned(UCM_Z_ROI_LEN-1 downto 0);
      mdtid : vec_mdtid_rt;
      data_valid : std_logic;
   end record csf_seed_rt;
   attribute w of csf_seed_rt : type is 70;
   function width(x: csf_seed_rt) return natural;
   function convert(x: csf_seed_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: csf_seed_rt) return csf_seed_rt;
   function zero(tpl: csf_seed_rt) return csf_seed_rt;

   type csf_hit_rt is record
      valid : std_logic;
      x : unsigned(MDT_LOCAL_X_LEN-1 downto 0);
      y : unsigned(MDT_LOCAL_Y_LEN-1 downto 0);
   end record csf_hit_rt;
   attribute w of csf_hit_rt : type is 31;
   function width(x: csf_hit_rt) return natural;
   function convert(x: csf_hit_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: csf_hit_rt) return csf_hit_rt;
   function zero(tpl: csf_hit_rt) return csf_hit_rt;

   subtype csf_hit_vt is std_logic_vector(csf_hit_rt'w-1 downto 0);
   attribute w of csf_hit_vt : subtype is 31;

   type csf_hit_art is array(integer range <>) of csf_hit_rt;
   function width(x: csf_hit_art) return integer;
   function convert(x: csf_hit_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: csf_hit_art) return csf_hit_art;
   function zero(tpl: csf_hit_art) return csf_hit_art;
   function convert(x: csf_hit_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: csf_hit_art) return csf_hit_art;

   subtype csf_hit_avt is std_logic_vector_array(open)(csf_hit_rt'w-1 downto 0);

   type csf_locseg_rt is record
      valid : std_logic;
      b : signed(CSF_SEG_B_LEN-1 downto 0);
      m : signed(CSF_SEG_M_LEN-1 downto 0);
      chi2 : unsigned(CSF_SEG_CHI2_LEN-1 downto 0);
      nhits : unsigned(CSF_MAXHITS_SEG_LEN-1 downto 0);
   end record csf_locseg_rt;
   attribute w of csf_locseg_rt : type is 48;
   function width(x: csf_locseg_rt) return natural;
   function convert(x: csf_locseg_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: csf_locseg_rt) return csf_locseg_rt;
   function zero(tpl: csf_locseg_rt) return csf_locseg_rt;

   subtype csf_locseg_vt is std_logic_vector(csf_locseg_rt'w-1 downto 0);
   attribute w of csf_locseg_vt : subtype is 48;

   type csf_locseg_art is array(integer range <>) of csf_locseg_rt;
   function width(x: csf_locseg_art) return integer;
   function convert(x: csf_locseg_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: csf_locseg_art) return csf_locseg_art;
   function zero(tpl: csf_locseg_art) return csf_locseg_art;
   function convert(x: csf_locseg_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: csf_locseg_art) return csf_locseg_art;

   subtype csf_locseg_avt is std_logic_vector_array(open)(csf_locseg_rt'w-1 downto 0);

   type csf_sums_rt is record
      valid : std_logic;
      xy : unsigned(SUM_XY_LEN-1 downto 0);
      y : unsigned(SUM_Y_LEN-1 downto 0);
      x : unsigned(SUM_X_LEN-1 downto 0);
      x2 : unsigned(SUM_X2_LEN-1 downto 0);
      n : unsigned(CSF_MAXHITS_SEG_LEN-1 downto 0);
   end record csf_sums_rt;
   attribute w of csf_sums_rt : type is 111;
   function width(x: csf_sums_rt) return natural;
   function convert(x: csf_sums_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: csf_sums_rt) return csf_sums_rt;
   function zero(tpl: csf_sums_rt) return csf_sums_rt;

   subtype csf_sums_vt is std_logic_vector(csf_sums_rt'w-1 downto 0);
   attribute w of csf_sums_vt : subtype is 111;

   type csf_sums_art is array(integer range <>) of csf_sums_rt;
   function width(x: csf_sums_art) return integer;
   function convert(x: csf_sums_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: csf_sums_art) return csf_sums_art;
   function zero(tpl: csf_sums_art) return csf_sums_art;
   function convert(x: csf_sums_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: csf_sums_art) return csf_sums_art;

   subtype csf_sums_avt is std_logic_vector_array(open)(csf_sums_rt'w-1 downto 0);

   type sf_seg_data_barrel_rt is record
      data_valid : std_logic;
      muid : slc_muid_rt;
      mdtid : vec_mdtid_rt;
      pos : signed(SF_SEG_POS_LEN-1 downto 0);
      angle : signed(SF_SEG_ANG_LEN-1 downto 0);
      quality : std_logic;
   end record sf_seg_data_barrel_rt;
   attribute w of sf_seg_data_barrel_rt : type is 64;
   function width(x: sf_seg_data_barrel_rt) return natural;
   function convert(x: sf_seg_data_barrel_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: sf_seg_data_barrel_rt) return sf_seg_data_barrel_rt;
   function zero(tpl: sf_seg_data_barrel_rt) return sf_seg_data_barrel_rt;

   type sf_seg_data_endcap_rt is record
      data_valid : std_logic;
      muid : slc_muid_rt;
      mdtid : vec_mdtid_rt;
      pos : unsigned(SF_SEG_POS_LEN-1 downto 0);
      angle : signed(SF_SEG_ANG_LEN-1 downto 0);
      quality : std_logic;
   end record sf_seg_data_endcap_rt;
   attribute w of sf_seg_data_endcap_rt : type is 64;
   function width(x: sf_seg_data_endcap_rt) return natural;
   function convert(x: sf_seg_data_endcap_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: sf_seg_data_endcap_rt) return sf_seg_data_endcap_rt;
   function zero(tpl: sf_seg_data_endcap_rt) return sf_seg_data_endcap_rt;

end package csf_pkg;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package body csf_pkg is

   -- Custom types and functions --

   function width(x: csf_seed_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.muid);
      w := w + width(x.mbar);
      w := w + width(x.pos);
      w := w + width(x.ang);
      w := w + width(x.mdtid);
      w := w + width(x.data_valid);
      return w;
   end function width;
   function convert(x: csf_seed_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.muid);
         y(u to u+w-1) := convert(x.muid, y(u to u+w-1));
         u := u + w;
         w := width(x.mbar);
         y(u to u+w-1) := convert(x.mbar, y(u to u+w-1));
         u := u + w;
         w := width(x.pos);
         y(u to u+w-1) := convert(x.pos, y(u to u+w-1));
         u := u + w;
         w := width(x.ang);
         y(u to u+w-1) := convert(x.ang, y(u to u+w-1));
         u := u + w;
         w := width(x.mdtid);
         y(u to u+w-1) := convert(x.mdtid, y(u to u+w-1));
         u := u + w;
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
      else
         w := width(x.muid);
         y(u downto u-w+1) := convert(x.muid, y(u downto u-w+1));
         u := u - w;
         w := width(x.mbar);
         y(u downto u-w+1) := convert(x.mbar, y(u downto u-w+1));
         u := u - w;
         w := width(x.pos);
         y(u downto u-w+1) := convert(x.pos, y(u downto u-w+1));
         u := u - w;
         w := width(x.ang);
         y(u downto u-w+1) := convert(x.ang, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdtid);
         y(u downto u-w+1) := convert(x.mdtid, y(u downto u-w+1));
         u := u - w;
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: csf_seed_rt) return csf_seed_rt is
      variable y : csf_seed_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.muid);
         y.muid := convert(x(u to u+w-1), tpl.muid);
         u := u + w;
         w := width(tpl.mbar);
         y.mbar := convert(x(u to u+w-1), tpl.mbar);
         u := u + w;
         w := width(tpl.pos);
         y.pos := convert(x(u to u+w-1), tpl.pos);
         u := u + w;
         w := width(tpl.ang);
         y.ang := convert(x(u to u+w-1), tpl.ang);
         u := u + w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u to u+w-1), tpl.mdtid);
         u := u + w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
      else
         w := width(tpl.muid);
         y.muid := convert(x(u downto u-w+1), tpl.muid);
         u := u - w;
         w := width(tpl.mbar);
         y.mbar := convert(x(u downto u-w+1), tpl.mbar);
         u := u - w;
         w := width(tpl.pos);
         y.pos := convert(x(u downto u-w+1), tpl.pos);
         u := u - w;
         w := width(tpl.ang);
         y.ang := convert(x(u downto u-w+1), tpl.ang);
         u := u - w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u downto u-w+1), tpl.mdtid);
         u := u - w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
      end if;
      return y;
   end function convert;
   function zero(tpl: csf_seed_rt) return csf_seed_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: csf_hit_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.valid);
      w := w + width(x.x);
      w := w + width(x.y);
      return w;
   end function width;
   function convert(x: csf_hit_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.valid);
         y(u to u+w-1) := convert(x.valid, y(u to u+w-1));
         u := u + w;
         w := width(x.x);
         y(u to u+w-1) := convert(x.x, y(u to u+w-1));
         u := u + w;
         w := width(x.y);
         y(u to u+w-1) := convert(x.y, y(u to u+w-1));
      else
         w := width(x.valid);
         y(u downto u-w+1) := convert(x.valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.x);
         y(u downto u-w+1) := convert(x.x, y(u downto u-w+1));
         u := u - w;
         w := width(x.y);
         y(u downto u-w+1) := convert(x.y, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: csf_hit_rt) return csf_hit_rt is
      variable y : csf_hit_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.valid);
         y.valid := convert(x(u to u+w-1), tpl.valid);
         u := u + w;
         w := width(tpl.x);
         y.x := convert(x(u to u+w-1), tpl.x);
         u := u + w;
         w := width(tpl.y);
         y.y := convert(x(u to u+w-1), tpl.y);
      else
         w := width(tpl.valid);
         y.valid := convert(x(u downto u-w+1), tpl.valid);
         u := u - w;
         w := width(tpl.x);
         y.x := convert(x(u downto u-w+1), tpl.x);
         u := u - w;
         w := width(tpl.y);
         y.y := convert(x(u downto u-w+1), tpl.y);
      end if;
      return y;
   end function convert;
   function zero(tpl: csf_hit_rt) return csf_hit_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: csf_hit_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: csf_hit_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: csf_hit_art) return csf_hit_art is
      variable y : csf_hit_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: csf_hit_art) return csf_hit_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: csf_hit_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: csf_hit_art) return csf_hit_art is
      variable y : csf_hit_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: csf_locseg_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.valid);
      w := w + width(x.b);
      w := w + width(x.m);
      w := w + width(x.chi2);
      w := w + width(x.nhits);
      return w;
   end function width;
   function convert(x: csf_locseg_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.valid);
         y(u to u+w-1) := convert(x.valid, y(u to u+w-1));
         u := u + w;
         w := width(x.b);
         y(u to u+w-1) := convert(x.b, y(u to u+w-1));
         u := u + w;
         w := width(x.m);
         y(u to u+w-1) := convert(x.m, y(u to u+w-1));
         u := u + w;
         w := width(x.chi2);
         y(u to u+w-1) := convert(x.chi2, y(u to u+w-1));
         u := u + w;
         w := width(x.nhits);
         y(u to u+w-1) := convert(x.nhits, y(u to u+w-1));
      else
         w := width(x.valid);
         y(u downto u-w+1) := convert(x.valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.b);
         y(u downto u-w+1) := convert(x.b, y(u downto u-w+1));
         u := u - w;
         w := width(x.m);
         y(u downto u-w+1) := convert(x.m, y(u downto u-w+1));
         u := u - w;
         w := width(x.chi2);
         y(u downto u-w+1) := convert(x.chi2, y(u downto u-w+1));
         u := u - w;
         w := width(x.nhits);
         y(u downto u-w+1) := convert(x.nhits, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: csf_locseg_rt) return csf_locseg_rt is
      variable y : csf_locseg_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.valid);
         y.valid := convert(x(u to u+w-1), tpl.valid);
         u := u + w;
         w := width(tpl.b);
         y.b := convert(x(u to u+w-1), tpl.b);
         u := u + w;
         w := width(tpl.m);
         y.m := convert(x(u to u+w-1), tpl.m);
         u := u + w;
         w := width(tpl.chi2);
         y.chi2 := convert(x(u to u+w-1), tpl.chi2);
         u := u + w;
         w := width(tpl.nhits);
         y.nhits := convert(x(u to u+w-1), tpl.nhits);
      else
         w := width(tpl.valid);
         y.valid := convert(x(u downto u-w+1), tpl.valid);
         u := u - w;
         w := width(tpl.b);
         y.b := convert(x(u downto u-w+1), tpl.b);
         u := u - w;
         w := width(tpl.m);
         y.m := convert(x(u downto u-w+1), tpl.m);
         u := u - w;
         w := width(tpl.chi2);
         y.chi2 := convert(x(u downto u-w+1), tpl.chi2);
         u := u - w;
         w := width(tpl.nhits);
         y.nhits := convert(x(u downto u-w+1), tpl.nhits);
      end if;
      return y;
   end function convert;
   function zero(tpl: csf_locseg_rt) return csf_locseg_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: csf_locseg_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: csf_locseg_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: csf_locseg_art) return csf_locseg_art is
      variable y : csf_locseg_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: csf_locseg_art) return csf_locseg_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: csf_locseg_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: csf_locseg_art) return csf_locseg_art is
      variable y : csf_locseg_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: csf_sums_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.valid);
      w := w + width(x.xy);
      w := w + width(x.y);
      w := w + width(x.x);
      w := w + width(x.x2);
      w := w + width(x.n);
      return w;
   end function width;
   function convert(x: csf_sums_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.valid);
         y(u to u+w-1) := convert(x.valid, y(u to u+w-1));
         u := u + w;
         w := width(x.xy);
         y(u to u+w-1) := convert(x.xy, y(u to u+w-1));
         u := u + w;
         w := width(x.y);
         y(u to u+w-1) := convert(x.y, y(u to u+w-1));
         u := u + w;
         w := width(x.x);
         y(u to u+w-1) := convert(x.x, y(u to u+w-1));
         u := u + w;
         w := width(x.x2);
         y(u to u+w-1) := convert(x.x2, y(u to u+w-1));
         u := u + w;
         w := width(x.n);
         y(u to u+w-1) := convert(x.n, y(u to u+w-1));
      else
         w := width(x.valid);
         y(u downto u-w+1) := convert(x.valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.xy);
         y(u downto u-w+1) := convert(x.xy, y(u downto u-w+1));
         u := u - w;
         w := width(x.y);
         y(u downto u-w+1) := convert(x.y, y(u downto u-w+1));
         u := u - w;
         w := width(x.x);
         y(u downto u-w+1) := convert(x.x, y(u downto u-w+1));
         u := u - w;
         w := width(x.x2);
         y(u downto u-w+1) := convert(x.x2, y(u downto u-w+1));
         u := u - w;
         w := width(x.n);
         y(u downto u-w+1) := convert(x.n, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: csf_sums_rt) return csf_sums_rt is
      variable y : csf_sums_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.valid);
         y.valid := convert(x(u to u+w-1), tpl.valid);
         u := u + w;
         w := width(tpl.xy);
         y.xy := convert(x(u to u+w-1), tpl.xy);
         u := u + w;
         w := width(tpl.y);
         y.y := convert(x(u to u+w-1), tpl.y);
         u := u + w;
         w := width(tpl.x);
         y.x := convert(x(u to u+w-1), tpl.x);
         u := u + w;
         w := width(tpl.x2);
         y.x2 := convert(x(u to u+w-1), tpl.x2);
         u := u + w;
         w := width(tpl.n);
         y.n := convert(x(u to u+w-1), tpl.n);
      else
         w := width(tpl.valid);
         y.valid := convert(x(u downto u-w+1), tpl.valid);
         u := u - w;
         w := width(tpl.xy);
         y.xy := convert(x(u downto u-w+1), tpl.xy);
         u := u - w;
         w := width(tpl.y);
         y.y := convert(x(u downto u-w+1), tpl.y);
         u := u - w;
         w := width(tpl.x);
         y.x := convert(x(u downto u-w+1), tpl.x);
         u := u - w;
         w := width(tpl.x2);
         y.x2 := convert(x(u downto u-w+1), tpl.x2);
         u := u - w;
         w := width(tpl.n);
         y.n := convert(x(u downto u-w+1), tpl.n);
      end if;
      return y;
   end function convert;
   function zero(tpl: csf_sums_rt) return csf_sums_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: csf_sums_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: csf_sums_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: csf_sums_art) return csf_sums_art is
      variable y : csf_sums_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: csf_sums_art) return csf_sums_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: csf_sums_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: csf_sums_art) return csf_sums_art is
      variable y : csf_sums_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: sf_seg_data_barrel_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.muid);
      w := w + width(x.mdtid);
      w := w + width(x.pos);
      w := w + width(x.angle);
      w := w + width(x.quality);
      return w;
   end function width;
   function convert(x: sf_seg_data_barrel_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.muid);
         y(u to u+w-1) := convert(x.muid, y(u to u+w-1));
         u := u + w;
         w := width(x.mdtid);
         y(u to u+w-1) := convert(x.mdtid, y(u to u+w-1));
         u := u + w;
         w := width(x.pos);
         y(u to u+w-1) := convert(x.pos, y(u to u+w-1));
         u := u + w;
         w := width(x.angle);
         y(u to u+w-1) := convert(x.angle, y(u to u+w-1));
         u := u + w;
         w := width(x.quality);
         y(u to u+w-1) := convert(x.quality, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.muid);
         y(u downto u-w+1) := convert(x.muid, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdtid);
         y(u downto u-w+1) := convert(x.mdtid, y(u downto u-w+1));
         u := u - w;
         w := width(x.pos);
         y(u downto u-w+1) := convert(x.pos, y(u downto u-w+1));
         u := u - w;
         w := width(x.angle);
         y(u downto u-w+1) := convert(x.angle, y(u downto u-w+1));
         u := u - w;
         w := width(x.quality);
         y(u downto u-w+1) := convert(x.quality, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: sf_seg_data_barrel_rt) return sf_seg_data_barrel_rt is
      variable y : sf_seg_data_barrel_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.muid);
         y.muid := convert(x(u to u+w-1), tpl.muid);
         u := u + w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u to u+w-1), tpl.mdtid);
         u := u + w;
         w := width(tpl.pos);
         y.pos := convert(x(u to u+w-1), tpl.pos);
         u := u + w;
         w := width(tpl.angle);
         y.angle := convert(x(u to u+w-1), tpl.angle);
         u := u + w;
         w := width(tpl.quality);
         y.quality := convert(x(u to u+w-1), tpl.quality);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.muid);
         y.muid := convert(x(u downto u-w+1), tpl.muid);
         u := u - w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u downto u-w+1), tpl.mdtid);
         u := u - w;
         w := width(tpl.pos);
         y.pos := convert(x(u downto u-w+1), tpl.pos);
         u := u - w;
         w := width(tpl.angle);
         y.angle := convert(x(u downto u-w+1), tpl.angle);
         u := u - w;
         w := width(tpl.quality);
         y.quality := convert(x(u downto u-w+1), tpl.quality);
      end if;
      return y;
   end function convert;
   function zero(tpl: sf_seg_data_barrel_rt) return sf_seg_data_barrel_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: sf_seg_data_endcap_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.muid);
      w := w + width(x.mdtid);
      w := w + width(x.pos);
      w := w + width(x.angle);
      w := w + width(x.quality);
      return w;
   end function width;
   function convert(x: sf_seg_data_endcap_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.muid);
         y(u to u+w-1) := convert(x.muid, y(u to u+w-1));
         u := u + w;
         w := width(x.mdtid);
         y(u to u+w-1) := convert(x.mdtid, y(u to u+w-1));
         u := u + w;
         w := width(x.pos);
         y(u to u+w-1) := convert(x.pos, y(u to u+w-1));
         u := u + w;
         w := width(x.angle);
         y(u to u+w-1) := convert(x.angle, y(u to u+w-1));
         u := u + w;
         w := width(x.quality);
         y(u to u+w-1) := convert(x.quality, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.muid);
         y(u downto u-w+1) := convert(x.muid, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdtid);
         y(u downto u-w+1) := convert(x.mdtid, y(u downto u-w+1));
         u := u - w;
         w := width(x.pos);
         y(u downto u-w+1) := convert(x.pos, y(u downto u-w+1));
         u := u - w;
         w := width(x.angle);
         y(u downto u-w+1) := convert(x.angle, y(u downto u-w+1));
         u := u - w;
         w := width(x.quality);
         y(u downto u-w+1) := convert(x.quality, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: sf_seg_data_endcap_rt) return sf_seg_data_endcap_rt is
      variable y : sf_seg_data_endcap_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.muid);
         y.muid := convert(x(u to u+w-1), tpl.muid);
         u := u + w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u to u+w-1), tpl.mdtid);
         u := u + w;
         w := width(tpl.pos);
         y.pos := convert(x(u to u+w-1), tpl.pos);
         u := u + w;
         w := width(tpl.angle);
         y.angle := convert(x(u to u+w-1), tpl.angle);
         u := u + w;
         w := width(tpl.quality);
         y.quality := convert(x(u to u+w-1), tpl.quality);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.muid);
         y.muid := convert(x(u downto u-w+1), tpl.muid);
         u := u - w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u downto u-w+1), tpl.mdtid);
         u := u - w;
         w := width(tpl.pos);
         y.pos := convert(x(u downto u-w+1), tpl.pos);
         u := u - w;
         w := width(tpl.angle);
         y.angle := convert(x(u downto u-w+1), tpl.angle);
         u := u - w;
         w := width(tpl.quality);
         y.quality := convert(x(u downto u-w+1), tpl.quality);
      end if;
      return y;
   end function convert;
   function zero(tpl: sf_seg_data_endcap_rt) return sf_seg_data_endcap_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

end package body csf_pkg;
