-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;

package hp_pkg is

  type hp_win_tubes_rt is record
    hi : unsigned(MDT_TUBE_LEN-1 downto 0);
    lo : unsigned(MDT_TUBE_LEN-1 downto 0);
  end record hp_win_tubes_rt;
  function len(x: hp_win_tubes_rt) return natural;
  function width(x: hp_win_tubes_rt) return natural;
  function vectorify(x: hp_win_tubes_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_win_tubes_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hp_win_tubes_rt) return hp_win_tubes_rt;
  function convert(x: in std_logic_vector; t: hp_win_tubes_rt) return hp_win_tubes_rt;
  function nullify(t: hp_win_tubes_rt) return hp_win_tubes_rt;
  function zeroed(t: hp_win_tubes_rt) return hp_win_tubes_rt;

  subtype hp_win_tubes_vt is std_logic_vector(18-1 downto 0);

  type hp_win_tubes_art is array(integer range <>) of hp_win_tubes_rt;
  function len(x: hp_win_tubes_art) return natural;
  function width(x: hp_win_tubes_art) return natural;
  function vectorify(x: hp_win_tubes_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_win_tubes_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: hp_win_tubes_art) return hp_win_tubes_art;
  function convert(x: std_logic_vector; t: hp_win_tubes_art) return hp_win_tubes_art;
  function nullify(x: hp_win_tubes_art) return hp_win_tubes_art;
  function zeroed(x: hp_win_tubes_art) return hp_win_tubes_art;

  type hp_win_tubes_avt is array(integer range <>) of hp_win_tubes_vt;
  function len(x: hp_win_tubes_avt) return natural;
  function width(x: hp_win_tubes_avt) return natural;
  function vectorify(x: hp_win_tubes_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_win_tubes_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: hp_win_tubes_avt) return hp_win_tubes_avt;
  function convert(x: std_logic_vector; t: hp_win_tubes_avt) return hp_win_tubes_avt;
  function nullify(x: hp_win_tubes_avt) return hp_win_tubes_avt;
  function zeroed(x: hp_win_tubes_avt) return hp_win_tubes_avt;

  type hp_win_tubes_limits_rt is record
    hi : signed(MDT_TUBE_LEN-1 downto 0);
    lo : signed(MDT_TUBE_LEN-1 downto 0);
  end record hp_win_tubes_limits_rt;
  function len(x: hp_win_tubes_limits_rt) return natural;
  function width(x: hp_win_tubes_limits_rt) return natural;
  function vectorify(x: hp_win_tubes_limits_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_win_tubes_limits_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt;
  function convert(x: in std_logic_vector; t: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt;
  function nullify(t: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt;
  function zeroed(t: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt;

  subtype hp_win_tubes_limits_vt is std_logic_vector(18-1 downto 0);

  type hp_win_tubes_limits_art is array(integer range <>) of hp_win_tubes_limits_rt;
  function len(x: hp_win_tubes_limits_art) return natural;
  function width(x: hp_win_tubes_limits_art) return natural;
  function vectorify(x: hp_win_tubes_limits_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_win_tubes_limits_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: hp_win_tubes_limits_art) return hp_win_tubes_limits_art;
  function convert(x: std_logic_vector; t: hp_win_tubes_limits_art) return hp_win_tubes_limits_art;
  function nullify(x: hp_win_tubes_limits_art) return hp_win_tubes_limits_art;
  function zeroed(x: hp_win_tubes_limits_art) return hp_win_tubes_limits_art;

  type hp_win_tubes_limits_avt is array(integer range <>) of hp_win_tubes_limits_vt;
  function len(x: hp_win_tubes_limits_avt) return natural;
  function width(x: hp_win_tubes_limits_avt) return natural;
  function vectorify(x: hp_win_tubes_limits_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_win_tubes_limits_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: hp_win_tubes_limits_avt) return hp_win_tubes_limits_avt;
  function convert(x: std_logic_vector; t: hp_win_tubes_limits_avt) return hp_win_tubes_limits_avt;
  function nullify(x: hp_win_tubes_limits_avt) return hp_win_tubes_limits_avt;
  function zeroed(x: hp_win_tubes_limits_avt) return hp_win_tubes_limits_avt;

  type hp_heg2hp_slc_b_rt is record
    roi_z : unsigned(MDT_GLOBAL_AXI_LEN-1 downto 0);
    roi_x : unsigned(MDT_GLOBAL_AXI_LEN-1 downto 0);
  end record hp_heg2hp_slc_b_rt;
  function len(x: hp_heg2hp_slc_b_rt) return natural;
  function width(x: hp_heg2hp_slc_b_rt) return natural;
  function vectorify(x: hp_heg2hp_slc_b_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_heg2hp_slc_b_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt;
  function convert(x: in std_logic_vector; t: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt;
  function nullify(t: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt;
  function zeroed(t: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt;

  constant HP_HEG2HP_SPECIFIC_LEN : integer := 38;

  type hp_heg2hp_slc_rt is record
    bcid : unsigned(BCID_LEN-1 downto 0);
    specific : std_logic_vector(HP_HEG2HP_SPECIFIC_LEN-1 downto 0);
    data_valid : std_logic;
  end record hp_heg2hp_slc_rt;
  function len(x: hp_heg2hp_slc_rt) return natural;
  function width(x: hp_heg2hp_slc_rt) return natural;
  function vectorify(x: hp_heg2hp_slc_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_heg2hp_slc_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt;
  function convert(x: in std_logic_vector; t: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt;
  function nullify(t: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt;
  function zeroed(t: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt;

  subtype hp_heg2hp_slc_vt is std_logic_vector(51-1 downto 0);

  type hp_heg2hp_slc_art is array(integer range <>) of hp_heg2hp_slc_rt;
  function len(x: hp_heg2hp_slc_art) return natural;
  function width(x: hp_heg2hp_slc_art) return natural;
  function vectorify(x: hp_heg2hp_slc_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_heg2hp_slc_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: hp_heg2hp_slc_art) return hp_heg2hp_slc_art;
  function convert(x: std_logic_vector; t: hp_heg2hp_slc_art) return hp_heg2hp_slc_art;
  function nullify(x: hp_heg2hp_slc_art) return hp_heg2hp_slc_art;
  function zeroed(x: hp_heg2hp_slc_art) return hp_heg2hp_slc_art;

  type hp_heg2hp_slc_avt is array(integer range <>) of hp_heg2hp_slc_vt;
  function len(x: hp_heg2hp_slc_avt) return natural;
  function width(x: hp_heg2hp_slc_avt) return natural;
  function vectorify(x: hp_heg2hp_slc_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_heg2hp_slc_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: hp_heg2hp_slc_avt) return hp_heg2hp_slc_avt;
  function convert(x: std_logic_vector; t: hp_heg2hp_slc_avt) return hp_heg2hp_slc_avt;
  function nullify(x: hp_heg2hp_slc_avt) return hp_heg2hp_slc_avt;
  function zeroed(x: hp_heg2hp_slc_avt) return hp_heg2hp_slc_avt;

  type hp_hpsPc2hp_rt is record
    tube : unsigned(MDT_TUBE_LEN-1 downto 0);
    layer : unsigned(MDT_LAYER_LEN-1 downto 0);
    time_t0 : unsigned(MDT_TIME_LEN-1 downto 0);
    global_z : unsigned(MDT_GLOBAL_AXI_LEN-1 downto 0);
    global_x : unsigned(MDT_GLOBAL_AXI_LEN-1 downto 0);
    data_valid : std_logic;
  end record hp_hpsPc2hp_rt;
  function len(x: hp_hpsPc2hp_rt) return natural;
  function width(x: hp_hpsPc2hp_rt) return natural;
  function vectorify(x: hp_hpsPc2hp_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_hpsPc2hp_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt;
  function convert(x: in std_logic_vector; t: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt;
  function nullify(t: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt;
  function zeroed(t: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt;

  subtype hp_hpsPc2hp_vt is std_logic_vector(70-1 downto 0);

  type hp_hp2sf_data_rt is record
    local_y : unsigned(MDT_LOCAL_Y_LEN-1 downto 0);
    local_x : unsigned(MDT_LOCAL_X_LEN-1 downto 0);
    radius : unsigned(MDT_RADIUS_LEN-1 downto 0);
    mlayer : std_logic;
  end record hp_hp2sf_data_rt;
  function len(x: hp_hp2sf_data_rt) return natural;
  function width(x: hp_hp2sf_data_rt) return natural;
  function vectorify(x: hp_hp2sf_data_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_hp2sf_data_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hp_hp2sf_data_rt) return hp_hp2sf_data_rt;
  function convert(x: in std_logic_vector; t: hp_hp2sf_data_rt) return hp_hp2sf_data_rt;
  function nullify(t: hp_hp2sf_data_rt) return hp_hp2sf_data_rt;
  function zeroed(t: hp_hp2sf_data_rt) return hp_hp2sf_data_rt;

  type hp_hp2bm_rt is record
    data : hp_hp2sf_data_rt;
    mdt_valid : std_logic;
    data_valid : std_logic;
  end record hp_hp2bm_rt;
  function len(x: hp_hp2bm_rt) return natural;
  function width(x: hp_hp2bm_rt) return natural;
  function vectorify(x: hp_hp2bm_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: hp_hp2bm_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: hp_hp2bm_rt) return hp_hp2bm_rt;
  function convert(x: in std_logic_vector; t: hp_hp2bm_rt) return hp_hp2bm_rt;
  function nullify(t: hp_hp2bm_rt) return hp_hp2bm_rt;
  function zeroed(t: hp_hp2bm_rt) return hp_hp2bm_rt;

  subtype hp_hp2bm_vt is std_logic_vector(42-1 downto 0);

end package hp_pkg;

------------------------------------------------------------

package body hp_pkg is

  function len(x: hp_win_tubes_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.hi);
    l := l + len(x.lo);
    return l;
  end function len;
  function width(x: hp_win_tubes_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.hi);
    l := l + width(x.lo);
    return l;
  end function width;
  function vectorify(x: hp_win_tubes_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.hi)-1), vectorify(x.hi, y(left to left+len(x.hi)-1)));
      left := left + len(x.hi);
      assign(y(left to left+len(x.lo)-1), vectorify(x.lo, y(left to left+len(x.lo)-1)));
    else
      assign(y(left downto left-len(x.hi)+1), vectorify(x.hi, y(left downto left-len(x.hi)+1)));
      left := left - len(x.hi);
      assign(y(left downto left-len(x.lo)+1), vectorify(x.lo, y(left downto left-len(x.lo)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_win_tubes_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.hi)-1), convert(x.hi, y(left to left+len(x.hi)-1)));
      left := left + len(x.hi);
      assign(y(left to left+len(x.lo)-1), convert(x.lo, y(left to left+len(x.lo)-1)));
    else
      assign(y(left downto left-len(x.hi)+1), convert(x.hi, y(left downto left-len(x.hi)+1)));
      left := left - len(x.hi);
      assign(y(left downto left-len(x.lo)+1), convert(x.lo, y(left downto left-len(x.lo)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hp_win_tubes_rt) return hp_win_tubes_rt is
    variable y: hp_win_tubes_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.hi := structify(x(left to left+len(y.hi)-1), y.hi);
      left := left + len(y.hi);
      y.lo := structify(x(left to left+len(y.lo)-1), y.lo);
    else
      y.hi := structify(x(left downto left-len(y.hi)+1), y.hi);
      left := left - len(y.hi);
      y.lo := structify(x(left downto left-len(y.lo)+1), y.lo);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hp_win_tubes_rt) return hp_win_tubes_rt is
    variable y: hp_win_tubes_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.hi := convert(x(left to left+len(y.hi)-1), y.hi);
      left := left + len(y.hi);
      y.lo := convert(x(left to left+len(y.lo)-1), y.lo);
    else
      y.hi := convert(x(left downto left-len(y.hi)+1), y.hi);
      left := left - len(y.hi);
      y.lo := convert(x(left downto left-len(y.lo)+1), y.lo);
    end if;
    return y;
  end function convert;
  function nullify(t: hp_win_tubes_rt) return hp_win_tubes_rt is
  variable y: hp_win_tubes_rt;
  begin
    y.hi := nullify(t.hi);
    y.lo := nullify(t.lo);
    return y;
  end function nullify;
  function zeroed(t: hp_win_tubes_rt) return hp_win_tubes_rt is
  variable y: hp_win_tubes_rt;
  begin
    y.hi := zeroed(t.hi);
    y.lo := zeroed(t.lo);
    return y;
  end function zeroed;

  function len(x: hp_win_tubes_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: hp_win_tubes_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: hp_win_tubes_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_win_tubes_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: hp_win_tubes_art) return hp_win_tubes_art is
    variable y : hp_win_tubes_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: hp_win_tubes_art) return hp_win_tubes_art is
    variable y : hp_win_tubes_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: hp_win_tubes_art) return hp_win_tubes_art is
    variable y : hp_win_tubes_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: hp_win_tubes_art) return hp_win_tubes_art is
    variable y : hp_win_tubes_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: hp_win_tubes_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: hp_win_tubes_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: hp_win_tubes_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_win_tubes_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: hp_win_tubes_avt) return hp_win_tubes_avt is
    variable y : hp_win_tubes_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: hp_win_tubes_avt) return hp_win_tubes_avt is
    variable y : hp_win_tubes_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: hp_win_tubes_avt) return hp_win_tubes_avt is
    variable y : hp_win_tubes_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: hp_win_tubes_avt) return hp_win_tubes_avt is
    variable y : hp_win_tubes_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: hp_win_tubes_limits_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.hi);
    l := l + len(x.lo);
    return l;
  end function len;
  function width(x: hp_win_tubes_limits_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.hi);
    l := l + width(x.lo);
    return l;
  end function width;
  function vectorify(x: hp_win_tubes_limits_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.hi)-1), vectorify(x.hi, y(left to left+len(x.hi)-1)));
      left := left + len(x.hi);
      assign(y(left to left+len(x.lo)-1), vectorify(x.lo, y(left to left+len(x.lo)-1)));
    else
      assign(y(left downto left-len(x.hi)+1), vectorify(x.hi, y(left downto left-len(x.hi)+1)));
      left := left - len(x.hi);
      assign(y(left downto left-len(x.lo)+1), vectorify(x.lo, y(left downto left-len(x.lo)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_win_tubes_limits_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.hi)-1), convert(x.hi, y(left to left+len(x.hi)-1)));
      left := left + len(x.hi);
      assign(y(left to left+len(x.lo)-1), convert(x.lo, y(left to left+len(x.lo)-1)));
    else
      assign(y(left downto left-len(x.hi)+1), convert(x.hi, y(left downto left-len(x.hi)+1)));
      left := left - len(x.hi);
      assign(y(left downto left-len(x.lo)+1), convert(x.lo, y(left downto left-len(x.lo)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt is
    variable y: hp_win_tubes_limits_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.hi := structify(x(left to left+len(y.hi)-1), y.hi);
      left := left + len(y.hi);
      y.lo := structify(x(left to left+len(y.lo)-1), y.lo);
    else
      y.hi := structify(x(left downto left-len(y.hi)+1), y.hi);
      left := left - len(y.hi);
      y.lo := structify(x(left downto left-len(y.lo)+1), y.lo);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt is
    variable y: hp_win_tubes_limits_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.hi := convert(x(left to left+len(y.hi)-1), y.hi);
      left := left + len(y.hi);
      y.lo := convert(x(left to left+len(y.lo)-1), y.lo);
    else
      y.hi := convert(x(left downto left-len(y.hi)+1), y.hi);
      left := left - len(y.hi);
      y.lo := convert(x(left downto left-len(y.lo)+1), y.lo);
    end if;
    return y;
  end function convert;
  function nullify(t: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt is
  variable y: hp_win_tubes_limits_rt;
  begin
    y.hi := nullify(t.hi);
    y.lo := nullify(t.lo);
    return y;
  end function nullify;
  function zeroed(t: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt is
  variable y: hp_win_tubes_limits_rt;
  begin
    y.hi := zeroed(t.hi);
    y.lo := zeroed(t.lo);
    return y;
  end function zeroed;

  function len(x: hp_win_tubes_limits_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: hp_win_tubes_limits_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: hp_win_tubes_limits_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_win_tubes_limits_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: hp_win_tubes_limits_art) return hp_win_tubes_limits_art is
    variable y : hp_win_tubes_limits_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: hp_win_tubes_limits_art) return hp_win_tubes_limits_art is
    variable y : hp_win_tubes_limits_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: hp_win_tubes_limits_art) return hp_win_tubes_limits_art is
    variable y : hp_win_tubes_limits_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: hp_win_tubes_limits_art) return hp_win_tubes_limits_art is
    variable y : hp_win_tubes_limits_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: hp_win_tubes_limits_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: hp_win_tubes_limits_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: hp_win_tubes_limits_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_win_tubes_limits_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: hp_win_tubes_limits_avt) return hp_win_tubes_limits_avt is
    variable y : hp_win_tubes_limits_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: hp_win_tubes_limits_avt) return hp_win_tubes_limits_avt is
    variable y : hp_win_tubes_limits_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: hp_win_tubes_limits_avt) return hp_win_tubes_limits_avt is
    variable y : hp_win_tubes_limits_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: hp_win_tubes_limits_avt) return hp_win_tubes_limits_avt is
    variable y : hp_win_tubes_limits_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: hp_heg2hp_slc_b_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.roi_z);
    l := l + len(x.roi_x);
    return l;
  end function len;
  function width(x: hp_heg2hp_slc_b_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.roi_z);
    l := l + width(x.roi_x);
    return l;
  end function width;
  function vectorify(x: hp_heg2hp_slc_b_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.roi_z)-1), vectorify(x.roi_z, y(left to left+len(x.roi_z)-1)));
      left := left + len(x.roi_z);
      assign(y(left to left+len(x.roi_x)-1), vectorify(x.roi_x, y(left to left+len(x.roi_x)-1)));
    else
      assign(y(left downto left-len(x.roi_z)+1), vectorify(x.roi_z, y(left downto left-len(x.roi_z)+1)));
      left := left - len(x.roi_z);
      assign(y(left downto left-len(x.roi_x)+1), vectorify(x.roi_x, y(left downto left-len(x.roi_x)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_heg2hp_slc_b_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.roi_z)-1), convert(x.roi_z, y(left to left+len(x.roi_z)-1)));
      left := left + len(x.roi_z);
      assign(y(left to left+len(x.roi_x)-1), convert(x.roi_x, y(left to left+len(x.roi_x)-1)));
    else
      assign(y(left downto left-len(x.roi_z)+1), convert(x.roi_z, y(left downto left-len(x.roi_z)+1)));
      left := left - len(x.roi_z);
      assign(y(left downto left-len(x.roi_x)+1), convert(x.roi_x, y(left downto left-len(x.roi_x)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt is
    variable y: hp_heg2hp_slc_b_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.roi_z := structify(x(left to left+len(y.roi_z)-1), y.roi_z);
      left := left + len(y.roi_z);
      y.roi_x := structify(x(left to left+len(y.roi_x)-1), y.roi_x);
    else
      y.roi_z := structify(x(left downto left-len(y.roi_z)+1), y.roi_z);
      left := left - len(y.roi_z);
      y.roi_x := structify(x(left downto left-len(y.roi_x)+1), y.roi_x);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt is
    variable y: hp_heg2hp_slc_b_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.roi_z := convert(x(left to left+len(y.roi_z)-1), y.roi_z);
      left := left + len(y.roi_z);
      y.roi_x := convert(x(left to left+len(y.roi_x)-1), y.roi_x);
    else
      y.roi_z := convert(x(left downto left-len(y.roi_z)+1), y.roi_z);
      left := left - len(y.roi_z);
      y.roi_x := convert(x(left downto left-len(y.roi_x)+1), y.roi_x);
    end if;
    return y;
  end function convert;
  function nullify(t: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt is
  variable y: hp_heg2hp_slc_b_rt;
  begin
    y.roi_z := nullify(t.roi_z);
    y.roi_x := nullify(t.roi_x);
    return y;
  end function nullify;
  function zeroed(t: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt is
  variable y: hp_heg2hp_slc_b_rt;
  begin
    y.roi_z := zeroed(t.roi_z);
    y.roi_x := zeroed(t.roi_x);
    return y;
  end function zeroed;

  function len(x: hp_heg2hp_slc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.bcid);
    l := l + len(x.specific);
    l := l + len(x.data_valid);
    return l;
  end function len;
  function width(x: hp_heg2hp_slc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.bcid);
    l := l + width(x.specific);
    l := l + width(x.data_valid);
    return l;
  end function width;
  function vectorify(x: hp_heg2hp_slc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcid)-1), vectorify(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.specific)-1), vectorify(x.specific, y(left to left+len(x.specific)-1)));
      left := left + len(x.specific);
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.bcid)+1), vectorify(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.specific)+1), vectorify(x.specific, y(left downto left-len(x.specific)+1)));
      left := left - len(x.specific);
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_heg2hp_slc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcid)-1), convert(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.specific)-1), convert(x.specific, y(left to left+len(x.specific)-1)));
      left := left + len(x.specific);
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.bcid)+1), convert(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.specific)+1), convert(x.specific, y(left downto left-len(x.specific)+1)));
      left := left - len(x.specific);
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt is
    variable y: hp_heg2hp_slc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcid := structify(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.specific := structify(x(left to left+len(y.specific)-1), y.specific);
      left := left + len(y.specific);
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.bcid := structify(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.specific := structify(x(left downto left-len(y.specific)+1), y.specific);
      left := left - len(y.specific);
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt is
    variable y: hp_heg2hp_slc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcid := convert(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.specific := convert(x(left to left+len(y.specific)-1), y.specific);
      left := left + len(y.specific);
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.bcid := convert(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.specific := convert(x(left downto left-len(y.specific)+1), y.specific);
      left := left - len(y.specific);
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt is
  variable y: hp_heg2hp_slc_rt;
  begin
    y.bcid := nullify(t.bcid);
    y.specific := nullify(t.specific);
    y.data_valid := nullify(t.data_valid);
    return y;
  end function nullify;
  function zeroed(t: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt is
  variable y: hp_heg2hp_slc_rt;
  begin
    y.bcid := zeroed(t.bcid);
    y.specific := zeroed(t.specific);
    y.data_valid := zeroed(t.data_valid);
    return y;
  end function zeroed;

  function len(x: hp_heg2hp_slc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: hp_heg2hp_slc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: hp_heg2hp_slc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_heg2hp_slc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: hp_heg2hp_slc_art) return hp_heg2hp_slc_art is
    variable y : hp_heg2hp_slc_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: hp_heg2hp_slc_art) return hp_heg2hp_slc_art is
    variable y : hp_heg2hp_slc_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: hp_heg2hp_slc_art) return hp_heg2hp_slc_art is
    variable y : hp_heg2hp_slc_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: hp_heg2hp_slc_art) return hp_heg2hp_slc_art is
    variable y : hp_heg2hp_slc_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: hp_heg2hp_slc_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: hp_heg2hp_slc_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: hp_heg2hp_slc_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_heg2hp_slc_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: hp_heg2hp_slc_avt) return hp_heg2hp_slc_avt is
    variable y : hp_heg2hp_slc_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: hp_heg2hp_slc_avt) return hp_heg2hp_slc_avt is
    variable y : hp_heg2hp_slc_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: hp_heg2hp_slc_avt) return hp_heg2hp_slc_avt is
    variable y : hp_heg2hp_slc_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: hp_heg2hp_slc_avt) return hp_heg2hp_slc_avt is
    variable y : hp_heg2hp_slc_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: hp_hpsPc2hp_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.tube);
    l := l + len(x.layer);
    l := l + len(x.time_t0);
    l := l + len(x.global_z);
    l := l + len(x.global_x);
    l := l + len(x.data_valid);
    return l;
  end function len;
  function width(x: hp_hpsPc2hp_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.tube);
    l := l + width(x.layer);
    l := l + width(x.time_t0);
    l := l + width(x.global_z);
    l := l + width(x.global_x);
    l := l + width(x.data_valid);
    return l;
  end function width;
  function vectorify(x: hp_hpsPc2hp_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.tube)-1), vectorify(x.tube, y(left to left+len(x.tube)-1)));
      left := left + len(x.tube);
      assign(y(left to left+len(x.layer)-1), vectorify(x.layer, y(left to left+len(x.layer)-1)));
      left := left + len(x.layer);
      assign(y(left to left+len(x.time_t0)-1), vectorify(x.time_t0, y(left to left+len(x.time_t0)-1)));
      left := left + len(x.time_t0);
      assign(y(left to left+len(x.global_z)-1), vectorify(x.global_z, y(left to left+len(x.global_z)-1)));
      left := left + len(x.global_z);
      assign(y(left to left+len(x.global_x)-1), vectorify(x.global_x, y(left to left+len(x.global_x)-1)));
      left := left + len(x.global_x);
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.tube)+1), vectorify(x.tube, y(left downto left-len(x.tube)+1)));
      left := left - len(x.tube);
      assign(y(left downto left-len(x.layer)+1), vectorify(x.layer, y(left downto left-len(x.layer)+1)));
      left := left - len(x.layer);
      assign(y(left downto left-len(x.time_t0)+1), vectorify(x.time_t0, y(left downto left-len(x.time_t0)+1)));
      left := left - len(x.time_t0);
      assign(y(left downto left-len(x.global_z)+1), vectorify(x.global_z, y(left downto left-len(x.global_z)+1)));
      left := left - len(x.global_z);
      assign(y(left downto left-len(x.global_x)+1), vectorify(x.global_x, y(left downto left-len(x.global_x)+1)));
      left := left - len(x.global_x);
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_hpsPc2hp_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.tube)-1), convert(x.tube, y(left to left+len(x.tube)-1)));
      left := left + len(x.tube);
      assign(y(left to left+len(x.layer)-1), convert(x.layer, y(left to left+len(x.layer)-1)));
      left := left + len(x.layer);
      assign(y(left to left+len(x.time_t0)-1), convert(x.time_t0, y(left to left+len(x.time_t0)-1)));
      left := left + len(x.time_t0);
      assign(y(left to left+len(x.global_z)-1), convert(x.global_z, y(left to left+len(x.global_z)-1)));
      left := left + len(x.global_z);
      assign(y(left to left+len(x.global_x)-1), convert(x.global_x, y(left to left+len(x.global_x)-1)));
      left := left + len(x.global_x);
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.tube)+1), convert(x.tube, y(left downto left-len(x.tube)+1)));
      left := left - len(x.tube);
      assign(y(left downto left-len(x.layer)+1), convert(x.layer, y(left downto left-len(x.layer)+1)));
      left := left - len(x.layer);
      assign(y(left downto left-len(x.time_t0)+1), convert(x.time_t0, y(left downto left-len(x.time_t0)+1)));
      left := left - len(x.time_t0);
      assign(y(left downto left-len(x.global_z)+1), convert(x.global_z, y(left downto left-len(x.global_z)+1)));
      left := left - len(x.global_z);
      assign(y(left downto left-len(x.global_x)+1), convert(x.global_x, y(left downto left-len(x.global_x)+1)));
      left := left - len(x.global_x);
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt is
    variable y: hp_hpsPc2hp_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.tube := structify(x(left to left+len(y.tube)-1), y.tube);
      left := left + len(y.tube);
      y.layer := structify(x(left to left+len(y.layer)-1), y.layer);
      left := left + len(y.layer);
      y.time_t0 := structify(x(left to left+len(y.time_t0)-1), y.time_t0);
      left := left + len(y.time_t0);
      y.global_z := structify(x(left to left+len(y.global_z)-1), y.global_z);
      left := left + len(y.global_z);
      y.global_x := structify(x(left to left+len(y.global_x)-1), y.global_x);
      left := left + len(y.global_x);
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.tube := structify(x(left downto left-len(y.tube)+1), y.tube);
      left := left - len(y.tube);
      y.layer := structify(x(left downto left-len(y.layer)+1), y.layer);
      left := left - len(y.layer);
      y.time_t0 := structify(x(left downto left-len(y.time_t0)+1), y.time_t0);
      left := left - len(y.time_t0);
      y.global_z := structify(x(left downto left-len(y.global_z)+1), y.global_z);
      left := left - len(y.global_z);
      y.global_x := structify(x(left downto left-len(y.global_x)+1), y.global_x);
      left := left - len(y.global_x);
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt is
    variable y: hp_hpsPc2hp_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.tube := convert(x(left to left+len(y.tube)-1), y.tube);
      left := left + len(y.tube);
      y.layer := convert(x(left to left+len(y.layer)-1), y.layer);
      left := left + len(y.layer);
      y.time_t0 := convert(x(left to left+len(y.time_t0)-1), y.time_t0);
      left := left + len(y.time_t0);
      y.global_z := convert(x(left to left+len(y.global_z)-1), y.global_z);
      left := left + len(y.global_z);
      y.global_x := convert(x(left to left+len(y.global_x)-1), y.global_x);
      left := left + len(y.global_x);
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.tube := convert(x(left downto left-len(y.tube)+1), y.tube);
      left := left - len(y.tube);
      y.layer := convert(x(left downto left-len(y.layer)+1), y.layer);
      left := left - len(y.layer);
      y.time_t0 := convert(x(left downto left-len(y.time_t0)+1), y.time_t0);
      left := left - len(y.time_t0);
      y.global_z := convert(x(left downto left-len(y.global_z)+1), y.global_z);
      left := left - len(y.global_z);
      y.global_x := convert(x(left downto left-len(y.global_x)+1), y.global_x);
      left := left - len(y.global_x);
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt is
  variable y: hp_hpsPc2hp_rt;
  begin
    y.tube := nullify(t.tube);
    y.layer := nullify(t.layer);
    y.time_t0 := nullify(t.time_t0);
    y.global_z := nullify(t.global_z);
    y.global_x := nullify(t.global_x);
    y.data_valid := nullify(t.data_valid);
    return y;
  end function nullify;
  function zeroed(t: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt is
  variable y: hp_hpsPc2hp_rt;
  begin
    y.tube := zeroed(t.tube);
    y.layer := zeroed(t.layer);
    y.time_t0 := zeroed(t.time_t0);
    y.global_z := zeroed(t.global_z);
    y.global_x := zeroed(t.global_x);
    y.data_valid := zeroed(t.data_valid);
    return y;
  end function zeroed;

  function len(x: hp_hp2sf_data_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.local_y);
    l := l + len(x.local_x);
    l := l + len(x.radius);
    l := l + len(x.mlayer);
    return l;
  end function len;
  function width(x: hp_hp2sf_data_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.local_y);
    l := l + width(x.local_x);
    l := l + width(x.radius);
    l := l + width(x.mlayer);
    return l;
  end function width;
  function vectorify(x: hp_hp2sf_data_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.local_y)-1), vectorify(x.local_y, y(left to left+len(x.local_y)-1)));
      left := left + len(x.local_y);
      assign(y(left to left+len(x.local_x)-1), vectorify(x.local_x, y(left to left+len(x.local_x)-1)));
      left := left + len(x.local_x);
      assign(y(left to left+len(x.radius)-1), vectorify(x.radius, y(left to left+len(x.radius)-1)));
      left := left + len(x.radius);
      assign(y(left to left+len(x.mlayer)-1), vectorify(x.mlayer, y(left to left+len(x.mlayer)-1)));
    else
      assign(y(left downto left-len(x.local_y)+1), vectorify(x.local_y, y(left downto left-len(x.local_y)+1)));
      left := left - len(x.local_y);
      assign(y(left downto left-len(x.local_x)+1), vectorify(x.local_x, y(left downto left-len(x.local_x)+1)));
      left := left - len(x.local_x);
      assign(y(left downto left-len(x.radius)+1), vectorify(x.radius, y(left downto left-len(x.radius)+1)));
      left := left - len(x.radius);
      assign(y(left downto left-len(x.mlayer)+1), vectorify(x.mlayer, y(left downto left-len(x.mlayer)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_hp2sf_data_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.local_y)-1), convert(x.local_y, y(left to left+len(x.local_y)-1)));
      left := left + len(x.local_y);
      assign(y(left to left+len(x.local_x)-1), convert(x.local_x, y(left to left+len(x.local_x)-1)));
      left := left + len(x.local_x);
      assign(y(left to left+len(x.radius)-1), convert(x.radius, y(left to left+len(x.radius)-1)));
      left := left + len(x.radius);
      assign(y(left to left+len(x.mlayer)-1), convert(x.mlayer, y(left to left+len(x.mlayer)-1)));
    else
      assign(y(left downto left-len(x.local_y)+1), convert(x.local_y, y(left downto left-len(x.local_y)+1)));
      left := left - len(x.local_y);
      assign(y(left downto left-len(x.local_x)+1), convert(x.local_x, y(left downto left-len(x.local_x)+1)));
      left := left - len(x.local_x);
      assign(y(left downto left-len(x.radius)+1), convert(x.radius, y(left downto left-len(x.radius)+1)));
      left := left - len(x.radius);
      assign(y(left downto left-len(x.mlayer)+1), convert(x.mlayer, y(left downto left-len(x.mlayer)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hp_hp2sf_data_rt) return hp_hp2sf_data_rt is
    variable y: hp_hp2sf_data_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.local_y := structify(x(left to left+len(y.local_y)-1), y.local_y);
      left := left + len(y.local_y);
      y.local_x := structify(x(left to left+len(y.local_x)-1), y.local_x);
      left := left + len(y.local_x);
      y.radius := structify(x(left to left+len(y.radius)-1), y.radius);
      left := left + len(y.radius);
      y.mlayer := structify(x(left to left+len(y.mlayer)-1), y.mlayer);
    else
      y.local_y := structify(x(left downto left-len(y.local_y)+1), y.local_y);
      left := left - len(y.local_y);
      y.local_x := structify(x(left downto left-len(y.local_x)+1), y.local_x);
      left := left - len(y.local_x);
      y.radius := structify(x(left downto left-len(y.radius)+1), y.radius);
      left := left - len(y.radius);
      y.mlayer := structify(x(left downto left-len(y.mlayer)+1), y.mlayer);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hp_hp2sf_data_rt) return hp_hp2sf_data_rt is
    variable y: hp_hp2sf_data_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.local_y := convert(x(left to left+len(y.local_y)-1), y.local_y);
      left := left + len(y.local_y);
      y.local_x := convert(x(left to left+len(y.local_x)-1), y.local_x);
      left := left + len(y.local_x);
      y.radius := convert(x(left to left+len(y.radius)-1), y.radius);
      left := left + len(y.radius);
      y.mlayer := convert(x(left to left+len(y.mlayer)-1), y.mlayer);
    else
      y.local_y := convert(x(left downto left-len(y.local_y)+1), y.local_y);
      left := left - len(y.local_y);
      y.local_x := convert(x(left downto left-len(y.local_x)+1), y.local_x);
      left := left - len(y.local_x);
      y.radius := convert(x(left downto left-len(y.radius)+1), y.radius);
      left := left - len(y.radius);
      y.mlayer := convert(x(left downto left-len(y.mlayer)+1), y.mlayer);
    end if;
    return y;
  end function convert;
  function nullify(t: hp_hp2sf_data_rt) return hp_hp2sf_data_rt is
  variable y: hp_hp2sf_data_rt;
  begin
    y.local_y := nullify(t.local_y);
    y.local_x := nullify(t.local_x);
    y.radius := nullify(t.radius);
    y.mlayer := nullify(t.mlayer);
    return y;
  end function nullify;
  function zeroed(t: hp_hp2sf_data_rt) return hp_hp2sf_data_rt is
  variable y: hp_hp2sf_data_rt;
  begin
    y.local_y := zeroed(t.local_y);
    y.local_x := zeroed(t.local_x);
    y.radius := zeroed(t.radius);
    y.mlayer := zeroed(t.mlayer);
    return y;
  end function zeroed;

  function len(x: hp_hp2bm_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data);
    l := l + len(x.mdt_valid);
    l := l + len(x.data_valid);
    return l;
  end function len;
  function width(x: hp_hp2bm_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data);
    l := l + width(x.mdt_valid);
    l := l + width(x.data_valid);
    return l;
  end function width;
  function vectorify(x: hp_hp2bm_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
      left := left + len(x.data);
      assign(y(left to left+len(x.mdt_valid)-1), vectorify(x.mdt_valid, y(left to left+len(x.mdt_valid)-1)));
      left := left + len(x.mdt_valid);
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
      left := left - len(x.data);
      assign(y(left downto left-len(x.mdt_valid)+1), vectorify(x.mdt_valid, y(left downto left-len(x.mdt_valid)+1)));
      left := left - len(x.mdt_valid);
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: hp_hp2bm_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
      left := left + len(x.data);
      assign(y(left to left+len(x.mdt_valid)-1), convert(x.mdt_valid, y(left to left+len(x.mdt_valid)-1)));
      left := left + len(x.mdt_valid);
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
      left := left - len(x.data);
      assign(y(left downto left-len(x.mdt_valid)+1), convert(x.mdt_valid, y(left downto left-len(x.mdt_valid)+1)));
      left := left - len(x.mdt_valid);
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: hp_hp2bm_rt) return hp_hp2bm_rt is
    variable y: hp_hp2bm_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data := structify(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.mdt_valid := structify(x(left to left+len(y.mdt_valid)-1), y.mdt_valid);
      left := left + len(y.mdt_valid);
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.mdt_valid := structify(x(left downto left-len(y.mdt_valid)+1), y.mdt_valid);
      left := left - len(y.mdt_valid);
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: hp_hp2bm_rt) return hp_hp2bm_rt is
    variable y: hp_hp2bm_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data := convert(x(left to left+len(y.data)-1), y.data);
      left := left + len(y.data);
      y.mdt_valid := convert(x(left to left+len(y.mdt_valid)-1), y.mdt_valid);
      left := left + len(y.mdt_valid);
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
      left := left - len(y.data);
      y.mdt_valid := convert(x(left downto left-len(y.mdt_valid)+1), y.mdt_valid);
      left := left - len(y.mdt_valid);
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: hp_hp2bm_rt) return hp_hp2bm_rt is
  variable y: hp_hp2bm_rt;
  begin
    y.data := nullify(t.data);
    y.mdt_valid := nullify(t.mdt_valid);
    y.data_valid := nullify(t.data_valid);
    return y;
  end function nullify;
  function zeroed(t: hp_hp2bm_rt) return hp_hp2bm_rt is
  variable y: hp_hp2bm_rt;
  begin
    y.data := zeroed(t.data);
    y.mdt_valid := zeroed(t.mdt_valid);
    y.data_valid := zeroed(t.data_valid);
    return y;
  end function zeroed;

end package body hp_pkg;
