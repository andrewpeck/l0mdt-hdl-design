-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_ieee_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package hp_pkg is

   -- Custom types and functions --

   type hp_win_tubes_rt is record
      hi : unsigned(MDT_TUBE_LEN-1 downto 0);
      lo : unsigned(MDT_TUBE_LEN-1 downto 0);
   end record hp_win_tubes_rt;
   attribute w of hp_win_tubes_rt : type is 18;
   function width(x: hp_win_tubes_rt) return natural;
   function convert(x: hp_win_tubes_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_win_tubes_rt) return hp_win_tubes_rt;
   function zero(tpl: hp_win_tubes_rt) return hp_win_tubes_rt;

   subtype hp_win_tubes_vt is std_logic_vector(hp_win_tubes_rt'w-1 downto 0);
   attribute w of hp_win_tubes_vt : subtype is 18;

   type hp_win_tubes_art is array(integer range <>) of hp_win_tubes_rt;
   function width(x: hp_win_tubes_art) return integer;
   function convert(x: hp_win_tubes_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_win_tubes_art) return hp_win_tubes_art;
   function zero(tpl: hp_win_tubes_art) return hp_win_tubes_art;
   function convert(x: hp_win_tubes_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: hp_win_tubes_art) return hp_win_tubes_art;

   subtype hp_win_tubes_avt is std_logic_vector_array(open)(hp_win_tubes_rt'w-1 downto 0);

   type hp_win_tubes_limits_rt is record
      hi : signed(MDT_TUBE_LEN-1 downto 0);
      lo : signed(MDT_TUBE_LEN-1 downto 0);
   end record hp_win_tubes_limits_rt;
   attribute w of hp_win_tubes_limits_rt : type is 18;
   function width(x: hp_win_tubes_limits_rt) return natural;
   function convert(x: hp_win_tubes_limits_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt;
   function zero(tpl: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt;

   subtype hp_win_tubes_limits_vt is std_logic_vector(hp_win_tubes_limits_rt'w-1 downto 0);
   attribute w of hp_win_tubes_limits_vt : subtype is 18;

   type hp_win_tubes_limits_art is array(integer range <>) of hp_win_tubes_limits_rt;
   function width(x: hp_win_tubes_limits_art) return integer;
   function convert(x: hp_win_tubes_limits_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_win_tubes_limits_art) return hp_win_tubes_limits_art;
   function zero(tpl: hp_win_tubes_limits_art) return hp_win_tubes_limits_art;
   function convert(x: hp_win_tubes_limits_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: hp_win_tubes_limits_art) return hp_win_tubes_limits_art;

   subtype hp_win_tubes_limits_avt is std_logic_vector_array(open)(hp_win_tubes_limits_rt'w-1 downto 0);

   type hp_heg2hp_slc_b_rt is record
      roi_z : unsigned(MDT_GLOBAL_AXI_LEN-1 downto 0);
      roi_x : unsigned(MDT_GLOBAL_AXI_LEN-1 downto 0);
   end record hp_heg2hp_slc_b_rt;
   attribute w of hp_heg2hp_slc_b_rt : type is 38;
   function width(x: hp_heg2hp_slc_b_rt) return natural;
   function convert(x: hp_heg2hp_slc_b_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt;
   function zero(tpl: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt;

   constant HP_HEG2HP_SPECIFIC_LEN : integer := 38;
   attribute w of HP_HEG2HP_SPECIFIC_LEN : constant is 32;

   type hp_heg2hp_slc_rt is record
      bcid : unsigned(BCID_LEN-1 downto 0);
      specific : std_logic_vector(HP_HEG2HP_SPECIFIC_LEN-1 downto 0);
      data_valid : std_logic;
   end record hp_heg2hp_slc_rt;
   attribute w of hp_heg2hp_slc_rt : type is 51;
   function width(x: hp_heg2hp_slc_rt) return natural;
   function convert(x: hp_heg2hp_slc_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt;
   function zero(tpl: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt;

   subtype hp_heg2hp_slc_vt is std_logic_vector(hp_heg2hp_slc_rt'w-1 downto 0);
   attribute w of hp_heg2hp_slc_vt : subtype is 51;

   type hp_heg2hp_slc_art is array(integer range <>) of hp_heg2hp_slc_rt;
   function width(x: hp_heg2hp_slc_art) return integer;
   function convert(x: hp_heg2hp_slc_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_heg2hp_slc_art) return hp_heg2hp_slc_art;
   function zero(tpl: hp_heg2hp_slc_art) return hp_heg2hp_slc_art;
   function convert(x: hp_heg2hp_slc_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: hp_heg2hp_slc_art) return hp_heg2hp_slc_art;

   subtype hp_heg2hp_slc_avt is std_logic_vector_array(open)(hp_heg2hp_slc_rt'w-1 downto 0);

   type hp_hpsPc2hp_rt is record
      tube : unsigned(MDT_TUBE_LEN-1 downto 0);
      layer : unsigned(MDT_LAYER_LEN-1 downto 0);
      time_t0 : unsigned(MDT_TIME_LEN-1 downto 0);
      global_z : unsigned(MDT_GLOBAL_AXI_LEN-1 downto 0);
      global_x : unsigned(MDT_GLOBAL_AXI_LEN-1 downto 0);
      data_valid : std_logic;
   end record hp_hpsPc2hp_rt;
   attribute w of hp_hpsPc2hp_rt : type is 70;
   function width(x: hp_hpsPc2hp_rt) return natural;
   function convert(x: hp_hpsPc2hp_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt;
   function zero(tpl: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt;

   subtype hp_hpsPc2hp_vt is std_logic_vector(hp_hpsPc2hp_rt'w-1 downto 0);
   attribute w of hp_hpsPc2hp_vt : subtype is 70;

   type hp_hp2sf_data_rt is record
      local_y : unsigned(MDT_LOCAL_Y_LEN-1 downto 0);
      local_x : unsigned(MDT_LOCAL_X_LEN-1 downto 0);
      radius : unsigned(MDT_RADIUS_LEN-1 downto 0);
      mlayer : std_logic;
   end record hp_hp2sf_data_rt;
   attribute w of hp_hp2sf_data_rt : type is 40;
   function width(x: hp_hp2sf_data_rt) return natural;
   function convert(x: hp_hp2sf_data_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_hp2sf_data_rt) return hp_hp2sf_data_rt;
   function zero(tpl: hp_hp2sf_data_rt) return hp_hp2sf_data_rt;

   subtype hp_hp2sf_data_vt is std_logic_vector(hp_hp2sf_data_rt'w-1 downto 0);
   attribute w of hp_hp2sf_data_vt : subtype is 40;

   type hp_hp2sf_data_art is array(integer range <>) of hp_hp2sf_data_rt;
   function width(x: hp_hp2sf_data_art) return integer;
   function convert(x: hp_hp2sf_data_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_hp2sf_data_art) return hp_hp2sf_data_art;
   function zero(tpl: hp_hp2sf_data_art) return hp_hp2sf_data_art;
   function convert(x: hp_hp2sf_data_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: hp_hp2sf_data_art) return hp_hp2sf_data_art;

   subtype hp_hp2sf_data_avt is std_logic_vector_array(open)(hp_hp2sf_data_rt'w-1 downto 0);

   type hp_hp2bm_rt is record
      data : hp_hp2sf_data_rt;
      mdt_valid : std_logic;
      data_valid : std_logic;
   end record hp_hp2bm_rt;
   attribute w of hp_hp2bm_rt : type is 42;
   function width(x: hp_hp2bm_rt) return natural;
   function convert(x: hp_hp2bm_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: hp_hp2bm_rt) return hp_hp2bm_rt;
   function zero(tpl: hp_hp2bm_rt) return hp_hp2bm_rt;

   subtype hp_hp2bm_vt is std_logic_vector(hp_hp2bm_rt'w-1 downto 0);
   attribute w of hp_hp2bm_vt : subtype is 42;

end package hp_pkg;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_ieee_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package body hp_pkg is

   -- Custom types and functions --

   function width(x: hp_win_tubes_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.hi);
      w := w + width(x.lo);
      return w;
   end function width;
   function convert(x: hp_win_tubes_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.hi);
         y(u to u+w-1) := convert(x.hi, y(u to u+w-1));
         u := u + w;
         w := width(x.lo);
         y(u to u+w-1) := convert(x.lo, y(u to u+w-1));
      else
         w := width(x.hi);
         y(u downto u-w+1) := convert(x.hi, y(u downto u-w+1));
         u := u - w;
         w := width(x.lo);
         y(u downto u-w+1) := convert(x.lo, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_win_tubes_rt) return hp_win_tubes_rt is
      variable y : hp_win_tubes_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.hi);
         y.hi := convert(x(u to u+w-1), tpl.hi);
         u := u + w;
         w := width(tpl.lo);
         y.lo := convert(x(u to u+w-1), tpl.lo);
      else
         w := width(tpl.hi);
         y.hi := convert(x(u downto u-w+1), tpl.hi);
         u := u - w;
         w := width(tpl.lo);
         y.lo := convert(x(u downto u-w+1), tpl.lo);
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_win_tubes_rt) return hp_win_tubes_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: hp_win_tubes_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: hp_win_tubes_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_win_tubes_art) return hp_win_tubes_art is
      variable y : hp_win_tubes_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_win_tubes_art) return hp_win_tubes_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: hp_win_tubes_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: hp_win_tubes_art) return hp_win_tubes_art is
      variable y : hp_win_tubes_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: hp_win_tubes_limits_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.hi);
      w := w + width(x.lo);
      return w;
   end function width;
   function convert(x: hp_win_tubes_limits_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.hi);
         y(u to u+w-1) := convert(x.hi, y(u to u+w-1));
         u := u + w;
         w := width(x.lo);
         y(u to u+w-1) := convert(x.lo, y(u to u+w-1));
      else
         w := width(x.hi);
         y(u downto u-w+1) := convert(x.hi, y(u downto u-w+1));
         u := u - w;
         w := width(x.lo);
         y(u downto u-w+1) := convert(x.lo, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt is
      variable y : hp_win_tubes_limits_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.hi);
         y.hi := convert(x(u to u+w-1), tpl.hi);
         u := u + w;
         w := width(tpl.lo);
         y.lo := convert(x(u to u+w-1), tpl.lo);
      else
         w := width(tpl.hi);
         y.hi := convert(x(u downto u-w+1), tpl.hi);
         u := u - w;
         w := width(tpl.lo);
         y.lo := convert(x(u downto u-w+1), tpl.lo);
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_win_tubes_limits_rt) return hp_win_tubes_limits_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: hp_win_tubes_limits_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: hp_win_tubes_limits_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_win_tubes_limits_art) return hp_win_tubes_limits_art is
      variable y : hp_win_tubes_limits_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_win_tubes_limits_art) return hp_win_tubes_limits_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: hp_win_tubes_limits_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: hp_win_tubes_limits_art) return hp_win_tubes_limits_art is
      variable y : hp_win_tubes_limits_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: hp_heg2hp_slc_b_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.roi_z);
      w := w + width(x.roi_x);
      return w;
   end function width;
   function convert(x: hp_heg2hp_slc_b_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.roi_z);
         y(u to u+w-1) := convert(x.roi_z, y(u to u+w-1));
         u := u + w;
         w := width(x.roi_x);
         y(u to u+w-1) := convert(x.roi_x, y(u to u+w-1));
      else
         w := width(x.roi_z);
         y(u downto u-w+1) := convert(x.roi_z, y(u downto u-w+1));
         u := u - w;
         w := width(x.roi_x);
         y(u downto u-w+1) := convert(x.roi_x, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt is
      variable y : hp_heg2hp_slc_b_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.roi_z);
         y.roi_z := convert(x(u to u+w-1), tpl.roi_z);
         u := u + w;
         w := width(tpl.roi_x);
         y.roi_x := convert(x(u to u+w-1), tpl.roi_x);
      else
         w := width(tpl.roi_z);
         y.roi_z := convert(x(u downto u-w+1), tpl.roi_z);
         u := u - w;
         w := width(tpl.roi_x);
         y.roi_x := convert(x(u downto u-w+1), tpl.roi_x);
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_heg2hp_slc_b_rt) return hp_heg2hp_slc_b_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: hp_heg2hp_slc_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.bcid);
      w := w + width(x.specific);
      w := w + width(x.data_valid);
      return w;
   end function width;
   function convert(x: hp_heg2hp_slc_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.bcid);
         y(u to u+w-1) := convert(x.bcid, y(u to u+w-1));
         u := u + w;
         w := width(x.specific);
         y(u to u+w-1) := convert(x.specific, y(u to u+w-1));
         u := u + w;
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
      else
         w := width(x.bcid);
         y(u downto u-w+1) := convert(x.bcid, y(u downto u-w+1));
         u := u - w;
         w := width(x.specific);
         y(u downto u-w+1) := convert(x.specific, y(u downto u-w+1));
         u := u - w;
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt is
      variable y : hp_heg2hp_slc_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.bcid);
         y.bcid := convert(x(u to u+w-1), tpl.bcid);
         u := u + w;
         w := width(tpl.specific);
         y.specific := convert(x(u to u+w-1), tpl.specific);
         u := u + w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
      else
         w := width(tpl.bcid);
         y.bcid := convert(x(u downto u-w+1), tpl.bcid);
         u := u - w;
         w := width(tpl.specific);
         y.specific := convert(x(u downto u-w+1), tpl.specific);
         u := u - w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_heg2hp_slc_rt) return hp_heg2hp_slc_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: hp_heg2hp_slc_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: hp_heg2hp_slc_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_heg2hp_slc_art) return hp_heg2hp_slc_art is
      variable y : hp_heg2hp_slc_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_heg2hp_slc_art) return hp_heg2hp_slc_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: hp_heg2hp_slc_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: hp_heg2hp_slc_art) return hp_heg2hp_slc_art is
      variable y : hp_heg2hp_slc_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: hp_hpsPc2hp_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.tube);
      w := w + width(x.layer);
      w := w + width(x.time_t0);
      w := w + width(x.global_z);
      w := w + width(x.global_x);
      w := w + width(x.data_valid);
      return w;
   end function width;
   function convert(x: hp_hpsPc2hp_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.tube);
         y(u to u+w-1) := convert(x.tube, y(u to u+w-1));
         u := u + w;
         w := width(x.layer);
         y(u to u+w-1) := convert(x.layer, y(u to u+w-1));
         u := u + w;
         w := width(x.time_t0);
         y(u to u+w-1) := convert(x.time_t0, y(u to u+w-1));
         u := u + w;
         w := width(x.global_z);
         y(u to u+w-1) := convert(x.global_z, y(u to u+w-1));
         u := u + w;
         w := width(x.global_x);
         y(u to u+w-1) := convert(x.global_x, y(u to u+w-1));
         u := u + w;
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
      else
         w := width(x.tube);
         y(u downto u-w+1) := convert(x.tube, y(u downto u-w+1));
         u := u - w;
         w := width(x.layer);
         y(u downto u-w+1) := convert(x.layer, y(u downto u-w+1));
         u := u - w;
         w := width(x.time_t0);
         y(u downto u-w+1) := convert(x.time_t0, y(u downto u-w+1));
         u := u - w;
         w := width(x.global_z);
         y(u downto u-w+1) := convert(x.global_z, y(u downto u-w+1));
         u := u - w;
         w := width(x.global_x);
         y(u downto u-w+1) := convert(x.global_x, y(u downto u-w+1));
         u := u - w;
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt is
      variable y : hp_hpsPc2hp_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.tube);
         y.tube := convert(x(u to u+w-1), tpl.tube);
         u := u + w;
         w := width(tpl.layer);
         y.layer := convert(x(u to u+w-1), tpl.layer);
         u := u + w;
         w := width(tpl.time_t0);
         y.time_t0 := convert(x(u to u+w-1), tpl.time_t0);
         u := u + w;
         w := width(tpl.global_z);
         y.global_z := convert(x(u to u+w-1), tpl.global_z);
         u := u + w;
         w := width(tpl.global_x);
         y.global_x := convert(x(u to u+w-1), tpl.global_x);
         u := u + w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
      else
         w := width(tpl.tube);
         y.tube := convert(x(u downto u-w+1), tpl.tube);
         u := u - w;
         w := width(tpl.layer);
         y.layer := convert(x(u downto u-w+1), tpl.layer);
         u := u - w;
         w := width(tpl.time_t0);
         y.time_t0 := convert(x(u downto u-w+1), tpl.time_t0);
         u := u - w;
         w := width(tpl.global_z);
         y.global_z := convert(x(u downto u-w+1), tpl.global_z);
         u := u - w;
         w := width(tpl.global_x);
         y.global_x := convert(x(u downto u-w+1), tpl.global_x);
         u := u - w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_hpsPc2hp_rt) return hp_hpsPc2hp_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: hp_hp2sf_data_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.local_y);
      w := w + width(x.local_x);
      w := w + width(x.radius);
      w := w + width(x.mlayer);
      return w;
   end function width;
   function convert(x: hp_hp2sf_data_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.local_y);
         y(u to u+w-1) := convert(x.local_y, y(u to u+w-1));
         u := u + w;
         w := width(x.local_x);
         y(u to u+w-1) := convert(x.local_x, y(u to u+w-1));
         u := u + w;
         w := width(x.radius);
         y(u to u+w-1) := convert(x.radius, y(u to u+w-1));
         u := u + w;
         w := width(x.mlayer);
         y(u to u+w-1) := convert(x.mlayer, y(u to u+w-1));
      else
         w := width(x.local_y);
         y(u downto u-w+1) := convert(x.local_y, y(u downto u-w+1));
         u := u - w;
         w := width(x.local_x);
         y(u downto u-w+1) := convert(x.local_x, y(u downto u-w+1));
         u := u - w;
         w := width(x.radius);
         y(u downto u-w+1) := convert(x.radius, y(u downto u-w+1));
         u := u - w;
         w := width(x.mlayer);
         y(u downto u-w+1) := convert(x.mlayer, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_hp2sf_data_rt) return hp_hp2sf_data_rt is
      variable y : hp_hp2sf_data_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.local_y);
         y.local_y := convert(x(u to u+w-1), tpl.local_y);
         u := u + w;
         w := width(tpl.local_x);
         y.local_x := convert(x(u to u+w-1), tpl.local_x);
         u := u + w;
         w := width(tpl.radius);
         y.radius := convert(x(u to u+w-1), tpl.radius);
         u := u + w;
         w := width(tpl.mlayer);
         y.mlayer := convert(x(u to u+w-1), tpl.mlayer);
      else
         w := width(tpl.local_y);
         y.local_y := convert(x(u downto u-w+1), tpl.local_y);
         u := u - w;
         w := width(tpl.local_x);
         y.local_x := convert(x(u downto u-w+1), tpl.local_x);
         u := u - w;
         w := width(tpl.radius);
         y.radius := convert(x(u downto u-w+1), tpl.radius);
         u := u - w;
         w := width(tpl.mlayer);
         y.mlayer := convert(x(u downto u-w+1), tpl.mlayer);
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_hp2sf_data_rt) return hp_hp2sf_data_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: hp_hp2sf_data_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: hp_hp2sf_data_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_hp2sf_data_art) return hp_hp2sf_data_art is
      variable y : hp_hp2sf_data_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_hp2sf_data_art) return hp_hp2sf_data_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: hp_hp2sf_data_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: hp_hp2sf_data_art) return hp_hp2sf_data_art is
      variable y : hp_hp2sf_data_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: hp_hp2bm_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data);
      w := w + width(x.mdt_valid);
      w := w + width(x.data_valid);
      return w;
   end function width;
   function convert(x: hp_hp2bm_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_valid);
         y(u to u+w-1) := convert(x.mdt_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
      else
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_valid);
         y(u downto u-w+1) := convert(x.mdt_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: hp_hp2bm_rt) return hp_hp2bm_rt is
      variable y : hp_hp2bm_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data);
         y.data := convert(x(u to u+w-1), tpl.data);
         u := u + w;
         w := width(tpl.mdt_valid);
         y.mdt_valid := convert(x(u to u+w-1), tpl.mdt_valid);
         u := u + w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
      else
         w := width(tpl.data);
         y.data := convert(x(u downto u-w+1), tpl.data);
         u := u - w;
         w := width(tpl.mdt_valid);
         y.mdt_valid := convert(x(u downto u-w+1), tpl.mdt_valid);
         u := u - w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
      end if;
      return y;
   end function convert;
   function zero(tpl: hp_hp2bm_rt) return hp_hp2bm_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

end package body hp_pkg;
