-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package fm_types is

   -- Custom types and functions --

   constant mon_dw_max : integer := 256;
   attribute w of mon_dw_max : constant is 32;

   constant stations_n : integer := 3;
   attribute w of stations_n : constant is 32;

   constant threads_n : integer := 3;
   attribute w of threads_n : constant is 32;

   constant primary_sl_n : integer := 3;
   attribute w of primary_sl_n : constant is 32;

   constant FM_INN : integer := 0;
   attribute w of FM_INN : constant is 32;

   constant FM_MID : integer := 1;
   attribute w of FM_MID : constant is 32;

   constant FM_OUT : integer := 2;
   attribute w of FM_OUT : constant is 32;

   constant FM_EXT : integer := 3;
   attribute w of FM_EXT : constant is 32;

   constant sf_sb_n : integer := 3;
   attribute w of sf_sb_n : constant is 32;

   constant sf_sb_single_station_n : integer := 9; -- sf_sb_n * threads_n
   attribute w of sf_sb_single_station_n : constant is 32;

   -- h2s_sb_single_station_n: there may be SB outside of SF in H2S block
   constant h2s_sb_single_station_n : integer := 9; -- sf_sb_single_station_n
   attribute w of h2s_sb_single_station_n : constant is 32;

   constant h2s_sb_all_station_n : integer := 27; -- h2s_sb_single_station_n * stations_n
   attribute w of h2s_sb_all_station_n : constant is 32;

   constant ucm2hps_sb_n : integer := 9; -- stations_n*threads_n
   attribute w of ucm2hps_sb_n : constant is 32;

   constant ucm_sb_n : integer := 15; -- primary_sl_n + ucm2hps_sb_n + primary_sl_n
   attribute w of ucm_sb_n : constant is 32;

   constant csm_polmux_in_sb_n : integer := 9;
   attribute w of csm_polmux_in_sb_n : constant is 32;

   constant csm_custom_sb_n : integer := 1;
   attribute w of csm_custom_sb_n : constant is 32;

   constant tar_sb_n : integer := 12;
   attribute w of tar_sb_n : constant is 32;

   constant tar_sb_all_stations_n : integer := 36; -- tar_sb_n * stations_n
   attribute w of tar_sb_all_stations_n : constant is 32;

   constant mtc_sb_n : integer := 3;
   attribute w of mtc_sb_n : constant is 32;

   constant mtc_sb_all_stations_n : integer := 9; -- mtc_sb_n * stations_n
   attribute w of mtc_sb_all_stations_n : constant is 32;

   constant total_l0mdt_sb : integer := 97; -- h2s_sb_all_station_n + ucm_sb_n + csm_polmux_in_sb_n + csm_custom_sb_n + tar_sb_all_stations_n + mtc_sb_all_stations_n
   attribute w of total_l0mdt_sb : constant is 32;

   type fm_rt is record
      fm_data : std_logic_vector(mon_dw_max-1 downto 0);
      fm_vld : std_logic;
   end record fm_rt;
   attribute w of fm_rt : type is 257;
   function width(x: fm_rt) return natural;
   function convert(x: fm_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_rt) return fm_rt;
   function zero(tpl: fm_rt) return fm_rt;

   type fm_art is array(integer range <>) of fm_rt;
   function width(x: fm_art) return integer;
   function convert(x: fm_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_art) return fm_art;
   function zero(tpl: fm_art) return fm_art;
   function convert(x: fm_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_art) return fm_art;

   type fm_sf_mon is array(0 to sf_sb_n -1) of fm_rt;
   attribute w of fm_sf_mon : type is 771;
   function width(x: fm_sf_mon) return integer;
   function convert(x: fm_sf_mon; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_sf_mon) return fm_sf_mon;
   function zero(tpl: fm_sf_mon) return fm_sf_mon;
   function convert(x: fm_sf_mon; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_sf_mon) return fm_sf_mon;

   type fm_hps_sf_mon is array(0 to threads_n -1) of fm_sf_mon;
   attribute w of fm_hps_sf_mon : type is 2313;
   function width(x: fm_hps_sf_mon) return integer;
   function convert(x: fm_hps_sf_mon; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_hps_sf_mon) return fm_hps_sf_mon;
   function zero(tpl: fm_hps_sf_mon) return fm_hps_sf_mon;
   function convert(x: fm_hps_sf_mon; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_hps_sf_mon) return fm_hps_sf_mon;

   type fm_hps_mon is record
      fm_hps_mon_inn : fm_hps_sf_mon;
      fm_hps_mon_mid : fm_hps_sf_mon;
      fm_hps_mon_out : fm_hps_sf_mon;
   end record fm_hps_mon;
   attribute w of fm_hps_mon : type is 6939;
   function width(x: fm_hps_mon) return natural;
   function convert(x: fm_hps_mon; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_hps_mon) return fm_hps_mon;
   function zero(tpl: fm_hps_mon) return fm_hps_mon;

   type fm_ucm2hps_thread_mon is array(0 to threads_n-1) of fm_rt;
   attribute w of fm_ucm2hps_thread_mon : type is 771;
   function width(x: fm_ucm2hps_thread_mon) return integer;
   function convert(x: fm_ucm2hps_thread_mon; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_ucm2hps_thread_mon) return fm_ucm2hps_thread_mon;
   function zero(tpl: fm_ucm2hps_thread_mon) return fm_ucm2hps_thread_mon;
   function convert(x: fm_ucm2hps_thread_mon; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_ucm2hps_thread_mon) return fm_ucm2hps_thread_mon;

   type fm_ucm_slc_rx is array(0 to primary_sl_n -1) of fm_rt;
   attribute w of fm_ucm_slc_rx : type is 771;
   function width(x: fm_ucm_slc_rx) return integer;
   function convert(x: fm_ucm_slc_rx; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_ucm_slc_rx) return fm_ucm_slc_rx;
   function zero(tpl: fm_ucm_slc_rx) return fm_ucm_slc_rx;
   function convert(x: fm_ucm_slc_rx; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_ucm_slc_rx) return fm_ucm_slc_rx;

   type fm_ucm2pl is array(0 to primary_sl_n -1) of fm_rt;
   attribute w of fm_ucm2pl : type is 771;
   function width(x: fm_ucm2pl) return integer;
   function convert(x: fm_ucm2pl; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_ucm2pl) return fm_ucm2pl;
   function zero(tpl: fm_ucm2pl) return fm_ucm2pl;
   function convert(x: fm_ucm2pl; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_ucm2pl) return fm_ucm2pl;

   type fm_ucm2hps is record
      fm_ucm2hps_inn : fm_ucm2hps_thread_mon;
      fm_ucm2hps_mid : fm_ucm2hps_thread_mon;
      fm_ucm2hps_out : fm_ucm2hps_thread_mon;
   end record fm_ucm2hps;
   attribute w of fm_ucm2hps : type is 2313;
   function width(x: fm_ucm2hps) return natural;
   function convert(x: fm_ucm2hps; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_ucm2hps) return fm_ucm2hps;
   function zero(tpl: fm_ucm2hps) return fm_ucm2hps;

   type fm_ucm_mon_data is record
      fm_ucm_slc_rx_mon : fm_ucm_slc_rx;
      fm_ucm2pl_mon : fm_ucm2pl;
      fm_ucm2hps : fm_ucm2hps;
   end record fm_ucm_mon_data;
   attribute w of fm_ucm_mon_data : type is 3855;
   function width(x: fm_ucm_mon_data) return natural;
   function convert(x: fm_ucm_mon_data; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_ucm_mon_data) return fm_ucm_mon_data;
   function zero(tpl: fm_ucm_mon_data) return fm_ucm_mon_data;

   type fm_csm_to_polmux is array(0 to csm_polmux_in_sb_n) of fm_rt;
   attribute w of fm_csm_to_polmux : type is 2570;
   function width(x: fm_csm_to_polmux) return integer;
   function convert(x: fm_csm_to_polmux; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_csm_to_polmux) return fm_csm_to_polmux;
   function zero(tpl: fm_csm_to_polmux) return fm_csm_to_polmux;
   function convert(x: fm_csm_to_polmux; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_csm_to_polmux) return fm_csm_to_polmux;

   type fm_csm_mon_data is record
      fm_csm_uplink_data : fm_rt;
      fm_csm_to_polmux : fm_csm_to_polmux;
   end record fm_csm_mon_data;
   attribute w of fm_csm_mon_data : type is 2827;
   function width(x: fm_csm_mon_data) return natural;
   function convert(x: fm_csm_mon_data; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_csm_mon_data) return fm_csm_mon_data;
   function zero(tpl: fm_csm_mon_data) return fm_csm_mon_data;

   type fm_tar_mon_data is array(0 to tar_sb_n-1) of fm_rt;
   attribute w of fm_tar_mon_data : type is 3084;
   function width(x: fm_tar_mon_data) return integer;
   function convert(x: fm_tar_mon_data; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_tar_mon_data) return fm_tar_mon_data;
   function zero(tpl: fm_tar_mon_data) return fm_tar_mon_data;
   function convert(x: fm_tar_mon_data; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_tar_mon_data) return fm_tar_mon_data;

   type fm_mtc_mon_data is array(0 to tar_sb_n-1) of fm_rt;
   attribute w of fm_mtc_mon_data : type is 3084;
   function width(x: fm_mtc_mon_data) return integer;
   function convert(x: fm_mtc_mon_data; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_mtc_mon_data) return fm_mtc_mon_data;
   function zero(tpl: fm_mtc_mon_data) return fm_mtc_mon_data;
   function convert(x: fm_mtc_mon_data; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_mtc_mon_data) return fm_mtc_mon_data;

   type fm_mon is record
      fm_hps_mon : fm_hps_mon;
      fm_ucm_mon : fm_ucm_mon_data;
      fm_csm_mon_data : fm_csm_mon_data;
      fm_tar_mon_data : fm_tar_mon_data(0 to stations_n-1);
      fm_mtc_mon_data : fm_mtc_mon_data(0 to stations_n-1);
   end record fm_mon;
   attribute w of fm_mon : type is 32125;
   function width(x: fm_mon) return natural;
   function convert(x: fm_mon; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_mon) return fm_mon;
   function zero(tpl: fm_mon) return fm_mon;

   type fm_pb is array(0 to total_l0mdt_sb -1) of std_logic_vector(mon_dw_max-1 downto 0);
   attribute w of fm_pb : type is 24832;
   function width(x: fm_pb) return integer;
   function convert(x: fm_pb; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: fm_pb) return fm_pb;
   function zero(tpl: fm_pb) return fm_pb;
   function convert(x: fm_pb; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: fm_pb) return fm_pb;

end package fm_types;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package body fm_types is

   -- Custom types and functions --

   function width(x: fm_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.fm_data);
      w := w + width(x.fm_vld);
      return w;
   end function width;
   function convert(x: fm_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.fm_data);
         y(u to u+w-1) := convert(x.fm_data, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_vld);
         y(u to u+w-1) := convert(x.fm_vld, y(u to u+w-1));
      else
         w := width(x.fm_data);
         y(u downto u-w+1) := convert(x.fm_data, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_vld);
         y(u downto u-w+1) := convert(x.fm_vld, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_rt) return fm_rt is
      variable y : fm_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.fm_data);
         y.fm_data := convert(x(u to u+w-1), tpl.fm_data);
         u := u + w;
         w := width(tpl.fm_vld);
         y.fm_vld := convert(x(u to u+w-1), tpl.fm_vld);
      else
         w := width(tpl.fm_data);
         y.fm_data := convert(x(u downto u-w+1), tpl.fm_data);
         u := u - w;
         w := width(tpl.fm_vld);
         y.fm_vld := convert(x(u downto u-w+1), tpl.fm_vld);
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_rt) return fm_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: fm_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_art) return fm_art is
      variable y : fm_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_art) return fm_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_art) return fm_art is
      variable y : fm_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: fm_sf_mon) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_sf_mon; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_sf_mon) return fm_sf_mon is
      variable y : fm_sf_mon;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_sf_mon) return fm_sf_mon is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_sf_mon; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_sf_mon) return fm_sf_mon is
      variable y : fm_sf_mon;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: fm_hps_sf_mon) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_hps_sf_mon; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_hps_sf_mon) return fm_hps_sf_mon is
      variable y : fm_hps_sf_mon;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_hps_sf_mon) return fm_hps_sf_mon is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_hps_sf_mon; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_hps_sf_mon) return fm_hps_sf_mon is
      variable y : fm_hps_sf_mon;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: fm_hps_mon) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.fm_hps_mon_inn);
      w := w + width(x.fm_hps_mon_mid);
      w := w + width(x.fm_hps_mon_out);
      return w;
   end function width;
   function convert(x: fm_hps_mon; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.fm_hps_mon_inn);
         y(u to u+w-1) := convert(x.fm_hps_mon_inn, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_hps_mon_mid);
         y(u to u+w-1) := convert(x.fm_hps_mon_mid, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_hps_mon_out);
         y(u to u+w-1) := convert(x.fm_hps_mon_out, y(u to u+w-1));
      else
         w := width(x.fm_hps_mon_inn);
         y(u downto u-w+1) := convert(x.fm_hps_mon_inn, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_hps_mon_mid);
         y(u downto u-w+1) := convert(x.fm_hps_mon_mid, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_hps_mon_out);
         y(u downto u-w+1) := convert(x.fm_hps_mon_out, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_hps_mon) return fm_hps_mon is
      variable y : fm_hps_mon;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.fm_hps_mon_inn);
         y.fm_hps_mon_inn := convert(x(u to u+w-1), tpl.fm_hps_mon_inn);
         u := u + w;
         w := width(tpl.fm_hps_mon_mid);
         y.fm_hps_mon_mid := convert(x(u to u+w-1), tpl.fm_hps_mon_mid);
         u := u + w;
         w := width(tpl.fm_hps_mon_out);
         y.fm_hps_mon_out := convert(x(u to u+w-1), tpl.fm_hps_mon_out);
      else
         w := width(tpl.fm_hps_mon_inn);
         y.fm_hps_mon_inn := convert(x(u downto u-w+1), tpl.fm_hps_mon_inn);
         u := u - w;
         w := width(tpl.fm_hps_mon_mid);
         y.fm_hps_mon_mid := convert(x(u downto u-w+1), tpl.fm_hps_mon_mid);
         u := u - w;
         w := width(tpl.fm_hps_mon_out);
         y.fm_hps_mon_out := convert(x(u downto u-w+1), tpl.fm_hps_mon_out);
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_hps_mon) return fm_hps_mon is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: fm_ucm2hps_thread_mon) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_ucm2hps_thread_mon; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_ucm2hps_thread_mon) return fm_ucm2hps_thread_mon is
      variable y : fm_ucm2hps_thread_mon;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_ucm2hps_thread_mon) return fm_ucm2hps_thread_mon is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_ucm2hps_thread_mon; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_ucm2hps_thread_mon) return fm_ucm2hps_thread_mon is
      variable y : fm_ucm2hps_thread_mon;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: fm_ucm_slc_rx) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_ucm_slc_rx; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_ucm_slc_rx) return fm_ucm_slc_rx is
      variable y : fm_ucm_slc_rx;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_ucm_slc_rx) return fm_ucm_slc_rx is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_ucm_slc_rx; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_ucm_slc_rx) return fm_ucm_slc_rx is
      variable y : fm_ucm_slc_rx;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: fm_ucm2pl) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_ucm2pl; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_ucm2pl) return fm_ucm2pl is
      variable y : fm_ucm2pl;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_ucm2pl) return fm_ucm2pl is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_ucm2pl; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_ucm2pl) return fm_ucm2pl is
      variable y : fm_ucm2pl;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: fm_ucm2hps) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.fm_ucm2hps_inn);
      w := w + width(x.fm_ucm2hps_mid);
      w := w + width(x.fm_ucm2hps_out);
      return w;
   end function width;
   function convert(x: fm_ucm2hps; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.fm_ucm2hps_inn);
         y(u to u+w-1) := convert(x.fm_ucm2hps_inn, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_ucm2hps_mid);
         y(u to u+w-1) := convert(x.fm_ucm2hps_mid, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_ucm2hps_out);
         y(u to u+w-1) := convert(x.fm_ucm2hps_out, y(u to u+w-1));
      else
         w := width(x.fm_ucm2hps_inn);
         y(u downto u-w+1) := convert(x.fm_ucm2hps_inn, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_ucm2hps_mid);
         y(u downto u-w+1) := convert(x.fm_ucm2hps_mid, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_ucm2hps_out);
         y(u downto u-w+1) := convert(x.fm_ucm2hps_out, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_ucm2hps) return fm_ucm2hps is
      variable y : fm_ucm2hps;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.fm_ucm2hps_inn);
         y.fm_ucm2hps_inn := convert(x(u to u+w-1), tpl.fm_ucm2hps_inn);
         u := u + w;
         w := width(tpl.fm_ucm2hps_mid);
         y.fm_ucm2hps_mid := convert(x(u to u+w-1), tpl.fm_ucm2hps_mid);
         u := u + w;
         w := width(tpl.fm_ucm2hps_out);
         y.fm_ucm2hps_out := convert(x(u to u+w-1), tpl.fm_ucm2hps_out);
      else
         w := width(tpl.fm_ucm2hps_inn);
         y.fm_ucm2hps_inn := convert(x(u downto u-w+1), tpl.fm_ucm2hps_inn);
         u := u - w;
         w := width(tpl.fm_ucm2hps_mid);
         y.fm_ucm2hps_mid := convert(x(u downto u-w+1), tpl.fm_ucm2hps_mid);
         u := u - w;
         w := width(tpl.fm_ucm2hps_out);
         y.fm_ucm2hps_out := convert(x(u downto u-w+1), tpl.fm_ucm2hps_out);
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_ucm2hps) return fm_ucm2hps is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: fm_ucm_mon_data) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.fm_ucm_slc_rx_mon);
      w := w + width(x.fm_ucm2pl_mon);
      w := w + width(x.fm_ucm2hps);
      return w;
   end function width;
   function convert(x: fm_ucm_mon_data; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.fm_ucm_slc_rx_mon);
         y(u to u+w-1) := convert(x.fm_ucm_slc_rx_mon, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_ucm2pl_mon);
         y(u to u+w-1) := convert(x.fm_ucm2pl_mon, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_ucm2hps);
         y(u to u+w-1) := convert(x.fm_ucm2hps, y(u to u+w-1));
      else
         w := width(x.fm_ucm_slc_rx_mon);
         y(u downto u-w+1) := convert(x.fm_ucm_slc_rx_mon, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_ucm2pl_mon);
         y(u downto u-w+1) := convert(x.fm_ucm2pl_mon, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_ucm2hps);
         y(u downto u-w+1) := convert(x.fm_ucm2hps, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_ucm_mon_data) return fm_ucm_mon_data is
      variable y : fm_ucm_mon_data;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.fm_ucm_slc_rx_mon);
         y.fm_ucm_slc_rx_mon := convert(x(u to u+w-1), tpl.fm_ucm_slc_rx_mon);
         u := u + w;
         w := width(tpl.fm_ucm2pl_mon);
         y.fm_ucm2pl_mon := convert(x(u to u+w-1), tpl.fm_ucm2pl_mon);
         u := u + w;
         w := width(tpl.fm_ucm2hps);
         y.fm_ucm2hps := convert(x(u to u+w-1), tpl.fm_ucm2hps);
      else
         w := width(tpl.fm_ucm_slc_rx_mon);
         y.fm_ucm_slc_rx_mon := convert(x(u downto u-w+1), tpl.fm_ucm_slc_rx_mon);
         u := u - w;
         w := width(tpl.fm_ucm2pl_mon);
         y.fm_ucm2pl_mon := convert(x(u downto u-w+1), tpl.fm_ucm2pl_mon);
         u := u - w;
         w := width(tpl.fm_ucm2hps);
         y.fm_ucm2hps := convert(x(u downto u-w+1), tpl.fm_ucm2hps);
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_ucm_mon_data) return fm_ucm_mon_data is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: fm_csm_to_polmux) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_csm_to_polmux; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_csm_to_polmux) return fm_csm_to_polmux is
      variable y : fm_csm_to_polmux;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_csm_to_polmux) return fm_csm_to_polmux is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_csm_to_polmux; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_csm_to_polmux) return fm_csm_to_polmux is
      variable y : fm_csm_to_polmux;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: fm_csm_mon_data) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.fm_csm_uplink_data);
      w := w + width(x.fm_csm_to_polmux);
      return w;
   end function width;
   function convert(x: fm_csm_mon_data; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.fm_csm_uplink_data);
         y(u to u+w-1) := convert(x.fm_csm_uplink_data, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_csm_to_polmux);
         y(u to u+w-1) := convert(x.fm_csm_to_polmux, y(u to u+w-1));
      else
         w := width(x.fm_csm_uplink_data);
         y(u downto u-w+1) := convert(x.fm_csm_uplink_data, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_csm_to_polmux);
         y(u downto u-w+1) := convert(x.fm_csm_to_polmux, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_csm_mon_data) return fm_csm_mon_data is
      variable y : fm_csm_mon_data;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.fm_csm_uplink_data);
         y.fm_csm_uplink_data := convert(x(u to u+w-1), tpl.fm_csm_uplink_data);
         u := u + w;
         w := width(tpl.fm_csm_to_polmux);
         y.fm_csm_to_polmux := convert(x(u to u+w-1), tpl.fm_csm_to_polmux);
      else
         w := width(tpl.fm_csm_uplink_data);
         y.fm_csm_uplink_data := convert(x(u downto u-w+1), tpl.fm_csm_uplink_data);
         u := u - w;
         w := width(tpl.fm_csm_to_polmux);
         y.fm_csm_to_polmux := convert(x(u downto u-w+1), tpl.fm_csm_to_polmux);
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_csm_mon_data) return fm_csm_mon_data is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: fm_tar_mon_data) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_tar_mon_data; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_tar_mon_data) return fm_tar_mon_data is
      variable y : fm_tar_mon_data;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_tar_mon_data) return fm_tar_mon_data is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_tar_mon_data; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_tar_mon_data) return fm_tar_mon_data is
      variable y : fm_tar_mon_data;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: fm_mtc_mon_data) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_mtc_mon_data; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_mtc_mon_data) return fm_mtc_mon_data is
      variable y : fm_mtc_mon_data;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_mtc_mon_data) return fm_mtc_mon_data is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_mtc_mon_data; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_mtc_mon_data) return fm_mtc_mon_data is
      variable y : fm_mtc_mon_data;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: fm_mon) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.fm_hps_mon);
      w := w + width(x.fm_ucm_mon);
      w := w + width(x.fm_csm_mon_data);
      w := w + width(x.fm_tar_mon_data);
      w := w + width(x.fm_mtc_mon_data);
      return w;
   end function width;
   function convert(x: fm_mon; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.fm_hps_mon);
         y(u to u+w-1) := convert(x.fm_hps_mon, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_ucm_mon);
         y(u to u+w-1) := convert(x.fm_ucm_mon, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_csm_mon_data);
         y(u to u+w-1) := convert(x.fm_csm_mon_data, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_tar_mon_data);
         y(u to u+w-1) := convert(x.fm_tar_mon_data, y(u to u+w-1));
         u := u + w;
         w := width(x.fm_mtc_mon_data);
         y(u to u+w-1) := convert(x.fm_mtc_mon_data, y(u to u+w-1));
      else
         w := width(x.fm_hps_mon);
         y(u downto u-w+1) := convert(x.fm_hps_mon, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_ucm_mon);
         y(u downto u-w+1) := convert(x.fm_ucm_mon, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_csm_mon_data);
         y(u downto u-w+1) := convert(x.fm_csm_mon_data, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_tar_mon_data);
         y(u downto u-w+1) := convert(x.fm_tar_mon_data, y(u downto u-w+1));
         u := u - w;
         w := width(x.fm_mtc_mon_data);
         y(u downto u-w+1) := convert(x.fm_mtc_mon_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_mon) return fm_mon is
      variable y : fm_mon;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.fm_hps_mon);
         y.fm_hps_mon := convert(x(u to u+w-1), tpl.fm_hps_mon);
         u := u + w;
         w := width(tpl.fm_ucm_mon);
         y.fm_ucm_mon := convert(x(u to u+w-1), tpl.fm_ucm_mon);
         u := u + w;
         w := width(tpl.fm_csm_mon_data);
         y.fm_csm_mon_data := convert(x(u to u+w-1), tpl.fm_csm_mon_data);
         u := u + w;
         w := width(tpl.fm_tar_mon_data);
         y.fm_tar_mon_data := convert(x(u to u+w-1), tpl.fm_tar_mon_data);
         u := u + w;
         w := width(tpl.fm_mtc_mon_data);
         y.fm_mtc_mon_data := convert(x(u to u+w-1), tpl.fm_mtc_mon_data);
      else
         w := width(tpl.fm_hps_mon);
         y.fm_hps_mon := convert(x(u downto u-w+1), tpl.fm_hps_mon);
         u := u - w;
         w := width(tpl.fm_ucm_mon);
         y.fm_ucm_mon := convert(x(u downto u-w+1), tpl.fm_ucm_mon);
         u := u - w;
         w := width(tpl.fm_csm_mon_data);
         y.fm_csm_mon_data := convert(x(u downto u-w+1), tpl.fm_csm_mon_data);
         u := u - w;
         w := width(tpl.fm_tar_mon_data);
         y.fm_tar_mon_data := convert(x(u downto u-w+1), tpl.fm_tar_mon_data);
         u := u - w;
         w := width(tpl.fm_mtc_mon_data);
         y.fm_mtc_mon_data := convert(x(u downto u-w+1), tpl.fm_mtc_mon_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_mon) return fm_mon is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: fm_pb) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: fm_pb; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: fm_pb) return fm_pb is
      variable y : fm_pb;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: fm_pb) return fm_pb is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: fm_pb; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: fm_pb) return fm_pb is
      variable y : fm_pb;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

end package body fm_types;
