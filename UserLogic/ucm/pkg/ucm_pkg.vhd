-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;

use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;

use shared_lib.common_ieee.all;
use shared_lib.common_constants.all;
use shared_lib.common_types.all;
use shared_lib.l0mdt_constants.all;
use shared_lib.l0mdt_dataformats.all;

package ucm_pkg is

  constant SLC_SPECIFIC_LEN : integer := 48;

  constant UCM_CDE2CVP_PHIMOD_LEN : integer := 5;

  constant UCM_CDE2CVP_PHIMOD_MULT : real := 12.0;
  function len(x: real) return integer;
  function width(x: real) return integer;

  constant UCM_PHIMOD_LEN : integer := 5;

  type ucm_prepro2ctrl is record
    data_valid : std_logic;
  end record ucm_prepro2ctrl;
  function len(x: ucm_prepro2ctrl) return natural;
  function width(x: ucm_prepro2ctrl) return natural;
  function vectorify(x: ucm_prepro2ctrl; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_prepro2ctrl; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_prepro2ctrl) return ucm_prepro2ctrl;
  function convert(x: in std_logic_vector; t: ucm_prepro2ctrl) return ucm_prepro2ctrl;
  function nullify(t: ucm_prepro2ctrl) return ucm_prepro2ctrl;
  function zeroed(t: ucm_prepro2ctrl) return ucm_prepro2ctrl;

  type ucm_prepro2ctrl_bus is array(integer range <>) of ucm_prepro2ctrl;
  function len(x: ucm_prepro2ctrl_bus) return natural;
  function width(x: ucm_prepro2ctrl_bus) return natural;
  function vectorify(x: ucm_prepro2ctrl_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_prepro2ctrl_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_prepro2ctrl_bus) return ucm_prepro2ctrl_bus;
  function convert(x: std_logic_vector; t: ucm_prepro2ctrl_bus) return ucm_prepro2ctrl_bus;
  function nullify(x: ucm_prepro2ctrl_bus) return ucm_prepro2ctrl_bus;
  function zeroed(x: ucm_prepro2ctrl_bus) return ucm_prepro2ctrl_bus;

  subtype ucm_rpc_r is std_logic_vector(SLC_Z_RPC_LEN-1 downto 0);

  type ucm_rpc_r_bus is array(integer range <>) of ucm_rpc_r;
  function len(x: ucm_rpc_r_bus) return natural;
  function width(x: ucm_rpc_r_bus) return natural;
  function vectorify(x: ucm_rpc_r_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_rpc_r_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_rpc_r_bus) return ucm_rpc_r_bus;
  function convert(x: std_logic_vector; t: ucm_rpc_r_bus) return ucm_rpc_r_bus;
  function nullify(x: ucm_rpc_r_bus) return ucm_rpc_r_bus;
  function zeroed(x: ucm_rpc_r_bus) return ucm_rpc_r_bus;

  subtype ucm_mdt_r is std_logic_vector(UCM_Z_ROI_LEN-1 downto 0);

  type ucm_mdt_r_bus is array(integer range <>) of ucm_mdt_r;
  function len(x: ucm_mdt_r_bus) return natural;
  function width(x: ucm_mdt_r_bus) return natural;
  function vectorify(x: ucm_mdt_r_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_mdt_r_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_mdt_r_bus) return ucm_mdt_r_bus;
  function convert(x: std_logic_vector; t: ucm_mdt_r_bus) return ucm_mdt_r_bus;
  function nullify(x: ucm_mdt_r_bus) return ucm_mdt_r_bus;
  function zeroed(x: ucm_mdt_r_bus) return ucm_mdt_r_bus;

  subtype chamb_ieta_rpc is unsigned(4-1 downto 0);

  type chamb_ieta_rpc_bus is array(4-1 downto 0) of chamb_ieta_rpc;
  function len(x: chamb_ieta_rpc_bus) return natural;
  function width(x: chamb_ieta_rpc_bus) return natural;
  function vectorify(x: chamb_ieta_rpc_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: chamb_ieta_rpc_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: chamb_ieta_rpc_bus) return chamb_ieta_rpc_bus;
  function convert(x: std_logic_vector; t: chamb_ieta_rpc_bus) return chamb_ieta_rpc_bus;
  function nullify(x: chamb_ieta_rpc_bus) return chamb_ieta_rpc_bus;
  function zeroed(x: chamb_ieta_rpc_bus) return chamb_ieta_rpc_bus;

  type ucm_cde is record
    muid : slc_muid;
    chamb_ieta : chamb_ieta_rpc_bus;
    cointype : std_logic_vector(SLC_COMMON_COINTYPE_LEN-1 downto 0);
    posphi : unsigned(SLC_COMMON_POSPHI_LEN-1 downto 0);
    phimod : std_logic_vector(UCM_CDE2CVP_PHIMOD_LEN-1 downto 0);
    specific : std_logic_vector(SLC_SPECIFIC_LEN-1 downto 0);
    data_valid : std_logic;
  end record ucm_cde;
  function len(x: ucm_cde) return natural;
  function width(x: ucm_cde) return natural;
  function vectorify(x: ucm_cde; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_cde; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_cde) return ucm_cde;
  function convert(x: in std_logic_vector; t: ucm_cde) return ucm_cde;
  function nullify(t: ucm_cde) return ucm_cde;
  function zeroed(t: ucm_cde) return ucm_cde;

  type ucm_cde_bus is array(integer range <>) of ucm_cde;
  function len(x: ucm_cde_bus) return natural;
  function width(x: ucm_cde_bus) return natural;
  function vectorify(x: ucm_cde_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_cde_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_cde_bus) return ucm_cde_bus;
  function convert(x: std_logic_vector; t: ucm_cde_bus) return ucm_cde_bus;
  function nullify(x: ucm_cde_bus) return ucm_cde_bus;
  function zeroed(x: ucm_cde_bus) return ucm_cde_bus;

  type ucm_csw_ch_control is record
    data_present : std_logic;
    addr_orig : std_logic_vector(4-1 downto 0);
  end record ucm_csw_ch_control;
  function len(x: ucm_csw_ch_control) return natural;
  function width(x: ucm_csw_ch_control) return natural;
  function vectorify(x: ucm_csw_ch_control; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_csw_ch_control; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_csw_ch_control) return ucm_csw_ch_control;
  function convert(x: in std_logic_vector; t: ucm_csw_ch_control) return ucm_csw_ch_control;
  function nullify(t: ucm_csw_ch_control) return ucm_csw_ch_control;
  function zeroed(t: ucm_csw_ch_control) return ucm_csw_ch_control;

  type ucm_csw_control is array(integer range <>) of ucm_csw_ch_control;
  function len(x: ucm_csw_control) return natural;
  function width(x: ucm_csw_control) return natural;
  function vectorify(x: ucm_csw_control; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_csw_control; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_csw_control) return ucm_csw_control;
  function convert(x: std_logic_vector; t: ucm_csw_control) return ucm_csw_control;
  function nullify(x: ucm_csw_control) return ucm_csw_control;
  function zeroed(x: ucm_csw_control) return ucm_csw_control;

  type ucm_pam_ch_control is record
    data_present : std_logic;
    addr_orig : std_logic_vector(4-1 downto 0);
  end record ucm_pam_ch_control;
  function len(x: ucm_pam_ch_control) return natural;
  function width(x: ucm_pam_ch_control) return natural;
  function vectorify(x: ucm_pam_ch_control; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_pam_ch_control; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_pam_ch_control) return ucm_pam_ch_control;
  function convert(x: in std_logic_vector; t: ucm_pam_ch_control) return ucm_pam_ch_control;
  function nullify(t: ucm_pam_ch_control) return ucm_pam_ch_control;
  function zeroed(t: ucm_pam_ch_control) return ucm_pam_ch_control;

  type ucm_pam_control is array(integer range <>) of ucm_pam_ch_control;
  function len(x: ucm_pam_control) return natural;
  function width(x: ucm_pam_control) return natural;
  function vectorify(x: ucm_pam_control; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_pam_control; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_pam_control) return ucm_pam_control;
  function convert(x: std_logic_vector; t: ucm_pam_control) return ucm_pam_control;
  function nullify(x: ucm_pam_control) return ucm_pam_control;
  function zeroed(x: ucm_pam_control) return ucm_pam_control;

  type ucm_proc_info_ch is record
    ch : std_logic_vector(4-1 downto 0);
    processed : std_logic;
    dv : std_logic;
  end record ucm_proc_info_ch;
  function len(x: ucm_proc_info_ch) return natural;
  function width(x: ucm_proc_info_ch) return natural;
  function vectorify(x: ucm_proc_info_ch; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_proc_info_ch; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_proc_info_ch) return ucm_proc_info_ch;
  function convert(x: in std_logic_vector; t: ucm_proc_info_ch) return ucm_proc_info_ch;
  function nullify(t: ucm_proc_info_ch) return ucm_proc_info_ch;
  function zeroed(t: ucm_proc_info_ch) return ucm_proc_info_ch;

  type ucm_proc_info is array(integer range <>) of ucm_proc_info_ch;
  function len(x: ucm_proc_info) return natural;
  function width(x: ucm_proc_info) return natural;
  function vectorify(x: ucm_proc_info; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_proc_info; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_proc_info) return ucm_proc_info;
  function convert(x: std_logic_vector; t: ucm_proc_info) return ucm_proc_info;
  function nullify(x: ucm_proc_info) return ucm_proc_info;
  function zeroed(x: ucm_proc_info) return ucm_proc_info;

end package ucm_pkg;

------------------------------------------------------------

package body ucm_pkg is

  function len(x: real) return integer is
  begin
    return 32;
  end function len;
  function width(x: real) return integer is
  begin
    return 32;
  end function width;
  function len(x: ucm_prepro2ctrl) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    return l;
  end function len;
  function width(x: ucm_prepro2ctrl) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    return l;
  end function width;
  function vectorify(x: ucm_prepro2ctrl; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_prepro2ctrl; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_prepro2ctrl) return ucm_prepro2ctrl is
    variable y: ucm_prepro2ctrl;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_prepro2ctrl) return ucm_prepro2ctrl is
    variable y: ucm_prepro2ctrl;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_prepro2ctrl) return ucm_prepro2ctrl is
  variable y: ucm_prepro2ctrl;
  begin
    y.data_valid := nullify(t.data_valid);
    return y;
  end function nullify;
  function zeroed(t: ucm_prepro2ctrl) return ucm_prepro2ctrl is
  variable y: ucm_prepro2ctrl;
  begin
    y.data_valid := zeroed(t.data_valid);
    return y;
  end function zeroed;

  function len(x: ucm_prepro2ctrl_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_prepro2ctrl_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_prepro2ctrl_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_prepro2ctrl_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_prepro2ctrl_bus) return ucm_prepro2ctrl_bus is
    variable y : ucm_prepro2ctrl_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_prepro2ctrl_bus) return ucm_prepro2ctrl_bus is
    variable y : ucm_prepro2ctrl_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_prepro2ctrl_bus) return ucm_prepro2ctrl_bus is
    variable y : ucm_prepro2ctrl_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_prepro2ctrl_bus) return ucm_prepro2ctrl_bus is
    variable y : ucm_prepro2ctrl_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_rpc_r_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_rpc_r_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_rpc_r_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_rpc_r_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_rpc_r_bus) return ucm_rpc_r_bus is
    variable y : ucm_rpc_r_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_rpc_r_bus) return ucm_rpc_r_bus is
    variable y : ucm_rpc_r_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_rpc_r_bus) return ucm_rpc_r_bus is
    variable y : ucm_rpc_r_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_rpc_r_bus) return ucm_rpc_r_bus is
    variable y : ucm_rpc_r_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_mdt_r_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_mdt_r_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_mdt_r_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_mdt_r_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_mdt_r_bus) return ucm_mdt_r_bus is
    variable y : ucm_mdt_r_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_mdt_r_bus) return ucm_mdt_r_bus is
    variable y : ucm_mdt_r_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_mdt_r_bus) return ucm_mdt_r_bus is
    variable y : ucm_mdt_r_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_mdt_r_bus) return ucm_mdt_r_bus is
    variable y : ucm_mdt_r_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: chamb_ieta_rpc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: chamb_ieta_rpc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: chamb_ieta_rpc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: chamb_ieta_rpc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: chamb_ieta_rpc_bus) return chamb_ieta_rpc_bus is
    variable y : chamb_ieta_rpc_bus;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: chamb_ieta_rpc_bus) return chamb_ieta_rpc_bus is
    variable y : chamb_ieta_rpc_bus;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: chamb_ieta_rpc_bus) return chamb_ieta_rpc_bus is
    variable y : chamb_ieta_rpc_bus;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: chamb_ieta_rpc_bus) return chamb_ieta_rpc_bus is
    variable y : chamb_ieta_rpc_bus;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_cde) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.muid);
    l := l + len(x.chamb_ieta);
    l := l + len(x.cointype);
    l := l + len(x.posphi);
    l := l + len(x.phimod);
    l := l + len(x.specific);
    l := l + len(x.data_valid);
    return l;
  end function len;
  function width(x: ucm_cde) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.muid);
    l := l + width(x.chamb_ieta);
    l := l + width(x.cointype);
    l := l + width(x.posphi);
    l := l + width(x.phimod);
    l := l + width(x.specific);
    l := l + width(x.data_valid);
    return l;
  end function width;
  function vectorify(x: ucm_cde; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.chamb_ieta)-1), vectorify(x.chamb_ieta, y(left to left+len(x.chamb_ieta)-1)));
      left := left + len(x.chamb_ieta);
      assign(y(left to left+len(x.cointype)-1), vectorify(x.cointype, y(left to left+len(x.cointype)-1)));
      left := left + len(x.cointype);
      assign(y(left to left+len(x.posphi)-1), vectorify(x.posphi, y(left to left+len(x.posphi)-1)));
      left := left + len(x.posphi);
      assign(y(left to left+len(x.phimod)-1), vectorify(x.phimod, y(left to left+len(x.phimod)-1)));
      left := left + len(x.phimod);
      assign(y(left to left+len(x.specific)-1), vectorify(x.specific, y(left to left+len(x.specific)-1)));
      left := left + len(x.specific);
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.chamb_ieta)+1), vectorify(x.chamb_ieta, y(left downto left-len(x.chamb_ieta)+1)));
      left := left - len(x.chamb_ieta);
      assign(y(left downto left-len(x.cointype)+1), vectorify(x.cointype, y(left downto left-len(x.cointype)+1)));
      left := left - len(x.cointype);
      assign(y(left downto left-len(x.posphi)+1), vectorify(x.posphi, y(left downto left-len(x.posphi)+1)));
      left := left - len(x.posphi);
      assign(y(left downto left-len(x.phimod)+1), vectorify(x.phimod, y(left downto left-len(x.phimod)+1)));
      left := left - len(x.phimod);
      assign(y(left downto left-len(x.specific)+1), vectorify(x.specific, y(left downto left-len(x.specific)+1)));
      left := left - len(x.specific);
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_cde; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.chamb_ieta)-1), convert(x.chamb_ieta, y(left to left+len(x.chamb_ieta)-1)));
      left := left + len(x.chamb_ieta);
      assign(y(left to left+len(x.cointype)-1), convert(x.cointype, y(left to left+len(x.cointype)-1)));
      left := left + len(x.cointype);
      assign(y(left to left+len(x.posphi)-1), convert(x.posphi, y(left to left+len(x.posphi)-1)));
      left := left + len(x.posphi);
      assign(y(left to left+len(x.phimod)-1), convert(x.phimod, y(left to left+len(x.phimod)-1)));
      left := left + len(x.phimod);
      assign(y(left to left+len(x.specific)-1), convert(x.specific, y(left to left+len(x.specific)-1)));
      left := left + len(x.specific);
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.chamb_ieta)+1), convert(x.chamb_ieta, y(left downto left-len(x.chamb_ieta)+1)));
      left := left - len(x.chamb_ieta);
      assign(y(left downto left-len(x.cointype)+1), convert(x.cointype, y(left downto left-len(x.cointype)+1)));
      left := left - len(x.cointype);
      assign(y(left downto left-len(x.posphi)+1), convert(x.posphi, y(left downto left-len(x.posphi)+1)));
      left := left - len(x.posphi);
      assign(y(left downto left-len(x.phimod)+1), convert(x.phimod, y(left downto left-len(x.phimod)+1)));
      left := left - len(x.phimod);
      assign(y(left downto left-len(x.specific)+1), convert(x.specific, y(left downto left-len(x.specific)+1)));
      left := left - len(x.specific);
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_cde) return ucm_cde is
    variable y: ucm_cde;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.chamb_ieta := structify(x(left to left+len(y.chamb_ieta)-1), y.chamb_ieta);
      left := left + len(y.chamb_ieta);
      y.cointype := structify(x(left to left+len(y.cointype)-1), y.cointype);
      left := left + len(y.cointype);
      y.posphi := structify(x(left to left+len(y.posphi)-1), y.posphi);
      left := left + len(y.posphi);
      y.phimod := structify(x(left to left+len(y.phimod)-1), y.phimod);
      left := left + len(y.phimod);
      y.specific := structify(x(left to left+len(y.specific)-1), y.specific);
      left := left + len(y.specific);
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.chamb_ieta := structify(x(left downto left-len(y.chamb_ieta)+1), y.chamb_ieta);
      left := left - len(y.chamb_ieta);
      y.cointype := structify(x(left downto left-len(y.cointype)+1), y.cointype);
      left := left - len(y.cointype);
      y.posphi := structify(x(left downto left-len(y.posphi)+1), y.posphi);
      left := left - len(y.posphi);
      y.phimod := structify(x(left downto left-len(y.phimod)+1), y.phimod);
      left := left - len(y.phimod);
      y.specific := structify(x(left downto left-len(y.specific)+1), y.specific);
      left := left - len(y.specific);
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_cde) return ucm_cde is
    variable y: ucm_cde;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.chamb_ieta := convert(x(left to left+len(y.chamb_ieta)-1), y.chamb_ieta);
      left := left + len(y.chamb_ieta);
      y.cointype := convert(x(left to left+len(y.cointype)-1), y.cointype);
      left := left + len(y.cointype);
      y.posphi := convert(x(left to left+len(y.posphi)-1), y.posphi);
      left := left + len(y.posphi);
      y.phimod := convert(x(left to left+len(y.phimod)-1), y.phimod);
      left := left + len(y.phimod);
      y.specific := convert(x(left to left+len(y.specific)-1), y.specific);
      left := left + len(y.specific);
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.chamb_ieta := convert(x(left downto left-len(y.chamb_ieta)+1), y.chamb_ieta);
      left := left - len(y.chamb_ieta);
      y.cointype := convert(x(left downto left-len(y.cointype)+1), y.cointype);
      left := left - len(y.cointype);
      y.posphi := convert(x(left downto left-len(y.posphi)+1), y.posphi);
      left := left - len(y.posphi);
      y.phimod := convert(x(left downto left-len(y.phimod)+1), y.phimod);
      left := left - len(y.phimod);
      y.specific := convert(x(left downto left-len(y.specific)+1), y.specific);
      left := left - len(y.specific);
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_cde) return ucm_cde is
  variable y: ucm_cde;
  begin
    y.muid := nullify(t.muid);
    y.chamb_ieta := nullify(t.chamb_ieta);
    y.cointype := nullify(t.cointype);
    y.posphi := nullify(t.posphi);
    y.phimod := nullify(t.phimod);
    y.specific := nullify(t.specific);
    y.data_valid := nullify(t.data_valid);
    return y;
  end function nullify;
  function zeroed(t: ucm_cde) return ucm_cde is
  variable y: ucm_cde;
  begin
    y.muid := zeroed(t.muid);
    y.chamb_ieta := zeroed(t.chamb_ieta);
    y.cointype := zeroed(t.cointype);
    y.posphi := zeroed(t.posphi);
    y.phimod := zeroed(t.phimod);
    y.specific := zeroed(t.specific);
    y.data_valid := zeroed(t.data_valid);
    return y;
  end function zeroed;

  function len(x: ucm_cde_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_cde_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_cde_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_cde_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_cde_bus) return ucm_cde_bus is
    variable y : ucm_cde_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_cde_bus) return ucm_cde_bus is
    variable y : ucm_cde_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_cde_bus) return ucm_cde_bus is
    variable y : ucm_cde_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_cde_bus) return ucm_cde_bus is
    variable y : ucm_cde_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_csw_ch_control) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_present);
    l := l + len(x.addr_orig);
    return l;
  end function len;
  function width(x: ucm_csw_ch_control) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_present);
    l := l + width(x.addr_orig);
    return l;
  end function width;
  function vectorify(x: ucm_csw_ch_control; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_present)-1), vectorify(x.data_present, y(left to left+len(x.data_present)-1)));
      left := left + len(x.data_present);
      assign(y(left to left+len(x.addr_orig)-1), vectorify(x.addr_orig, y(left to left+len(x.addr_orig)-1)));
    else
      assign(y(left downto left-len(x.data_present)+1), vectorify(x.data_present, y(left downto left-len(x.data_present)+1)));
      left := left - len(x.data_present);
      assign(y(left downto left-len(x.addr_orig)+1), vectorify(x.addr_orig, y(left downto left-len(x.addr_orig)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_csw_ch_control; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_present)-1), convert(x.data_present, y(left to left+len(x.data_present)-1)));
      left := left + len(x.data_present);
      assign(y(left to left+len(x.addr_orig)-1), convert(x.addr_orig, y(left to left+len(x.addr_orig)-1)));
    else
      assign(y(left downto left-len(x.data_present)+1), convert(x.data_present, y(left downto left-len(x.data_present)+1)));
      left := left - len(x.data_present);
      assign(y(left downto left-len(x.addr_orig)+1), convert(x.addr_orig, y(left downto left-len(x.addr_orig)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_csw_ch_control) return ucm_csw_ch_control is
    variable y: ucm_csw_ch_control;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_present := structify(x(left to left+len(y.data_present)-1), y.data_present);
      left := left + len(y.data_present);
      y.addr_orig := structify(x(left to left+len(y.addr_orig)-1), y.addr_orig);
    else
      y.data_present := structify(x(left downto left-len(y.data_present)+1), y.data_present);
      left := left - len(y.data_present);
      y.addr_orig := structify(x(left downto left-len(y.addr_orig)+1), y.addr_orig);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_csw_ch_control) return ucm_csw_ch_control is
    variable y: ucm_csw_ch_control;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_present := convert(x(left to left+len(y.data_present)-1), y.data_present);
      left := left + len(y.data_present);
      y.addr_orig := convert(x(left to left+len(y.addr_orig)-1), y.addr_orig);
    else
      y.data_present := convert(x(left downto left-len(y.data_present)+1), y.data_present);
      left := left - len(y.data_present);
      y.addr_orig := convert(x(left downto left-len(y.addr_orig)+1), y.addr_orig);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_csw_ch_control) return ucm_csw_ch_control is
  variable y: ucm_csw_ch_control;
  begin
    y.data_present := nullify(t.data_present);
    y.addr_orig := nullify(t.addr_orig);
    return y;
  end function nullify;
  function zeroed(t: ucm_csw_ch_control) return ucm_csw_ch_control is
  variable y: ucm_csw_ch_control;
  begin
    y.data_present := zeroed(t.data_present);
    y.addr_orig := zeroed(t.addr_orig);
    return y;
  end function zeroed;

  function len(x: ucm_csw_control) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_csw_control) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_csw_control; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_csw_control; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_csw_control) return ucm_csw_control is
    variable y : ucm_csw_control(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_csw_control) return ucm_csw_control is
    variable y : ucm_csw_control(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_csw_control) return ucm_csw_control is
    variable y : ucm_csw_control(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_csw_control) return ucm_csw_control is
    variable y : ucm_csw_control(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_pam_ch_control) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_present);
    l := l + len(x.addr_orig);
    return l;
  end function len;
  function width(x: ucm_pam_ch_control) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_present);
    l := l + width(x.addr_orig);
    return l;
  end function width;
  function vectorify(x: ucm_pam_ch_control; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_present)-1), vectorify(x.data_present, y(left to left+len(x.data_present)-1)));
      left := left + len(x.data_present);
      assign(y(left to left+len(x.addr_orig)-1), vectorify(x.addr_orig, y(left to left+len(x.addr_orig)-1)));
    else
      assign(y(left downto left-len(x.data_present)+1), vectorify(x.data_present, y(left downto left-len(x.data_present)+1)));
      left := left - len(x.data_present);
      assign(y(left downto left-len(x.addr_orig)+1), vectorify(x.addr_orig, y(left downto left-len(x.addr_orig)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_pam_ch_control; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_present)-1), convert(x.data_present, y(left to left+len(x.data_present)-1)));
      left := left + len(x.data_present);
      assign(y(left to left+len(x.addr_orig)-1), convert(x.addr_orig, y(left to left+len(x.addr_orig)-1)));
    else
      assign(y(left downto left-len(x.data_present)+1), convert(x.data_present, y(left downto left-len(x.data_present)+1)));
      left := left - len(x.data_present);
      assign(y(left downto left-len(x.addr_orig)+1), convert(x.addr_orig, y(left downto left-len(x.addr_orig)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_pam_ch_control) return ucm_pam_ch_control is
    variable y: ucm_pam_ch_control;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_present := structify(x(left to left+len(y.data_present)-1), y.data_present);
      left := left + len(y.data_present);
      y.addr_orig := structify(x(left to left+len(y.addr_orig)-1), y.addr_orig);
    else
      y.data_present := structify(x(left downto left-len(y.data_present)+1), y.data_present);
      left := left - len(y.data_present);
      y.addr_orig := structify(x(left downto left-len(y.addr_orig)+1), y.addr_orig);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_pam_ch_control) return ucm_pam_ch_control is
    variable y: ucm_pam_ch_control;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_present := convert(x(left to left+len(y.data_present)-1), y.data_present);
      left := left + len(y.data_present);
      y.addr_orig := convert(x(left to left+len(y.addr_orig)-1), y.addr_orig);
    else
      y.data_present := convert(x(left downto left-len(y.data_present)+1), y.data_present);
      left := left - len(y.data_present);
      y.addr_orig := convert(x(left downto left-len(y.addr_orig)+1), y.addr_orig);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_pam_ch_control) return ucm_pam_ch_control is
  variable y: ucm_pam_ch_control;
  begin
    y.data_present := nullify(t.data_present);
    y.addr_orig := nullify(t.addr_orig);
    return y;
  end function nullify;
  function zeroed(t: ucm_pam_ch_control) return ucm_pam_ch_control is
  variable y: ucm_pam_ch_control;
  begin
    y.data_present := zeroed(t.data_present);
    y.addr_orig := zeroed(t.addr_orig);
    return y;
  end function zeroed;

  function len(x: ucm_pam_control) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_pam_control) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_pam_control; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_pam_control; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_pam_control) return ucm_pam_control is
    variable y : ucm_pam_control(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_pam_control) return ucm_pam_control is
    variable y : ucm_pam_control(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_pam_control) return ucm_pam_control is
    variable y : ucm_pam_control(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_pam_control) return ucm_pam_control is
    variable y : ucm_pam_control(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_proc_info_ch) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ch);
    l := l + len(x.processed);
    l := l + len(x.dv);
    return l;
  end function len;
  function width(x: ucm_proc_info_ch) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ch);
    l := l + width(x.processed);
    l := l + width(x.dv);
    return l;
  end function width;
  function vectorify(x: ucm_proc_info_ch; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ch)-1), vectorify(x.ch, y(left to left+len(x.ch)-1)));
      left := left + len(x.ch);
      assign(y(left to left+len(x.processed)-1), vectorify(x.processed, y(left to left+len(x.processed)-1)));
      left := left + len(x.processed);
      assign(y(left to left+len(x.dv)-1), vectorify(x.dv, y(left to left+len(x.dv)-1)));
    else
      assign(y(left downto left-len(x.ch)+1), vectorify(x.ch, y(left downto left-len(x.ch)+1)));
      left := left - len(x.ch);
      assign(y(left downto left-len(x.processed)+1), vectorify(x.processed, y(left downto left-len(x.processed)+1)));
      left := left - len(x.processed);
      assign(y(left downto left-len(x.dv)+1), vectorify(x.dv, y(left downto left-len(x.dv)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_proc_info_ch; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ch)-1), convert(x.ch, y(left to left+len(x.ch)-1)));
      left := left + len(x.ch);
      assign(y(left to left+len(x.processed)-1), convert(x.processed, y(left to left+len(x.processed)-1)));
      left := left + len(x.processed);
      assign(y(left to left+len(x.dv)-1), convert(x.dv, y(left to left+len(x.dv)-1)));
    else
      assign(y(left downto left-len(x.ch)+1), convert(x.ch, y(left downto left-len(x.ch)+1)));
      left := left - len(x.ch);
      assign(y(left downto left-len(x.processed)+1), convert(x.processed, y(left downto left-len(x.processed)+1)));
      left := left - len(x.processed);
      assign(y(left downto left-len(x.dv)+1), convert(x.dv, y(left downto left-len(x.dv)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_proc_info_ch) return ucm_proc_info_ch is
    variable y: ucm_proc_info_ch;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ch := structify(x(left to left+len(y.ch)-1), y.ch);
      left := left + len(y.ch);
      y.processed := structify(x(left to left+len(y.processed)-1), y.processed);
      left := left + len(y.processed);
      y.dv := structify(x(left to left+len(y.dv)-1), y.dv);
    else
      y.ch := structify(x(left downto left-len(y.ch)+1), y.ch);
      left := left - len(y.ch);
      y.processed := structify(x(left downto left-len(y.processed)+1), y.processed);
      left := left - len(y.processed);
      y.dv := structify(x(left downto left-len(y.dv)+1), y.dv);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_proc_info_ch) return ucm_proc_info_ch is
    variable y: ucm_proc_info_ch;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ch := convert(x(left to left+len(y.ch)-1), y.ch);
      left := left + len(y.ch);
      y.processed := convert(x(left to left+len(y.processed)-1), y.processed);
      left := left + len(y.processed);
      y.dv := convert(x(left to left+len(y.dv)-1), y.dv);
    else
      y.ch := convert(x(left downto left-len(y.ch)+1), y.ch);
      left := left - len(y.ch);
      y.processed := convert(x(left downto left-len(y.processed)+1), y.processed);
      left := left - len(y.processed);
      y.dv := convert(x(left downto left-len(y.dv)+1), y.dv);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_proc_info_ch) return ucm_proc_info_ch is
  variable y: ucm_proc_info_ch;
  begin
    y.ch := nullify(t.ch);
    y.processed := nullify(t.processed);
    y.dv := nullify(t.dv);
    return y;
  end function nullify;
  function zeroed(t: ucm_proc_info_ch) return ucm_proc_info_ch is
  variable y: ucm_proc_info_ch;
  begin
    y.ch := zeroed(t.ch);
    y.processed := zeroed(t.processed);
    y.dv := zeroed(t.dv);
    return y;
  end function zeroed;

  function len(x: ucm_proc_info) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_proc_info) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_proc_info; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_proc_info; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_proc_info) return ucm_proc_info is
    variable y : ucm_proc_info(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_proc_info) return ucm_proc_info is
    variable y : ucm_proc_info(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_proc_info) return ucm_proc_info is
    variable y : ucm_proc_info(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_proc_info) return ucm_proc_info is
    variable y : ucm_proc_info(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

end package body ucm_pkg;
