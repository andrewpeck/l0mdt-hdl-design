-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package ucm_pkg is

   -- Custom types and functions --

   constant SLC_SPECIFIC_LEN : integer := 48;
   attribute w of SLC_SPECIFIC_LEN : constant is 32;

   constant UCM_CDE2CVP_PHIMOD_LEN : integer := 5;
   attribute w of UCM_CDE2CVP_PHIMOD_LEN : constant is 32;

   constant UCM_CDE2CVP_PHIMOD_MULT : real := 12.0;
   attribute w of UCM_CDE2CVP_PHIMOD_MULT : constant is 32;

   constant UCM_PHIMOD_LEN : integer := 5;
   attribute w of UCM_PHIMOD_LEN : constant is 32;

   type ucm_prepro2ctrl_rt is record
      data_valid : std_logic;
   end record ucm_prepro2ctrl_rt;
   attribute w of ucm_prepro2ctrl_rt : type is 1;
   function width(x: ucm_prepro2ctrl_rt) return natural;
   function convert(x: ucm_prepro2ctrl_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt;
   function zero(tpl: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt;

   subtype ucm_prepro2ctrl_vt is std_logic_vector(ucm_prepro2ctrl_rt'w-1 to 0);
   attribute w of ucm_prepro2ctrl_vt : subtype is 1;

   type ucm_prepro2ctrl_art is array(integer range <>) of ucm_prepro2ctrl_rt;
   function width(x: ucm_prepro2ctrl_art) return integer;
   function convert(x: ucm_prepro2ctrl_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art;
   function zero(tpl: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art;
   function convert(x: ucm_prepro2ctrl_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art;

   type ucm_prepro2ctrl_avt is array(integer range <>) of ucm_prepro2ctrl_vt;
   function width(x: ucm_prepro2ctrl_avt) return integer;
   function convert(x: ucm_prepro2ctrl_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt;
   function zero(tpl: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt;
   function convert(x: ucm_prepro2ctrl_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt;

   subtype ucm_rpc_lt is std_logic_vector(SLC_Z_RPC_LEN -1 downto 0);
   attribute w of ucm_rpc_lt : subtype is 12;

   type ucm_rpc_r_alt is array(integer range <>) of ucm_rpc_lt;
   function width(x: ucm_rpc_r_alt) return integer;
   function convert(x: ucm_rpc_r_alt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_rpc_r_alt) return ucm_rpc_r_alt;
   function zero(tpl: ucm_rpc_r_alt) return ucm_rpc_r_alt;
   function convert(x: ucm_rpc_r_alt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_rpc_r_alt) return ucm_rpc_r_alt;

   subtype ucm_mdt_lt is std_logic_vector(UCM_Z_ROI_LEN -1 downto 0);
   attribute w of ucm_mdt_lt : subtype is 14;

   type ucm_mdt_r_alt is array(integer range <>) of ucm_mdt_lt;
   function width(x: ucm_mdt_r_alt) return integer;
   function convert(x: ucm_mdt_r_alt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_mdt_r_alt) return ucm_mdt_r_alt;
   function zero(tpl: ucm_mdt_r_alt) return ucm_mdt_r_alt;
   function convert(x: ucm_mdt_r_alt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_mdt_r_alt) return ucm_mdt_r_alt;

   subtype chamb_ieta_rpc_ut is unsigned(4-1 downto 0);
   attribute w of chamb_ieta_rpc_ut : subtype is 4;

   type chamb_ieta_rpc_aut is array(4-1 downto 0) of chamb_ieta_rpc_ut;
   attribute w of chamb_ieta_rpc_aut : type is 16;
   function width(x: chamb_ieta_rpc_aut) return integer;
   function convert(x: chamb_ieta_rpc_aut; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut;
   function zero(tpl: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut;
   function convert(x: chamb_ieta_rpc_aut; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut;

   type ucm_cde_rt is record
      muid : slc_muid_rt;
      chamb_ieta : chamb_ieta_rpc_aut;
      cointype : std_logic_vector(SLC_COMMON_COINTYPE_LEN - 1 downto 0);
      posphi : unsigned(SLC_COMMON_POSPHI_LEN -1 downto 0);
      phimod : std_logic_vector(UCM_CDE2CVP_PHIMOD_LEN -1 downto 0);
      specific : std_logic_vector(SLC_SPECIFIC_LEN -1 downto 0);
      data_valid : std_logic;
   end record ucm_cde_rt;
   attribute w of ucm_cde_rt : type is 103;
   function width(x: ucm_cde_rt) return natural;
   function convert(x: ucm_cde_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_cde_rt) return ucm_cde_rt;
   function zero(tpl: ucm_cde_rt) return ucm_cde_rt;

   subtype ucm_cde_vt is std_logic_vector(ucm_cde_rt'w-1 downto 0);
   attribute w of ucm_cde_vt : subtype is 103;

   type ucm_cde_art is array(integer range <>) of ucm_cde_rt;
   function width(x: ucm_cde_art) return integer;
   function convert(x: ucm_cde_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_cde_art) return ucm_cde_art;
   function zero(tpl: ucm_cde_art) return ucm_cde_art;
   function convert(x: ucm_cde_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_cde_art) return ucm_cde_art;

   type ucm_cde_avt is array(integer range <>) of ucm_cde_vt;
   function width(x: ucm_cde_avt) return integer;
   function convert(x: ucm_cde_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_cde_avt) return ucm_cde_avt;
   function zero(tpl: ucm_cde_avt) return ucm_cde_avt;
   function convert(x: ucm_cde_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_cde_avt) return ucm_cde_avt;

   type ucm_csw_control_rt is record
      data_present : std_logic;
      addr_dest : std_logic_vector(4-1 downto 0);
   end record ucm_csw_control_rt;
   attribute w of ucm_csw_control_rt : type is 5;
   function width(x: ucm_csw_control_rt) return natural;
   function convert(x: ucm_csw_control_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_csw_control_rt) return ucm_csw_control_rt;
   function zero(tpl: ucm_csw_control_rt) return ucm_csw_control_rt;

   subtype ucm_csw_control_vt is std_logic_vector(ucm_csw_control_rt'w-1 downto 0);
   attribute w of ucm_csw_control_vt : subtype is 5;

   type ucm_csw_control_art is array(integer range <>) of ucm_csw_control_rt;
   function width(x: ucm_csw_control_art) return integer;
   function convert(x: ucm_csw_control_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_csw_control_art) return ucm_csw_control_art;
   function zero(tpl: ucm_csw_control_art) return ucm_csw_control_art;
   function convert(x: ucm_csw_control_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_csw_control_art) return ucm_csw_control_art;

   type ucm_csw_control_avt is array(integer range <>) of ucm_csw_control_vt;
   function width(x: ucm_csw_control_avt) return integer;
   function convert(x: ucm_csw_control_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_csw_control_avt) return ucm_csw_control_avt;
   function zero(tpl: ucm_csw_control_avt) return ucm_csw_control_avt;
   function convert(x: ucm_csw_control_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_csw_control_avt) return ucm_csw_control_avt;

   type ucm_pam_control_rt is record
      data_present : std_logic;
      addr_dest : std_logic_vector(4-1 downto 0);
   end record ucm_pam_control_rt;
   attribute w of ucm_pam_control_rt : type is 5;
   function width(x: ucm_pam_control_rt) return natural;
   function convert(x: ucm_pam_control_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_pam_control_rt) return ucm_pam_control_rt;
   function zero(tpl: ucm_pam_control_rt) return ucm_pam_control_rt;

   subtype ucm_pam_control_vt is std_logic_vector(ucm_pam_control_rt'w-1 downto 0);
   attribute w of ucm_pam_control_vt : subtype is 5;

   type ucm_pam_control_art is array(integer range <>) of ucm_pam_control_rt;
   function width(x: ucm_pam_control_art) return integer;
   function convert(x: ucm_pam_control_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_pam_control_art) return ucm_pam_control_art;
   function zero(tpl: ucm_pam_control_art) return ucm_pam_control_art;
   function convert(x: ucm_pam_control_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_pam_control_art) return ucm_pam_control_art;

   type ucm_pam_control_avt is array(integer range <>) of ucm_pam_control_vt;
   function width(x: ucm_pam_control_avt) return integer;
   function convert(x: ucm_pam_control_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_pam_control_avt) return ucm_pam_control_avt;
   function zero(tpl: ucm_pam_control_avt) return ucm_pam_control_avt;
   function convert(x: ucm_pam_control_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_pam_control_avt) return ucm_pam_control_avt;

   type ucm_proc_info_rt is record
      ch : std_logic_vector(4-1 downto 0);
      processed : std_logic;
      dv : std_logic;
   end record ucm_proc_info_rt;
   attribute w of ucm_proc_info_rt : type is 6;
   function width(x: ucm_proc_info_rt) return natural;
   function convert(x: ucm_proc_info_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_proc_info_rt) return ucm_proc_info_rt;
   function zero(tpl: ucm_proc_info_rt) return ucm_proc_info_rt;

   subtype ucm_proc_info_vt is std_logic_vector(ucm_proc_info_rt'w-1 downto 0);
   attribute w of ucm_proc_info_vt : subtype is 6;

   type ucm_proc_info_art is array(integer range <>) of ucm_proc_info_rt;
   function width(x: ucm_proc_info_art) return integer;
   function convert(x: ucm_proc_info_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_proc_info_art) return ucm_proc_info_art;
   function zero(tpl: ucm_proc_info_art) return ucm_proc_info_art;
   function convert(x: ucm_proc_info_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_proc_info_art) return ucm_proc_info_art;

   type ucm_proc_info_avt is array(integer range <>) of ucm_proc_info_vt;
   function width(x: ucm_proc_info_avt) return integer;
   function convert(x: ucm_proc_info_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm_proc_info_avt) return ucm_proc_info_avt;
   function zero(tpl: ucm_proc_info_avt) return ucm_proc_info_avt;
   function convert(x: ucm_proc_info_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm_proc_info_avt) return ucm_proc_info_avt;

end package ucm_pkg;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;

package body ucm_pkg is

   -- Custom types and functions --

   function width(x: ucm_prepro2ctrl_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      return w;
   end function width;
   function convert(x: ucm_prepro2ctrl_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt is
      variable y : ucm_prepro2ctrl_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: ucm_prepro2ctrl_art) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_prepro2ctrl_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art is
      variable y : ucm_prepro2ctrl_art(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_prepro2ctrl_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art is
      variable y : ucm_prepro2ctrl_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_prepro2ctrl_avt) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_prepro2ctrl_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt is
      variable y : ucm_prepro2ctrl_avt(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_prepro2ctrl_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt is
      variable y : ucm_prepro2ctrl_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_rpc_r_alt) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_rpc_r_alt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_rpc_r_alt) return ucm_rpc_r_alt is
      variable y : ucm_rpc_r_alt(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_rpc_r_alt) return ucm_rpc_r_alt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_rpc_r_alt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_rpc_r_alt) return ucm_rpc_r_alt is
      variable y : ucm_rpc_r_alt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_mdt_r_alt) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_mdt_r_alt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_mdt_r_alt) return ucm_mdt_r_alt is
      variable y : ucm_mdt_r_alt(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_mdt_r_alt) return ucm_mdt_r_alt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_mdt_r_alt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_mdt_r_alt) return ucm_mdt_r_alt is
      variable y : ucm_mdt_r_alt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: chamb_ieta_rpc_aut) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: chamb_ieta_rpc_aut; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut is
      variable y : chamb_ieta_rpc_aut;
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: chamb_ieta_rpc_aut; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut is
      variable y : chamb_ieta_rpc_aut;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_cde_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.muid);
      w := w + width(x.chamb_ieta);
      w := w + width(x.cointype);
      w := w + width(x.posphi);
      w := w + width(x.phimod);
      w := w + width(x.specific);
      w := w + width(x.data_valid);
      return w;
   end function width;
   function convert(x: ucm_cde_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.muid);
         y(u to u+w-1) := convert(x.muid, y(u to u+w-1));
         u := u + w;
         w := width(x.chamb_ieta);
         y(u to u+w-1) := convert(x.chamb_ieta, y(u to u+w-1));
         u := u + w;
         w := width(x.cointype);
         y(u to u+w-1) := convert(x.cointype, y(u to u+w-1));
         u := u + w;
         w := width(x.posphi);
         y(u to u+w-1) := convert(x.posphi, y(u to u+w-1));
         u := u + w;
         w := width(x.phimod);
         y(u to u+w-1) := convert(x.phimod, y(u to u+w-1));
         u := u + w;
         w := width(x.specific);
         y(u to u+w-1) := convert(x.specific, y(u to u+w-1));
         u := u + w;
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
      else
         w := width(x.muid);
         y(u downto u-w+1) := convert(x.muid, y(u downto u-w+1));
         u := u - w;
         w := width(x.chamb_ieta);
         y(u downto u-w+1) := convert(x.chamb_ieta, y(u downto u-w+1));
         u := u - w;
         w := width(x.cointype);
         y(u downto u-w+1) := convert(x.cointype, y(u downto u-w+1));
         u := u - w;
         w := width(x.posphi);
         y(u downto u-w+1) := convert(x.posphi, y(u downto u-w+1));
         u := u - w;
         w := width(x.phimod);
         y(u downto u-w+1) := convert(x.phimod, y(u downto u-w+1));
         u := u - w;
         w := width(x.specific);
         y(u downto u-w+1) := convert(x.specific, y(u downto u-w+1));
         u := u - w;
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_cde_rt) return ucm_cde_rt is
      variable y : ucm_cde_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.muid);
         y.muid := convert(x(u to u+w-1), tpl.muid);
         u := u + w;
         w := width(tpl.chamb_ieta);
         y.chamb_ieta := convert(x(u to u+w-1), tpl.chamb_ieta);
         u := u + w;
         w := width(tpl.cointype);
         y.cointype := convert(x(u to u+w-1), tpl.cointype);
         u := u + w;
         w := width(tpl.posphi);
         y.posphi := convert(x(u to u+w-1), tpl.posphi);
         u := u + w;
         w := width(tpl.phimod);
         y.phimod := convert(x(u to u+w-1), tpl.phimod);
         u := u + w;
         w := width(tpl.specific);
         y.specific := convert(x(u to u+w-1), tpl.specific);
         u := u + w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
      else
         w := width(tpl.muid);
         y.muid := convert(x(u downto u-w+1), tpl.muid);
         u := u - w;
         w := width(tpl.chamb_ieta);
         y.chamb_ieta := convert(x(u downto u-w+1), tpl.chamb_ieta);
         u := u - w;
         w := width(tpl.cointype);
         y.cointype := convert(x(u downto u-w+1), tpl.cointype);
         u := u - w;
         w := width(tpl.posphi);
         y.posphi := convert(x(u downto u-w+1), tpl.posphi);
         u := u - w;
         w := width(tpl.phimod);
         y.phimod := convert(x(u downto u-w+1), tpl.phimod);
         u := u - w;
         w := width(tpl.specific);
         y.specific := convert(x(u downto u-w+1), tpl.specific);
         u := u - w;
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_cde_rt) return ucm_cde_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: ucm_cde_art) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_cde_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_cde_art) return ucm_cde_art is
      variable y : ucm_cde_art(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_cde_art) return ucm_cde_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_cde_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_cde_art) return ucm_cde_art is
      variable y : ucm_cde_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_cde_avt) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_cde_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_cde_avt) return ucm_cde_avt is
      variable y : ucm_cde_avt(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_cde_avt) return ucm_cde_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_cde_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_cde_avt) return ucm_cde_avt is
      variable y : ucm_cde_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_csw_control_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_present);
      w := w + width(x.addr_dest);
      return w;
   end function width;
   function convert(x: ucm_csw_control_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_present);
         y(u to u+w-1) := convert(x.data_present, y(u to u+w-1));
         u := u + w;
         w := width(x.addr_dest);
         y(u to u+w-1) := convert(x.addr_dest, y(u to u+w-1));
      else
         w := width(x.data_present);
         y(u downto u-w+1) := convert(x.data_present, y(u downto u-w+1));
         u := u - w;
         w := width(x.addr_dest);
         y(u downto u-w+1) := convert(x.addr_dest, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_csw_control_rt) return ucm_csw_control_rt is
      variable y : ucm_csw_control_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_present);
         y.data_present := convert(x(u to u+w-1), tpl.data_present);
         u := u + w;
         w := width(tpl.addr_dest);
         y.addr_dest := convert(x(u to u+w-1), tpl.addr_dest);
      else
         w := width(tpl.data_present);
         y.data_present := convert(x(u downto u-w+1), tpl.data_present);
         u := u - w;
         w := width(tpl.addr_dest);
         y.addr_dest := convert(x(u downto u-w+1), tpl.addr_dest);
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_csw_control_rt) return ucm_csw_control_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: ucm_csw_control_art) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_csw_control_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_csw_control_art) return ucm_csw_control_art is
      variable y : ucm_csw_control_art(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_csw_control_art) return ucm_csw_control_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_csw_control_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_csw_control_art) return ucm_csw_control_art is
      variable y : ucm_csw_control_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_csw_control_avt) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_csw_control_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_csw_control_avt) return ucm_csw_control_avt is
      variable y : ucm_csw_control_avt(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_csw_control_avt) return ucm_csw_control_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_csw_control_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_csw_control_avt) return ucm_csw_control_avt is
      variable y : ucm_csw_control_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_pam_control_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_present);
      w := w + width(x.addr_dest);
      return w;
   end function width;
   function convert(x: ucm_pam_control_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_present);
         y(u to u+w-1) := convert(x.data_present, y(u to u+w-1));
         u := u + w;
         w := width(x.addr_dest);
         y(u to u+w-1) := convert(x.addr_dest, y(u to u+w-1));
      else
         w := width(x.data_present);
         y(u downto u-w+1) := convert(x.data_present, y(u downto u-w+1));
         u := u - w;
         w := width(x.addr_dest);
         y(u downto u-w+1) := convert(x.addr_dest, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_pam_control_rt) return ucm_pam_control_rt is
      variable y : ucm_pam_control_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_present);
         y.data_present := convert(x(u to u+w-1), tpl.data_present);
         u := u + w;
         w := width(tpl.addr_dest);
         y.addr_dest := convert(x(u to u+w-1), tpl.addr_dest);
      else
         w := width(tpl.data_present);
         y.data_present := convert(x(u downto u-w+1), tpl.data_present);
         u := u - w;
         w := width(tpl.addr_dest);
         y.addr_dest := convert(x(u downto u-w+1), tpl.addr_dest);
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_pam_control_rt) return ucm_pam_control_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: ucm_pam_control_art) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_pam_control_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_pam_control_art) return ucm_pam_control_art is
      variable y : ucm_pam_control_art(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_pam_control_art) return ucm_pam_control_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_pam_control_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_pam_control_art) return ucm_pam_control_art is
      variable y : ucm_pam_control_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_pam_control_avt) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_pam_control_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_pam_control_avt) return ucm_pam_control_avt is
      variable y : ucm_pam_control_avt(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_pam_control_avt) return ucm_pam_control_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_pam_control_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_pam_control_avt) return ucm_pam_control_avt is
      variable y : ucm_pam_control_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_proc_info_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ch);
      w := w + width(x.processed);
      w := w + width(x.dv);
      return w;
   end function width;
   function convert(x: ucm_proc_info_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ch);
         y(u to u+w-1) := convert(x.ch, y(u to u+w-1));
         u := u + w;
         w := width(x.processed);
         y(u to u+w-1) := convert(x.processed, y(u to u+w-1));
         u := u + w;
         w := width(x.dv);
         y(u to u+w-1) := convert(x.dv, y(u to u+w-1));
      else
         w := width(x.ch);
         y(u downto u-w+1) := convert(x.ch, y(u downto u-w+1));
         u := u - w;
         w := width(x.processed);
         y(u downto u-w+1) := convert(x.processed, y(u downto u-w+1));
         u := u - w;
         w := width(x.dv);
         y(u downto u-w+1) := convert(x.dv, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_proc_info_rt) return ucm_proc_info_rt is
      variable y : ucm_proc_info_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ch);
         y.ch := convert(x(u to u+w-1), tpl.ch);
         u := u + w;
         w := width(tpl.processed);
         y.processed := convert(x(u to u+w-1), tpl.processed);
         u := u + w;
         w := width(tpl.dv);
         y.dv := convert(x(u to u+w-1), tpl.dv);
      else
         w := width(tpl.ch);
         y.ch := convert(x(u downto u-w+1), tpl.ch);
         u := u - w;
         w := width(tpl.processed);
         y.processed := convert(x(u downto u-w+1), tpl.processed);
         u := u - w;
         w := width(tpl.dv);
         y.dv := convert(x(u downto u-w+1), tpl.dv);
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_proc_info_rt) return ucm_proc_info_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: ucm_proc_info_art) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_proc_info_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_proc_info_art) return ucm_proc_info_art is
      variable y : ucm_proc_info_art(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_proc_info_art) return ucm_proc_info_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_proc_info_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_proc_info_art) return ucm_proc_info_art is
      variable y : ucm_proc_info_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm_proc_info_avt) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: ucm_proc_info_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm_proc_info_avt) return ucm_proc_info_avt is
      variable y : ucm_proc_info_avt(tpl'range);
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm_proc_info_avt) return ucm_proc_info_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm_proc_info_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl'range(1));
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm_proc_info_avt) return ucm_proc_info_avt is
      variable y : ucm_proc_info_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

end package body ucm_pkg;
