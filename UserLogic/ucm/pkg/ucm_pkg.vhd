-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.common_types_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;

package ucm_pkg is

  constant SLC_SPECIFIC_LEN : integer := 48;

  constant UCM_CDE2CVP_PHIMOD_LEN : integer := 5;

  constant UCM_CDE2CVP_PHIMOD_MULT : real := 12.0;

  constant UCM_PHIMOD_LEN : integer := 5;

  type ucm_prepro2ctrl_rt is record
    data_valid : std_logic;
  end record ucm_prepro2ctrl_rt;
  function len(x: ucm_prepro2ctrl_rt) return natural;
  function width(x: ucm_prepro2ctrl_rt) return natural;
  function vectorify(x: ucm_prepro2ctrl_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_prepro2ctrl_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt;
  function convert(x: in std_logic_vector; t: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt;
  function nullify(t: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt;
  function zeroed(t: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt;

  subtype ucm_prepro2ctrl_vt is std_logic_vector(1-1 downto 0);

  type ucm_prepro2ctrl_art is array(integer range <>) of ucm_prepro2ctrl_rt;
  function len(x: ucm_prepro2ctrl_art) return natural;
  function width(x: ucm_prepro2ctrl_art) return natural;
  function vectorify(x: ucm_prepro2ctrl_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_prepro2ctrl_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art;
  function convert(x: std_logic_vector; t: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art;
  function nullify(x: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art;
  function zeroed(x: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art;

  type ucm_prepro2ctrl_avt is array(integer range <>) of ucm_prepro2ctrl_vt;
  function len(x: ucm_prepro2ctrl_avt) return natural;
  function width(x: ucm_prepro2ctrl_avt) return natural;
  function vectorify(x: ucm_prepro2ctrl_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_prepro2ctrl_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt;
  function convert(x: std_logic_vector; t: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt;
  function nullify(x: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt;
  function zeroed(x: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt;

  subtype ucm_rpc_lt is std_logic_vector(SLC_Z_RPC_LEN-1 downto 0);

  type ucm_rpc_r_alt is array(integer range <>) of ucm_rpc_lt;
  function len(x: ucm_rpc_r_alt) return natural;
  function width(x: ucm_rpc_r_alt) return natural;
  function vectorify(x: ucm_rpc_r_alt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_rpc_r_alt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_rpc_r_alt) return ucm_rpc_r_alt;
  function convert(x: std_logic_vector; t: ucm_rpc_r_alt) return ucm_rpc_r_alt;
  function nullify(x: ucm_rpc_r_alt) return ucm_rpc_r_alt;
  function zeroed(x: ucm_rpc_r_alt) return ucm_rpc_r_alt;

  subtype ucm_mdt_lt is std_logic_vector(UCM_Z_ROI_LEN-1 downto 0);

  type ucm_mdt_r_alt is array(integer range <>) of ucm_mdt_lt;
  function len(x: ucm_mdt_r_alt) return natural;
  function width(x: ucm_mdt_r_alt) return natural;
  function vectorify(x: ucm_mdt_r_alt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_mdt_r_alt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_mdt_r_alt) return ucm_mdt_r_alt;
  function convert(x: std_logic_vector; t: ucm_mdt_r_alt) return ucm_mdt_r_alt;
  function nullify(x: ucm_mdt_r_alt) return ucm_mdt_r_alt;
  function zeroed(x: ucm_mdt_r_alt) return ucm_mdt_r_alt;

  subtype chamb_ieta_rpc_ut is unsigned(4-1 downto 0);

  type chamb_ieta_rpc_aut is array(4-1 downto 0) of chamb_ieta_rpc_ut;
  function len(x: chamb_ieta_rpc_aut) return natural;
  function width(x: chamb_ieta_rpc_aut) return natural;
  function vectorify(x: chamb_ieta_rpc_aut; t: std_logic_vector) return std_logic_vector;
  function convert(x: chamb_ieta_rpc_aut; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut;
  function convert(x: std_logic_vector; t: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut;
  function nullify(x: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut;
  function zeroed(x: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut;

  type ucm_cde_rt is record
    muid : slc_muid_rt;
    chamb_ieta : chamb_ieta_rpc_aut;
    cointype : std_logic_vector(SLC_COMMON_COINTYPE_LEN-1 downto 0);
    posphi : unsigned(SLC_COMMON_POSPHI_LEN-1 downto 0);
    phimod : std_logic_vector(UCM_CDE2CVP_PHIMOD_LEN-1 downto 0);
    specific : std_logic_vector(SLC_SPECIFIC_LEN-1 downto 0);
    data_valid : std_logic;
  end record ucm_cde_rt;
  function len(x: ucm_cde_rt) return natural;
  function width(x: ucm_cde_rt) return natural;
  function vectorify(x: ucm_cde_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_cde_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_cde_rt) return ucm_cde_rt;
  function convert(x: in std_logic_vector; t: ucm_cde_rt) return ucm_cde_rt;
  function nullify(t: ucm_cde_rt) return ucm_cde_rt;
  function zeroed(t: ucm_cde_rt) return ucm_cde_rt;

  subtype ucm_cde_vt is std_logic_vector(103-1 downto 0);

  type ucm_cde_art is array(integer range <>) of ucm_cde_rt;
  function len(x: ucm_cde_art) return natural;
  function width(x: ucm_cde_art) return natural;
  function vectorify(x: ucm_cde_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_cde_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_cde_art) return ucm_cde_art;
  function convert(x: std_logic_vector; t: ucm_cde_art) return ucm_cde_art;
  function nullify(x: ucm_cde_art) return ucm_cde_art;
  function zeroed(x: ucm_cde_art) return ucm_cde_art;

  type ucm_cde_avt is array(integer range <>) of ucm_cde_vt;
  function len(x: ucm_cde_avt) return natural;
  function width(x: ucm_cde_avt) return natural;
  function vectorify(x: ucm_cde_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_cde_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_cde_avt) return ucm_cde_avt;
  function convert(x: std_logic_vector; t: ucm_cde_avt) return ucm_cde_avt;
  function nullify(x: ucm_cde_avt) return ucm_cde_avt;
  function zeroed(x: ucm_cde_avt) return ucm_cde_avt;

  type ucm_csw_control_rt is record
    data_present : std_logic;
    addr_orig : std_logic_vector(4-1 downto 0);
  end record ucm_csw_control_rt;
  function len(x: ucm_csw_control_rt) return natural;
  function width(x: ucm_csw_control_rt) return natural;
  function vectorify(x: ucm_csw_control_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_csw_control_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_csw_control_rt) return ucm_csw_control_rt;
  function convert(x: in std_logic_vector; t: ucm_csw_control_rt) return ucm_csw_control_rt;
  function nullify(t: ucm_csw_control_rt) return ucm_csw_control_rt;
  function zeroed(t: ucm_csw_control_rt) return ucm_csw_control_rt;

  subtype ucm_csw_control_vt is std_logic_vector(5-1 downto 0);

  type ucm_csw_control_art is array(integer range <>) of ucm_csw_control_rt;
  function len(x: ucm_csw_control_art) return natural;
  function width(x: ucm_csw_control_art) return natural;
  function vectorify(x: ucm_csw_control_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_csw_control_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_csw_control_art) return ucm_csw_control_art;
  function convert(x: std_logic_vector; t: ucm_csw_control_art) return ucm_csw_control_art;
  function nullify(x: ucm_csw_control_art) return ucm_csw_control_art;
  function zeroed(x: ucm_csw_control_art) return ucm_csw_control_art;

  type ucm_csw_control_avt is array(integer range <>) of ucm_csw_control_vt;
  function len(x: ucm_csw_control_avt) return natural;
  function width(x: ucm_csw_control_avt) return natural;
  function vectorify(x: ucm_csw_control_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_csw_control_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_csw_control_avt) return ucm_csw_control_avt;
  function convert(x: std_logic_vector; t: ucm_csw_control_avt) return ucm_csw_control_avt;
  function nullify(x: ucm_csw_control_avt) return ucm_csw_control_avt;
  function zeroed(x: ucm_csw_control_avt) return ucm_csw_control_avt;

  type ucm_pam_control_rt is record
    data_present : std_logic;
    addr_orig : std_logic_vector(4-1 downto 0);
  end record ucm_pam_control_rt;
  function len(x: ucm_pam_control_rt) return natural;
  function width(x: ucm_pam_control_rt) return natural;
  function vectorify(x: ucm_pam_control_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_pam_control_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_pam_control_rt) return ucm_pam_control_rt;
  function convert(x: in std_logic_vector; t: ucm_pam_control_rt) return ucm_pam_control_rt;
  function nullify(t: ucm_pam_control_rt) return ucm_pam_control_rt;
  function zeroed(t: ucm_pam_control_rt) return ucm_pam_control_rt;

  subtype ucm_pam_control_vt is std_logic_vector(5-1 downto 0);

  type ucm_pam_control_art is array(integer range <>) of ucm_pam_control_rt;
  function len(x: ucm_pam_control_art) return natural;
  function width(x: ucm_pam_control_art) return natural;
  function vectorify(x: ucm_pam_control_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_pam_control_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_pam_control_art) return ucm_pam_control_art;
  function convert(x: std_logic_vector; t: ucm_pam_control_art) return ucm_pam_control_art;
  function nullify(x: ucm_pam_control_art) return ucm_pam_control_art;
  function zeroed(x: ucm_pam_control_art) return ucm_pam_control_art;

  type ucm_pam_control_avt is array(integer range <>) of ucm_pam_control_vt;
  function len(x: ucm_pam_control_avt) return natural;
  function width(x: ucm_pam_control_avt) return natural;
  function vectorify(x: ucm_pam_control_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_pam_control_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_pam_control_avt) return ucm_pam_control_avt;
  function convert(x: std_logic_vector; t: ucm_pam_control_avt) return ucm_pam_control_avt;
  function nullify(x: ucm_pam_control_avt) return ucm_pam_control_avt;
  function zeroed(x: ucm_pam_control_avt) return ucm_pam_control_avt;

  type ucm_proc_info_rt is record
    ch : std_logic_vector(4-1 downto 0);
    processed : std_logic;
    dv : std_logic;
  end record ucm_proc_info_rt;
  function len(x: ucm_proc_info_rt) return natural;
  function width(x: ucm_proc_info_rt) return natural;
  function vectorify(x: ucm_proc_info_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_proc_info_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm_proc_info_rt) return ucm_proc_info_rt;
  function convert(x: in std_logic_vector; t: ucm_proc_info_rt) return ucm_proc_info_rt;
  function nullify(t: ucm_proc_info_rt) return ucm_proc_info_rt;
  function zeroed(t: ucm_proc_info_rt) return ucm_proc_info_rt;

  subtype ucm_proc_info_vt is std_logic_vector(6-1 downto 0);

  type ucm_proc_info_art is array(integer range <>) of ucm_proc_info_rt;
  function len(x: ucm_proc_info_art) return natural;
  function width(x: ucm_proc_info_art) return natural;
  function vectorify(x: ucm_proc_info_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_proc_info_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_proc_info_art) return ucm_proc_info_art;
  function convert(x: std_logic_vector; t: ucm_proc_info_art) return ucm_proc_info_art;
  function nullify(x: ucm_proc_info_art) return ucm_proc_info_art;
  function zeroed(x: ucm_proc_info_art) return ucm_proc_info_art;

  type ucm_proc_info_avt is array(integer range <>) of ucm_proc_info_vt;
  function len(x: ucm_proc_info_avt) return natural;
  function width(x: ucm_proc_info_avt) return natural;
  function vectorify(x: ucm_proc_info_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm_proc_info_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm_proc_info_avt) return ucm_proc_info_avt;
  function convert(x: std_logic_vector; t: ucm_proc_info_avt) return ucm_proc_info_avt;
  function nullify(x: ucm_proc_info_avt) return ucm_proc_info_avt;
  function zeroed(x: ucm_proc_info_avt) return ucm_proc_info_avt;

end package ucm_pkg;

------------------------------------------------------------

package body ucm_pkg is

  function len(x: ucm_prepro2ctrl_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    return l;
  end function len;
  function width(x: ucm_prepro2ctrl_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    return l;
  end function width;
  function vectorify(x: ucm_prepro2ctrl_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_prepro2ctrl_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt is
    variable y: ucm_prepro2ctrl_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt is
    variable y: ucm_prepro2ctrl_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt is
  variable y: ucm_prepro2ctrl_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    return y;
  end function nullify;
  function zeroed(t: ucm_prepro2ctrl_rt) return ucm_prepro2ctrl_rt is
  variable y: ucm_prepro2ctrl_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    return y;
  end function zeroed;

  function len(x: ucm_prepro2ctrl_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_prepro2ctrl_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_prepro2ctrl_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_prepro2ctrl_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art is
    variable y : ucm_prepro2ctrl_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art is
    variable y : ucm_prepro2ctrl_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art is
    variable y : ucm_prepro2ctrl_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_prepro2ctrl_art) return ucm_prepro2ctrl_art is
    variable y : ucm_prepro2ctrl_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_prepro2ctrl_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_prepro2ctrl_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_prepro2ctrl_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_prepro2ctrl_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt is
    variable y : ucm_prepro2ctrl_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt is
    variable y : ucm_prepro2ctrl_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt is
    variable y : ucm_prepro2ctrl_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_prepro2ctrl_avt) return ucm_prepro2ctrl_avt is
    variable y : ucm_prepro2ctrl_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_rpc_r_alt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_rpc_r_alt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_rpc_r_alt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_rpc_r_alt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_rpc_r_alt) return ucm_rpc_r_alt is
    variable y : ucm_rpc_r_alt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_rpc_r_alt) return ucm_rpc_r_alt is
    variable y : ucm_rpc_r_alt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_rpc_r_alt) return ucm_rpc_r_alt is
    variable y : ucm_rpc_r_alt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_rpc_r_alt) return ucm_rpc_r_alt is
    variable y : ucm_rpc_r_alt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_mdt_r_alt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_mdt_r_alt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_mdt_r_alt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_mdt_r_alt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_mdt_r_alt) return ucm_mdt_r_alt is
    variable y : ucm_mdt_r_alt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_mdt_r_alt) return ucm_mdt_r_alt is
    variable y : ucm_mdt_r_alt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_mdt_r_alt) return ucm_mdt_r_alt is
    variable y : ucm_mdt_r_alt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_mdt_r_alt) return ucm_mdt_r_alt is
    variable y : ucm_mdt_r_alt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: chamb_ieta_rpc_aut) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: chamb_ieta_rpc_aut) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: chamb_ieta_rpc_aut; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: chamb_ieta_rpc_aut; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut is
    variable y : chamb_ieta_rpc_aut;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut is
    variable y : chamb_ieta_rpc_aut;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut is
    variable y : chamb_ieta_rpc_aut;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: chamb_ieta_rpc_aut) return chamb_ieta_rpc_aut is
    variable y : chamb_ieta_rpc_aut;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_cde_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.muid);
    l := l + len(x.chamb_ieta);
    l := l + len(x.cointype);
    l := l + len(x.posphi);
    l := l + len(x.phimod);
    l := l + len(x.specific);
    l := l + len(x.data_valid);
    return l;
  end function len;
  function width(x: ucm_cde_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.muid);
    l := l + width(x.chamb_ieta);
    l := l + width(x.cointype);
    l := l + width(x.posphi);
    l := l + width(x.phimod);
    l := l + width(x.specific);
    l := l + width(x.data_valid);
    return l;
  end function width;
  function vectorify(x: ucm_cde_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.chamb_ieta)-1), vectorify(x.chamb_ieta, y(left to left+len(x.chamb_ieta)-1)));
      left := left + len(x.chamb_ieta);
      assign(y(left to left+len(x.cointype)-1), vectorify(x.cointype, y(left to left+len(x.cointype)-1)));
      left := left + len(x.cointype);
      assign(y(left to left+len(x.posphi)-1), vectorify(x.posphi, y(left to left+len(x.posphi)-1)));
      left := left + len(x.posphi);
      assign(y(left to left+len(x.phimod)-1), vectorify(x.phimod, y(left to left+len(x.phimod)-1)));
      left := left + len(x.phimod);
      assign(y(left to left+len(x.specific)-1), vectorify(x.specific, y(left to left+len(x.specific)-1)));
      left := left + len(x.specific);
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.chamb_ieta)+1), vectorify(x.chamb_ieta, y(left downto left-len(x.chamb_ieta)+1)));
      left := left - len(x.chamb_ieta);
      assign(y(left downto left-len(x.cointype)+1), vectorify(x.cointype, y(left downto left-len(x.cointype)+1)));
      left := left - len(x.cointype);
      assign(y(left downto left-len(x.posphi)+1), vectorify(x.posphi, y(left downto left-len(x.posphi)+1)));
      left := left - len(x.posphi);
      assign(y(left downto left-len(x.phimod)+1), vectorify(x.phimod, y(left downto left-len(x.phimod)+1)));
      left := left - len(x.phimod);
      assign(y(left downto left-len(x.specific)+1), vectorify(x.specific, y(left downto left-len(x.specific)+1)));
      left := left - len(x.specific);
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_cde_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.chamb_ieta)-1), convert(x.chamb_ieta, y(left to left+len(x.chamb_ieta)-1)));
      left := left + len(x.chamb_ieta);
      assign(y(left to left+len(x.cointype)-1), convert(x.cointype, y(left to left+len(x.cointype)-1)));
      left := left + len(x.cointype);
      assign(y(left to left+len(x.posphi)-1), convert(x.posphi, y(left to left+len(x.posphi)-1)));
      left := left + len(x.posphi);
      assign(y(left to left+len(x.phimod)-1), convert(x.phimod, y(left to left+len(x.phimod)-1)));
      left := left + len(x.phimod);
      assign(y(left to left+len(x.specific)-1), convert(x.specific, y(left to left+len(x.specific)-1)));
      left := left + len(x.specific);
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
    else
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.chamb_ieta)+1), convert(x.chamb_ieta, y(left downto left-len(x.chamb_ieta)+1)));
      left := left - len(x.chamb_ieta);
      assign(y(left downto left-len(x.cointype)+1), convert(x.cointype, y(left downto left-len(x.cointype)+1)));
      left := left - len(x.cointype);
      assign(y(left downto left-len(x.posphi)+1), convert(x.posphi, y(left downto left-len(x.posphi)+1)));
      left := left - len(x.posphi);
      assign(y(left downto left-len(x.phimod)+1), convert(x.phimod, y(left downto left-len(x.phimod)+1)));
      left := left - len(x.phimod);
      assign(y(left downto left-len(x.specific)+1), convert(x.specific, y(left downto left-len(x.specific)+1)));
      left := left - len(x.specific);
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_cde_rt) return ucm_cde_rt is
    variable y: ucm_cde_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.chamb_ieta := structify(x(left to left+len(y.chamb_ieta)-1), y.chamb_ieta);
      left := left + len(y.chamb_ieta);
      y.cointype := structify(x(left to left+len(y.cointype)-1), y.cointype);
      left := left + len(y.cointype);
      y.posphi := structify(x(left to left+len(y.posphi)-1), y.posphi);
      left := left + len(y.posphi);
      y.phimod := structify(x(left to left+len(y.phimod)-1), y.phimod);
      left := left + len(y.phimod);
      y.specific := structify(x(left to left+len(y.specific)-1), y.specific);
      left := left + len(y.specific);
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.chamb_ieta := structify(x(left downto left-len(y.chamb_ieta)+1), y.chamb_ieta);
      left := left - len(y.chamb_ieta);
      y.cointype := structify(x(left downto left-len(y.cointype)+1), y.cointype);
      left := left - len(y.cointype);
      y.posphi := structify(x(left downto left-len(y.posphi)+1), y.posphi);
      left := left - len(y.posphi);
      y.phimod := structify(x(left downto left-len(y.phimod)+1), y.phimod);
      left := left - len(y.phimod);
      y.specific := structify(x(left downto left-len(y.specific)+1), y.specific);
      left := left - len(y.specific);
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_cde_rt) return ucm_cde_rt is
    variable y: ucm_cde_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.chamb_ieta := convert(x(left to left+len(y.chamb_ieta)-1), y.chamb_ieta);
      left := left + len(y.chamb_ieta);
      y.cointype := convert(x(left to left+len(y.cointype)-1), y.cointype);
      left := left + len(y.cointype);
      y.posphi := convert(x(left to left+len(y.posphi)-1), y.posphi);
      left := left + len(y.posphi);
      y.phimod := convert(x(left to left+len(y.phimod)-1), y.phimod);
      left := left + len(y.phimod);
      y.specific := convert(x(left to left+len(y.specific)-1), y.specific);
      left := left + len(y.specific);
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
    else
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.chamb_ieta := convert(x(left downto left-len(y.chamb_ieta)+1), y.chamb_ieta);
      left := left - len(y.chamb_ieta);
      y.cointype := convert(x(left downto left-len(y.cointype)+1), y.cointype);
      left := left - len(y.cointype);
      y.posphi := convert(x(left downto left-len(y.posphi)+1), y.posphi);
      left := left - len(y.posphi);
      y.phimod := convert(x(left downto left-len(y.phimod)+1), y.phimod);
      left := left - len(y.phimod);
      y.specific := convert(x(left downto left-len(y.specific)+1), y.specific);
      left := left - len(y.specific);
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_cde_rt) return ucm_cde_rt is
  variable y: ucm_cde_rt;
  begin
    y.muid := nullify(t.muid);
    y.chamb_ieta := nullify(t.chamb_ieta);
    y.cointype := nullify(t.cointype);
    y.posphi := nullify(t.posphi);
    y.phimod := nullify(t.phimod);
    y.specific := nullify(t.specific);
    y.data_valid := nullify(t.data_valid);
    return y;
  end function nullify;
  function zeroed(t: ucm_cde_rt) return ucm_cde_rt is
  variable y: ucm_cde_rt;
  begin
    y.muid := zeroed(t.muid);
    y.chamb_ieta := zeroed(t.chamb_ieta);
    y.cointype := zeroed(t.cointype);
    y.posphi := zeroed(t.posphi);
    y.phimod := zeroed(t.phimod);
    y.specific := zeroed(t.specific);
    y.data_valid := zeroed(t.data_valid);
    return y;
  end function zeroed;

  function len(x: ucm_cde_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_cde_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_cde_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_cde_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_cde_art) return ucm_cde_art is
    variable y : ucm_cde_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_cde_art) return ucm_cde_art is
    variable y : ucm_cde_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_cde_art) return ucm_cde_art is
    variable y : ucm_cde_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_cde_art) return ucm_cde_art is
    variable y : ucm_cde_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_cde_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_cde_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_cde_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_cde_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_cde_avt) return ucm_cde_avt is
    variable y : ucm_cde_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_cde_avt) return ucm_cde_avt is
    variable y : ucm_cde_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_cde_avt) return ucm_cde_avt is
    variable y : ucm_cde_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_cde_avt) return ucm_cde_avt is
    variable y : ucm_cde_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_csw_control_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_present);
    l := l + len(x.addr_orig);
    return l;
  end function len;
  function width(x: ucm_csw_control_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_present);
    l := l + width(x.addr_orig);
    return l;
  end function width;
  function vectorify(x: ucm_csw_control_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_present)-1), vectorify(x.data_present, y(left to left+len(x.data_present)-1)));
      left := left + len(x.data_present);
      assign(y(left to left+len(x.addr_orig)-1), vectorify(x.addr_orig, y(left to left+len(x.addr_orig)-1)));
    else
      assign(y(left downto left-len(x.data_present)+1), vectorify(x.data_present, y(left downto left-len(x.data_present)+1)));
      left := left - len(x.data_present);
      assign(y(left downto left-len(x.addr_orig)+1), vectorify(x.addr_orig, y(left downto left-len(x.addr_orig)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_csw_control_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_present)-1), convert(x.data_present, y(left to left+len(x.data_present)-1)));
      left := left + len(x.data_present);
      assign(y(left to left+len(x.addr_orig)-1), convert(x.addr_orig, y(left to left+len(x.addr_orig)-1)));
    else
      assign(y(left downto left-len(x.data_present)+1), convert(x.data_present, y(left downto left-len(x.data_present)+1)));
      left := left - len(x.data_present);
      assign(y(left downto left-len(x.addr_orig)+1), convert(x.addr_orig, y(left downto left-len(x.addr_orig)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_csw_control_rt) return ucm_csw_control_rt is
    variable y: ucm_csw_control_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_present := structify(x(left to left+len(y.data_present)-1), y.data_present);
      left := left + len(y.data_present);
      y.addr_orig := structify(x(left to left+len(y.addr_orig)-1), y.addr_orig);
    else
      y.data_present := structify(x(left downto left-len(y.data_present)+1), y.data_present);
      left := left - len(y.data_present);
      y.addr_orig := structify(x(left downto left-len(y.addr_orig)+1), y.addr_orig);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_csw_control_rt) return ucm_csw_control_rt is
    variable y: ucm_csw_control_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_present := convert(x(left to left+len(y.data_present)-1), y.data_present);
      left := left + len(y.data_present);
      y.addr_orig := convert(x(left to left+len(y.addr_orig)-1), y.addr_orig);
    else
      y.data_present := convert(x(left downto left-len(y.data_present)+1), y.data_present);
      left := left - len(y.data_present);
      y.addr_orig := convert(x(left downto left-len(y.addr_orig)+1), y.addr_orig);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_csw_control_rt) return ucm_csw_control_rt is
  variable y: ucm_csw_control_rt;
  begin
    y.data_present := nullify(t.data_present);
    y.addr_orig := nullify(t.addr_orig);
    return y;
  end function nullify;
  function zeroed(t: ucm_csw_control_rt) return ucm_csw_control_rt is
  variable y: ucm_csw_control_rt;
  begin
    y.data_present := zeroed(t.data_present);
    y.addr_orig := zeroed(t.addr_orig);
    return y;
  end function zeroed;

  function len(x: ucm_csw_control_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_csw_control_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_csw_control_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_csw_control_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_csw_control_art) return ucm_csw_control_art is
    variable y : ucm_csw_control_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_csw_control_art) return ucm_csw_control_art is
    variable y : ucm_csw_control_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_csw_control_art) return ucm_csw_control_art is
    variable y : ucm_csw_control_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_csw_control_art) return ucm_csw_control_art is
    variable y : ucm_csw_control_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_csw_control_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_csw_control_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_csw_control_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_csw_control_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_csw_control_avt) return ucm_csw_control_avt is
    variable y : ucm_csw_control_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_csw_control_avt) return ucm_csw_control_avt is
    variable y : ucm_csw_control_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_csw_control_avt) return ucm_csw_control_avt is
    variable y : ucm_csw_control_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_csw_control_avt) return ucm_csw_control_avt is
    variable y : ucm_csw_control_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_pam_control_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_present);
    l := l + len(x.addr_orig);
    return l;
  end function len;
  function width(x: ucm_pam_control_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_present);
    l := l + width(x.addr_orig);
    return l;
  end function width;
  function vectorify(x: ucm_pam_control_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_present)-1), vectorify(x.data_present, y(left to left+len(x.data_present)-1)));
      left := left + len(x.data_present);
      assign(y(left to left+len(x.addr_orig)-1), vectorify(x.addr_orig, y(left to left+len(x.addr_orig)-1)));
    else
      assign(y(left downto left-len(x.data_present)+1), vectorify(x.data_present, y(left downto left-len(x.data_present)+1)));
      left := left - len(x.data_present);
      assign(y(left downto left-len(x.addr_orig)+1), vectorify(x.addr_orig, y(left downto left-len(x.addr_orig)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_pam_control_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_present)-1), convert(x.data_present, y(left to left+len(x.data_present)-1)));
      left := left + len(x.data_present);
      assign(y(left to left+len(x.addr_orig)-1), convert(x.addr_orig, y(left to left+len(x.addr_orig)-1)));
    else
      assign(y(left downto left-len(x.data_present)+1), convert(x.data_present, y(left downto left-len(x.data_present)+1)));
      left := left - len(x.data_present);
      assign(y(left downto left-len(x.addr_orig)+1), convert(x.addr_orig, y(left downto left-len(x.addr_orig)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_pam_control_rt) return ucm_pam_control_rt is
    variable y: ucm_pam_control_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_present := structify(x(left to left+len(y.data_present)-1), y.data_present);
      left := left + len(y.data_present);
      y.addr_orig := structify(x(left to left+len(y.addr_orig)-1), y.addr_orig);
    else
      y.data_present := structify(x(left downto left-len(y.data_present)+1), y.data_present);
      left := left - len(y.data_present);
      y.addr_orig := structify(x(left downto left-len(y.addr_orig)+1), y.addr_orig);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_pam_control_rt) return ucm_pam_control_rt is
    variable y: ucm_pam_control_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_present := convert(x(left to left+len(y.data_present)-1), y.data_present);
      left := left + len(y.data_present);
      y.addr_orig := convert(x(left to left+len(y.addr_orig)-1), y.addr_orig);
    else
      y.data_present := convert(x(left downto left-len(y.data_present)+1), y.data_present);
      left := left - len(y.data_present);
      y.addr_orig := convert(x(left downto left-len(y.addr_orig)+1), y.addr_orig);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_pam_control_rt) return ucm_pam_control_rt is
  variable y: ucm_pam_control_rt;
  begin
    y.data_present := nullify(t.data_present);
    y.addr_orig := nullify(t.addr_orig);
    return y;
  end function nullify;
  function zeroed(t: ucm_pam_control_rt) return ucm_pam_control_rt is
  variable y: ucm_pam_control_rt;
  begin
    y.data_present := zeroed(t.data_present);
    y.addr_orig := zeroed(t.addr_orig);
    return y;
  end function zeroed;

  function len(x: ucm_pam_control_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_pam_control_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_pam_control_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_pam_control_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_pam_control_art) return ucm_pam_control_art is
    variable y : ucm_pam_control_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_pam_control_art) return ucm_pam_control_art is
    variable y : ucm_pam_control_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_pam_control_art) return ucm_pam_control_art is
    variable y : ucm_pam_control_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_pam_control_art) return ucm_pam_control_art is
    variable y : ucm_pam_control_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_pam_control_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_pam_control_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_pam_control_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_pam_control_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_pam_control_avt) return ucm_pam_control_avt is
    variable y : ucm_pam_control_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_pam_control_avt) return ucm_pam_control_avt is
    variable y : ucm_pam_control_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_pam_control_avt) return ucm_pam_control_avt is
    variable y : ucm_pam_control_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_pam_control_avt) return ucm_pam_control_avt is
    variable y : ucm_pam_control_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_proc_info_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ch);
    l := l + len(x.processed);
    l := l + len(x.dv);
    return l;
  end function len;
  function width(x: ucm_proc_info_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ch);
    l := l + width(x.processed);
    l := l + width(x.dv);
    return l;
  end function width;
  function vectorify(x: ucm_proc_info_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ch)-1), vectorify(x.ch, y(left to left+len(x.ch)-1)));
      left := left + len(x.ch);
      assign(y(left to left+len(x.processed)-1), vectorify(x.processed, y(left to left+len(x.processed)-1)));
      left := left + len(x.processed);
      assign(y(left to left+len(x.dv)-1), vectorify(x.dv, y(left to left+len(x.dv)-1)));
    else
      assign(y(left downto left-len(x.ch)+1), vectorify(x.ch, y(left downto left-len(x.ch)+1)));
      left := left - len(x.ch);
      assign(y(left downto left-len(x.processed)+1), vectorify(x.processed, y(left downto left-len(x.processed)+1)));
      left := left - len(x.processed);
      assign(y(left downto left-len(x.dv)+1), vectorify(x.dv, y(left downto left-len(x.dv)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_proc_info_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ch)-1), convert(x.ch, y(left to left+len(x.ch)-1)));
      left := left + len(x.ch);
      assign(y(left to left+len(x.processed)-1), convert(x.processed, y(left to left+len(x.processed)-1)));
      left := left + len(x.processed);
      assign(y(left to left+len(x.dv)-1), convert(x.dv, y(left to left+len(x.dv)-1)));
    else
      assign(y(left downto left-len(x.ch)+1), convert(x.ch, y(left downto left-len(x.ch)+1)));
      left := left - len(x.ch);
      assign(y(left downto left-len(x.processed)+1), convert(x.processed, y(left downto left-len(x.processed)+1)));
      left := left - len(x.processed);
      assign(y(left downto left-len(x.dv)+1), convert(x.dv, y(left downto left-len(x.dv)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm_proc_info_rt) return ucm_proc_info_rt is
    variable y: ucm_proc_info_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ch := structify(x(left to left+len(y.ch)-1), y.ch);
      left := left + len(y.ch);
      y.processed := structify(x(left to left+len(y.processed)-1), y.processed);
      left := left + len(y.processed);
      y.dv := structify(x(left to left+len(y.dv)-1), y.dv);
    else
      y.ch := structify(x(left downto left-len(y.ch)+1), y.ch);
      left := left - len(y.ch);
      y.processed := structify(x(left downto left-len(y.processed)+1), y.processed);
      left := left - len(y.processed);
      y.dv := structify(x(left downto left-len(y.dv)+1), y.dv);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm_proc_info_rt) return ucm_proc_info_rt is
    variable y: ucm_proc_info_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ch := convert(x(left to left+len(y.ch)-1), y.ch);
      left := left + len(y.ch);
      y.processed := convert(x(left to left+len(y.processed)-1), y.processed);
      left := left + len(y.processed);
      y.dv := convert(x(left to left+len(y.dv)-1), y.dv);
    else
      y.ch := convert(x(left downto left-len(y.ch)+1), y.ch);
      left := left - len(y.ch);
      y.processed := convert(x(left downto left-len(y.processed)+1), y.processed);
      left := left - len(y.processed);
      y.dv := convert(x(left downto left-len(y.dv)+1), y.dv);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm_proc_info_rt) return ucm_proc_info_rt is
  variable y: ucm_proc_info_rt;
  begin
    y.ch := nullify(t.ch);
    y.processed := nullify(t.processed);
    y.dv := nullify(t.dv);
    return y;
  end function nullify;
  function zeroed(t: ucm_proc_info_rt) return ucm_proc_info_rt is
  variable y: ucm_proc_info_rt;
  begin
    y.ch := zeroed(t.ch);
    y.processed := zeroed(t.processed);
    y.dv := zeroed(t.dv);
    return y;
  end function zeroed;

  function len(x: ucm_proc_info_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_proc_info_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_proc_info_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_proc_info_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_proc_info_art) return ucm_proc_info_art is
    variable y : ucm_proc_info_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_proc_info_art) return ucm_proc_info_art is
    variable y : ucm_proc_info_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_proc_info_art) return ucm_proc_info_art is
    variable y : ucm_proc_info_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_proc_info_art) return ucm_proc_info_art is
    variable y : ucm_proc_info_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm_proc_info_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm_proc_info_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm_proc_info_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm_proc_info_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm_proc_info_avt) return ucm_proc_info_avt is
    variable y : ucm_proc_info_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm_proc_info_avt) return ucm_proc_info_avt is
    variable y : ucm_proc_info_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm_proc_info_avt) return ucm_proc_info_avt is
    variable y : ucm_proc_info_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm_proc_info_avt) return ucm_proc_info_avt is
    variable y : ucm_proc_info_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

end package body ucm_pkg;
