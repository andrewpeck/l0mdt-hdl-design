-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;

package l0mdt_dataformats_pkg is

  type sl_header_rt is record
    h_reserved : std_logic_vector(SL_HEADER_H_RESERVED_LEN-1 downto 0);
    tcoverflow : std_logic;
    nmtc_sl : unsigned(SL_HEADER_NMTC_SL_LEN-1 downto 0);
    nmtc_mdt : unsigned(SL_HEADER_NMTC_MDT_LEN-1 downto 0);
    nslc : unsigned(SL_HEADER_NSLC_LEN-1 downto 0);
    bcid : unsigned(SL_HEADER_BCID_LEN-1 downto 0);
  end record sl_header_rt;
  function len(x: sl_header_rt) return natural;
  function width(x: sl_header_rt) return natural;
  function vectorify(x: sl_header_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: sl_header_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: sl_header_rt) return sl_header_rt;
  function convert(x: in std_logic_vector; t: sl_header_rt) return sl_header_rt;
  function nullify(t: sl_header_rt) return sl_header_rt;
  function zeroed(t: sl_header_rt) return sl_header_rt;

  type sl_trailer_rt is record
    t_reserved : std_logic_vector(SL_TRAILER_T_RESERVED_LEN-1 downto 0);
    crc : std_logic_vector(SL_TRAILER_CRC_LEN-1 downto 0);
    fiberid : unsigned(SL_TRAILER_FIBERID_LEN-1 downto 0);
    slid : unsigned(SL_TRAILER_SLID_LEN-1 downto 0);
    comma : std_logic_vector(SL_TRAILER_COMMA_LEN-1 downto 0);
  end record sl_trailer_rt;
  function len(x: sl_trailer_rt) return natural;
  function width(x: sl_trailer_rt) return natural;
  function vectorify(x: sl_trailer_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: sl_trailer_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: sl_trailer_rt) return sl_trailer_rt;
  function convert(x: in std_logic_vector; t: sl_trailer_rt) return sl_trailer_rt;
  function nullify(t: sl_trailer_rt) return sl_trailer_rt;
  function zeroed(t: sl_trailer_rt) return sl_trailer_rt;

  type slc_common_rt is record
    header : sl_header_rt;
    slcid : unsigned(SLC_COMMON_SLCID_LEN-1 downto 0);
    tcsent : std_logic;
    poseta : signed(SLC_COMMON_POSETA_LEN-1 downto 0);
    posphi : unsigned(SLC_COMMON_POSPHI_LEN-1 downto 0);
    sl_pt : unsigned(SLC_COMMON_SL_PT_LEN-1 downto 0);
    sl_ptthresh : unsigned(SLC_COMMON_SL_PTTHRESH_LEN-1 downto 0);
    sl_charge : std_logic;
    cointype : std_logic_vector(SLC_COMMON_COINTYPE_LEN-1 downto 0);
    trailer : sl_trailer_rt;
  end record slc_common_rt;
  function len(x: slc_common_rt) return natural;
  function width(x: slc_common_rt) return natural;
  function vectorify(x: slc_common_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_common_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: slc_common_rt) return slc_common_rt;
  function convert(x: in std_logic_vector; t: slc_common_rt) return slc_common_rt;
  function nullify(t: slc_common_rt) return slc_common_rt;
  function zeroed(t: slc_common_rt) return slc_common_rt;

  type slc_endcap_rt is record
    e_reserved : std_logic_vector(SLC_ENDCAP_E_RESERVED_LEN-1 downto 0);
    nswseg_mon : std_logic;
    nswseg_angdtheta : signed(SLC_ENDCAP_NSWSEG_ANGDTHETA_LEN-1 downto 0);
    nswseg_posphi : unsigned(SLC_ENDCAP_NSWSEG_POSPHI_LEN-1 downto 0);
    nswseg_poseta : unsigned(SLC_ENDCAP_NSWSEG_POSETA_LEN-1 downto 0);
    seg_angdphi : signed(SLC_ENDCAP_SEG_ANGDPHI_LEN-1 downto 0);
    seg_angdtheta : signed(SLC_ENDCAP_SEG_ANGDTHETA_LEN-1 downto 0);
  end record slc_endcap_rt;
  function len(x: slc_endcap_rt) return natural;
  function width(x: slc_endcap_rt) return natural;
  function vectorify(x: slc_endcap_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_endcap_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: slc_endcap_rt) return slc_endcap_rt;
  function convert(x: in std_logic_vector; t: slc_endcap_rt) return slc_endcap_rt;
  function nullify(t: slc_endcap_rt) return slc_endcap_rt;
  function zeroed(t: slc_endcap_rt) return slc_endcap_rt;

  type slc_barrel_rt is record
    rpc3_posz : signed(SLC_BARREL_RPC3_POSZ_LEN-1 downto 0);
    rpc2_posz : signed(SLC_BARREL_RPC2_POSZ_LEN-1 downto 0);
    rpc1_posz : signed(SLC_BARREL_RPC1_POSZ_LEN-1 downto 0);
    rpc0_posz : signed(SLC_BARREL_RPC0_POSZ_LEN-1 downto 0);
  end record slc_barrel_rt;
  function len(x: slc_barrel_rt) return natural;
  function width(x: slc_barrel_rt) return natural;
  function vectorify(x: slc_barrel_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_barrel_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: slc_barrel_rt) return slc_barrel_rt;
  function convert(x: in std_logic_vector; t: slc_barrel_rt) return slc_barrel_rt;
  function nullify(t: slc_barrel_rt) return slc_barrel_rt;
  function zeroed(t: slc_barrel_rt) return slc_barrel_rt;

  type slc_rx_rt is record
    data_valid : std_logic;
    common : slc_common_rt;
    specific : std_logic_vector(SLC_RX_SPECIFIC_LEN-1 downto 0);
  end record slc_rx_rt;
  function len(x: slc_rx_rt) return natural;
  function width(x: slc_rx_rt) return natural;
  function vectorify(x: slc_rx_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_rx_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: slc_rx_rt) return slc_rx_rt;
  function convert(x: in std_logic_vector; t: slc_rx_rt) return slc_rx_rt;
  function nullify(t: slc_rx_rt) return slc_rx_rt;
  function zeroed(t: slc_rx_rt) return slc_rx_rt;

  type slc_muid_rt is record
    slcid : unsigned(SLC_COMMON_SLCID_LEN-1 downto 0);
    slid : unsigned(SL_TRAILER_SLID_LEN-1 downto 0);
    bcid : unsigned(SL_HEADER_BCID_LEN-1 downto 0);
  end record slc_muid_rt;
  function len(x: slc_muid_rt) return natural;
  function width(x: slc_muid_rt) return natural;
  function vectorify(x: slc_muid_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_muid_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: slc_muid_rt) return slc_muid_rt;
  function convert(x: in std_logic_vector; t: slc_muid_rt) return slc_muid_rt;
  function nullify(t: slc_muid_rt) return slc_muid_rt;
  function zeroed(t: slc_muid_rt) return slc_muid_rt;

  type vec_mdtid_rt is record
    chamber_id : unsigned(VEC_MDTID_CHAMBER_ID_LEN-1 downto 0);
    chamber_ieta : unsigned(VEC_MDTID_CHAMBER_IETA_LEN-1 downto 0);
  end record vec_mdtid_rt;
  function len(x: vec_mdtid_rt) return natural;
  function width(x: vec_mdtid_rt) return natural;
  function vectorify(x: vec_mdtid_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: vec_mdtid_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: vec_mdtid_rt) return vec_mdtid_rt;
  function convert(x: in std_logic_vector; t: vec_mdtid_rt) return vec_mdtid_rt;
  function nullify(t: vec_mdtid_rt) return vec_mdtid_rt;
  function zeroed(t: vec_mdtid_rt) return vec_mdtid_rt;

  type tdc_rt is record
    chanid : unsigned(TDC_CHANID_LEN-1 downto 0);
    edgemode : std_logic_vector(TDC_EDGEMODE_LEN-1 downto 0);
    coarsetime : unsigned(TDC_COARSETIME_LEN-1 downto 0);
    finetime : unsigned(TDC_FINETIME_LEN-1 downto 0);
    pulsewidth : unsigned(TDC_PULSEWIDTH_LEN-1 downto 0);
  end record tdc_rt;
  function len(x: tdc_rt) return natural;
  function width(x: tdc_rt) return natural;
  function vectorify(x: tdc_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: tdc_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: tdc_rt) return tdc_rt;
  function convert(x: in std_logic_vector; t: tdc_rt) return tdc_rt;
  function nullify(t: tdc_rt) return tdc_rt;
  function zeroed(t: tdc_rt) return tdc_rt;

  type ucm2pl_rt is record
    data_valid : std_logic;
    busy : std_logic;
    process_ch : std_logic_vector(UCM2PL_PROCESS_CH_LEN-1 downto 0);
    common : slc_common_rt;
    phimod : signed(UCM2PL_PHIMOD_LEN-1 downto 0);
    nswseg_angdtheta : signed(SLC_ENDCAP_NSWSEG_ANGDTHETA_LEN-1 downto 0);
    nswseg_posphi : unsigned(SLC_ENDCAP_NSWSEG_POSPHI_LEN-1 downto 0);
    nswseg_poseta : unsigned(SLC_ENDCAP_NSWSEG_POSETA_LEN-1 downto 0);
  end record ucm2pl_rt;
  function len(x: ucm2pl_rt) return natural;
  function width(x: ucm2pl_rt) return natural;
  function vectorify(x: ucm2pl_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm2pl_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm2pl_rt) return ucm2pl_rt;
  function convert(x: in std_logic_vector; t: ucm2pl_rt) return ucm2pl_rt;
  function nullify(t: ucm2pl_rt) return ucm2pl_rt;
  function zeroed(t: ucm2pl_rt) return ucm2pl_rt;

  type tdcpolmux2tar_rt is record
    data_valid : std_logic;
    tdc : tdc_rt;
    csmid : unsigned(TDCPOLMUX2TAR_CSMID_LEN-1 downto 0);
    tdcid : unsigned(TDCPOLMUX2TAR_TDCID_LEN-1 downto 0);
  end record tdcpolmux2tar_rt;
  function len(x: tdcpolmux2tar_rt) return natural;
  function width(x: tdcpolmux2tar_rt) return natural;
  function vectorify(x: tdcpolmux2tar_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: tdcpolmux2tar_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: tdcpolmux2tar_rt) return tdcpolmux2tar_rt;
  function convert(x: in std_logic_vector; t: tdcpolmux2tar_rt) return tdcpolmux2tar_rt;
  function nullify(t: tdcpolmux2tar_rt) return tdcpolmux2tar_rt;
  function zeroed(t: tdcpolmux2tar_rt) return tdcpolmux2tar_rt;

  type ucm2hps_rt is record
    data_valid : std_logic;
    muid : slc_muid_rt;
    mdtseg_dest : std_logic_vector(UCM2HPS_MDTSEG_DEST_LEN-1 downto 0);
    mdtid : vec_mdtid_rt;
    vec_pos : unsigned(UCM2HPS_VEC_POS_LEN-1 downto 0);
    vec_ang : unsigned(UCM2HPS_VEC_ANG_LEN-1 downto 0);
  end record ucm2hps_rt;
  function len(x: ucm2hps_rt) return natural;
  function width(x: ucm2hps_rt) return natural;
  function vectorify(x: ucm2hps_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm2hps_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ucm2hps_rt) return ucm2hps_rt;
  function convert(x: in std_logic_vector; t: ucm2hps_rt) return ucm2hps_rt;
  function nullify(t: ucm2hps_rt) return ucm2hps_rt;
  function zeroed(t: ucm2hps_rt) return ucm2hps_rt;

  type heg2sfslc_rt is record
    data_valid : std_logic;
    muid : slc_muid_rt;
    mdtseg_dest : std_logic_vector(HEG2SFSLC_MDTSEG_DEST_LEN-1 downto 0);
    mdtid : vec_mdtid_rt;
    vec_pos : unsigned(UCM2HPS_VEC_POS_LEN-1 downto 0);
    vec_ang : unsigned(UCM2HPS_VEC_ANG_LEN-1 downto 0);
    hewindow_pos : unsigned(HEG2SFSLC_HEWINDOW_POS_LEN-1 downto 0);
  end record heg2sfslc_rt;
  function len(x: heg2sfslc_rt) return natural;
  function width(x: heg2sfslc_rt) return natural;
  function vectorify(x: heg2sfslc_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg2sfslc_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: heg2sfslc_rt) return heg2sfslc_rt;
  function convert(x: in std_logic_vector; t: heg2sfslc_rt) return heg2sfslc_rt;
  function nullify(t: heg2sfslc_rt) return heg2sfslc_rt;
  function zeroed(t: heg2sfslc_rt) return heg2sfslc_rt;

  type tar2hps_rt is record
    data_valid : std_logic;
    chamber_ieta : unsigned(VEC_MDTID_CHAMBER_IETA_LEN-1 downto 0);
    layer : unsigned(TAR2HPS_LAYER_LEN-1 downto 0);
    tube : unsigned(TAR2HPS_TUBE_LEN-1 downto 0);
    time : unsigned(TAR2HPS_TIME_LEN-1 downto 0);
  end record tar2hps_rt;
  function len(x: tar2hps_rt) return natural;
  function width(x: tar2hps_rt) return natural;
  function vectorify(x: tar2hps_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: tar2hps_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: tar2hps_rt) return tar2hps_rt;
  function convert(x: in std_logic_vector; t: tar2hps_rt) return tar2hps_rt;
  function nullify(t: tar2hps_rt) return tar2hps_rt;
  function zeroed(t: tar2hps_rt) return tar2hps_rt;

  type heg2sfhit_rt is record
    data_valid : std_logic;
    mlayer : std_logic;
    localx : unsigned(HEG2SFHIT_LOCALX_LEN-1 downto 0);
    localy : unsigned(HEG2SFHIT_LOCALY_LEN-1 downto 0);
    radius : unsigned(HEG2SFHIT_RADIUS_LEN-1 downto 0);
  end record heg2sfhit_rt;
  function len(x: heg2sfhit_rt) return natural;
  function width(x: heg2sfhit_rt) return natural;
  function vectorify(x: heg2sfhit_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg2sfhit_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: heg2sfhit_rt) return heg2sfhit_rt;
  function convert(x: in std_logic_vector; t: heg2sfhit_rt) return heg2sfhit_rt;
  function nullify(t: heg2sfhit_rt) return heg2sfhit_rt;
  function zeroed(t: heg2sfhit_rt) return heg2sfhit_rt;

  type pl2ptcalc_rt is record
    data_valid : std_logic;
    muid : slc_muid_rt;
    phimod : signed(UCM2PL_PHIMOD_LEN-1 downto 0);
    sl_charge : std_logic;
    nswseg_poseta : unsigned(SLC_ENDCAP_NSWSEG_POSETA_LEN-1 downto 0);
    nswseg_posphi : unsigned(SLC_ENDCAP_NSWSEG_POSPHI_LEN-1 downto 0);
    nswseg_angdtheta : signed(SLC_ENDCAP_NSWSEG_ANGDTHETA_LEN-1 downto 0);
  end record pl2ptcalc_rt;
  function len(x: pl2ptcalc_rt) return natural;
  function width(x: pl2ptcalc_rt) return natural;
  function vectorify(x: pl2ptcalc_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: pl2ptcalc_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: pl2ptcalc_rt) return pl2ptcalc_rt;
  function convert(x: in std_logic_vector; t: pl2ptcalc_rt) return pl2ptcalc_rt;
  function nullify(t: pl2ptcalc_rt) return pl2ptcalc_rt;
  function zeroed(t: pl2ptcalc_rt) return pl2ptcalc_rt;

  type sf2ptcalc_rt is record
    data_valid : std_logic;
    muid : slc_muid_rt;
    segpos : unsigned(SF2PTCALC_SEGPOS_LEN-1 downto 0);
    segangle : unsigned(SF2PTCALC_SEGANGLE_LEN-1 downto 0);
    segquality : std_logic;
    mdtid : vec_mdtid_rt;
  end record sf2ptcalc_rt;
  function len(x: sf2ptcalc_rt) return natural;
  function width(x: sf2ptcalc_rt) return natural;
  function vectorify(x: sf2ptcalc_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: sf2ptcalc_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: sf2ptcalc_rt) return sf2ptcalc_rt;
  function convert(x: in std_logic_vector; t: sf2ptcalc_rt) return sf2ptcalc_rt;
  function nullify(t: sf2ptcalc_rt) return sf2ptcalc_rt;
  function zeroed(t: sf2ptcalc_rt) return sf2ptcalc_rt;

  type ptcalc2mtc_rt is record
    data_valid : std_logic;
    muid : slc_muid_rt;
    mdt_eta : signed(PTCALC2MTC_MDT_ETA_LEN-1 downto 0);
    mdt_pt : unsigned(PTCALC2MTC_MDT_PT_LEN-1 downto 0);
    mdt_ptthresh : unsigned(PTCALC2MTC_MDT_PTTHRESH_LEN-1 downto 0);
    mdt_charge : std_logic;
    mdt_nsegments : unsigned(PTCALC2MTC_MDT_NSEGMENTS_LEN-1 downto 0);
    mdt_quality : std_logic_vector(PTCALC2MTC_MDT_QUALITY_LEN-1 downto 0);
  end record ptcalc2mtc_rt;
  function len(x: ptcalc2mtc_rt) return natural;
  function width(x: ptcalc2mtc_rt) return natural;
  function vectorify(x: ptcalc2mtc_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ptcalc2mtc_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ptcalc2mtc_rt) return ptcalc2mtc_rt;
  function convert(x: in std_logic_vector; t: ptcalc2mtc_rt) return ptcalc2mtc_rt;
  function nullify(t: ptcalc2mtc_rt) return ptcalc2mtc_rt;
  function zeroed(t: ptcalc2mtc_rt) return ptcalc2mtc_rt;

  type pl2mtc_rt is record
    data_valid : std_logic;
    busy : std_logic;
    process_ch : std_logic_vector(UCM2PL_PROCESS_CH_LEN-1 downto 0);
    common : slc_common_rt;
  end record pl2mtc_rt;
  function len(x: pl2mtc_rt) return natural;
  function width(x: pl2mtc_rt) return natural;
  function vectorify(x: pl2mtc_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: pl2mtc_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: pl2mtc_rt) return pl2mtc_rt;
  function convert(x: in std_logic_vector; t: pl2mtc_rt) return pl2mtc_rt;
  function nullify(t: pl2mtc_rt) return pl2mtc_rt;
  function zeroed(t: pl2mtc_rt) return pl2mtc_rt;

  type mtc2sl_rt is record
    data_valid : std_logic;
    common : slc_common_rt;
    mdt_eta : signed(PTCALC2MTC_MDT_ETA_LEN-1 downto 0);
    mdt_pt : unsigned(PTCALC2MTC_MDT_PT_LEN-1 downto 0);
    mdt_ptthresh : unsigned(PTCALC2MTC_MDT_PTTHRESH_LEN-1 downto 0);
    mdt_charge : std_logic;
    mdt_procflags : std_logic_vector(MTC2SL_MDT_PROCFLAGS_LEN-1 downto 0);
    mdt_nsegments : unsigned(PTCALC2MTC_MDT_NSEGMENTS_LEN-1 downto 0);
    mdt_quality : std_logic_vector(PTCALC2MTC_MDT_QUALITY_LEN-1 downto 0);
    m_reserved : std_logic_vector(MTC2SL_M_RESERVED_LEN-1 downto 0);
  end record mtc2sl_rt;
  function len(x: mtc2sl_rt) return natural;
  function width(x: mtc2sl_rt) return natural;
  function vectorify(x: mtc2sl_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: mtc2sl_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: mtc2sl_rt) return mtc2sl_rt;
  function convert(x: in std_logic_vector; t: mtc2sl_rt) return mtc2sl_rt;
  function nullify(t: mtc2sl_rt) return mtc2sl_rt;
  function zeroed(t: mtc2sl_rt) return mtc2sl_rt;

end package l0mdt_dataformats_pkg;

------------------------------------------------------------

package body l0mdt_dataformats_pkg is

  function len(x: sl_header_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.h_reserved);
    l := l + len(x.tcoverflow);
    l := l + len(x.nmtc_sl);
    l := l + len(x.nmtc_mdt);
    l := l + len(x.nslc);
    l := l + len(x.bcid);
    return l;
  end function len;
  function width(x: sl_header_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.h_reserved);
    l := l + width(x.tcoverflow);
    l := l + width(x.nmtc_sl);
    l := l + width(x.nmtc_mdt);
    l := l + width(x.nslc);
    l := l + width(x.bcid);
    return l;
  end function width;
  function vectorify(x: sl_header_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.h_reserved)-1), vectorify(x.h_reserved, y(left to left+len(x.h_reserved)-1)));
      left := left + len(x.h_reserved);
      assign(y(left to left+len(x.tcoverflow)-1), vectorify(x.tcoverflow, y(left to left+len(x.tcoverflow)-1)));
      left := left + len(x.tcoverflow);
      assign(y(left to left+len(x.nmtc_sl)-1), vectorify(x.nmtc_sl, y(left to left+len(x.nmtc_sl)-1)));
      left := left + len(x.nmtc_sl);
      assign(y(left to left+len(x.nmtc_mdt)-1), vectorify(x.nmtc_mdt, y(left to left+len(x.nmtc_mdt)-1)));
      left := left + len(x.nmtc_mdt);
      assign(y(left to left+len(x.nslc)-1), vectorify(x.nslc, y(left to left+len(x.nslc)-1)));
      left := left + len(x.nslc);
      assign(y(left to left+len(x.bcid)-1), vectorify(x.bcid, y(left to left+len(x.bcid)-1)));
    else
      assign(y(left downto left-len(x.h_reserved)+1), vectorify(x.h_reserved, y(left downto left-len(x.h_reserved)+1)));
      left := left - len(x.h_reserved);
      assign(y(left downto left-len(x.tcoverflow)+1), vectorify(x.tcoverflow, y(left downto left-len(x.tcoverflow)+1)));
      left := left - len(x.tcoverflow);
      assign(y(left downto left-len(x.nmtc_sl)+1), vectorify(x.nmtc_sl, y(left downto left-len(x.nmtc_sl)+1)));
      left := left - len(x.nmtc_sl);
      assign(y(left downto left-len(x.nmtc_mdt)+1), vectorify(x.nmtc_mdt, y(left downto left-len(x.nmtc_mdt)+1)));
      left := left - len(x.nmtc_mdt);
      assign(y(left downto left-len(x.nslc)+1), vectorify(x.nslc, y(left downto left-len(x.nslc)+1)));
      left := left - len(x.nslc);
      assign(y(left downto left-len(x.bcid)+1), vectorify(x.bcid, y(left downto left-len(x.bcid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: sl_header_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.h_reserved)-1), convert(x.h_reserved, y(left to left+len(x.h_reserved)-1)));
      left := left + len(x.h_reserved);
      assign(y(left to left+len(x.tcoverflow)-1), convert(x.tcoverflow, y(left to left+len(x.tcoverflow)-1)));
      left := left + len(x.tcoverflow);
      assign(y(left to left+len(x.nmtc_sl)-1), convert(x.nmtc_sl, y(left to left+len(x.nmtc_sl)-1)));
      left := left + len(x.nmtc_sl);
      assign(y(left to left+len(x.nmtc_mdt)-1), convert(x.nmtc_mdt, y(left to left+len(x.nmtc_mdt)-1)));
      left := left + len(x.nmtc_mdt);
      assign(y(left to left+len(x.nslc)-1), convert(x.nslc, y(left to left+len(x.nslc)-1)));
      left := left + len(x.nslc);
      assign(y(left to left+len(x.bcid)-1), convert(x.bcid, y(left to left+len(x.bcid)-1)));
    else
      assign(y(left downto left-len(x.h_reserved)+1), convert(x.h_reserved, y(left downto left-len(x.h_reserved)+1)));
      left := left - len(x.h_reserved);
      assign(y(left downto left-len(x.tcoverflow)+1), convert(x.tcoverflow, y(left downto left-len(x.tcoverflow)+1)));
      left := left - len(x.tcoverflow);
      assign(y(left downto left-len(x.nmtc_sl)+1), convert(x.nmtc_sl, y(left downto left-len(x.nmtc_sl)+1)));
      left := left - len(x.nmtc_sl);
      assign(y(left downto left-len(x.nmtc_mdt)+1), convert(x.nmtc_mdt, y(left downto left-len(x.nmtc_mdt)+1)));
      left := left - len(x.nmtc_mdt);
      assign(y(left downto left-len(x.nslc)+1), convert(x.nslc, y(left downto left-len(x.nslc)+1)));
      left := left - len(x.nslc);
      assign(y(left downto left-len(x.bcid)+1), convert(x.bcid, y(left downto left-len(x.bcid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: sl_header_rt) return sl_header_rt is
    variable y: sl_header_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.h_reserved := structify(x(left to left+len(y.h_reserved)-1), y.h_reserved);
      left := left + len(y.h_reserved);
      y.tcoverflow := structify(x(left to left+len(y.tcoverflow)-1), y.tcoverflow);
      left := left + len(y.tcoverflow);
      y.nmtc_sl := structify(x(left to left+len(y.nmtc_sl)-1), y.nmtc_sl);
      left := left + len(y.nmtc_sl);
      y.nmtc_mdt := structify(x(left to left+len(y.nmtc_mdt)-1), y.nmtc_mdt);
      left := left + len(y.nmtc_mdt);
      y.nslc := structify(x(left to left+len(y.nslc)-1), y.nslc);
      left := left + len(y.nslc);
      y.bcid := structify(x(left to left+len(y.bcid)-1), y.bcid);
    else
      y.h_reserved := structify(x(left downto left-len(y.h_reserved)+1), y.h_reserved);
      left := left - len(y.h_reserved);
      y.tcoverflow := structify(x(left downto left-len(y.tcoverflow)+1), y.tcoverflow);
      left := left - len(y.tcoverflow);
      y.nmtc_sl := structify(x(left downto left-len(y.nmtc_sl)+1), y.nmtc_sl);
      left := left - len(y.nmtc_sl);
      y.nmtc_mdt := structify(x(left downto left-len(y.nmtc_mdt)+1), y.nmtc_mdt);
      left := left - len(y.nmtc_mdt);
      y.nslc := structify(x(left downto left-len(y.nslc)+1), y.nslc);
      left := left - len(y.nslc);
      y.bcid := structify(x(left downto left-len(y.bcid)+1), y.bcid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: sl_header_rt) return sl_header_rt is
    variable y: sl_header_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.h_reserved := convert(x(left to left+len(y.h_reserved)-1), y.h_reserved);
      left := left + len(y.h_reserved);
      y.tcoverflow := convert(x(left to left+len(y.tcoverflow)-1), y.tcoverflow);
      left := left + len(y.tcoverflow);
      y.nmtc_sl := convert(x(left to left+len(y.nmtc_sl)-1), y.nmtc_sl);
      left := left + len(y.nmtc_sl);
      y.nmtc_mdt := convert(x(left to left+len(y.nmtc_mdt)-1), y.nmtc_mdt);
      left := left + len(y.nmtc_mdt);
      y.nslc := convert(x(left to left+len(y.nslc)-1), y.nslc);
      left := left + len(y.nslc);
      y.bcid := convert(x(left to left+len(y.bcid)-1), y.bcid);
    else
      y.h_reserved := convert(x(left downto left-len(y.h_reserved)+1), y.h_reserved);
      left := left - len(y.h_reserved);
      y.tcoverflow := convert(x(left downto left-len(y.tcoverflow)+1), y.tcoverflow);
      left := left - len(y.tcoverflow);
      y.nmtc_sl := convert(x(left downto left-len(y.nmtc_sl)+1), y.nmtc_sl);
      left := left - len(y.nmtc_sl);
      y.nmtc_mdt := convert(x(left downto left-len(y.nmtc_mdt)+1), y.nmtc_mdt);
      left := left - len(y.nmtc_mdt);
      y.nslc := convert(x(left downto left-len(y.nslc)+1), y.nslc);
      left := left - len(y.nslc);
      y.bcid := convert(x(left downto left-len(y.bcid)+1), y.bcid);
    end if;
    return y;
  end function convert;
  function nullify(t: sl_header_rt) return sl_header_rt is
  variable y: sl_header_rt;
  begin
    y.h_reserved := nullify(t.h_reserved);
    y.tcoverflow := nullify(t.tcoverflow);
    y.nmtc_sl := nullify(t.nmtc_sl);
    y.nmtc_mdt := nullify(t.nmtc_mdt);
    y.nslc := nullify(t.nslc);
    y.bcid := nullify(t.bcid);
    return y;
  end function nullify;
  function zeroed(t: sl_header_rt) return sl_header_rt is
  variable y: sl_header_rt;
  begin
    y.h_reserved := zeroed(t.h_reserved);
    y.tcoverflow := zeroed(t.tcoverflow);
    y.nmtc_sl := zeroed(t.nmtc_sl);
    y.nmtc_mdt := zeroed(t.nmtc_mdt);
    y.nslc := zeroed(t.nslc);
    y.bcid := zeroed(t.bcid);
    return y;
  end function zeroed;

  function len(x: sl_trailer_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.t_reserved);
    l := l + len(x.crc);
    l := l + len(x.fiberid);
    l := l + len(x.slid);
    l := l + len(x.comma);
    return l;
  end function len;
  function width(x: sl_trailer_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.t_reserved);
    l := l + width(x.crc);
    l := l + width(x.fiberid);
    l := l + width(x.slid);
    l := l + width(x.comma);
    return l;
  end function width;
  function vectorify(x: sl_trailer_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.t_reserved)-1), vectorify(x.t_reserved, y(left to left+len(x.t_reserved)-1)));
      left := left + len(x.t_reserved);
      assign(y(left to left+len(x.crc)-1), vectorify(x.crc, y(left to left+len(x.crc)-1)));
      left := left + len(x.crc);
      assign(y(left to left+len(x.fiberid)-1), vectorify(x.fiberid, y(left to left+len(x.fiberid)-1)));
      left := left + len(x.fiberid);
      assign(y(left to left+len(x.slid)-1), vectorify(x.slid, y(left to left+len(x.slid)-1)));
      left := left + len(x.slid);
      assign(y(left to left+len(x.comma)-1), vectorify(x.comma, y(left to left+len(x.comma)-1)));
    else
      assign(y(left downto left-len(x.t_reserved)+1), vectorify(x.t_reserved, y(left downto left-len(x.t_reserved)+1)));
      left := left - len(x.t_reserved);
      assign(y(left downto left-len(x.crc)+1), vectorify(x.crc, y(left downto left-len(x.crc)+1)));
      left := left - len(x.crc);
      assign(y(left downto left-len(x.fiberid)+1), vectorify(x.fiberid, y(left downto left-len(x.fiberid)+1)));
      left := left - len(x.fiberid);
      assign(y(left downto left-len(x.slid)+1), vectorify(x.slid, y(left downto left-len(x.slid)+1)));
      left := left - len(x.slid);
      assign(y(left downto left-len(x.comma)+1), vectorify(x.comma, y(left downto left-len(x.comma)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: sl_trailer_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.t_reserved)-1), convert(x.t_reserved, y(left to left+len(x.t_reserved)-1)));
      left := left + len(x.t_reserved);
      assign(y(left to left+len(x.crc)-1), convert(x.crc, y(left to left+len(x.crc)-1)));
      left := left + len(x.crc);
      assign(y(left to left+len(x.fiberid)-1), convert(x.fiberid, y(left to left+len(x.fiberid)-1)));
      left := left + len(x.fiberid);
      assign(y(left to left+len(x.slid)-1), convert(x.slid, y(left to left+len(x.slid)-1)));
      left := left + len(x.slid);
      assign(y(left to left+len(x.comma)-1), convert(x.comma, y(left to left+len(x.comma)-1)));
    else
      assign(y(left downto left-len(x.t_reserved)+1), convert(x.t_reserved, y(left downto left-len(x.t_reserved)+1)));
      left := left - len(x.t_reserved);
      assign(y(left downto left-len(x.crc)+1), convert(x.crc, y(left downto left-len(x.crc)+1)));
      left := left - len(x.crc);
      assign(y(left downto left-len(x.fiberid)+1), convert(x.fiberid, y(left downto left-len(x.fiberid)+1)));
      left := left - len(x.fiberid);
      assign(y(left downto left-len(x.slid)+1), convert(x.slid, y(left downto left-len(x.slid)+1)));
      left := left - len(x.slid);
      assign(y(left downto left-len(x.comma)+1), convert(x.comma, y(left downto left-len(x.comma)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: sl_trailer_rt) return sl_trailer_rt is
    variable y: sl_trailer_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.t_reserved := structify(x(left to left+len(y.t_reserved)-1), y.t_reserved);
      left := left + len(y.t_reserved);
      y.crc := structify(x(left to left+len(y.crc)-1), y.crc);
      left := left + len(y.crc);
      y.fiberid := structify(x(left to left+len(y.fiberid)-1), y.fiberid);
      left := left + len(y.fiberid);
      y.slid := structify(x(left to left+len(y.slid)-1), y.slid);
      left := left + len(y.slid);
      y.comma := structify(x(left to left+len(y.comma)-1), y.comma);
    else
      y.t_reserved := structify(x(left downto left-len(y.t_reserved)+1), y.t_reserved);
      left := left - len(y.t_reserved);
      y.crc := structify(x(left downto left-len(y.crc)+1), y.crc);
      left := left - len(y.crc);
      y.fiberid := structify(x(left downto left-len(y.fiberid)+1), y.fiberid);
      left := left - len(y.fiberid);
      y.slid := structify(x(left downto left-len(y.slid)+1), y.slid);
      left := left - len(y.slid);
      y.comma := structify(x(left downto left-len(y.comma)+1), y.comma);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: sl_trailer_rt) return sl_trailer_rt is
    variable y: sl_trailer_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.t_reserved := convert(x(left to left+len(y.t_reserved)-1), y.t_reserved);
      left := left + len(y.t_reserved);
      y.crc := convert(x(left to left+len(y.crc)-1), y.crc);
      left := left + len(y.crc);
      y.fiberid := convert(x(left to left+len(y.fiberid)-1), y.fiberid);
      left := left + len(y.fiberid);
      y.slid := convert(x(left to left+len(y.slid)-1), y.slid);
      left := left + len(y.slid);
      y.comma := convert(x(left to left+len(y.comma)-1), y.comma);
    else
      y.t_reserved := convert(x(left downto left-len(y.t_reserved)+1), y.t_reserved);
      left := left - len(y.t_reserved);
      y.crc := convert(x(left downto left-len(y.crc)+1), y.crc);
      left := left - len(y.crc);
      y.fiberid := convert(x(left downto left-len(y.fiberid)+1), y.fiberid);
      left := left - len(y.fiberid);
      y.slid := convert(x(left downto left-len(y.slid)+1), y.slid);
      left := left - len(y.slid);
      y.comma := convert(x(left downto left-len(y.comma)+1), y.comma);
    end if;
    return y;
  end function convert;
  function nullify(t: sl_trailer_rt) return sl_trailer_rt is
  variable y: sl_trailer_rt;
  begin
    y.t_reserved := nullify(t.t_reserved);
    y.crc := nullify(t.crc);
    y.fiberid := nullify(t.fiberid);
    y.slid := nullify(t.slid);
    y.comma := nullify(t.comma);
    return y;
  end function nullify;
  function zeroed(t: sl_trailer_rt) return sl_trailer_rt is
  variable y: sl_trailer_rt;
  begin
    y.t_reserved := zeroed(t.t_reserved);
    y.crc := zeroed(t.crc);
    y.fiberid := zeroed(t.fiberid);
    y.slid := zeroed(t.slid);
    y.comma := zeroed(t.comma);
    return y;
  end function zeroed;

  function len(x: slc_common_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.header);
    l := l + len(x.slcid);
    l := l + len(x.tcsent);
    l := l + len(x.poseta);
    l := l + len(x.posphi);
    l := l + len(x.sl_pt);
    l := l + len(x.sl_ptthresh);
    l := l + len(x.sl_charge);
    l := l + len(x.cointype);
    l := l + len(x.trailer);
    return l;
  end function len;
  function width(x: slc_common_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.header);
    l := l + width(x.slcid);
    l := l + width(x.tcsent);
    l := l + width(x.poseta);
    l := l + width(x.posphi);
    l := l + width(x.sl_pt);
    l := l + width(x.sl_ptthresh);
    l := l + width(x.sl_charge);
    l := l + width(x.cointype);
    l := l + width(x.trailer);
    return l;
  end function width;
  function vectorify(x: slc_common_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.header)-1), vectorify(x.header, y(left to left+len(x.header)-1)));
      left := left + len(x.header);
      assign(y(left to left+len(x.slcid)-1), vectorify(x.slcid, y(left to left+len(x.slcid)-1)));
      left := left + len(x.slcid);
      assign(y(left to left+len(x.tcsent)-1), vectorify(x.tcsent, y(left to left+len(x.tcsent)-1)));
      left := left + len(x.tcsent);
      assign(y(left to left+len(x.poseta)-1), vectorify(x.poseta, y(left to left+len(x.poseta)-1)));
      left := left + len(x.poseta);
      assign(y(left to left+len(x.posphi)-1), vectorify(x.posphi, y(left to left+len(x.posphi)-1)));
      left := left + len(x.posphi);
      assign(y(left to left+len(x.sl_pt)-1), vectorify(x.sl_pt, y(left to left+len(x.sl_pt)-1)));
      left := left + len(x.sl_pt);
      assign(y(left to left+len(x.sl_ptthresh)-1), vectorify(x.sl_ptthresh, y(left to left+len(x.sl_ptthresh)-1)));
      left := left + len(x.sl_ptthresh);
      assign(y(left to left+len(x.sl_charge)-1), vectorify(x.sl_charge, y(left to left+len(x.sl_charge)-1)));
      left := left + len(x.sl_charge);
      assign(y(left to left+len(x.cointype)-1), vectorify(x.cointype, y(left to left+len(x.cointype)-1)));
      left := left + len(x.cointype);
      assign(y(left to left+len(x.trailer)-1), vectorify(x.trailer, y(left to left+len(x.trailer)-1)));
    else
      assign(y(left downto left-len(x.header)+1), vectorify(x.header, y(left downto left-len(x.header)+1)));
      left := left - len(x.header);
      assign(y(left downto left-len(x.slcid)+1), vectorify(x.slcid, y(left downto left-len(x.slcid)+1)));
      left := left - len(x.slcid);
      assign(y(left downto left-len(x.tcsent)+1), vectorify(x.tcsent, y(left downto left-len(x.tcsent)+1)));
      left := left - len(x.tcsent);
      assign(y(left downto left-len(x.poseta)+1), vectorify(x.poseta, y(left downto left-len(x.poseta)+1)));
      left := left - len(x.poseta);
      assign(y(left downto left-len(x.posphi)+1), vectorify(x.posphi, y(left downto left-len(x.posphi)+1)));
      left := left - len(x.posphi);
      assign(y(left downto left-len(x.sl_pt)+1), vectorify(x.sl_pt, y(left downto left-len(x.sl_pt)+1)));
      left := left - len(x.sl_pt);
      assign(y(left downto left-len(x.sl_ptthresh)+1), vectorify(x.sl_ptthresh, y(left downto left-len(x.sl_ptthresh)+1)));
      left := left - len(x.sl_ptthresh);
      assign(y(left downto left-len(x.sl_charge)+1), vectorify(x.sl_charge, y(left downto left-len(x.sl_charge)+1)));
      left := left - len(x.sl_charge);
      assign(y(left downto left-len(x.cointype)+1), vectorify(x.cointype, y(left downto left-len(x.cointype)+1)));
      left := left - len(x.cointype);
      assign(y(left downto left-len(x.trailer)+1), vectorify(x.trailer, y(left downto left-len(x.trailer)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_common_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.header)-1), convert(x.header, y(left to left+len(x.header)-1)));
      left := left + len(x.header);
      assign(y(left to left+len(x.slcid)-1), convert(x.slcid, y(left to left+len(x.slcid)-1)));
      left := left + len(x.slcid);
      assign(y(left to left+len(x.tcsent)-1), convert(x.tcsent, y(left to left+len(x.tcsent)-1)));
      left := left + len(x.tcsent);
      assign(y(left to left+len(x.poseta)-1), convert(x.poseta, y(left to left+len(x.poseta)-1)));
      left := left + len(x.poseta);
      assign(y(left to left+len(x.posphi)-1), convert(x.posphi, y(left to left+len(x.posphi)-1)));
      left := left + len(x.posphi);
      assign(y(left to left+len(x.sl_pt)-1), convert(x.sl_pt, y(left to left+len(x.sl_pt)-1)));
      left := left + len(x.sl_pt);
      assign(y(left to left+len(x.sl_ptthresh)-1), convert(x.sl_ptthresh, y(left to left+len(x.sl_ptthresh)-1)));
      left := left + len(x.sl_ptthresh);
      assign(y(left to left+len(x.sl_charge)-1), convert(x.sl_charge, y(left to left+len(x.sl_charge)-1)));
      left := left + len(x.sl_charge);
      assign(y(left to left+len(x.cointype)-1), convert(x.cointype, y(left to left+len(x.cointype)-1)));
      left := left + len(x.cointype);
      assign(y(left to left+len(x.trailer)-1), convert(x.trailer, y(left to left+len(x.trailer)-1)));
    else
      assign(y(left downto left-len(x.header)+1), convert(x.header, y(left downto left-len(x.header)+1)));
      left := left - len(x.header);
      assign(y(left downto left-len(x.slcid)+1), convert(x.slcid, y(left downto left-len(x.slcid)+1)));
      left := left - len(x.slcid);
      assign(y(left downto left-len(x.tcsent)+1), convert(x.tcsent, y(left downto left-len(x.tcsent)+1)));
      left := left - len(x.tcsent);
      assign(y(left downto left-len(x.poseta)+1), convert(x.poseta, y(left downto left-len(x.poseta)+1)));
      left := left - len(x.poseta);
      assign(y(left downto left-len(x.posphi)+1), convert(x.posphi, y(left downto left-len(x.posphi)+1)));
      left := left - len(x.posphi);
      assign(y(left downto left-len(x.sl_pt)+1), convert(x.sl_pt, y(left downto left-len(x.sl_pt)+1)));
      left := left - len(x.sl_pt);
      assign(y(left downto left-len(x.sl_ptthresh)+1), convert(x.sl_ptthresh, y(left downto left-len(x.sl_ptthresh)+1)));
      left := left - len(x.sl_ptthresh);
      assign(y(left downto left-len(x.sl_charge)+1), convert(x.sl_charge, y(left downto left-len(x.sl_charge)+1)));
      left := left - len(x.sl_charge);
      assign(y(left downto left-len(x.cointype)+1), convert(x.cointype, y(left downto left-len(x.cointype)+1)));
      left := left - len(x.cointype);
      assign(y(left downto left-len(x.trailer)+1), convert(x.trailer, y(left downto left-len(x.trailer)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: slc_common_rt) return slc_common_rt is
    variable y: slc_common_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.header := structify(x(left to left+len(y.header)-1), y.header);
      left := left + len(y.header);
      y.slcid := structify(x(left to left+len(y.slcid)-1), y.slcid);
      left := left + len(y.slcid);
      y.tcsent := structify(x(left to left+len(y.tcsent)-1), y.tcsent);
      left := left + len(y.tcsent);
      y.poseta := structify(x(left to left+len(y.poseta)-1), y.poseta);
      left := left + len(y.poseta);
      y.posphi := structify(x(left to left+len(y.posphi)-1), y.posphi);
      left := left + len(y.posphi);
      y.sl_pt := structify(x(left to left+len(y.sl_pt)-1), y.sl_pt);
      left := left + len(y.sl_pt);
      y.sl_ptthresh := structify(x(left to left+len(y.sl_ptthresh)-1), y.sl_ptthresh);
      left := left + len(y.sl_ptthresh);
      y.sl_charge := structify(x(left to left+len(y.sl_charge)-1), y.sl_charge);
      left := left + len(y.sl_charge);
      y.cointype := structify(x(left to left+len(y.cointype)-1), y.cointype);
      left := left + len(y.cointype);
      y.trailer := structify(x(left to left+len(y.trailer)-1), y.trailer);
    else
      y.header := structify(x(left downto left-len(y.header)+1), y.header);
      left := left - len(y.header);
      y.slcid := structify(x(left downto left-len(y.slcid)+1), y.slcid);
      left := left - len(y.slcid);
      y.tcsent := structify(x(left downto left-len(y.tcsent)+1), y.tcsent);
      left := left - len(y.tcsent);
      y.poseta := structify(x(left downto left-len(y.poseta)+1), y.poseta);
      left := left - len(y.poseta);
      y.posphi := structify(x(left downto left-len(y.posphi)+1), y.posphi);
      left := left - len(y.posphi);
      y.sl_pt := structify(x(left downto left-len(y.sl_pt)+1), y.sl_pt);
      left := left - len(y.sl_pt);
      y.sl_ptthresh := structify(x(left downto left-len(y.sl_ptthresh)+1), y.sl_ptthresh);
      left := left - len(y.sl_ptthresh);
      y.sl_charge := structify(x(left downto left-len(y.sl_charge)+1), y.sl_charge);
      left := left - len(y.sl_charge);
      y.cointype := structify(x(left downto left-len(y.cointype)+1), y.cointype);
      left := left - len(y.cointype);
      y.trailer := structify(x(left downto left-len(y.trailer)+1), y.trailer);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: slc_common_rt) return slc_common_rt is
    variable y: slc_common_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.header := convert(x(left to left+len(y.header)-1), y.header);
      left := left + len(y.header);
      y.slcid := convert(x(left to left+len(y.slcid)-1), y.slcid);
      left := left + len(y.slcid);
      y.tcsent := convert(x(left to left+len(y.tcsent)-1), y.tcsent);
      left := left + len(y.tcsent);
      y.poseta := convert(x(left to left+len(y.poseta)-1), y.poseta);
      left := left + len(y.poseta);
      y.posphi := convert(x(left to left+len(y.posphi)-1), y.posphi);
      left := left + len(y.posphi);
      y.sl_pt := convert(x(left to left+len(y.sl_pt)-1), y.sl_pt);
      left := left + len(y.sl_pt);
      y.sl_ptthresh := convert(x(left to left+len(y.sl_ptthresh)-1), y.sl_ptthresh);
      left := left + len(y.sl_ptthresh);
      y.sl_charge := convert(x(left to left+len(y.sl_charge)-1), y.sl_charge);
      left := left + len(y.sl_charge);
      y.cointype := convert(x(left to left+len(y.cointype)-1), y.cointype);
      left := left + len(y.cointype);
      y.trailer := convert(x(left to left+len(y.trailer)-1), y.trailer);
    else
      y.header := convert(x(left downto left-len(y.header)+1), y.header);
      left := left - len(y.header);
      y.slcid := convert(x(left downto left-len(y.slcid)+1), y.slcid);
      left := left - len(y.slcid);
      y.tcsent := convert(x(left downto left-len(y.tcsent)+1), y.tcsent);
      left := left - len(y.tcsent);
      y.poseta := convert(x(left downto left-len(y.poseta)+1), y.poseta);
      left := left - len(y.poseta);
      y.posphi := convert(x(left downto left-len(y.posphi)+1), y.posphi);
      left := left - len(y.posphi);
      y.sl_pt := convert(x(left downto left-len(y.sl_pt)+1), y.sl_pt);
      left := left - len(y.sl_pt);
      y.sl_ptthresh := convert(x(left downto left-len(y.sl_ptthresh)+1), y.sl_ptthresh);
      left := left - len(y.sl_ptthresh);
      y.sl_charge := convert(x(left downto left-len(y.sl_charge)+1), y.sl_charge);
      left := left - len(y.sl_charge);
      y.cointype := convert(x(left downto left-len(y.cointype)+1), y.cointype);
      left := left - len(y.cointype);
      y.trailer := convert(x(left downto left-len(y.trailer)+1), y.trailer);
    end if;
    return y;
  end function convert;
  function nullify(t: slc_common_rt) return slc_common_rt is
  variable y: slc_common_rt;
  begin
    y.header := nullify(t.header);
    y.slcid := nullify(t.slcid);
    y.tcsent := nullify(t.tcsent);
    y.poseta := nullify(t.poseta);
    y.posphi := nullify(t.posphi);
    y.sl_pt := nullify(t.sl_pt);
    y.sl_ptthresh := nullify(t.sl_ptthresh);
    y.sl_charge := nullify(t.sl_charge);
    y.cointype := nullify(t.cointype);
    y.trailer := nullify(t.trailer);
    return y;
  end function nullify;
  function zeroed(t: slc_common_rt) return slc_common_rt is
  variable y: slc_common_rt;
  begin
    y.header := zeroed(t.header);
    y.slcid := zeroed(t.slcid);
    y.tcsent := zeroed(t.tcsent);
    y.poseta := zeroed(t.poseta);
    y.posphi := zeroed(t.posphi);
    y.sl_pt := zeroed(t.sl_pt);
    y.sl_ptthresh := zeroed(t.sl_ptthresh);
    y.sl_charge := zeroed(t.sl_charge);
    y.cointype := zeroed(t.cointype);
    y.trailer := zeroed(t.trailer);
    return y;
  end function zeroed;

  function len(x: slc_endcap_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.e_reserved);
    l := l + len(x.nswseg_mon);
    l := l + len(x.nswseg_angdtheta);
    l := l + len(x.nswseg_posphi);
    l := l + len(x.nswseg_poseta);
    l := l + len(x.seg_angdphi);
    l := l + len(x.seg_angdtheta);
    return l;
  end function len;
  function width(x: slc_endcap_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.e_reserved);
    l := l + width(x.nswseg_mon);
    l := l + width(x.nswseg_angdtheta);
    l := l + width(x.nswseg_posphi);
    l := l + width(x.nswseg_poseta);
    l := l + width(x.seg_angdphi);
    l := l + width(x.seg_angdtheta);
    return l;
  end function width;
  function vectorify(x: slc_endcap_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.e_reserved)-1), vectorify(x.e_reserved, y(left to left+len(x.e_reserved)-1)));
      left := left + len(x.e_reserved);
      assign(y(left to left+len(x.nswseg_mon)-1), vectorify(x.nswseg_mon, y(left to left+len(x.nswseg_mon)-1)));
      left := left + len(x.nswseg_mon);
      assign(y(left to left+len(x.nswseg_angdtheta)-1), vectorify(x.nswseg_angdtheta, y(left to left+len(x.nswseg_angdtheta)-1)));
      left := left + len(x.nswseg_angdtheta);
      assign(y(left to left+len(x.nswseg_posphi)-1), vectorify(x.nswseg_posphi, y(left to left+len(x.nswseg_posphi)-1)));
      left := left + len(x.nswseg_posphi);
      assign(y(left to left+len(x.nswseg_poseta)-1), vectorify(x.nswseg_poseta, y(left to left+len(x.nswseg_poseta)-1)));
      left := left + len(x.nswseg_poseta);
      assign(y(left to left+len(x.seg_angdphi)-1), vectorify(x.seg_angdphi, y(left to left+len(x.seg_angdphi)-1)));
      left := left + len(x.seg_angdphi);
      assign(y(left to left+len(x.seg_angdtheta)-1), vectorify(x.seg_angdtheta, y(left to left+len(x.seg_angdtheta)-1)));
    else
      assign(y(left downto left-len(x.e_reserved)+1), vectorify(x.e_reserved, y(left downto left-len(x.e_reserved)+1)));
      left := left - len(x.e_reserved);
      assign(y(left downto left-len(x.nswseg_mon)+1), vectorify(x.nswseg_mon, y(left downto left-len(x.nswseg_mon)+1)));
      left := left - len(x.nswseg_mon);
      assign(y(left downto left-len(x.nswseg_angdtheta)+1), vectorify(x.nswseg_angdtheta, y(left downto left-len(x.nswseg_angdtheta)+1)));
      left := left - len(x.nswseg_angdtheta);
      assign(y(left downto left-len(x.nswseg_posphi)+1), vectorify(x.nswseg_posphi, y(left downto left-len(x.nswseg_posphi)+1)));
      left := left - len(x.nswseg_posphi);
      assign(y(left downto left-len(x.nswseg_poseta)+1), vectorify(x.nswseg_poseta, y(left downto left-len(x.nswseg_poseta)+1)));
      left := left - len(x.nswseg_poseta);
      assign(y(left downto left-len(x.seg_angdphi)+1), vectorify(x.seg_angdphi, y(left downto left-len(x.seg_angdphi)+1)));
      left := left - len(x.seg_angdphi);
      assign(y(left downto left-len(x.seg_angdtheta)+1), vectorify(x.seg_angdtheta, y(left downto left-len(x.seg_angdtheta)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_endcap_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.e_reserved)-1), convert(x.e_reserved, y(left to left+len(x.e_reserved)-1)));
      left := left + len(x.e_reserved);
      assign(y(left to left+len(x.nswseg_mon)-1), convert(x.nswseg_mon, y(left to left+len(x.nswseg_mon)-1)));
      left := left + len(x.nswseg_mon);
      assign(y(left to left+len(x.nswseg_angdtheta)-1), convert(x.nswseg_angdtheta, y(left to left+len(x.nswseg_angdtheta)-1)));
      left := left + len(x.nswseg_angdtheta);
      assign(y(left to left+len(x.nswseg_posphi)-1), convert(x.nswseg_posphi, y(left to left+len(x.nswseg_posphi)-1)));
      left := left + len(x.nswseg_posphi);
      assign(y(left to left+len(x.nswseg_poseta)-1), convert(x.nswseg_poseta, y(left to left+len(x.nswseg_poseta)-1)));
      left := left + len(x.nswseg_poseta);
      assign(y(left to left+len(x.seg_angdphi)-1), convert(x.seg_angdphi, y(left to left+len(x.seg_angdphi)-1)));
      left := left + len(x.seg_angdphi);
      assign(y(left to left+len(x.seg_angdtheta)-1), convert(x.seg_angdtheta, y(left to left+len(x.seg_angdtheta)-1)));
    else
      assign(y(left downto left-len(x.e_reserved)+1), convert(x.e_reserved, y(left downto left-len(x.e_reserved)+1)));
      left := left - len(x.e_reserved);
      assign(y(left downto left-len(x.nswseg_mon)+1), convert(x.nswseg_mon, y(left downto left-len(x.nswseg_mon)+1)));
      left := left - len(x.nswseg_mon);
      assign(y(left downto left-len(x.nswseg_angdtheta)+1), convert(x.nswseg_angdtheta, y(left downto left-len(x.nswseg_angdtheta)+1)));
      left := left - len(x.nswseg_angdtheta);
      assign(y(left downto left-len(x.nswseg_posphi)+1), convert(x.nswseg_posphi, y(left downto left-len(x.nswseg_posphi)+1)));
      left := left - len(x.nswseg_posphi);
      assign(y(left downto left-len(x.nswseg_poseta)+1), convert(x.nswseg_poseta, y(left downto left-len(x.nswseg_poseta)+1)));
      left := left - len(x.nswseg_poseta);
      assign(y(left downto left-len(x.seg_angdphi)+1), convert(x.seg_angdphi, y(left downto left-len(x.seg_angdphi)+1)));
      left := left - len(x.seg_angdphi);
      assign(y(left downto left-len(x.seg_angdtheta)+1), convert(x.seg_angdtheta, y(left downto left-len(x.seg_angdtheta)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: slc_endcap_rt) return slc_endcap_rt is
    variable y: slc_endcap_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.e_reserved := structify(x(left to left+len(y.e_reserved)-1), y.e_reserved);
      left := left + len(y.e_reserved);
      y.nswseg_mon := structify(x(left to left+len(y.nswseg_mon)-1), y.nswseg_mon);
      left := left + len(y.nswseg_mon);
      y.nswseg_angdtheta := structify(x(left to left+len(y.nswseg_angdtheta)-1), y.nswseg_angdtheta);
      left := left + len(y.nswseg_angdtheta);
      y.nswseg_posphi := structify(x(left to left+len(y.nswseg_posphi)-1), y.nswseg_posphi);
      left := left + len(y.nswseg_posphi);
      y.nswseg_poseta := structify(x(left to left+len(y.nswseg_poseta)-1), y.nswseg_poseta);
      left := left + len(y.nswseg_poseta);
      y.seg_angdphi := structify(x(left to left+len(y.seg_angdphi)-1), y.seg_angdphi);
      left := left + len(y.seg_angdphi);
      y.seg_angdtheta := structify(x(left to left+len(y.seg_angdtheta)-1), y.seg_angdtheta);
    else
      y.e_reserved := structify(x(left downto left-len(y.e_reserved)+1), y.e_reserved);
      left := left - len(y.e_reserved);
      y.nswseg_mon := structify(x(left downto left-len(y.nswseg_mon)+1), y.nswseg_mon);
      left := left - len(y.nswseg_mon);
      y.nswseg_angdtheta := structify(x(left downto left-len(y.nswseg_angdtheta)+1), y.nswseg_angdtheta);
      left := left - len(y.nswseg_angdtheta);
      y.nswseg_posphi := structify(x(left downto left-len(y.nswseg_posphi)+1), y.nswseg_posphi);
      left := left - len(y.nswseg_posphi);
      y.nswseg_poseta := structify(x(left downto left-len(y.nswseg_poseta)+1), y.nswseg_poseta);
      left := left - len(y.nswseg_poseta);
      y.seg_angdphi := structify(x(left downto left-len(y.seg_angdphi)+1), y.seg_angdphi);
      left := left - len(y.seg_angdphi);
      y.seg_angdtheta := structify(x(left downto left-len(y.seg_angdtheta)+1), y.seg_angdtheta);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: slc_endcap_rt) return slc_endcap_rt is
    variable y: slc_endcap_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.e_reserved := convert(x(left to left+len(y.e_reserved)-1), y.e_reserved);
      left := left + len(y.e_reserved);
      y.nswseg_mon := convert(x(left to left+len(y.nswseg_mon)-1), y.nswseg_mon);
      left := left + len(y.nswseg_mon);
      y.nswseg_angdtheta := convert(x(left to left+len(y.nswseg_angdtheta)-1), y.nswseg_angdtheta);
      left := left + len(y.nswseg_angdtheta);
      y.nswseg_posphi := convert(x(left to left+len(y.nswseg_posphi)-1), y.nswseg_posphi);
      left := left + len(y.nswseg_posphi);
      y.nswseg_poseta := convert(x(left to left+len(y.nswseg_poseta)-1), y.nswseg_poseta);
      left := left + len(y.nswseg_poseta);
      y.seg_angdphi := convert(x(left to left+len(y.seg_angdphi)-1), y.seg_angdphi);
      left := left + len(y.seg_angdphi);
      y.seg_angdtheta := convert(x(left to left+len(y.seg_angdtheta)-1), y.seg_angdtheta);
    else
      y.e_reserved := convert(x(left downto left-len(y.e_reserved)+1), y.e_reserved);
      left := left - len(y.e_reserved);
      y.nswseg_mon := convert(x(left downto left-len(y.nswseg_mon)+1), y.nswseg_mon);
      left := left - len(y.nswseg_mon);
      y.nswseg_angdtheta := convert(x(left downto left-len(y.nswseg_angdtheta)+1), y.nswseg_angdtheta);
      left := left - len(y.nswseg_angdtheta);
      y.nswseg_posphi := convert(x(left downto left-len(y.nswseg_posphi)+1), y.nswseg_posphi);
      left := left - len(y.nswseg_posphi);
      y.nswseg_poseta := convert(x(left downto left-len(y.nswseg_poseta)+1), y.nswseg_poseta);
      left := left - len(y.nswseg_poseta);
      y.seg_angdphi := convert(x(left downto left-len(y.seg_angdphi)+1), y.seg_angdphi);
      left := left - len(y.seg_angdphi);
      y.seg_angdtheta := convert(x(left downto left-len(y.seg_angdtheta)+1), y.seg_angdtheta);
    end if;
    return y;
  end function convert;
  function nullify(t: slc_endcap_rt) return slc_endcap_rt is
  variable y: slc_endcap_rt;
  begin
    y.e_reserved := nullify(t.e_reserved);
    y.nswseg_mon := nullify(t.nswseg_mon);
    y.nswseg_angdtheta := nullify(t.nswseg_angdtheta);
    y.nswseg_posphi := nullify(t.nswseg_posphi);
    y.nswseg_poseta := nullify(t.nswseg_poseta);
    y.seg_angdphi := nullify(t.seg_angdphi);
    y.seg_angdtheta := nullify(t.seg_angdtheta);
    return y;
  end function nullify;
  function zeroed(t: slc_endcap_rt) return slc_endcap_rt is
  variable y: slc_endcap_rt;
  begin
    y.e_reserved := zeroed(t.e_reserved);
    y.nswseg_mon := zeroed(t.nswseg_mon);
    y.nswseg_angdtheta := zeroed(t.nswseg_angdtheta);
    y.nswseg_posphi := zeroed(t.nswseg_posphi);
    y.nswseg_poseta := zeroed(t.nswseg_poseta);
    y.seg_angdphi := zeroed(t.seg_angdphi);
    y.seg_angdtheta := zeroed(t.seg_angdtheta);
    return y;
  end function zeroed;

  function len(x: slc_barrel_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rpc3_posz);
    l := l + len(x.rpc2_posz);
    l := l + len(x.rpc1_posz);
    l := l + len(x.rpc0_posz);
    return l;
  end function len;
  function width(x: slc_barrel_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rpc3_posz);
    l := l + width(x.rpc2_posz);
    l := l + width(x.rpc1_posz);
    l := l + width(x.rpc0_posz);
    return l;
  end function width;
  function vectorify(x: slc_barrel_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rpc3_posz)-1), vectorify(x.rpc3_posz, y(left to left+len(x.rpc3_posz)-1)));
      left := left + len(x.rpc3_posz);
      assign(y(left to left+len(x.rpc2_posz)-1), vectorify(x.rpc2_posz, y(left to left+len(x.rpc2_posz)-1)));
      left := left + len(x.rpc2_posz);
      assign(y(left to left+len(x.rpc1_posz)-1), vectorify(x.rpc1_posz, y(left to left+len(x.rpc1_posz)-1)));
      left := left + len(x.rpc1_posz);
      assign(y(left to left+len(x.rpc0_posz)-1), vectorify(x.rpc0_posz, y(left to left+len(x.rpc0_posz)-1)));
    else
      assign(y(left downto left-len(x.rpc3_posz)+1), vectorify(x.rpc3_posz, y(left downto left-len(x.rpc3_posz)+1)));
      left := left - len(x.rpc3_posz);
      assign(y(left downto left-len(x.rpc2_posz)+1), vectorify(x.rpc2_posz, y(left downto left-len(x.rpc2_posz)+1)));
      left := left - len(x.rpc2_posz);
      assign(y(left downto left-len(x.rpc1_posz)+1), vectorify(x.rpc1_posz, y(left downto left-len(x.rpc1_posz)+1)));
      left := left - len(x.rpc1_posz);
      assign(y(left downto left-len(x.rpc0_posz)+1), vectorify(x.rpc0_posz, y(left downto left-len(x.rpc0_posz)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_barrel_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rpc3_posz)-1), convert(x.rpc3_posz, y(left to left+len(x.rpc3_posz)-1)));
      left := left + len(x.rpc3_posz);
      assign(y(left to left+len(x.rpc2_posz)-1), convert(x.rpc2_posz, y(left to left+len(x.rpc2_posz)-1)));
      left := left + len(x.rpc2_posz);
      assign(y(left to left+len(x.rpc1_posz)-1), convert(x.rpc1_posz, y(left to left+len(x.rpc1_posz)-1)));
      left := left + len(x.rpc1_posz);
      assign(y(left to left+len(x.rpc0_posz)-1), convert(x.rpc0_posz, y(left to left+len(x.rpc0_posz)-1)));
    else
      assign(y(left downto left-len(x.rpc3_posz)+1), convert(x.rpc3_posz, y(left downto left-len(x.rpc3_posz)+1)));
      left := left - len(x.rpc3_posz);
      assign(y(left downto left-len(x.rpc2_posz)+1), convert(x.rpc2_posz, y(left downto left-len(x.rpc2_posz)+1)));
      left := left - len(x.rpc2_posz);
      assign(y(left downto left-len(x.rpc1_posz)+1), convert(x.rpc1_posz, y(left downto left-len(x.rpc1_posz)+1)));
      left := left - len(x.rpc1_posz);
      assign(y(left downto left-len(x.rpc0_posz)+1), convert(x.rpc0_posz, y(left downto left-len(x.rpc0_posz)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: slc_barrel_rt) return slc_barrel_rt is
    variable y: slc_barrel_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rpc3_posz := structify(x(left to left+len(y.rpc3_posz)-1), y.rpc3_posz);
      left := left + len(y.rpc3_posz);
      y.rpc2_posz := structify(x(left to left+len(y.rpc2_posz)-1), y.rpc2_posz);
      left := left + len(y.rpc2_posz);
      y.rpc1_posz := structify(x(left to left+len(y.rpc1_posz)-1), y.rpc1_posz);
      left := left + len(y.rpc1_posz);
      y.rpc0_posz := structify(x(left to left+len(y.rpc0_posz)-1), y.rpc0_posz);
    else
      y.rpc3_posz := structify(x(left downto left-len(y.rpc3_posz)+1), y.rpc3_posz);
      left := left - len(y.rpc3_posz);
      y.rpc2_posz := structify(x(left downto left-len(y.rpc2_posz)+1), y.rpc2_posz);
      left := left - len(y.rpc2_posz);
      y.rpc1_posz := structify(x(left downto left-len(y.rpc1_posz)+1), y.rpc1_posz);
      left := left - len(y.rpc1_posz);
      y.rpc0_posz := structify(x(left downto left-len(y.rpc0_posz)+1), y.rpc0_posz);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: slc_barrel_rt) return slc_barrel_rt is
    variable y: slc_barrel_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rpc3_posz := convert(x(left to left+len(y.rpc3_posz)-1), y.rpc3_posz);
      left := left + len(y.rpc3_posz);
      y.rpc2_posz := convert(x(left to left+len(y.rpc2_posz)-1), y.rpc2_posz);
      left := left + len(y.rpc2_posz);
      y.rpc1_posz := convert(x(left to left+len(y.rpc1_posz)-1), y.rpc1_posz);
      left := left + len(y.rpc1_posz);
      y.rpc0_posz := convert(x(left to left+len(y.rpc0_posz)-1), y.rpc0_posz);
    else
      y.rpc3_posz := convert(x(left downto left-len(y.rpc3_posz)+1), y.rpc3_posz);
      left := left - len(y.rpc3_posz);
      y.rpc2_posz := convert(x(left downto left-len(y.rpc2_posz)+1), y.rpc2_posz);
      left := left - len(y.rpc2_posz);
      y.rpc1_posz := convert(x(left downto left-len(y.rpc1_posz)+1), y.rpc1_posz);
      left := left - len(y.rpc1_posz);
      y.rpc0_posz := convert(x(left downto left-len(y.rpc0_posz)+1), y.rpc0_posz);
    end if;
    return y;
  end function convert;
  function nullify(t: slc_barrel_rt) return slc_barrel_rt is
  variable y: slc_barrel_rt;
  begin
    y.rpc3_posz := nullify(t.rpc3_posz);
    y.rpc2_posz := nullify(t.rpc2_posz);
    y.rpc1_posz := nullify(t.rpc1_posz);
    y.rpc0_posz := nullify(t.rpc0_posz);
    return y;
  end function nullify;
  function zeroed(t: slc_barrel_rt) return slc_barrel_rt is
  variable y: slc_barrel_rt;
  begin
    y.rpc3_posz := zeroed(t.rpc3_posz);
    y.rpc2_posz := zeroed(t.rpc2_posz);
    y.rpc1_posz := zeroed(t.rpc1_posz);
    y.rpc0_posz := zeroed(t.rpc0_posz);
    return y;
  end function zeroed;

  function len(x: slc_rx_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.common);
    l := l + len(x.specific);
    return l;
  end function len;
  function width(x: slc_rx_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.common);
    l := l + width(x.specific);
    return l;
  end function width;
  function vectorify(x: slc_rx_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.common)-1), vectorify(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.specific)-1), vectorify(x.specific, y(left to left+len(x.specific)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.common)+1), vectorify(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.specific)+1), vectorify(x.specific, y(left downto left-len(x.specific)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_rx_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.common)-1), convert(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.specific)-1), convert(x.specific, y(left to left+len(x.specific)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.common)+1), convert(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.specific)+1), convert(x.specific, y(left downto left-len(x.specific)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: slc_rx_rt) return slc_rx_rt is
    variable y: slc_rx_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.common := structify(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.specific := structify(x(left to left+len(y.specific)-1), y.specific);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.common := structify(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.specific := structify(x(left downto left-len(y.specific)+1), y.specific);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: slc_rx_rt) return slc_rx_rt is
    variable y: slc_rx_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.common := convert(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.specific := convert(x(left to left+len(y.specific)-1), y.specific);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.common := convert(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.specific := convert(x(left downto left-len(y.specific)+1), y.specific);
    end if;
    return y;
  end function convert;
  function nullify(t: slc_rx_rt) return slc_rx_rt is
  variable y: slc_rx_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.common := nullify(t.common);
    y.specific := nullify(t.specific);
    return y;
  end function nullify;
  function zeroed(t: slc_rx_rt) return slc_rx_rt is
  variable y: slc_rx_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.common := zeroed(t.common);
    y.specific := zeroed(t.specific);
    return y;
  end function zeroed;

  function len(x: slc_muid_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.slcid);
    l := l + len(x.slid);
    l := l + len(x.bcid);
    return l;
  end function len;
  function width(x: slc_muid_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.slcid);
    l := l + width(x.slid);
    l := l + width(x.bcid);
    return l;
  end function width;
  function vectorify(x: slc_muid_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.slcid)-1), vectorify(x.slcid, y(left to left+len(x.slcid)-1)));
      left := left + len(x.slcid);
      assign(y(left to left+len(x.slid)-1), vectorify(x.slid, y(left to left+len(x.slid)-1)));
      left := left + len(x.slid);
      assign(y(left to left+len(x.bcid)-1), vectorify(x.bcid, y(left to left+len(x.bcid)-1)));
    else
      assign(y(left downto left-len(x.slcid)+1), vectorify(x.slcid, y(left downto left-len(x.slcid)+1)));
      left := left - len(x.slcid);
      assign(y(left downto left-len(x.slid)+1), vectorify(x.slid, y(left downto left-len(x.slid)+1)));
      left := left - len(x.slid);
      assign(y(left downto left-len(x.bcid)+1), vectorify(x.bcid, y(left downto left-len(x.bcid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_muid_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.slcid)-1), convert(x.slcid, y(left to left+len(x.slcid)-1)));
      left := left + len(x.slcid);
      assign(y(left to left+len(x.slid)-1), convert(x.slid, y(left to left+len(x.slid)-1)));
      left := left + len(x.slid);
      assign(y(left to left+len(x.bcid)-1), convert(x.bcid, y(left to left+len(x.bcid)-1)));
    else
      assign(y(left downto left-len(x.slcid)+1), convert(x.slcid, y(left downto left-len(x.slcid)+1)));
      left := left - len(x.slcid);
      assign(y(left downto left-len(x.slid)+1), convert(x.slid, y(left downto left-len(x.slid)+1)));
      left := left - len(x.slid);
      assign(y(left downto left-len(x.bcid)+1), convert(x.bcid, y(left downto left-len(x.bcid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: slc_muid_rt) return slc_muid_rt is
    variable y: slc_muid_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.slcid := structify(x(left to left+len(y.slcid)-1), y.slcid);
      left := left + len(y.slcid);
      y.slid := structify(x(left to left+len(y.slid)-1), y.slid);
      left := left + len(y.slid);
      y.bcid := structify(x(left to left+len(y.bcid)-1), y.bcid);
    else
      y.slcid := structify(x(left downto left-len(y.slcid)+1), y.slcid);
      left := left - len(y.slcid);
      y.slid := structify(x(left downto left-len(y.slid)+1), y.slid);
      left := left - len(y.slid);
      y.bcid := structify(x(left downto left-len(y.bcid)+1), y.bcid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: slc_muid_rt) return slc_muid_rt is
    variable y: slc_muid_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.slcid := convert(x(left to left+len(y.slcid)-1), y.slcid);
      left := left + len(y.slcid);
      y.slid := convert(x(left to left+len(y.slid)-1), y.slid);
      left := left + len(y.slid);
      y.bcid := convert(x(left to left+len(y.bcid)-1), y.bcid);
    else
      y.slcid := convert(x(left downto left-len(y.slcid)+1), y.slcid);
      left := left - len(y.slcid);
      y.slid := convert(x(left downto left-len(y.slid)+1), y.slid);
      left := left - len(y.slid);
      y.bcid := convert(x(left downto left-len(y.bcid)+1), y.bcid);
    end if;
    return y;
  end function convert;
  function nullify(t: slc_muid_rt) return slc_muid_rt is
  variable y: slc_muid_rt;
  begin
    y.slcid := nullify(t.slcid);
    y.slid := nullify(t.slid);
    y.bcid := nullify(t.bcid);
    return y;
  end function nullify;
  function zeroed(t: slc_muid_rt) return slc_muid_rt is
  variable y: slc_muid_rt;
  begin
    y.slcid := zeroed(t.slcid);
    y.slid := zeroed(t.slid);
    y.bcid := zeroed(t.bcid);
    return y;
  end function zeroed;

  function len(x: vec_mdtid_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.chamber_id);
    l := l + len(x.chamber_ieta);
    return l;
  end function len;
  function width(x: vec_mdtid_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.chamber_id);
    l := l + width(x.chamber_ieta);
    return l;
  end function width;
  function vectorify(x: vec_mdtid_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.chamber_id)-1), vectorify(x.chamber_id, y(left to left+len(x.chamber_id)-1)));
      left := left + len(x.chamber_id);
      assign(y(left to left+len(x.chamber_ieta)-1), vectorify(x.chamber_ieta, y(left to left+len(x.chamber_ieta)-1)));
    else
      assign(y(left downto left-len(x.chamber_id)+1), vectorify(x.chamber_id, y(left downto left-len(x.chamber_id)+1)));
      left := left - len(x.chamber_id);
      assign(y(left downto left-len(x.chamber_ieta)+1), vectorify(x.chamber_ieta, y(left downto left-len(x.chamber_ieta)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: vec_mdtid_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.chamber_id)-1), convert(x.chamber_id, y(left to left+len(x.chamber_id)-1)));
      left := left + len(x.chamber_id);
      assign(y(left to left+len(x.chamber_ieta)-1), convert(x.chamber_ieta, y(left to left+len(x.chamber_ieta)-1)));
    else
      assign(y(left downto left-len(x.chamber_id)+1), convert(x.chamber_id, y(left downto left-len(x.chamber_id)+1)));
      left := left - len(x.chamber_id);
      assign(y(left downto left-len(x.chamber_ieta)+1), convert(x.chamber_ieta, y(left downto left-len(x.chamber_ieta)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: vec_mdtid_rt) return vec_mdtid_rt is
    variable y: vec_mdtid_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.chamber_id := structify(x(left to left+len(y.chamber_id)-1), y.chamber_id);
      left := left + len(y.chamber_id);
      y.chamber_ieta := structify(x(left to left+len(y.chamber_ieta)-1), y.chamber_ieta);
    else
      y.chamber_id := structify(x(left downto left-len(y.chamber_id)+1), y.chamber_id);
      left := left - len(y.chamber_id);
      y.chamber_ieta := structify(x(left downto left-len(y.chamber_ieta)+1), y.chamber_ieta);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: vec_mdtid_rt) return vec_mdtid_rt is
    variable y: vec_mdtid_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.chamber_id := convert(x(left to left+len(y.chamber_id)-1), y.chamber_id);
      left := left + len(y.chamber_id);
      y.chamber_ieta := convert(x(left to left+len(y.chamber_ieta)-1), y.chamber_ieta);
    else
      y.chamber_id := convert(x(left downto left-len(y.chamber_id)+1), y.chamber_id);
      left := left - len(y.chamber_id);
      y.chamber_ieta := convert(x(left downto left-len(y.chamber_ieta)+1), y.chamber_ieta);
    end if;
    return y;
  end function convert;
  function nullify(t: vec_mdtid_rt) return vec_mdtid_rt is
  variable y: vec_mdtid_rt;
  begin
    y.chamber_id := nullify(t.chamber_id);
    y.chamber_ieta := nullify(t.chamber_ieta);
    return y;
  end function nullify;
  function zeroed(t: vec_mdtid_rt) return vec_mdtid_rt is
  variable y: vec_mdtid_rt;
  begin
    y.chamber_id := zeroed(t.chamber_id);
    y.chamber_ieta := zeroed(t.chamber_ieta);
    return y;
  end function zeroed;

  function len(x: tdc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.chanid);
    l := l + len(x.edgemode);
    l := l + len(x.coarsetime);
    l := l + len(x.finetime);
    l := l + len(x.pulsewidth);
    return l;
  end function len;
  function width(x: tdc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.chanid);
    l := l + width(x.edgemode);
    l := l + width(x.coarsetime);
    l := l + width(x.finetime);
    l := l + width(x.pulsewidth);
    return l;
  end function width;
  function vectorify(x: tdc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.chanid)-1), vectorify(x.chanid, y(left to left+len(x.chanid)-1)));
      left := left + len(x.chanid);
      assign(y(left to left+len(x.edgemode)-1), vectorify(x.edgemode, y(left to left+len(x.edgemode)-1)));
      left := left + len(x.edgemode);
      assign(y(left to left+len(x.coarsetime)-1), vectorify(x.coarsetime, y(left to left+len(x.coarsetime)-1)));
      left := left + len(x.coarsetime);
      assign(y(left to left+len(x.finetime)-1), vectorify(x.finetime, y(left to left+len(x.finetime)-1)));
      left := left + len(x.finetime);
      assign(y(left to left+len(x.pulsewidth)-1), vectorify(x.pulsewidth, y(left to left+len(x.pulsewidth)-1)));
    else
      assign(y(left downto left-len(x.chanid)+1), vectorify(x.chanid, y(left downto left-len(x.chanid)+1)));
      left := left - len(x.chanid);
      assign(y(left downto left-len(x.edgemode)+1), vectorify(x.edgemode, y(left downto left-len(x.edgemode)+1)));
      left := left - len(x.edgemode);
      assign(y(left downto left-len(x.coarsetime)+1), vectorify(x.coarsetime, y(left downto left-len(x.coarsetime)+1)));
      left := left - len(x.coarsetime);
      assign(y(left downto left-len(x.finetime)+1), vectorify(x.finetime, y(left downto left-len(x.finetime)+1)));
      left := left - len(x.finetime);
      assign(y(left downto left-len(x.pulsewidth)+1), vectorify(x.pulsewidth, y(left downto left-len(x.pulsewidth)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: tdc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.chanid)-1), convert(x.chanid, y(left to left+len(x.chanid)-1)));
      left := left + len(x.chanid);
      assign(y(left to left+len(x.edgemode)-1), convert(x.edgemode, y(left to left+len(x.edgemode)-1)));
      left := left + len(x.edgemode);
      assign(y(left to left+len(x.coarsetime)-1), convert(x.coarsetime, y(left to left+len(x.coarsetime)-1)));
      left := left + len(x.coarsetime);
      assign(y(left to left+len(x.finetime)-1), convert(x.finetime, y(left to left+len(x.finetime)-1)));
      left := left + len(x.finetime);
      assign(y(left to left+len(x.pulsewidth)-1), convert(x.pulsewidth, y(left to left+len(x.pulsewidth)-1)));
    else
      assign(y(left downto left-len(x.chanid)+1), convert(x.chanid, y(left downto left-len(x.chanid)+1)));
      left := left - len(x.chanid);
      assign(y(left downto left-len(x.edgemode)+1), convert(x.edgemode, y(left downto left-len(x.edgemode)+1)));
      left := left - len(x.edgemode);
      assign(y(left downto left-len(x.coarsetime)+1), convert(x.coarsetime, y(left downto left-len(x.coarsetime)+1)));
      left := left - len(x.coarsetime);
      assign(y(left downto left-len(x.finetime)+1), convert(x.finetime, y(left downto left-len(x.finetime)+1)));
      left := left - len(x.finetime);
      assign(y(left downto left-len(x.pulsewidth)+1), convert(x.pulsewidth, y(left downto left-len(x.pulsewidth)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: tdc_rt) return tdc_rt is
    variable y: tdc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.chanid := structify(x(left to left+len(y.chanid)-1), y.chanid);
      left := left + len(y.chanid);
      y.edgemode := structify(x(left to left+len(y.edgemode)-1), y.edgemode);
      left := left + len(y.edgemode);
      y.coarsetime := structify(x(left to left+len(y.coarsetime)-1), y.coarsetime);
      left := left + len(y.coarsetime);
      y.finetime := structify(x(left to left+len(y.finetime)-1), y.finetime);
      left := left + len(y.finetime);
      y.pulsewidth := structify(x(left to left+len(y.pulsewidth)-1), y.pulsewidth);
    else
      y.chanid := structify(x(left downto left-len(y.chanid)+1), y.chanid);
      left := left - len(y.chanid);
      y.edgemode := structify(x(left downto left-len(y.edgemode)+1), y.edgemode);
      left := left - len(y.edgemode);
      y.coarsetime := structify(x(left downto left-len(y.coarsetime)+1), y.coarsetime);
      left := left - len(y.coarsetime);
      y.finetime := structify(x(left downto left-len(y.finetime)+1), y.finetime);
      left := left - len(y.finetime);
      y.pulsewidth := structify(x(left downto left-len(y.pulsewidth)+1), y.pulsewidth);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: tdc_rt) return tdc_rt is
    variable y: tdc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.chanid := convert(x(left to left+len(y.chanid)-1), y.chanid);
      left := left + len(y.chanid);
      y.edgemode := convert(x(left to left+len(y.edgemode)-1), y.edgemode);
      left := left + len(y.edgemode);
      y.coarsetime := convert(x(left to left+len(y.coarsetime)-1), y.coarsetime);
      left := left + len(y.coarsetime);
      y.finetime := convert(x(left to left+len(y.finetime)-1), y.finetime);
      left := left + len(y.finetime);
      y.pulsewidth := convert(x(left to left+len(y.pulsewidth)-1), y.pulsewidth);
    else
      y.chanid := convert(x(left downto left-len(y.chanid)+1), y.chanid);
      left := left - len(y.chanid);
      y.edgemode := convert(x(left downto left-len(y.edgemode)+1), y.edgemode);
      left := left - len(y.edgemode);
      y.coarsetime := convert(x(left downto left-len(y.coarsetime)+1), y.coarsetime);
      left := left - len(y.coarsetime);
      y.finetime := convert(x(left downto left-len(y.finetime)+1), y.finetime);
      left := left - len(y.finetime);
      y.pulsewidth := convert(x(left downto left-len(y.pulsewidth)+1), y.pulsewidth);
    end if;
    return y;
  end function convert;
  function nullify(t: tdc_rt) return tdc_rt is
  variable y: tdc_rt;
  begin
    y.chanid := nullify(t.chanid);
    y.edgemode := nullify(t.edgemode);
    y.coarsetime := nullify(t.coarsetime);
    y.finetime := nullify(t.finetime);
    y.pulsewidth := nullify(t.pulsewidth);
    return y;
  end function nullify;
  function zeroed(t: tdc_rt) return tdc_rt is
  variable y: tdc_rt;
  begin
    y.chanid := zeroed(t.chanid);
    y.edgemode := zeroed(t.edgemode);
    y.coarsetime := zeroed(t.coarsetime);
    y.finetime := zeroed(t.finetime);
    y.pulsewidth := zeroed(t.pulsewidth);
    return y;
  end function zeroed;

  function len(x: ucm2pl_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.busy);
    l := l + len(x.process_ch);
    l := l + len(x.common);
    l := l + len(x.phimod);
    l := l + len(x.nswseg_angdtheta);
    l := l + len(x.nswseg_posphi);
    l := l + len(x.nswseg_poseta);
    return l;
  end function len;
  function width(x: ucm2pl_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.busy);
    l := l + width(x.process_ch);
    l := l + width(x.common);
    l := l + width(x.phimod);
    l := l + width(x.nswseg_angdtheta);
    l := l + width(x.nswseg_posphi);
    l := l + width(x.nswseg_poseta);
    return l;
  end function width;
  function vectorify(x: ucm2pl_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.busy)-1), vectorify(x.busy, y(left to left+len(x.busy)-1)));
      left := left + len(x.busy);
      assign(y(left to left+len(x.process_ch)-1), vectorify(x.process_ch, y(left to left+len(x.process_ch)-1)));
      left := left + len(x.process_ch);
      assign(y(left to left+len(x.common)-1), vectorify(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.phimod)-1), vectorify(x.phimod, y(left to left+len(x.phimod)-1)));
      left := left + len(x.phimod);
      assign(y(left to left+len(x.nswseg_angdtheta)-1), vectorify(x.nswseg_angdtheta, y(left to left+len(x.nswseg_angdtheta)-1)));
      left := left + len(x.nswseg_angdtheta);
      assign(y(left to left+len(x.nswseg_posphi)-1), vectorify(x.nswseg_posphi, y(left to left+len(x.nswseg_posphi)-1)));
      left := left + len(x.nswseg_posphi);
      assign(y(left to left+len(x.nswseg_poseta)-1), vectorify(x.nswseg_poseta, y(left to left+len(x.nswseg_poseta)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.busy)+1), vectorify(x.busy, y(left downto left-len(x.busy)+1)));
      left := left - len(x.busy);
      assign(y(left downto left-len(x.process_ch)+1), vectorify(x.process_ch, y(left downto left-len(x.process_ch)+1)));
      left := left - len(x.process_ch);
      assign(y(left downto left-len(x.common)+1), vectorify(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.phimod)+1), vectorify(x.phimod, y(left downto left-len(x.phimod)+1)));
      left := left - len(x.phimod);
      assign(y(left downto left-len(x.nswseg_angdtheta)+1), vectorify(x.nswseg_angdtheta, y(left downto left-len(x.nswseg_angdtheta)+1)));
      left := left - len(x.nswseg_angdtheta);
      assign(y(left downto left-len(x.nswseg_posphi)+1), vectorify(x.nswseg_posphi, y(left downto left-len(x.nswseg_posphi)+1)));
      left := left - len(x.nswseg_posphi);
      assign(y(left downto left-len(x.nswseg_poseta)+1), vectorify(x.nswseg_poseta, y(left downto left-len(x.nswseg_poseta)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm2pl_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.busy)-1), convert(x.busy, y(left to left+len(x.busy)-1)));
      left := left + len(x.busy);
      assign(y(left to left+len(x.process_ch)-1), convert(x.process_ch, y(left to left+len(x.process_ch)-1)));
      left := left + len(x.process_ch);
      assign(y(left to left+len(x.common)-1), convert(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.phimod)-1), convert(x.phimod, y(left to left+len(x.phimod)-1)));
      left := left + len(x.phimod);
      assign(y(left to left+len(x.nswseg_angdtheta)-1), convert(x.nswseg_angdtheta, y(left to left+len(x.nswseg_angdtheta)-1)));
      left := left + len(x.nswseg_angdtheta);
      assign(y(left to left+len(x.nswseg_posphi)-1), convert(x.nswseg_posphi, y(left to left+len(x.nswseg_posphi)-1)));
      left := left + len(x.nswseg_posphi);
      assign(y(left to left+len(x.nswseg_poseta)-1), convert(x.nswseg_poseta, y(left to left+len(x.nswseg_poseta)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.busy)+1), convert(x.busy, y(left downto left-len(x.busy)+1)));
      left := left - len(x.busy);
      assign(y(left downto left-len(x.process_ch)+1), convert(x.process_ch, y(left downto left-len(x.process_ch)+1)));
      left := left - len(x.process_ch);
      assign(y(left downto left-len(x.common)+1), convert(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.phimod)+1), convert(x.phimod, y(left downto left-len(x.phimod)+1)));
      left := left - len(x.phimod);
      assign(y(left downto left-len(x.nswseg_angdtheta)+1), convert(x.nswseg_angdtheta, y(left downto left-len(x.nswseg_angdtheta)+1)));
      left := left - len(x.nswseg_angdtheta);
      assign(y(left downto left-len(x.nswseg_posphi)+1), convert(x.nswseg_posphi, y(left downto left-len(x.nswseg_posphi)+1)));
      left := left - len(x.nswseg_posphi);
      assign(y(left downto left-len(x.nswseg_poseta)+1), convert(x.nswseg_poseta, y(left downto left-len(x.nswseg_poseta)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm2pl_rt) return ucm2pl_rt is
    variable y: ucm2pl_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.busy := structify(x(left to left+len(y.busy)-1), y.busy);
      left := left + len(y.busy);
      y.process_ch := structify(x(left to left+len(y.process_ch)-1), y.process_ch);
      left := left + len(y.process_ch);
      y.common := structify(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.phimod := structify(x(left to left+len(y.phimod)-1), y.phimod);
      left := left + len(y.phimod);
      y.nswseg_angdtheta := structify(x(left to left+len(y.nswseg_angdtheta)-1), y.nswseg_angdtheta);
      left := left + len(y.nswseg_angdtheta);
      y.nswseg_posphi := structify(x(left to left+len(y.nswseg_posphi)-1), y.nswseg_posphi);
      left := left + len(y.nswseg_posphi);
      y.nswseg_poseta := structify(x(left to left+len(y.nswseg_poseta)-1), y.nswseg_poseta);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.busy := structify(x(left downto left-len(y.busy)+1), y.busy);
      left := left - len(y.busy);
      y.process_ch := structify(x(left downto left-len(y.process_ch)+1), y.process_ch);
      left := left - len(y.process_ch);
      y.common := structify(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.phimod := structify(x(left downto left-len(y.phimod)+1), y.phimod);
      left := left - len(y.phimod);
      y.nswseg_angdtheta := structify(x(left downto left-len(y.nswseg_angdtheta)+1), y.nswseg_angdtheta);
      left := left - len(y.nswseg_angdtheta);
      y.nswseg_posphi := structify(x(left downto left-len(y.nswseg_posphi)+1), y.nswseg_posphi);
      left := left - len(y.nswseg_posphi);
      y.nswseg_poseta := structify(x(left downto left-len(y.nswseg_poseta)+1), y.nswseg_poseta);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm2pl_rt) return ucm2pl_rt is
    variable y: ucm2pl_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.busy := convert(x(left to left+len(y.busy)-1), y.busy);
      left := left + len(y.busy);
      y.process_ch := convert(x(left to left+len(y.process_ch)-1), y.process_ch);
      left := left + len(y.process_ch);
      y.common := convert(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.phimod := convert(x(left to left+len(y.phimod)-1), y.phimod);
      left := left + len(y.phimod);
      y.nswseg_angdtheta := convert(x(left to left+len(y.nswseg_angdtheta)-1), y.nswseg_angdtheta);
      left := left + len(y.nswseg_angdtheta);
      y.nswseg_posphi := convert(x(left to left+len(y.nswseg_posphi)-1), y.nswseg_posphi);
      left := left + len(y.nswseg_posphi);
      y.nswseg_poseta := convert(x(left to left+len(y.nswseg_poseta)-1), y.nswseg_poseta);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.busy := convert(x(left downto left-len(y.busy)+1), y.busy);
      left := left - len(y.busy);
      y.process_ch := convert(x(left downto left-len(y.process_ch)+1), y.process_ch);
      left := left - len(y.process_ch);
      y.common := convert(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.phimod := convert(x(left downto left-len(y.phimod)+1), y.phimod);
      left := left - len(y.phimod);
      y.nswseg_angdtheta := convert(x(left downto left-len(y.nswseg_angdtheta)+1), y.nswseg_angdtheta);
      left := left - len(y.nswseg_angdtheta);
      y.nswseg_posphi := convert(x(left downto left-len(y.nswseg_posphi)+1), y.nswseg_posphi);
      left := left - len(y.nswseg_posphi);
      y.nswseg_poseta := convert(x(left downto left-len(y.nswseg_poseta)+1), y.nswseg_poseta);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm2pl_rt) return ucm2pl_rt is
  variable y: ucm2pl_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.busy := nullify(t.busy);
    y.process_ch := nullify(t.process_ch);
    y.common := nullify(t.common);
    y.phimod := nullify(t.phimod);
    y.nswseg_angdtheta := nullify(t.nswseg_angdtheta);
    y.nswseg_posphi := nullify(t.nswseg_posphi);
    y.nswseg_poseta := nullify(t.nswseg_poseta);
    return y;
  end function nullify;
  function zeroed(t: ucm2pl_rt) return ucm2pl_rt is
  variable y: ucm2pl_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.busy := zeroed(t.busy);
    y.process_ch := zeroed(t.process_ch);
    y.common := zeroed(t.common);
    y.phimod := zeroed(t.phimod);
    y.nswseg_angdtheta := zeroed(t.nswseg_angdtheta);
    y.nswseg_posphi := zeroed(t.nswseg_posphi);
    y.nswseg_poseta := zeroed(t.nswseg_poseta);
    return y;
  end function zeroed;

  function len(x: tdcpolmux2tar_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.tdc);
    l := l + len(x.csmid);
    l := l + len(x.tdcid);
    return l;
  end function len;
  function width(x: tdcpolmux2tar_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.tdc);
    l := l + width(x.csmid);
    l := l + width(x.tdcid);
    return l;
  end function width;
  function vectorify(x: tdcpolmux2tar_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.tdc)-1), vectorify(x.tdc, y(left to left+len(x.tdc)-1)));
      left := left + len(x.tdc);
      assign(y(left to left+len(x.csmid)-1), vectorify(x.csmid, y(left to left+len(x.csmid)-1)));
      left := left + len(x.csmid);
      assign(y(left to left+len(x.tdcid)-1), vectorify(x.tdcid, y(left to left+len(x.tdcid)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.tdc)+1), vectorify(x.tdc, y(left downto left-len(x.tdc)+1)));
      left := left - len(x.tdc);
      assign(y(left downto left-len(x.csmid)+1), vectorify(x.csmid, y(left downto left-len(x.csmid)+1)));
      left := left - len(x.csmid);
      assign(y(left downto left-len(x.tdcid)+1), vectorify(x.tdcid, y(left downto left-len(x.tdcid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: tdcpolmux2tar_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.tdc)-1), convert(x.tdc, y(left to left+len(x.tdc)-1)));
      left := left + len(x.tdc);
      assign(y(left to left+len(x.csmid)-1), convert(x.csmid, y(left to left+len(x.csmid)-1)));
      left := left + len(x.csmid);
      assign(y(left to left+len(x.tdcid)-1), convert(x.tdcid, y(left to left+len(x.tdcid)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.tdc)+1), convert(x.tdc, y(left downto left-len(x.tdc)+1)));
      left := left - len(x.tdc);
      assign(y(left downto left-len(x.csmid)+1), convert(x.csmid, y(left downto left-len(x.csmid)+1)));
      left := left - len(x.csmid);
      assign(y(left downto left-len(x.tdcid)+1), convert(x.tdcid, y(left downto left-len(x.tdcid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: tdcpolmux2tar_rt) return tdcpolmux2tar_rt is
    variable y: tdcpolmux2tar_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.tdc := structify(x(left to left+len(y.tdc)-1), y.tdc);
      left := left + len(y.tdc);
      y.csmid := structify(x(left to left+len(y.csmid)-1), y.csmid);
      left := left + len(y.csmid);
      y.tdcid := structify(x(left to left+len(y.tdcid)-1), y.tdcid);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.tdc := structify(x(left downto left-len(y.tdc)+1), y.tdc);
      left := left - len(y.tdc);
      y.csmid := structify(x(left downto left-len(y.csmid)+1), y.csmid);
      left := left - len(y.csmid);
      y.tdcid := structify(x(left downto left-len(y.tdcid)+1), y.tdcid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: tdcpolmux2tar_rt) return tdcpolmux2tar_rt is
    variable y: tdcpolmux2tar_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.tdc := convert(x(left to left+len(y.tdc)-1), y.tdc);
      left := left + len(y.tdc);
      y.csmid := convert(x(left to left+len(y.csmid)-1), y.csmid);
      left := left + len(y.csmid);
      y.tdcid := convert(x(left to left+len(y.tdcid)-1), y.tdcid);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.tdc := convert(x(left downto left-len(y.tdc)+1), y.tdc);
      left := left - len(y.tdc);
      y.csmid := convert(x(left downto left-len(y.csmid)+1), y.csmid);
      left := left - len(y.csmid);
      y.tdcid := convert(x(left downto left-len(y.tdcid)+1), y.tdcid);
    end if;
    return y;
  end function convert;
  function nullify(t: tdcpolmux2tar_rt) return tdcpolmux2tar_rt is
  variable y: tdcpolmux2tar_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.tdc := nullify(t.tdc);
    y.csmid := nullify(t.csmid);
    y.tdcid := nullify(t.tdcid);
    return y;
  end function nullify;
  function zeroed(t: tdcpolmux2tar_rt) return tdcpolmux2tar_rt is
  variable y: tdcpolmux2tar_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.tdc := zeroed(t.tdc);
    y.csmid := zeroed(t.csmid);
    y.tdcid := zeroed(t.tdcid);
    return y;
  end function zeroed;

  function len(x: ucm2hps_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.muid);
    l := l + len(x.mdtseg_dest);
    l := l + len(x.mdtid);
    l := l + len(x.vec_pos);
    l := l + len(x.vec_ang);
    return l;
  end function len;
  function width(x: ucm2hps_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.muid);
    l := l + width(x.mdtseg_dest);
    l := l + width(x.mdtid);
    l := l + width(x.vec_pos);
    l := l + width(x.vec_ang);
    return l;
  end function width;
  function vectorify(x: ucm2hps_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdtseg_dest)-1), vectorify(x.mdtseg_dest, y(left to left+len(x.mdtseg_dest)-1)));
      left := left + len(x.mdtseg_dest);
      assign(y(left to left+len(x.mdtid)-1), vectorify(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.vec_pos)-1), vectorify(x.vec_pos, y(left to left+len(x.vec_pos)-1)));
      left := left + len(x.vec_pos);
      assign(y(left to left+len(x.vec_ang)-1), vectorify(x.vec_ang, y(left to left+len(x.vec_ang)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdtseg_dest)+1), vectorify(x.mdtseg_dest, y(left downto left-len(x.mdtseg_dest)+1)));
      left := left - len(x.mdtseg_dest);
      assign(y(left downto left-len(x.mdtid)+1), vectorify(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.vec_pos)+1), vectorify(x.vec_pos, y(left downto left-len(x.vec_pos)+1)));
      left := left - len(x.vec_pos);
      assign(y(left downto left-len(x.vec_ang)+1), vectorify(x.vec_ang, y(left downto left-len(x.vec_ang)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm2hps_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdtseg_dest)-1), convert(x.mdtseg_dest, y(left to left+len(x.mdtseg_dest)-1)));
      left := left + len(x.mdtseg_dest);
      assign(y(left to left+len(x.mdtid)-1), convert(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.vec_pos)-1), convert(x.vec_pos, y(left to left+len(x.vec_pos)-1)));
      left := left + len(x.vec_pos);
      assign(y(left to left+len(x.vec_ang)-1), convert(x.vec_ang, y(left to left+len(x.vec_ang)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdtseg_dest)+1), convert(x.mdtseg_dest, y(left downto left-len(x.mdtseg_dest)+1)));
      left := left - len(x.mdtseg_dest);
      assign(y(left downto left-len(x.mdtid)+1), convert(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.vec_pos)+1), convert(x.vec_pos, y(left downto left-len(x.vec_pos)+1)));
      left := left - len(x.vec_pos);
      assign(y(left downto left-len(x.vec_ang)+1), convert(x.vec_ang, y(left downto left-len(x.vec_ang)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ucm2hps_rt) return ucm2hps_rt is
    variable y: ucm2hps_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdtseg_dest := structify(x(left to left+len(y.mdtseg_dest)-1), y.mdtseg_dest);
      left := left + len(y.mdtseg_dest);
      y.mdtid := structify(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.vec_pos := structify(x(left to left+len(y.vec_pos)-1), y.vec_pos);
      left := left + len(y.vec_pos);
      y.vec_ang := structify(x(left to left+len(y.vec_ang)-1), y.vec_ang);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdtseg_dest := structify(x(left downto left-len(y.mdtseg_dest)+1), y.mdtseg_dest);
      left := left - len(y.mdtseg_dest);
      y.mdtid := structify(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.vec_pos := structify(x(left downto left-len(y.vec_pos)+1), y.vec_pos);
      left := left - len(y.vec_pos);
      y.vec_ang := structify(x(left downto left-len(y.vec_ang)+1), y.vec_ang);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ucm2hps_rt) return ucm2hps_rt is
    variable y: ucm2hps_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdtseg_dest := convert(x(left to left+len(y.mdtseg_dest)-1), y.mdtseg_dest);
      left := left + len(y.mdtseg_dest);
      y.mdtid := convert(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.vec_pos := convert(x(left to left+len(y.vec_pos)-1), y.vec_pos);
      left := left + len(y.vec_pos);
      y.vec_ang := convert(x(left to left+len(y.vec_ang)-1), y.vec_ang);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdtseg_dest := convert(x(left downto left-len(y.mdtseg_dest)+1), y.mdtseg_dest);
      left := left - len(y.mdtseg_dest);
      y.mdtid := convert(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.vec_pos := convert(x(left downto left-len(y.vec_pos)+1), y.vec_pos);
      left := left - len(y.vec_pos);
      y.vec_ang := convert(x(left downto left-len(y.vec_ang)+1), y.vec_ang);
    end if;
    return y;
  end function convert;
  function nullify(t: ucm2hps_rt) return ucm2hps_rt is
  variable y: ucm2hps_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.muid := nullify(t.muid);
    y.mdtseg_dest := nullify(t.mdtseg_dest);
    y.mdtid := nullify(t.mdtid);
    y.vec_pos := nullify(t.vec_pos);
    y.vec_ang := nullify(t.vec_ang);
    return y;
  end function nullify;
  function zeroed(t: ucm2hps_rt) return ucm2hps_rt is
  variable y: ucm2hps_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.muid := zeroed(t.muid);
    y.mdtseg_dest := zeroed(t.mdtseg_dest);
    y.mdtid := zeroed(t.mdtid);
    y.vec_pos := zeroed(t.vec_pos);
    y.vec_ang := zeroed(t.vec_ang);
    return y;
  end function zeroed;

  function len(x: heg2sfslc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.muid);
    l := l + len(x.mdtseg_dest);
    l := l + len(x.mdtid);
    l := l + len(x.vec_pos);
    l := l + len(x.vec_ang);
    l := l + len(x.hewindow_pos);
    return l;
  end function len;
  function width(x: heg2sfslc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.muid);
    l := l + width(x.mdtseg_dest);
    l := l + width(x.mdtid);
    l := l + width(x.vec_pos);
    l := l + width(x.vec_ang);
    l := l + width(x.hewindow_pos);
    return l;
  end function width;
  function vectorify(x: heg2sfslc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdtseg_dest)-1), vectorify(x.mdtseg_dest, y(left to left+len(x.mdtseg_dest)-1)));
      left := left + len(x.mdtseg_dest);
      assign(y(left to left+len(x.mdtid)-1), vectorify(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.vec_pos)-1), vectorify(x.vec_pos, y(left to left+len(x.vec_pos)-1)));
      left := left + len(x.vec_pos);
      assign(y(left to left+len(x.vec_ang)-1), vectorify(x.vec_ang, y(left to left+len(x.vec_ang)-1)));
      left := left + len(x.vec_ang);
      assign(y(left to left+len(x.hewindow_pos)-1), vectorify(x.hewindow_pos, y(left to left+len(x.hewindow_pos)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdtseg_dest)+1), vectorify(x.mdtseg_dest, y(left downto left-len(x.mdtseg_dest)+1)));
      left := left - len(x.mdtseg_dest);
      assign(y(left downto left-len(x.mdtid)+1), vectorify(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.vec_pos)+1), vectorify(x.vec_pos, y(left downto left-len(x.vec_pos)+1)));
      left := left - len(x.vec_pos);
      assign(y(left downto left-len(x.vec_ang)+1), vectorify(x.vec_ang, y(left downto left-len(x.vec_ang)+1)));
      left := left - len(x.vec_ang);
      assign(y(left downto left-len(x.hewindow_pos)+1), vectorify(x.hewindow_pos, y(left downto left-len(x.hewindow_pos)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: heg2sfslc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdtseg_dest)-1), convert(x.mdtseg_dest, y(left to left+len(x.mdtseg_dest)-1)));
      left := left + len(x.mdtseg_dest);
      assign(y(left to left+len(x.mdtid)-1), convert(x.mdtid, y(left to left+len(x.mdtid)-1)));
      left := left + len(x.mdtid);
      assign(y(left to left+len(x.vec_pos)-1), convert(x.vec_pos, y(left to left+len(x.vec_pos)-1)));
      left := left + len(x.vec_pos);
      assign(y(left to left+len(x.vec_ang)-1), convert(x.vec_ang, y(left to left+len(x.vec_ang)-1)));
      left := left + len(x.vec_ang);
      assign(y(left to left+len(x.hewindow_pos)-1), convert(x.hewindow_pos, y(left to left+len(x.hewindow_pos)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdtseg_dest)+1), convert(x.mdtseg_dest, y(left downto left-len(x.mdtseg_dest)+1)));
      left := left - len(x.mdtseg_dest);
      assign(y(left downto left-len(x.mdtid)+1), convert(x.mdtid, y(left downto left-len(x.mdtid)+1)));
      left := left - len(x.mdtid);
      assign(y(left downto left-len(x.vec_pos)+1), convert(x.vec_pos, y(left downto left-len(x.vec_pos)+1)));
      left := left - len(x.vec_pos);
      assign(y(left downto left-len(x.vec_ang)+1), convert(x.vec_ang, y(left downto left-len(x.vec_ang)+1)));
      left := left - len(x.vec_ang);
      assign(y(left downto left-len(x.hewindow_pos)+1), convert(x.hewindow_pos, y(left downto left-len(x.hewindow_pos)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: heg2sfslc_rt) return heg2sfslc_rt is
    variable y: heg2sfslc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdtseg_dest := structify(x(left to left+len(y.mdtseg_dest)-1), y.mdtseg_dest);
      left := left + len(y.mdtseg_dest);
      y.mdtid := structify(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.vec_pos := structify(x(left to left+len(y.vec_pos)-1), y.vec_pos);
      left := left + len(y.vec_pos);
      y.vec_ang := structify(x(left to left+len(y.vec_ang)-1), y.vec_ang);
      left := left + len(y.vec_ang);
      y.hewindow_pos := structify(x(left to left+len(y.hewindow_pos)-1), y.hewindow_pos);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdtseg_dest := structify(x(left downto left-len(y.mdtseg_dest)+1), y.mdtseg_dest);
      left := left - len(y.mdtseg_dest);
      y.mdtid := structify(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.vec_pos := structify(x(left downto left-len(y.vec_pos)+1), y.vec_pos);
      left := left - len(y.vec_pos);
      y.vec_ang := structify(x(left downto left-len(y.vec_ang)+1), y.vec_ang);
      left := left - len(y.vec_ang);
      y.hewindow_pos := structify(x(left downto left-len(y.hewindow_pos)+1), y.hewindow_pos);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: heg2sfslc_rt) return heg2sfslc_rt is
    variable y: heg2sfslc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdtseg_dest := convert(x(left to left+len(y.mdtseg_dest)-1), y.mdtseg_dest);
      left := left + len(y.mdtseg_dest);
      y.mdtid := convert(x(left to left+len(y.mdtid)-1), y.mdtid);
      left := left + len(y.mdtid);
      y.vec_pos := convert(x(left to left+len(y.vec_pos)-1), y.vec_pos);
      left := left + len(y.vec_pos);
      y.vec_ang := convert(x(left to left+len(y.vec_ang)-1), y.vec_ang);
      left := left + len(y.vec_ang);
      y.hewindow_pos := convert(x(left to left+len(y.hewindow_pos)-1), y.hewindow_pos);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdtseg_dest := convert(x(left downto left-len(y.mdtseg_dest)+1), y.mdtseg_dest);
      left := left - len(y.mdtseg_dest);
      y.mdtid := convert(x(left downto left-len(y.mdtid)+1), y.mdtid);
      left := left - len(y.mdtid);
      y.vec_pos := convert(x(left downto left-len(y.vec_pos)+1), y.vec_pos);
      left := left - len(y.vec_pos);
      y.vec_ang := convert(x(left downto left-len(y.vec_ang)+1), y.vec_ang);
      left := left - len(y.vec_ang);
      y.hewindow_pos := convert(x(left downto left-len(y.hewindow_pos)+1), y.hewindow_pos);
    end if;
    return y;
  end function convert;
  function nullify(t: heg2sfslc_rt) return heg2sfslc_rt is
  variable y: heg2sfslc_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.muid := nullify(t.muid);
    y.mdtseg_dest := nullify(t.mdtseg_dest);
    y.mdtid := nullify(t.mdtid);
    y.vec_pos := nullify(t.vec_pos);
    y.vec_ang := nullify(t.vec_ang);
    y.hewindow_pos := nullify(t.hewindow_pos);
    return y;
  end function nullify;
  function zeroed(t: heg2sfslc_rt) return heg2sfslc_rt is
  variable y: heg2sfslc_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.muid := zeroed(t.muid);
    y.mdtseg_dest := zeroed(t.mdtseg_dest);
    y.mdtid := zeroed(t.mdtid);
    y.vec_pos := zeroed(t.vec_pos);
    y.vec_ang := zeroed(t.vec_ang);
    y.hewindow_pos := zeroed(t.hewindow_pos);
    return y;
  end function zeroed;

  function len(x: tar2hps_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.chamber_ieta);
    l := l + len(x.layer);
    l := l + len(x.tube);
    l := l + len(x.time);
    return l;
  end function len;
  function width(x: tar2hps_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.chamber_ieta);
    l := l + width(x.layer);
    l := l + width(x.tube);
    l := l + width(x.time);
    return l;
  end function width;
  function vectorify(x: tar2hps_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.chamber_ieta)-1), vectorify(x.chamber_ieta, y(left to left+len(x.chamber_ieta)-1)));
      left := left + len(x.chamber_ieta);
      assign(y(left to left+len(x.layer)-1), vectorify(x.layer, y(left to left+len(x.layer)-1)));
      left := left + len(x.layer);
      assign(y(left to left+len(x.tube)-1), vectorify(x.tube, y(left to left+len(x.tube)-1)));
      left := left + len(x.tube);
      assign(y(left to left+len(x.time)-1), vectorify(x.time, y(left to left+len(x.time)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.chamber_ieta)+1), vectorify(x.chamber_ieta, y(left downto left-len(x.chamber_ieta)+1)));
      left := left - len(x.chamber_ieta);
      assign(y(left downto left-len(x.layer)+1), vectorify(x.layer, y(left downto left-len(x.layer)+1)));
      left := left - len(x.layer);
      assign(y(left downto left-len(x.tube)+1), vectorify(x.tube, y(left downto left-len(x.tube)+1)));
      left := left - len(x.tube);
      assign(y(left downto left-len(x.time)+1), vectorify(x.time, y(left downto left-len(x.time)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: tar2hps_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.chamber_ieta)-1), convert(x.chamber_ieta, y(left to left+len(x.chamber_ieta)-1)));
      left := left + len(x.chamber_ieta);
      assign(y(left to left+len(x.layer)-1), convert(x.layer, y(left to left+len(x.layer)-1)));
      left := left + len(x.layer);
      assign(y(left to left+len(x.tube)-1), convert(x.tube, y(left to left+len(x.tube)-1)));
      left := left + len(x.tube);
      assign(y(left to left+len(x.time)-1), convert(x.time, y(left to left+len(x.time)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.chamber_ieta)+1), convert(x.chamber_ieta, y(left downto left-len(x.chamber_ieta)+1)));
      left := left - len(x.chamber_ieta);
      assign(y(left downto left-len(x.layer)+1), convert(x.layer, y(left downto left-len(x.layer)+1)));
      left := left - len(x.layer);
      assign(y(left downto left-len(x.tube)+1), convert(x.tube, y(left downto left-len(x.tube)+1)));
      left := left - len(x.tube);
      assign(y(left downto left-len(x.time)+1), convert(x.time, y(left downto left-len(x.time)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: tar2hps_rt) return tar2hps_rt is
    variable y: tar2hps_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.chamber_ieta := structify(x(left to left+len(y.chamber_ieta)-1), y.chamber_ieta);
      left := left + len(y.chamber_ieta);
      y.layer := structify(x(left to left+len(y.layer)-1), y.layer);
      left := left + len(y.layer);
      y.tube := structify(x(left to left+len(y.tube)-1), y.tube);
      left := left + len(y.tube);
      y.time := structify(x(left to left+len(y.time)-1), y.time);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.chamber_ieta := structify(x(left downto left-len(y.chamber_ieta)+1), y.chamber_ieta);
      left := left - len(y.chamber_ieta);
      y.layer := structify(x(left downto left-len(y.layer)+1), y.layer);
      left := left - len(y.layer);
      y.tube := structify(x(left downto left-len(y.tube)+1), y.tube);
      left := left - len(y.tube);
      y.time := structify(x(left downto left-len(y.time)+1), y.time);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: tar2hps_rt) return tar2hps_rt is
    variable y: tar2hps_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.chamber_ieta := convert(x(left to left+len(y.chamber_ieta)-1), y.chamber_ieta);
      left := left + len(y.chamber_ieta);
      y.layer := convert(x(left to left+len(y.layer)-1), y.layer);
      left := left + len(y.layer);
      y.tube := convert(x(left to left+len(y.tube)-1), y.tube);
      left := left + len(y.tube);
      y.time := convert(x(left to left+len(y.time)-1), y.time);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.chamber_ieta := convert(x(left downto left-len(y.chamber_ieta)+1), y.chamber_ieta);
      left := left - len(y.chamber_ieta);
      y.layer := convert(x(left downto left-len(y.layer)+1), y.layer);
      left := left - len(y.layer);
      y.tube := convert(x(left downto left-len(y.tube)+1), y.tube);
      left := left - len(y.tube);
      y.time := convert(x(left downto left-len(y.time)+1), y.time);
    end if;
    return y;
  end function convert;
  function nullify(t: tar2hps_rt) return tar2hps_rt is
  variable y: tar2hps_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.chamber_ieta := nullify(t.chamber_ieta);
    y.layer := nullify(t.layer);
    y.tube := nullify(t.tube);
    y.time := nullify(t.time);
    return y;
  end function nullify;
  function zeroed(t: tar2hps_rt) return tar2hps_rt is
  variable y: tar2hps_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.chamber_ieta := zeroed(t.chamber_ieta);
    y.layer := zeroed(t.layer);
    y.tube := zeroed(t.tube);
    y.time := zeroed(t.time);
    return y;
  end function zeroed;

  function len(x: heg2sfhit_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.mlayer);
    l := l + len(x.localx);
    l := l + len(x.localy);
    l := l + len(x.radius);
    return l;
  end function len;
  function width(x: heg2sfhit_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.mlayer);
    l := l + width(x.localx);
    l := l + width(x.localy);
    l := l + width(x.radius);
    return l;
  end function width;
  function vectorify(x: heg2sfhit_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.mlayer)-1), vectorify(x.mlayer, y(left to left+len(x.mlayer)-1)));
      left := left + len(x.mlayer);
      assign(y(left to left+len(x.localx)-1), vectorify(x.localx, y(left to left+len(x.localx)-1)));
      left := left + len(x.localx);
      assign(y(left to left+len(x.localy)-1), vectorify(x.localy, y(left to left+len(x.localy)-1)));
      left := left + len(x.localy);
      assign(y(left to left+len(x.radius)-1), vectorify(x.radius, y(left to left+len(x.radius)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.mlayer)+1), vectorify(x.mlayer, y(left downto left-len(x.mlayer)+1)));
      left := left - len(x.mlayer);
      assign(y(left downto left-len(x.localx)+1), vectorify(x.localx, y(left downto left-len(x.localx)+1)));
      left := left - len(x.localx);
      assign(y(left downto left-len(x.localy)+1), vectorify(x.localy, y(left downto left-len(x.localy)+1)));
      left := left - len(x.localy);
      assign(y(left downto left-len(x.radius)+1), vectorify(x.radius, y(left downto left-len(x.radius)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: heg2sfhit_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.mlayer)-1), convert(x.mlayer, y(left to left+len(x.mlayer)-1)));
      left := left + len(x.mlayer);
      assign(y(left to left+len(x.localx)-1), convert(x.localx, y(left to left+len(x.localx)-1)));
      left := left + len(x.localx);
      assign(y(left to left+len(x.localy)-1), convert(x.localy, y(left to left+len(x.localy)-1)));
      left := left + len(x.localy);
      assign(y(left to left+len(x.radius)-1), convert(x.radius, y(left to left+len(x.radius)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.mlayer)+1), convert(x.mlayer, y(left downto left-len(x.mlayer)+1)));
      left := left - len(x.mlayer);
      assign(y(left downto left-len(x.localx)+1), convert(x.localx, y(left downto left-len(x.localx)+1)));
      left := left - len(x.localx);
      assign(y(left downto left-len(x.localy)+1), convert(x.localy, y(left downto left-len(x.localy)+1)));
      left := left - len(x.localy);
      assign(y(left downto left-len(x.radius)+1), convert(x.radius, y(left downto left-len(x.radius)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: heg2sfhit_rt) return heg2sfhit_rt is
    variable y: heg2sfhit_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.mlayer := structify(x(left to left+len(y.mlayer)-1), y.mlayer);
      left := left + len(y.mlayer);
      y.localx := structify(x(left to left+len(y.localx)-1), y.localx);
      left := left + len(y.localx);
      y.localy := structify(x(left to left+len(y.localy)-1), y.localy);
      left := left + len(y.localy);
      y.radius := structify(x(left to left+len(y.radius)-1), y.radius);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.mlayer := structify(x(left downto left-len(y.mlayer)+1), y.mlayer);
      left := left - len(y.mlayer);
      y.localx := structify(x(left downto left-len(y.localx)+1), y.localx);
      left := left - len(y.localx);
      y.localy := structify(x(left downto left-len(y.localy)+1), y.localy);
      left := left - len(y.localy);
      y.radius := structify(x(left downto left-len(y.radius)+1), y.radius);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: heg2sfhit_rt) return heg2sfhit_rt is
    variable y: heg2sfhit_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.mlayer := convert(x(left to left+len(y.mlayer)-1), y.mlayer);
      left := left + len(y.mlayer);
      y.localx := convert(x(left to left+len(y.localx)-1), y.localx);
      left := left + len(y.localx);
      y.localy := convert(x(left to left+len(y.localy)-1), y.localy);
      left := left + len(y.localy);
      y.radius := convert(x(left to left+len(y.radius)-1), y.radius);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.mlayer := convert(x(left downto left-len(y.mlayer)+1), y.mlayer);
      left := left - len(y.mlayer);
      y.localx := convert(x(left downto left-len(y.localx)+1), y.localx);
      left := left - len(y.localx);
      y.localy := convert(x(left downto left-len(y.localy)+1), y.localy);
      left := left - len(y.localy);
      y.radius := convert(x(left downto left-len(y.radius)+1), y.radius);
    end if;
    return y;
  end function convert;
  function nullify(t: heg2sfhit_rt) return heg2sfhit_rt is
  variable y: heg2sfhit_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.mlayer := nullify(t.mlayer);
    y.localx := nullify(t.localx);
    y.localy := nullify(t.localy);
    y.radius := nullify(t.radius);
    return y;
  end function nullify;
  function zeroed(t: heg2sfhit_rt) return heg2sfhit_rt is
  variable y: heg2sfhit_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.mlayer := zeroed(t.mlayer);
    y.localx := zeroed(t.localx);
    y.localy := zeroed(t.localy);
    y.radius := zeroed(t.radius);
    return y;
  end function zeroed;

  function len(x: pl2ptcalc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.muid);
    l := l + len(x.phimod);
    l := l + len(x.sl_charge);
    l := l + len(x.nswseg_poseta);
    l := l + len(x.nswseg_posphi);
    l := l + len(x.nswseg_angdtheta);
    return l;
  end function len;
  function width(x: pl2ptcalc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.muid);
    l := l + width(x.phimod);
    l := l + width(x.sl_charge);
    l := l + width(x.nswseg_poseta);
    l := l + width(x.nswseg_posphi);
    l := l + width(x.nswseg_angdtheta);
    return l;
  end function width;
  function vectorify(x: pl2ptcalc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.phimod)-1), vectorify(x.phimod, y(left to left+len(x.phimod)-1)));
      left := left + len(x.phimod);
      assign(y(left to left+len(x.sl_charge)-1), vectorify(x.sl_charge, y(left to left+len(x.sl_charge)-1)));
      left := left + len(x.sl_charge);
      assign(y(left to left+len(x.nswseg_poseta)-1), vectorify(x.nswseg_poseta, y(left to left+len(x.nswseg_poseta)-1)));
      left := left + len(x.nswseg_poseta);
      assign(y(left to left+len(x.nswseg_posphi)-1), vectorify(x.nswseg_posphi, y(left to left+len(x.nswseg_posphi)-1)));
      left := left + len(x.nswseg_posphi);
      assign(y(left to left+len(x.nswseg_angdtheta)-1), vectorify(x.nswseg_angdtheta, y(left to left+len(x.nswseg_angdtheta)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.phimod)+1), vectorify(x.phimod, y(left downto left-len(x.phimod)+1)));
      left := left - len(x.phimod);
      assign(y(left downto left-len(x.sl_charge)+1), vectorify(x.sl_charge, y(left downto left-len(x.sl_charge)+1)));
      left := left - len(x.sl_charge);
      assign(y(left downto left-len(x.nswseg_poseta)+1), vectorify(x.nswseg_poseta, y(left downto left-len(x.nswseg_poseta)+1)));
      left := left - len(x.nswseg_poseta);
      assign(y(left downto left-len(x.nswseg_posphi)+1), vectorify(x.nswseg_posphi, y(left downto left-len(x.nswseg_posphi)+1)));
      left := left - len(x.nswseg_posphi);
      assign(y(left downto left-len(x.nswseg_angdtheta)+1), vectorify(x.nswseg_angdtheta, y(left downto left-len(x.nswseg_angdtheta)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: pl2ptcalc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.phimod)-1), convert(x.phimod, y(left to left+len(x.phimod)-1)));
      left := left + len(x.phimod);
      assign(y(left to left+len(x.sl_charge)-1), convert(x.sl_charge, y(left to left+len(x.sl_charge)-1)));
      left := left + len(x.sl_charge);
      assign(y(left to left+len(x.nswseg_poseta)-1), convert(x.nswseg_poseta, y(left to left+len(x.nswseg_poseta)-1)));
      left := left + len(x.nswseg_poseta);
      assign(y(left to left+len(x.nswseg_posphi)-1), convert(x.nswseg_posphi, y(left to left+len(x.nswseg_posphi)-1)));
      left := left + len(x.nswseg_posphi);
      assign(y(left to left+len(x.nswseg_angdtheta)-1), convert(x.nswseg_angdtheta, y(left to left+len(x.nswseg_angdtheta)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.phimod)+1), convert(x.phimod, y(left downto left-len(x.phimod)+1)));
      left := left - len(x.phimod);
      assign(y(left downto left-len(x.sl_charge)+1), convert(x.sl_charge, y(left downto left-len(x.sl_charge)+1)));
      left := left - len(x.sl_charge);
      assign(y(left downto left-len(x.nswseg_poseta)+1), convert(x.nswseg_poseta, y(left downto left-len(x.nswseg_poseta)+1)));
      left := left - len(x.nswseg_poseta);
      assign(y(left downto left-len(x.nswseg_posphi)+1), convert(x.nswseg_posphi, y(left downto left-len(x.nswseg_posphi)+1)));
      left := left - len(x.nswseg_posphi);
      assign(y(left downto left-len(x.nswseg_angdtheta)+1), convert(x.nswseg_angdtheta, y(left downto left-len(x.nswseg_angdtheta)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: pl2ptcalc_rt) return pl2ptcalc_rt is
    variable y: pl2ptcalc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.phimod := structify(x(left to left+len(y.phimod)-1), y.phimod);
      left := left + len(y.phimod);
      y.sl_charge := structify(x(left to left+len(y.sl_charge)-1), y.sl_charge);
      left := left + len(y.sl_charge);
      y.nswseg_poseta := structify(x(left to left+len(y.nswseg_poseta)-1), y.nswseg_poseta);
      left := left + len(y.nswseg_poseta);
      y.nswseg_posphi := structify(x(left to left+len(y.nswseg_posphi)-1), y.nswseg_posphi);
      left := left + len(y.nswseg_posphi);
      y.nswseg_angdtheta := structify(x(left to left+len(y.nswseg_angdtheta)-1), y.nswseg_angdtheta);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.phimod := structify(x(left downto left-len(y.phimod)+1), y.phimod);
      left := left - len(y.phimod);
      y.sl_charge := structify(x(left downto left-len(y.sl_charge)+1), y.sl_charge);
      left := left - len(y.sl_charge);
      y.nswseg_poseta := structify(x(left downto left-len(y.nswseg_poseta)+1), y.nswseg_poseta);
      left := left - len(y.nswseg_poseta);
      y.nswseg_posphi := structify(x(left downto left-len(y.nswseg_posphi)+1), y.nswseg_posphi);
      left := left - len(y.nswseg_posphi);
      y.nswseg_angdtheta := structify(x(left downto left-len(y.nswseg_angdtheta)+1), y.nswseg_angdtheta);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: pl2ptcalc_rt) return pl2ptcalc_rt is
    variable y: pl2ptcalc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.phimod := convert(x(left to left+len(y.phimod)-1), y.phimod);
      left := left + len(y.phimod);
      y.sl_charge := convert(x(left to left+len(y.sl_charge)-1), y.sl_charge);
      left := left + len(y.sl_charge);
      y.nswseg_poseta := convert(x(left to left+len(y.nswseg_poseta)-1), y.nswseg_poseta);
      left := left + len(y.nswseg_poseta);
      y.nswseg_posphi := convert(x(left to left+len(y.nswseg_posphi)-1), y.nswseg_posphi);
      left := left + len(y.nswseg_posphi);
      y.nswseg_angdtheta := convert(x(left to left+len(y.nswseg_angdtheta)-1), y.nswseg_angdtheta);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.phimod := convert(x(left downto left-len(y.phimod)+1), y.phimod);
      left := left - len(y.phimod);
      y.sl_charge := convert(x(left downto left-len(y.sl_charge)+1), y.sl_charge);
      left := left - len(y.sl_charge);
      y.nswseg_poseta := convert(x(left downto left-len(y.nswseg_poseta)+1), y.nswseg_poseta);
      left := left - len(y.nswseg_poseta);
      y.nswseg_posphi := convert(x(left downto left-len(y.nswseg_posphi)+1), y.nswseg_posphi);
      left := left - len(y.nswseg_posphi);
      y.nswseg_angdtheta := convert(x(left downto left-len(y.nswseg_angdtheta)+1), y.nswseg_angdtheta);
    end if;
    return y;
  end function convert;
  function nullify(t: pl2ptcalc_rt) return pl2ptcalc_rt is
  variable y: pl2ptcalc_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.muid := nullify(t.muid);
    y.phimod := nullify(t.phimod);
    y.sl_charge := nullify(t.sl_charge);
    y.nswseg_poseta := nullify(t.nswseg_poseta);
    y.nswseg_posphi := nullify(t.nswseg_posphi);
    y.nswseg_angdtheta := nullify(t.nswseg_angdtheta);
    return y;
  end function nullify;
  function zeroed(t: pl2ptcalc_rt) return pl2ptcalc_rt is
  variable y: pl2ptcalc_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.muid := zeroed(t.muid);
    y.phimod := zeroed(t.phimod);
    y.sl_charge := zeroed(t.sl_charge);
    y.nswseg_poseta := zeroed(t.nswseg_poseta);
    y.nswseg_posphi := zeroed(t.nswseg_posphi);
    y.nswseg_angdtheta := zeroed(t.nswseg_angdtheta);
    return y;
  end function zeroed;

  function len(x: sf2ptcalc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.muid);
    l := l + len(x.segpos);
    l := l + len(x.segangle);
    l := l + len(x.segquality);
    l := l + len(x.mdtid);
    return l;
  end function len;
  function width(x: sf2ptcalc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.muid);
    l := l + width(x.segpos);
    l := l + width(x.segangle);
    l := l + width(x.segquality);
    l := l + width(x.mdtid);
    return l;
  end function width;
  function vectorify(x: sf2ptcalc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.segpos)-1), vectorify(x.segpos, y(left to left+len(x.segpos)-1)));
      left := left + len(x.segpos);
      assign(y(left to left+len(x.segangle)-1), vectorify(x.segangle, y(left to left+len(x.segangle)-1)));
      left := left + len(x.segangle);
      assign(y(left to left+len(x.segquality)-1), vectorify(x.segquality, y(left to left+len(x.segquality)-1)));
      left := left + len(x.segquality);
      assign(y(left to left+len(x.mdtid)-1), vectorify(x.mdtid, y(left to left+len(x.mdtid)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.segpos)+1), vectorify(x.segpos, y(left downto left-len(x.segpos)+1)));
      left := left - len(x.segpos);
      assign(y(left downto left-len(x.segangle)+1), vectorify(x.segangle, y(left downto left-len(x.segangle)+1)));
      left := left - len(x.segangle);
      assign(y(left downto left-len(x.segquality)+1), vectorify(x.segquality, y(left downto left-len(x.segquality)+1)));
      left := left - len(x.segquality);
      assign(y(left downto left-len(x.mdtid)+1), vectorify(x.mdtid, y(left downto left-len(x.mdtid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: sf2ptcalc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.segpos)-1), convert(x.segpos, y(left to left+len(x.segpos)-1)));
      left := left + len(x.segpos);
      assign(y(left to left+len(x.segangle)-1), convert(x.segangle, y(left to left+len(x.segangle)-1)));
      left := left + len(x.segangle);
      assign(y(left to left+len(x.segquality)-1), convert(x.segquality, y(left to left+len(x.segquality)-1)));
      left := left + len(x.segquality);
      assign(y(left to left+len(x.mdtid)-1), convert(x.mdtid, y(left to left+len(x.mdtid)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.segpos)+1), convert(x.segpos, y(left downto left-len(x.segpos)+1)));
      left := left - len(x.segpos);
      assign(y(left downto left-len(x.segangle)+1), convert(x.segangle, y(left downto left-len(x.segangle)+1)));
      left := left - len(x.segangle);
      assign(y(left downto left-len(x.segquality)+1), convert(x.segquality, y(left downto left-len(x.segquality)+1)));
      left := left - len(x.segquality);
      assign(y(left downto left-len(x.mdtid)+1), convert(x.mdtid, y(left downto left-len(x.mdtid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: sf2ptcalc_rt) return sf2ptcalc_rt is
    variable y: sf2ptcalc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.segpos := structify(x(left to left+len(y.segpos)-1), y.segpos);
      left := left + len(y.segpos);
      y.segangle := structify(x(left to left+len(y.segangle)-1), y.segangle);
      left := left + len(y.segangle);
      y.segquality := structify(x(left to left+len(y.segquality)-1), y.segquality);
      left := left + len(y.segquality);
      y.mdtid := structify(x(left to left+len(y.mdtid)-1), y.mdtid);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.segpos := structify(x(left downto left-len(y.segpos)+1), y.segpos);
      left := left - len(y.segpos);
      y.segangle := structify(x(left downto left-len(y.segangle)+1), y.segangle);
      left := left - len(y.segangle);
      y.segquality := structify(x(left downto left-len(y.segquality)+1), y.segquality);
      left := left - len(y.segquality);
      y.mdtid := structify(x(left downto left-len(y.mdtid)+1), y.mdtid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: sf2ptcalc_rt) return sf2ptcalc_rt is
    variable y: sf2ptcalc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.segpos := convert(x(left to left+len(y.segpos)-1), y.segpos);
      left := left + len(y.segpos);
      y.segangle := convert(x(left to left+len(y.segangle)-1), y.segangle);
      left := left + len(y.segangle);
      y.segquality := convert(x(left to left+len(y.segquality)-1), y.segquality);
      left := left + len(y.segquality);
      y.mdtid := convert(x(left to left+len(y.mdtid)-1), y.mdtid);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.segpos := convert(x(left downto left-len(y.segpos)+1), y.segpos);
      left := left - len(y.segpos);
      y.segangle := convert(x(left downto left-len(y.segangle)+1), y.segangle);
      left := left - len(y.segangle);
      y.segquality := convert(x(left downto left-len(y.segquality)+1), y.segquality);
      left := left - len(y.segquality);
      y.mdtid := convert(x(left downto left-len(y.mdtid)+1), y.mdtid);
    end if;
    return y;
  end function convert;
  function nullify(t: sf2ptcalc_rt) return sf2ptcalc_rt is
  variable y: sf2ptcalc_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.muid := nullify(t.muid);
    y.segpos := nullify(t.segpos);
    y.segangle := nullify(t.segangle);
    y.segquality := nullify(t.segquality);
    y.mdtid := nullify(t.mdtid);
    return y;
  end function nullify;
  function zeroed(t: sf2ptcalc_rt) return sf2ptcalc_rt is
  variable y: sf2ptcalc_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.muid := zeroed(t.muid);
    y.segpos := zeroed(t.segpos);
    y.segangle := zeroed(t.segangle);
    y.segquality := zeroed(t.segquality);
    y.mdtid := zeroed(t.mdtid);
    return y;
  end function zeroed;

  function len(x: ptcalc2mtc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.muid);
    l := l + len(x.mdt_eta);
    l := l + len(x.mdt_pt);
    l := l + len(x.mdt_ptthresh);
    l := l + len(x.mdt_charge);
    l := l + len(x.mdt_nsegments);
    l := l + len(x.mdt_quality);
    return l;
  end function len;
  function width(x: ptcalc2mtc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.muid);
    l := l + width(x.mdt_eta);
    l := l + width(x.mdt_pt);
    l := l + width(x.mdt_ptthresh);
    l := l + width(x.mdt_charge);
    l := l + width(x.mdt_nsegments);
    l := l + width(x.mdt_quality);
    return l;
  end function width;
  function vectorify(x: ptcalc2mtc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), vectorify(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdt_eta)-1), vectorify(x.mdt_eta, y(left to left+len(x.mdt_eta)-1)));
      left := left + len(x.mdt_eta);
      assign(y(left to left+len(x.mdt_pt)-1), vectorify(x.mdt_pt, y(left to left+len(x.mdt_pt)-1)));
      left := left + len(x.mdt_pt);
      assign(y(left to left+len(x.mdt_ptthresh)-1), vectorify(x.mdt_ptthresh, y(left to left+len(x.mdt_ptthresh)-1)));
      left := left + len(x.mdt_ptthresh);
      assign(y(left to left+len(x.mdt_charge)-1), vectorify(x.mdt_charge, y(left to left+len(x.mdt_charge)-1)));
      left := left + len(x.mdt_charge);
      assign(y(left to left+len(x.mdt_nsegments)-1), vectorify(x.mdt_nsegments, y(left to left+len(x.mdt_nsegments)-1)));
      left := left + len(x.mdt_nsegments);
      assign(y(left to left+len(x.mdt_quality)-1), vectorify(x.mdt_quality, y(left to left+len(x.mdt_quality)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), vectorify(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdt_eta)+1), vectorify(x.mdt_eta, y(left downto left-len(x.mdt_eta)+1)));
      left := left - len(x.mdt_eta);
      assign(y(left downto left-len(x.mdt_pt)+1), vectorify(x.mdt_pt, y(left downto left-len(x.mdt_pt)+1)));
      left := left - len(x.mdt_pt);
      assign(y(left downto left-len(x.mdt_ptthresh)+1), vectorify(x.mdt_ptthresh, y(left downto left-len(x.mdt_ptthresh)+1)));
      left := left - len(x.mdt_ptthresh);
      assign(y(left downto left-len(x.mdt_charge)+1), vectorify(x.mdt_charge, y(left downto left-len(x.mdt_charge)+1)));
      left := left - len(x.mdt_charge);
      assign(y(left downto left-len(x.mdt_nsegments)+1), vectorify(x.mdt_nsegments, y(left downto left-len(x.mdt_nsegments)+1)));
      left := left - len(x.mdt_nsegments);
      assign(y(left downto left-len(x.mdt_quality)+1), vectorify(x.mdt_quality, y(left downto left-len(x.mdt_quality)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ptcalc2mtc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.muid)-1), convert(x.muid, y(left to left+len(x.muid)-1)));
      left := left + len(x.muid);
      assign(y(left to left+len(x.mdt_eta)-1), convert(x.mdt_eta, y(left to left+len(x.mdt_eta)-1)));
      left := left + len(x.mdt_eta);
      assign(y(left to left+len(x.mdt_pt)-1), convert(x.mdt_pt, y(left to left+len(x.mdt_pt)-1)));
      left := left + len(x.mdt_pt);
      assign(y(left to left+len(x.mdt_ptthresh)-1), convert(x.mdt_ptthresh, y(left to left+len(x.mdt_ptthresh)-1)));
      left := left + len(x.mdt_ptthresh);
      assign(y(left to left+len(x.mdt_charge)-1), convert(x.mdt_charge, y(left to left+len(x.mdt_charge)-1)));
      left := left + len(x.mdt_charge);
      assign(y(left to left+len(x.mdt_nsegments)-1), convert(x.mdt_nsegments, y(left to left+len(x.mdt_nsegments)-1)));
      left := left + len(x.mdt_nsegments);
      assign(y(left to left+len(x.mdt_quality)-1), convert(x.mdt_quality, y(left to left+len(x.mdt_quality)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.muid)+1), convert(x.muid, y(left downto left-len(x.muid)+1)));
      left := left - len(x.muid);
      assign(y(left downto left-len(x.mdt_eta)+1), convert(x.mdt_eta, y(left downto left-len(x.mdt_eta)+1)));
      left := left - len(x.mdt_eta);
      assign(y(left downto left-len(x.mdt_pt)+1), convert(x.mdt_pt, y(left downto left-len(x.mdt_pt)+1)));
      left := left - len(x.mdt_pt);
      assign(y(left downto left-len(x.mdt_ptthresh)+1), convert(x.mdt_ptthresh, y(left downto left-len(x.mdt_ptthresh)+1)));
      left := left - len(x.mdt_ptthresh);
      assign(y(left downto left-len(x.mdt_charge)+1), convert(x.mdt_charge, y(left downto left-len(x.mdt_charge)+1)));
      left := left - len(x.mdt_charge);
      assign(y(left downto left-len(x.mdt_nsegments)+1), convert(x.mdt_nsegments, y(left downto left-len(x.mdt_nsegments)+1)));
      left := left - len(x.mdt_nsegments);
      assign(y(left downto left-len(x.mdt_quality)+1), convert(x.mdt_quality, y(left downto left-len(x.mdt_quality)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ptcalc2mtc_rt) return ptcalc2mtc_rt is
    variable y: ptcalc2mtc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := structify(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdt_eta := structify(x(left to left+len(y.mdt_eta)-1), y.mdt_eta);
      left := left + len(y.mdt_eta);
      y.mdt_pt := structify(x(left to left+len(y.mdt_pt)-1), y.mdt_pt);
      left := left + len(y.mdt_pt);
      y.mdt_ptthresh := structify(x(left to left+len(y.mdt_ptthresh)-1), y.mdt_ptthresh);
      left := left + len(y.mdt_ptthresh);
      y.mdt_charge := structify(x(left to left+len(y.mdt_charge)-1), y.mdt_charge);
      left := left + len(y.mdt_charge);
      y.mdt_nsegments := structify(x(left to left+len(y.mdt_nsegments)-1), y.mdt_nsegments);
      left := left + len(y.mdt_nsegments);
      y.mdt_quality := structify(x(left to left+len(y.mdt_quality)-1), y.mdt_quality);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := structify(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdt_eta := structify(x(left downto left-len(y.mdt_eta)+1), y.mdt_eta);
      left := left - len(y.mdt_eta);
      y.mdt_pt := structify(x(left downto left-len(y.mdt_pt)+1), y.mdt_pt);
      left := left - len(y.mdt_pt);
      y.mdt_ptthresh := structify(x(left downto left-len(y.mdt_ptthresh)+1), y.mdt_ptthresh);
      left := left - len(y.mdt_ptthresh);
      y.mdt_charge := structify(x(left downto left-len(y.mdt_charge)+1), y.mdt_charge);
      left := left - len(y.mdt_charge);
      y.mdt_nsegments := structify(x(left downto left-len(y.mdt_nsegments)+1), y.mdt_nsegments);
      left := left - len(y.mdt_nsegments);
      y.mdt_quality := structify(x(left downto left-len(y.mdt_quality)+1), y.mdt_quality);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ptcalc2mtc_rt) return ptcalc2mtc_rt is
    variable y: ptcalc2mtc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.muid := convert(x(left to left+len(y.muid)-1), y.muid);
      left := left + len(y.muid);
      y.mdt_eta := convert(x(left to left+len(y.mdt_eta)-1), y.mdt_eta);
      left := left + len(y.mdt_eta);
      y.mdt_pt := convert(x(left to left+len(y.mdt_pt)-1), y.mdt_pt);
      left := left + len(y.mdt_pt);
      y.mdt_ptthresh := convert(x(left to left+len(y.mdt_ptthresh)-1), y.mdt_ptthresh);
      left := left + len(y.mdt_ptthresh);
      y.mdt_charge := convert(x(left to left+len(y.mdt_charge)-1), y.mdt_charge);
      left := left + len(y.mdt_charge);
      y.mdt_nsegments := convert(x(left to left+len(y.mdt_nsegments)-1), y.mdt_nsegments);
      left := left + len(y.mdt_nsegments);
      y.mdt_quality := convert(x(left to left+len(y.mdt_quality)-1), y.mdt_quality);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.muid := convert(x(left downto left-len(y.muid)+1), y.muid);
      left := left - len(y.muid);
      y.mdt_eta := convert(x(left downto left-len(y.mdt_eta)+1), y.mdt_eta);
      left := left - len(y.mdt_eta);
      y.mdt_pt := convert(x(left downto left-len(y.mdt_pt)+1), y.mdt_pt);
      left := left - len(y.mdt_pt);
      y.mdt_ptthresh := convert(x(left downto left-len(y.mdt_ptthresh)+1), y.mdt_ptthresh);
      left := left - len(y.mdt_ptthresh);
      y.mdt_charge := convert(x(left downto left-len(y.mdt_charge)+1), y.mdt_charge);
      left := left - len(y.mdt_charge);
      y.mdt_nsegments := convert(x(left downto left-len(y.mdt_nsegments)+1), y.mdt_nsegments);
      left := left - len(y.mdt_nsegments);
      y.mdt_quality := convert(x(left downto left-len(y.mdt_quality)+1), y.mdt_quality);
    end if;
    return y;
  end function convert;
  function nullify(t: ptcalc2mtc_rt) return ptcalc2mtc_rt is
  variable y: ptcalc2mtc_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.muid := nullify(t.muid);
    y.mdt_eta := nullify(t.mdt_eta);
    y.mdt_pt := nullify(t.mdt_pt);
    y.mdt_ptthresh := nullify(t.mdt_ptthresh);
    y.mdt_charge := nullify(t.mdt_charge);
    y.mdt_nsegments := nullify(t.mdt_nsegments);
    y.mdt_quality := nullify(t.mdt_quality);
    return y;
  end function nullify;
  function zeroed(t: ptcalc2mtc_rt) return ptcalc2mtc_rt is
  variable y: ptcalc2mtc_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.muid := zeroed(t.muid);
    y.mdt_eta := zeroed(t.mdt_eta);
    y.mdt_pt := zeroed(t.mdt_pt);
    y.mdt_ptthresh := zeroed(t.mdt_ptthresh);
    y.mdt_charge := zeroed(t.mdt_charge);
    y.mdt_nsegments := zeroed(t.mdt_nsegments);
    y.mdt_quality := zeroed(t.mdt_quality);
    return y;
  end function zeroed;

  function len(x: pl2mtc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.busy);
    l := l + len(x.process_ch);
    l := l + len(x.common);
    return l;
  end function len;
  function width(x: pl2mtc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.busy);
    l := l + width(x.process_ch);
    l := l + width(x.common);
    return l;
  end function width;
  function vectorify(x: pl2mtc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.busy)-1), vectorify(x.busy, y(left to left+len(x.busy)-1)));
      left := left + len(x.busy);
      assign(y(left to left+len(x.process_ch)-1), vectorify(x.process_ch, y(left to left+len(x.process_ch)-1)));
      left := left + len(x.process_ch);
      assign(y(left to left+len(x.common)-1), vectorify(x.common, y(left to left+len(x.common)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.busy)+1), vectorify(x.busy, y(left downto left-len(x.busy)+1)));
      left := left - len(x.busy);
      assign(y(left downto left-len(x.process_ch)+1), vectorify(x.process_ch, y(left downto left-len(x.process_ch)+1)));
      left := left - len(x.process_ch);
      assign(y(left downto left-len(x.common)+1), vectorify(x.common, y(left downto left-len(x.common)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: pl2mtc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.busy)-1), convert(x.busy, y(left to left+len(x.busy)-1)));
      left := left + len(x.busy);
      assign(y(left to left+len(x.process_ch)-1), convert(x.process_ch, y(left to left+len(x.process_ch)-1)));
      left := left + len(x.process_ch);
      assign(y(left to left+len(x.common)-1), convert(x.common, y(left to left+len(x.common)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.busy)+1), convert(x.busy, y(left downto left-len(x.busy)+1)));
      left := left - len(x.busy);
      assign(y(left downto left-len(x.process_ch)+1), convert(x.process_ch, y(left downto left-len(x.process_ch)+1)));
      left := left - len(x.process_ch);
      assign(y(left downto left-len(x.common)+1), convert(x.common, y(left downto left-len(x.common)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: pl2mtc_rt) return pl2mtc_rt is
    variable y: pl2mtc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.busy := structify(x(left to left+len(y.busy)-1), y.busy);
      left := left + len(y.busy);
      y.process_ch := structify(x(left to left+len(y.process_ch)-1), y.process_ch);
      left := left + len(y.process_ch);
      y.common := structify(x(left to left+len(y.common)-1), y.common);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.busy := structify(x(left downto left-len(y.busy)+1), y.busy);
      left := left - len(y.busy);
      y.process_ch := structify(x(left downto left-len(y.process_ch)+1), y.process_ch);
      left := left - len(y.process_ch);
      y.common := structify(x(left downto left-len(y.common)+1), y.common);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: pl2mtc_rt) return pl2mtc_rt is
    variable y: pl2mtc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.busy := convert(x(left to left+len(y.busy)-1), y.busy);
      left := left + len(y.busy);
      y.process_ch := convert(x(left to left+len(y.process_ch)-1), y.process_ch);
      left := left + len(y.process_ch);
      y.common := convert(x(left to left+len(y.common)-1), y.common);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.busy := convert(x(left downto left-len(y.busy)+1), y.busy);
      left := left - len(y.busy);
      y.process_ch := convert(x(left downto left-len(y.process_ch)+1), y.process_ch);
      left := left - len(y.process_ch);
      y.common := convert(x(left downto left-len(y.common)+1), y.common);
    end if;
    return y;
  end function convert;
  function nullify(t: pl2mtc_rt) return pl2mtc_rt is
  variable y: pl2mtc_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.busy := nullify(t.busy);
    y.process_ch := nullify(t.process_ch);
    y.common := nullify(t.common);
    return y;
  end function nullify;
  function zeroed(t: pl2mtc_rt) return pl2mtc_rt is
  variable y: pl2mtc_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.busy := zeroed(t.busy);
    y.process_ch := zeroed(t.process_ch);
    y.common := zeroed(t.common);
    return y;
  end function zeroed;

  function len(x: mtc2sl_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.common);
    l := l + len(x.mdt_eta);
    l := l + len(x.mdt_pt);
    l := l + len(x.mdt_ptthresh);
    l := l + len(x.mdt_charge);
    l := l + len(x.mdt_procflags);
    l := l + len(x.mdt_nsegments);
    l := l + len(x.mdt_quality);
    l := l + len(x.m_reserved);
    return l;
  end function len;
  function width(x: mtc2sl_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.common);
    l := l + width(x.mdt_eta);
    l := l + width(x.mdt_pt);
    l := l + width(x.mdt_ptthresh);
    l := l + width(x.mdt_charge);
    l := l + width(x.mdt_procflags);
    l := l + width(x.mdt_nsegments);
    l := l + width(x.mdt_quality);
    l := l + width(x.m_reserved);
    return l;
  end function width;
  function vectorify(x: mtc2sl_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.common)-1), vectorify(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.mdt_eta)-1), vectorify(x.mdt_eta, y(left to left+len(x.mdt_eta)-1)));
      left := left + len(x.mdt_eta);
      assign(y(left to left+len(x.mdt_pt)-1), vectorify(x.mdt_pt, y(left to left+len(x.mdt_pt)-1)));
      left := left + len(x.mdt_pt);
      assign(y(left to left+len(x.mdt_ptthresh)-1), vectorify(x.mdt_ptthresh, y(left to left+len(x.mdt_ptthresh)-1)));
      left := left + len(x.mdt_ptthresh);
      assign(y(left to left+len(x.mdt_charge)-1), vectorify(x.mdt_charge, y(left to left+len(x.mdt_charge)-1)));
      left := left + len(x.mdt_charge);
      assign(y(left to left+len(x.mdt_procflags)-1), vectorify(x.mdt_procflags, y(left to left+len(x.mdt_procflags)-1)));
      left := left + len(x.mdt_procflags);
      assign(y(left to left+len(x.mdt_nsegments)-1), vectorify(x.mdt_nsegments, y(left to left+len(x.mdt_nsegments)-1)));
      left := left + len(x.mdt_nsegments);
      assign(y(left to left+len(x.mdt_quality)-1), vectorify(x.mdt_quality, y(left to left+len(x.mdt_quality)-1)));
      left := left + len(x.mdt_quality);
      assign(y(left to left+len(x.m_reserved)-1), vectorify(x.m_reserved, y(left to left+len(x.m_reserved)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.common)+1), vectorify(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.mdt_eta)+1), vectorify(x.mdt_eta, y(left downto left-len(x.mdt_eta)+1)));
      left := left - len(x.mdt_eta);
      assign(y(left downto left-len(x.mdt_pt)+1), vectorify(x.mdt_pt, y(left downto left-len(x.mdt_pt)+1)));
      left := left - len(x.mdt_pt);
      assign(y(left downto left-len(x.mdt_ptthresh)+1), vectorify(x.mdt_ptthresh, y(left downto left-len(x.mdt_ptthresh)+1)));
      left := left - len(x.mdt_ptthresh);
      assign(y(left downto left-len(x.mdt_charge)+1), vectorify(x.mdt_charge, y(left downto left-len(x.mdt_charge)+1)));
      left := left - len(x.mdt_charge);
      assign(y(left downto left-len(x.mdt_procflags)+1), vectorify(x.mdt_procflags, y(left downto left-len(x.mdt_procflags)+1)));
      left := left - len(x.mdt_procflags);
      assign(y(left downto left-len(x.mdt_nsegments)+1), vectorify(x.mdt_nsegments, y(left downto left-len(x.mdt_nsegments)+1)));
      left := left - len(x.mdt_nsegments);
      assign(y(left downto left-len(x.mdt_quality)+1), vectorify(x.mdt_quality, y(left downto left-len(x.mdt_quality)+1)));
      left := left - len(x.mdt_quality);
      assign(y(left downto left-len(x.m_reserved)+1), vectorify(x.m_reserved, y(left downto left-len(x.m_reserved)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: mtc2sl_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.common)-1), convert(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.mdt_eta)-1), convert(x.mdt_eta, y(left to left+len(x.mdt_eta)-1)));
      left := left + len(x.mdt_eta);
      assign(y(left to left+len(x.mdt_pt)-1), convert(x.mdt_pt, y(left to left+len(x.mdt_pt)-1)));
      left := left + len(x.mdt_pt);
      assign(y(left to left+len(x.mdt_ptthresh)-1), convert(x.mdt_ptthresh, y(left to left+len(x.mdt_ptthresh)-1)));
      left := left + len(x.mdt_ptthresh);
      assign(y(left to left+len(x.mdt_charge)-1), convert(x.mdt_charge, y(left to left+len(x.mdt_charge)-1)));
      left := left + len(x.mdt_charge);
      assign(y(left to left+len(x.mdt_procflags)-1), convert(x.mdt_procflags, y(left to left+len(x.mdt_procflags)-1)));
      left := left + len(x.mdt_procflags);
      assign(y(left to left+len(x.mdt_nsegments)-1), convert(x.mdt_nsegments, y(left to left+len(x.mdt_nsegments)-1)));
      left := left + len(x.mdt_nsegments);
      assign(y(left to left+len(x.mdt_quality)-1), convert(x.mdt_quality, y(left to left+len(x.mdt_quality)-1)));
      left := left + len(x.mdt_quality);
      assign(y(left to left+len(x.m_reserved)-1), convert(x.m_reserved, y(left to left+len(x.m_reserved)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.common)+1), convert(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.mdt_eta)+1), convert(x.mdt_eta, y(left downto left-len(x.mdt_eta)+1)));
      left := left - len(x.mdt_eta);
      assign(y(left downto left-len(x.mdt_pt)+1), convert(x.mdt_pt, y(left downto left-len(x.mdt_pt)+1)));
      left := left - len(x.mdt_pt);
      assign(y(left downto left-len(x.mdt_ptthresh)+1), convert(x.mdt_ptthresh, y(left downto left-len(x.mdt_ptthresh)+1)));
      left := left - len(x.mdt_ptthresh);
      assign(y(left downto left-len(x.mdt_charge)+1), convert(x.mdt_charge, y(left downto left-len(x.mdt_charge)+1)));
      left := left - len(x.mdt_charge);
      assign(y(left downto left-len(x.mdt_procflags)+1), convert(x.mdt_procflags, y(left downto left-len(x.mdt_procflags)+1)));
      left := left - len(x.mdt_procflags);
      assign(y(left downto left-len(x.mdt_nsegments)+1), convert(x.mdt_nsegments, y(left downto left-len(x.mdt_nsegments)+1)));
      left := left - len(x.mdt_nsegments);
      assign(y(left downto left-len(x.mdt_quality)+1), convert(x.mdt_quality, y(left downto left-len(x.mdt_quality)+1)));
      left := left - len(x.mdt_quality);
      assign(y(left downto left-len(x.m_reserved)+1), convert(x.m_reserved, y(left downto left-len(x.m_reserved)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: mtc2sl_rt) return mtc2sl_rt is
    variable y: mtc2sl_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.common := structify(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.mdt_eta := structify(x(left to left+len(y.mdt_eta)-1), y.mdt_eta);
      left := left + len(y.mdt_eta);
      y.mdt_pt := structify(x(left to left+len(y.mdt_pt)-1), y.mdt_pt);
      left := left + len(y.mdt_pt);
      y.mdt_ptthresh := structify(x(left to left+len(y.mdt_ptthresh)-1), y.mdt_ptthresh);
      left := left + len(y.mdt_ptthresh);
      y.mdt_charge := structify(x(left to left+len(y.mdt_charge)-1), y.mdt_charge);
      left := left + len(y.mdt_charge);
      y.mdt_procflags := structify(x(left to left+len(y.mdt_procflags)-1), y.mdt_procflags);
      left := left + len(y.mdt_procflags);
      y.mdt_nsegments := structify(x(left to left+len(y.mdt_nsegments)-1), y.mdt_nsegments);
      left := left + len(y.mdt_nsegments);
      y.mdt_quality := structify(x(left to left+len(y.mdt_quality)-1), y.mdt_quality);
      left := left + len(y.mdt_quality);
      y.m_reserved := structify(x(left to left+len(y.m_reserved)-1), y.m_reserved);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.common := structify(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.mdt_eta := structify(x(left downto left-len(y.mdt_eta)+1), y.mdt_eta);
      left := left - len(y.mdt_eta);
      y.mdt_pt := structify(x(left downto left-len(y.mdt_pt)+1), y.mdt_pt);
      left := left - len(y.mdt_pt);
      y.mdt_ptthresh := structify(x(left downto left-len(y.mdt_ptthresh)+1), y.mdt_ptthresh);
      left := left - len(y.mdt_ptthresh);
      y.mdt_charge := structify(x(left downto left-len(y.mdt_charge)+1), y.mdt_charge);
      left := left - len(y.mdt_charge);
      y.mdt_procflags := structify(x(left downto left-len(y.mdt_procflags)+1), y.mdt_procflags);
      left := left - len(y.mdt_procflags);
      y.mdt_nsegments := structify(x(left downto left-len(y.mdt_nsegments)+1), y.mdt_nsegments);
      left := left - len(y.mdt_nsegments);
      y.mdt_quality := structify(x(left downto left-len(y.mdt_quality)+1), y.mdt_quality);
      left := left - len(y.mdt_quality);
      y.m_reserved := structify(x(left downto left-len(y.m_reserved)+1), y.m_reserved);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: mtc2sl_rt) return mtc2sl_rt is
    variable y: mtc2sl_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.common := convert(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.mdt_eta := convert(x(left to left+len(y.mdt_eta)-1), y.mdt_eta);
      left := left + len(y.mdt_eta);
      y.mdt_pt := convert(x(left to left+len(y.mdt_pt)-1), y.mdt_pt);
      left := left + len(y.mdt_pt);
      y.mdt_ptthresh := convert(x(left to left+len(y.mdt_ptthresh)-1), y.mdt_ptthresh);
      left := left + len(y.mdt_ptthresh);
      y.mdt_charge := convert(x(left to left+len(y.mdt_charge)-1), y.mdt_charge);
      left := left + len(y.mdt_charge);
      y.mdt_procflags := convert(x(left to left+len(y.mdt_procflags)-1), y.mdt_procflags);
      left := left + len(y.mdt_procflags);
      y.mdt_nsegments := convert(x(left to left+len(y.mdt_nsegments)-1), y.mdt_nsegments);
      left := left + len(y.mdt_nsegments);
      y.mdt_quality := convert(x(left to left+len(y.mdt_quality)-1), y.mdt_quality);
      left := left + len(y.mdt_quality);
      y.m_reserved := convert(x(left to left+len(y.m_reserved)-1), y.m_reserved);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.common := convert(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.mdt_eta := convert(x(left downto left-len(y.mdt_eta)+1), y.mdt_eta);
      left := left - len(y.mdt_eta);
      y.mdt_pt := convert(x(left downto left-len(y.mdt_pt)+1), y.mdt_pt);
      left := left - len(y.mdt_pt);
      y.mdt_ptthresh := convert(x(left downto left-len(y.mdt_ptthresh)+1), y.mdt_ptthresh);
      left := left - len(y.mdt_ptthresh);
      y.mdt_charge := convert(x(left downto left-len(y.mdt_charge)+1), y.mdt_charge);
      left := left - len(y.mdt_charge);
      y.mdt_procflags := convert(x(left downto left-len(y.mdt_procflags)+1), y.mdt_procflags);
      left := left - len(y.mdt_procflags);
      y.mdt_nsegments := convert(x(left downto left-len(y.mdt_nsegments)+1), y.mdt_nsegments);
      left := left - len(y.mdt_nsegments);
      y.mdt_quality := convert(x(left downto left-len(y.mdt_quality)+1), y.mdt_quality);
      left := left - len(y.mdt_quality);
      y.m_reserved := convert(x(left downto left-len(y.m_reserved)+1), y.m_reserved);
    end if;
    return y;
  end function convert;
  function nullify(t: mtc2sl_rt) return mtc2sl_rt is
  variable y: mtc2sl_rt;
  begin
    y.data_valid := nullify(t.data_valid);
    y.common := nullify(t.common);
    y.mdt_eta := nullify(t.mdt_eta);
    y.mdt_pt := nullify(t.mdt_pt);
    y.mdt_ptthresh := nullify(t.mdt_ptthresh);
    y.mdt_charge := nullify(t.mdt_charge);
    y.mdt_procflags := nullify(t.mdt_procflags);
    y.mdt_nsegments := nullify(t.mdt_nsegments);
    y.mdt_quality := nullify(t.mdt_quality);
    y.m_reserved := nullify(t.m_reserved);
    return y;
  end function nullify;
  function zeroed(t: mtc2sl_rt) return mtc2sl_rt is
  variable y: mtc2sl_rt;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.common := zeroed(t.common);
    y.mdt_eta := zeroed(t.mdt_eta);
    y.mdt_pt := zeroed(t.mdt_pt);
    y.mdt_ptthresh := zeroed(t.mdt_ptthresh);
    y.mdt_charge := zeroed(t.mdt_charge);
    y.mdt_procflags := zeroed(t.mdt_procflags);
    y.mdt_nsegments := zeroed(t.mdt_nsegments);
    y.mdt_quality := zeroed(t.mdt_quality);
    y.m_reserved := zeroed(t.m_reserved);
    return y;
  end function zeroed;

end package body l0mdt_dataformats_pkg;
