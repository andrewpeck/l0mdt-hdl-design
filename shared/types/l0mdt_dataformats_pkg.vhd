-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl
-- 2022-03-22 21:18:22

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;

package l0mdt_dataformats_pkg is

   -- Custom types and functions --

   type sl_header_rt is record
      h_reserved : std_logic_vector(SL_HEADER_H_RESERVED_LEN-1 downto 0);
      tcoverflow : std_logic;
      nmtc_sl : unsigned(SL_HEADER_NMTC_SL_LEN-1 downto 0);
      nmtc_mdt : unsigned(SL_HEADER_NMTC_MDT_LEN-1 downto 0);
      nslc : unsigned(SL_HEADER_NSLC_LEN-1 downto 0);
      bcid : unsigned(SL_HEADER_BCID_LEN-1 downto 0);
   end record sl_header_rt;
   attribute w of sl_header_rt : type is 32;
   function width(x: sl_header_rt) return natural;
   function convert(x: sl_header_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: sl_header_rt) return sl_header_rt;
   function zero(tpl: sl_header_rt) return sl_header_rt;

   type sl_trailer_rt is record
      t_reserved : std_logic_vector(SL_TRAILER_T_RESERVED_LEN-1 downto 0);
      crc : std_logic_vector(SL_TRAILER_CRC_LEN-1 downto 0);
      fiberid : unsigned(SL_TRAILER_FIBERID_LEN-1 downto 0);
      slid : unsigned(SL_TRAILER_SLID_LEN-1 downto 0);
      comma : std_logic_vector(SL_TRAILER_COMMA_LEN-1 downto 0);
   end record sl_trailer_rt;
   attribute w of sl_trailer_rt : type is 32;
   function width(x: sl_trailer_rt) return natural;
   function convert(x: sl_trailer_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: sl_trailer_rt) return sl_trailer_rt;
   function zero(tpl: sl_trailer_rt) return sl_trailer_rt;

   type slc_common_rt is record
      header : sl_header_rt;
      slcid : unsigned(SLC_COMMON_SLCID_LEN-1 downto 0);
      tcsent : std_logic;
      poseta : signed(SLC_COMMON_POSETA_LEN-1 downto 0);
      posphi : unsigned(SLC_COMMON_POSPHI_LEN-1 downto 0);
      sl_pt : unsigned(SLC_COMMON_SL_PT_LEN-1 downto 0);
      sl_ptthresh : unsigned(SLC_COMMON_SL_PTTHRESH_LEN-1 downto 0);
      sl_charge : std_logic;
      cointype : std_logic_vector(SLC_COMMON_COINTYPE_LEN-1 downto 0);
      trailer : sl_trailer_rt;
   end record slc_common_rt;
   attribute w of slc_common_rt : type is 107;
   function width(x: slc_common_rt) return natural;
   function convert(x: slc_common_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_common_rt) return slc_common_rt;
   function zero(tpl: slc_common_rt) return slc_common_rt;

   type slc_endcap_rt is record
      e_reserved : std_logic_vector(SLC_ENDCAP_E_RESERVED_LEN-1 downto 0);
      nswseg_mon : std_logic;
      nswseg_angdtheta : signed(SLC_ENDCAP_NSWSEG_ANGDTHETA_LEN-1 downto 0);
      nswseg_posphi : unsigned(SLC_ENDCAP_NSWSEG_POSPHI_LEN-1 downto 0);
      nswseg_poseta : unsigned(SLC_ENDCAP_NSWSEG_POSETA_LEN-1 downto 0);
      seg_angdphi : signed(SLC_ENDCAP_SEG_ANGDPHI_LEN-1 downto 0);
      seg_angdtheta : signed(SLC_ENDCAP_SEG_ANGDTHETA_LEN-1 downto 0);
   end record slc_endcap_rt;
   attribute w of slc_endcap_rt : type is 48;
   function width(x: slc_endcap_rt) return natural;
   function convert(x: slc_endcap_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_endcap_rt) return slc_endcap_rt;
   function zero(tpl: slc_endcap_rt) return slc_endcap_rt;

   type slc_barrel_rt is record
      rpc3_posz : signed(SLC_BARREL_RPC3_POSZ_LEN-1 downto 0);
      rpc2_posz : signed(SLC_BARREL_RPC2_POSZ_LEN-1 downto 0);
      rpc1_posz : signed(SLC_BARREL_RPC1_POSZ_LEN-1 downto 0);
      rpc0_posz : signed(SLC_BARREL_RPC0_POSZ_LEN-1 downto 0);
   end record slc_barrel_rt;
   attribute w of slc_barrel_rt : type is 48;
   function width(x: slc_barrel_rt) return natural;
   function convert(x: slc_barrel_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_barrel_rt) return slc_barrel_rt;
   function zero(tpl: slc_barrel_rt) return slc_barrel_rt;

   type slc_rx_rt is record
      data_valid : std_logic;
      common : slc_common_rt;
      specific : std_logic_vector(SLC_RX_SPECIFIC_LEN-1 downto 0);
   end record slc_rx_rt;
   attribute w of slc_rx_rt : type is 156;
   function width(x: slc_rx_rt) return natural;
   function convert(x: slc_rx_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_rx_rt) return slc_rx_rt;
   function zero(tpl: slc_rx_rt) return slc_rx_rt;

   type slc_muid_rt is record
      slcid : unsigned(SLC_COMMON_SLCID_LEN-1 downto 0);
      slid : unsigned(SL_TRAILER_SLID_LEN-1 downto 0);
      bcid : unsigned(SL_HEADER_BCID_LEN-1 downto 0);
   end record slc_muid_rt;
   attribute w of slc_muid_rt : type is 21;
   function width(x: slc_muid_rt) return natural;
   function convert(x: slc_muid_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_muid_rt) return slc_muid_rt;
   function zero(tpl: slc_muid_rt) return slc_muid_rt;

   type vec_mdtid_rt is record
      chamber_id : unsigned(VEC_MDTID_CHAMBER_ID_LEN-1 downto 0);
      chamber_ieta : unsigned(VEC_MDTID_CHAMBER_IETA_LEN-1 downto 0);
   end record vec_mdtid_rt;
   attribute w of vec_mdtid_rt : type is 9;
   function width(x: vec_mdtid_rt) return natural;
   function convert(x: vec_mdtid_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: vec_mdtid_rt) return vec_mdtid_rt;
   function zero(tpl: vec_mdtid_rt) return vec_mdtid_rt;

   type tdc_rt is record
      chanid : unsigned(TDC_CHANID_LEN-1 downto 0);
      edgemode : std_logic_vector(TDC_EDGEMODE_LEN-1 downto 0);
      coarsetime : unsigned(TDC_COARSETIME_LEN-1 downto 0);
      finetime : unsigned(TDC_FINETIME_LEN-1 downto 0);
      pulsewidth : unsigned(TDC_PULSEWIDTH_LEN-1 downto 0);
   end record tdc_rt;
   attribute w of tdc_rt : type is 32;
   function width(x: tdc_rt) return natural;
   function convert(x: tdc_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: tdc_rt) return tdc_rt;
   function zero(tpl: tdc_rt) return tdc_rt;

   type ucm2pl_rt is record
      data_valid : std_logic;
      busy : std_logic;
      process_ch : std_logic_vector(UCM2PL_PROCESS_CH_LEN-1 downto 0);
      common : slc_common_rt;
      phimod : signed(UCM2PL_PHIMOD_LEN-1 downto 0);
      nswseg_angdtheta : signed(SLC_ENDCAP_NSWSEG_ANGDTHETA_LEN-1 downto 0);
      nswseg_posphi : unsigned(SLC_ENDCAP_NSWSEG_POSPHI_LEN-1 downto 0);
      nswseg_poseta : unsigned(SLC_ENDCAP_NSWSEG_POSETA_LEN-1 downto 0);
   end record ucm2pl_rt;
   attribute w of ucm2pl_rt : type is 148;
   function width(x: ucm2pl_rt) return natural;
   function convert(x: ucm2pl_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm2pl_rt) return ucm2pl_rt;
   function zero(tpl: ucm2pl_rt) return ucm2pl_rt;

   type tdcpolmux2tar_rt is record
      data_valid : std_logic;
      tdc : tdc_rt;
      csmid : unsigned(TDCPOLMUX2TAR_CSMID_LEN-1 downto 0);
      tdcid : unsigned(TDCPOLMUX2TAR_TDCID_LEN-1 downto 0);
   end record tdcpolmux2tar_rt;
   attribute w of tdcpolmux2tar_rt : type is 42;
   function width(x: tdcpolmux2tar_rt) return natural;
   function convert(x: tdcpolmux2tar_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: tdcpolmux2tar_rt) return tdcpolmux2tar_rt;
   function zero(tpl: tdcpolmux2tar_rt) return tdcpolmux2tar_rt;

   type ucm2hps_rt is record
      data_valid : std_logic;
      muid : slc_muid_rt;
      mdtseg_dest : std_logic_vector(UCM2HPS_MDTSEG_DEST_LEN-1 downto 0);
      mdtid : vec_mdtid_rt;
      vec_pos : unsigned(UCM2HPS_VEC_POS_LEN-1 downto 0);
      vec_ang : unsigned(UCM2HPS_VEC_ANG_LEN-1 downto 0);
   end record ucm2hps_rt;
   attribute w of ucm2hps_rt : type is 58;
   function width(x: ucm2hps_rt) return natural;
   function convert(x: ucm2hps_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm2hps_rt) return ucm2hps_rt;
   function zero(tpl: ucm2hps_rt) return ucm2hps_rt;

   type heg2sfslc_rt is record
      data_valid : std_logic;
      muid : slc_muid_rt;
      mdtseg_dest : std_logic_vector(HEG2SFSLC_MDTSEG_DEST_LEN-1 downto 0);
      mdtid : vec_mdtid_rt;
      vec_pos : unsigned(UCM2HPS_VEC_POS_LEN-1 downto 0);
      vec_ang : unsigned(UCM2HPS_VEC_ANG_LEN-1 downto 0);
      hewindow_pos : unsigned(HEG2SFSLC_HEWINDOW_POS_LEN-1 downto 0);
   end record heg2sfslc_rt;
   attribute w of heg2sfslc_rt : type is 77;
   function width(x: heg2sfslc_rt) return natural;
   function convert(x: heg2sfslc_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: heg2sfslc_rt) return heg2sfslc_rt;
   function zero(tpl: heg2sfslc_rt) return heg2sfslc_rt;

   type tar2hps_rt is record
      data_valid : std_logic;
      chamber_ieta : unsigned(VEC_MDTID_CHAMBER_IETA_LEN-1 downto 0);
      layer : unsigned(TAR2HPS_LAYER_LEN-1 downto 0);
      tube : unsigned(TAR2HPS_TUBE_LEN-1 downto 0);
      time : unsigned(TAR2HPS_TIME_LEN-1 downto 0);
   end record tar2hps_rt;
   attribute w of tar2hps_rt : type is 36;
   function width(x: tar2hps_rt) return natural;
   function convert(x: tar2hps_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: tar2hps_rt) return tar2hps_rt;
   function zero(tpl: tar2hps_rt) return tar2hps_rt;

   type heg2sfhit_rt is record
      data_valid : std_logic;
      mlayer : std_logic;
      localx : unsigned(HEG2SFHIT_LOCALX_LEN-1 downto 0);
      localy : unsigned(HEG2SFHIT_LOCALY_LEN-1 downto 0);
      radius : unsigned(HEG2SFHIT_RADIUS_LEN-1 downto 0);
   end record heg2sfhit_rt;
   attribute w of heg2sfhit_rt : type is 41;
   function width(x: heg2sfhit_rt) return natural;
   function convert(x: heg2sfhit_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: heg2sfhit_rt) return heg2sfhit_rt;
   function zero(tpl: heg2sfhit_rt) return heg2sfhit_rt;

   type pl2ptcalc_rt is record
      data_valid : std_logic;
      muid : slc_muid_rt;
      phimod : signed(UCM2PL_PHIMOD_LEN-1 downto 0);
      sl_charge : std_logic;
      nswseg_poseta : unsigned(SLC_ENDCAP_NSWSEG_POSETA_LEN-1 downto 0);
      nswseg_posphi : unsigned(SLC_ENDCAP_NSWSEG_POSPHI_LEN-1 downto 0);
      nswseg_angdtheta : signed(SLC_ENDCAP_NSWSEG_ANGDTHETA_LEN-1 downto 0);
   end record pl2ptcalc_rt;
   attribute w of pl2ptcalc_rt : type is 58;
   function width(x: pl2ptcalc_rt) return natural;
   function convert(x: pl2ptcalc_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: pl2ptcalc_rt) return pl2ptcalc_rt;
   function zero(tpl: pl2ptcalc_rt) return pl2ptcalc_rt;

   type sf2ptcalc_rt is record
      data_valid : std_logic;
      muid : slc_muid_rt;
      segpos : unsigned(SF2PTCALC_SEGPOS_LEN-1 downto 0);
      segangle : unsigned(SF2PTCALC_SEGANGLE_LEN-1 downto 0);
      segquality : std_logic;
      mdtid : vec_mdtid_rt;
   end record sf2ptcalc_rt;
   attribute w of sf2ptcalc_rt : type is 64;
   function width(x: sf2ptcalc_rt) return natural;
   function convert(x: sf2ptcalc_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: sf2ptcalc_rt) return sf2ptcalc_rt;
   function zero(tpl: sf2ptcalc_rt) return sf2ptcalc_rt;

   type ptcalc2mtc_rt is record
      data_valid : std_logic;
      muid : slc_muid_rt;
      mdt_eta : signed(PTCALC2MTC_MDT_ETA_LEN-1 downto 0);
      mdt_pt : unsigned(PTCALC2MTC_MDT_PT_LEN-1 downto 0);
      mdt_ptthresh : unsigned(PTCALC2MTC_MDT_PTTHRESH_LEN-1 downto 0);
      mdt_charge : std_logic;
      mdt_nsegments : unsigned(PTCALC2MTC_MDT_NSEGMENTS_LEN-1 downto 0);
      mdt_quality : std_logic_vector(PTCALC2MTC_MDT_QUALITY_LEN-1 downto 0);
   end record ptcalc2mtc_rt;
   attribute w of ptcalc2mtc_rt : type is 54;
   function width(x: ptcalc2mtc_rt) return natural;
   function convert(x: ptcalc2mtc_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ptcalc2mtc_rt) return ptcalc2mtc_rt;
   function zero(tpl: ptcalc2mtc_rt) return ptcalc2mtc_rt;

   type pl2mtc_rt is record
      data_valid : std_logic;
      busy : std_logic;
      process_ch : std_logic_vector(UCM2PL_PROCESS_CH_LEN-1 downto 0);
      common : slc_common_rt;
   end record pl2mtc_rt;
   attribute w of pl2mtc_rt : type is 113;
   function width(x: pl2mtc_rt) return natural;
   function convert(x: pl2mtc_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: pl2mtc_rt) return pl2mtc_rt;
   function zero(tpl: pl2mtc_rt) return pl2mtc_rt;

   type mtc2sl_rt is record
      data_valid : std_logic;
      common : slc_common_rt;
      mdt_eta : signed(PTCALC2MTC_MDT_ETA_LEN-1 downto 0);
      mdt_pt : unsigned(PTCALC2MTC_MDT_PT_LEN-1 downto 0);
      mdt_ptthresh : unsigned(PTCALC2MTC_MDT_PTTHRESH_LEN-1 downto 0);
      mdt_charge : std_logic;
      mdt_procflags : std_logic_vector(MTC2SL_MDT_PROCFLAGS_LEN-1 downto 0);
      mdt_nsegments : unsigned(PTCALC2MTC_MDT_NSEGMENTS_LEN-1 downto 0);
      mdt_quality : std_logic_vector(PTCALC2MTC_MDT_QUALITY_LEN-1 downto 0);
      m_reserved : std_logic_vector(MTC2SL_M_RESERVED_LEN-1 downto 0);
   end record mtc2sl_rt;
   attribute w of mtc2sl_rt : type is 193;
   function width(x: mtc2sl_rt) return natural;
   function convert(x: mtc2sl_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: mtc2sl_rt) return mtc2sl_rt;
   function zero(tpl: mtc2sl_rt) return mtc2sl_rt;

end package l0mdt_dataformats_pkg;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;

package body l0mdt_dataformats_pkg is

   -- Custom types and functions --

   function width(x: sl_header_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.h_reserved);
      w := w + width(x.tcoverflow);
      w := w + width(x.nmtc_sl);
      w := w + width(x.nmtc_mdt);
      w := w + width(x.nslc);
      w := w + width(x.bcid);
      return w;
   end function width;
   function convert(x: sl_header_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.h_reserved);
         y(u to u+w-1) := convert(x.h_reserved, y(u to u+w-1));
         u := u + w;
         w := width(x.tcoverflow);
         y(u to u+w-1) := convert(x.tcoverflow, y(u to u+w-1));
         u := u + w;
         w := width(x.nmtc_sl);
         y(u to u+w-1) := convert(x.nmtc_sl, y(u to u+w-1));
         u := u + w;
         w := width(x.nmtc_mdt);
         y(u to u+w-1) := convert(x.nmtc_mdt, y(u to u+w-1));
         u := u + w;
         w := width(x.nslc);
         y(u to u+w-1) := convert(x.nslc, y(u to u+w-1));
         u := u + w;
         w := width(x.bcid);
         y(u to u+w-1) := convert(x.bcid, y(u to u+w-1));
      else
         w := width(x.h_reserved);
         y(u downto u-w+1) := convert(x.h_reserved, y(u downto u-w+1));
         u := u - w;
         w := width(x.tcoverflow);
         y(u downto u-w+1) := convert(x.tcoverflow, y(u downto u-w+1));
         u := u - w;
         w := width(x.nmtc_sl);
         y(u downto u-w+1) := convert(x.nmtc_sl, y(u downto u-w+1));
         u := u - w;
         w := width(x.nmtc_mdt);
         y(u downto u-w+1) := convert(x.nmtc_mdt, y(u downto u-w+1));
         u := u - w;
         w := width(x.nslc);
         y(u downto u-w+1) := convert(x.nslc, y(u downto u-w+1));
         u := u - w;
         w := width(x.bcid);
         y(u downto u-w+1) := convert(x.bcid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: sl_header_rt) return sl_header_rt is
      variable y : sl_header_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.h_reserved);
         y.h_reserved := convert(x(u to u+w-1), tpl.h_reserved);
         u := u + w;
         w := width(tpl.tcoverflow);
         y.tcoverflow := convert(x(u to u+w-1), tpl.tcoverflow);
         u := u + w;
         w := width(tpl.nmtc_sl);
         y.nmtc_sl := convert(x(u to u+w-1), tpl.nmtc_sl);
         u := u + w;
         w := width(tpl.nmtc_mdt);
         y.nmtc_mdt := convert(x(u to u+w-1), tpl.nmtc_mdt);
         u := u + w;
         w := width(tpl.nslc);
         y.nslc := convert(x(u to u+w-1), tpl.nslc);
         u := u + w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u to u+w-1), tpl.bcid);
      else
         w := width(tpl.h_reserved);
         y.h_reserved := convert(x(u downto u-w+1), tpl.h_reserved);
         u := u - w;
         w := width(tpl.tcoverflow);
         y.tcoverflow := convert(x(u downto u-w+1), tpl.tcoverflow);
         u := u - w;
         w := width(tpl.nmtc_sl);
         y.nmtc_sl := convert(x(u downto u-w+1), tpl.nmtc_sl);
         u := u - w;
         w := width(tpl.nmtc_mdt);
         y.nmtc_mdt := convert(x(u downto u-w+1), tpl.nmtc_mdt);
         u := u - w;
         w := width(tpl.nslc);
         y.nslc := convert(x(u downto u-w+1), tpl.nslc);
         u := u - w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u downto u-w+1), tpl.bcid);
      end if;
      return y;
   end function convert;
   function zero(tpl: sl_header_rt) return sl_header_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: sl_trailer_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.t_reserved);
      w := w + width(x.crc);
      w := w + width(x.fiberid);
      w := w + width(x.slid);
      w := w + width(x.comma);
      return w;
   end function width;
   function convert(x: sl_trailer_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.t_reserved);
         y(u to u+w-1) := convert(x.t_reserved, y(u to u+w-1));
         u := u + w;
         w := width(x.crc);
         y(u to u+w-1) := convert(x.crc, y(u to u+w-1));
         u := u + w;
         w := width(x.fiberid);
         y(u to u+w-1) := convert(x.fiberid, y(u to u+w-1));
         u := u + w;
         w := width(x.slid);
         y(u to u+w-1) := convert(x.slid, y(u to u+w-1));
         u := u + w;
         w := width(x.comma);
         y(u to u+w-1) := convert(x.comma, y(u to u+w-1));
      else
         w := width(x.t_reserved);
         y(u downto u-w+1) := convert(x.t_reserved, y(u downto u-w+1));
         u := u - w;
         w := width(x.crc);
         y(u downto u-w+1) := convert(x.crc, y(u downto u-w+1));
         u := u - w;
         w := width(x.fiberid);
         y(u downto u-w+1) := convert(x.fiberid, y(u downto u-w+1));
         u := u - w;
         w := width(x.slid);
         y(u downto u-w+1) := convert(x.slid, y(u downto u-w+1));
         u := u - w;
         w := width(x.comma);
         y(u downto u-w+1) := convert(x.comma, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: sl_trailer_rt) return sl_trailer_rt is
      variable y : sl_trailer_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.t_reserved);
         y.t_reserved := convert(x(u to u+w-1), tpl.t_reserved);
         u := u + w;
         w := width(tpl.crc);
         y.crc := convert(x(u to u+w-1), tpl.crc);
         u := u + w;
         w := width(tpl.fiberid);
         y.fiberid := convert(x(u to u+w-1), tpl.fiberid);
         u := u + w;
         w := width(tpl.slid);
         y.slid := convert(x(u to u+w-1), tpl.slid);
         u := u + w;
         w := width(tpl.comma);
         y.comma := convert(x(u to u+w-1), tpl.comma);
      else
         w := width(tpl.t_reserved);
         y.t_reserved := convert(x(u downto u-w+1), tpl.t_reserved);
         u := u - w;
         w := width(tpl.crc);
         y.crc := convert(x(u downto u-w+1), tpl.crc);
         u := u - w;
         w := width(tpl.fiberid);
         y.fiberid := convert(x(u downto u-w+1), tpl.fiberid);
         u := u - w;
         w := width(tpl.slid);
         y.slid := convert(x(u downto u-w+1), tpl.slid);
         u := u - w;
         w := width(tpl.comma);
         y.comma := convert(x(u downto u-w+1), tpl.comma);
      end if;
      return y;
   end function convert;
   function zero(tpl: sl_trailer_rt) return sl_trailer_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: slc_common_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.header);
      w := w + width(x.slcid);
      w := w + width(x.tcsent);
      w := w + width(x.poseta);
      w := w + width(x.posphi);
      w := w + width(x.sl_pt);
      w := w + width(x.sl_ptthresh);
      w := w + width(x.sl_charge);
      w := w + width(x.cointype);
      w := w + width(x.trailer);
      return w;
   end function width;
   function convert(x: slc_common_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.header);
         y(u to u+w-1) := convert(x.header, y(u to u+w-1));
         u := u + w;
         w := width(x.slcid);
         y(u to u+w-1) := convert(x.slcid, y(u to u+w-1));
         u := u + w;
         w := width(x.tcsent);
         y(u to u+w-1) := convert(x.tcsent, y(u to u+w-1));
         u := u + w;
         w := width(x.poseta);
         y(u to u+w-1) := convert(x.poseta, y(u to u+w-1));
         u := u + w;
         w := width(x.posphi);
         y(u to u+w-1) := convert(x.posphi, y(u to u+w-1));
         u := u + w;
         w := width(x.sl_pt);
         y(u to u+w-1) := convert(x.sl_pt, y(u to u+w-1));
         u := u + w;
         w := width(x.sl_ptthresh);
         y(u to u+w-1) := convert(x.sl_ptthresh, y(u to u+w-1));
         u := u + w;
         w := width(x.sl_charge);
         y(u to u+w-1) := convert(x.sl_charge, y(u to u+w-1));
         u := u + w;
         w := width(x.cointype);
         y(u to u+w-1) := convert(x.cointype, y(u to u+w-1));
         u := u + w;
         w := width(x.trailer);
         y(u to u+w-1) := convert(x.trailer, y(u to u+w-1));
      else
         w := width(x.header);
         y(u downto u-w+1) := convert(x.header, y(u downto u-w+1));
         u := u - w;
         w := width(x.slcid);
         y(u downto u-w+1) := convert(x.slcid, y(u downto u-w+1));
         u := u - w;
         w := width(x.tcsent);
         y(u downto u-w+1) := convert(x.tcsent, y(u downto u-w+1));
         u := u - w;
         w := width(x.poseta);
         y(u downto u-w+1) := convert(x.poseta, y(u downto u-w+1));
         u := u - w;
         w := width(x.posphi);
         y(u downto u-w+1) := convert(x.posphi, y(u downto u-w+1));
         u := u - w;
         w := width(x.sl_pt);
         y(u downto u-w+1) := convert(x.sl_pt, y(u downto u-w+1));
         u := u - w;
         w := width(x.sl_ptthresh);
         y(u downto u-w+1) := convert(x.sl_ptthresh, y(u downto u-w+1));
         u := u - w;
         w := width(x.sl_charge);
         y(u downto u-w+1) := convert(x.sl_charge, y(u downto u-w+1));
         u := u - w;
         w := width(x.cointype);
         y(u downto u-w+1) := convert(x.cointype, y(u downto u-w+1));
         u := u - w;
         w := width(x.trailer);
         y(u downto u-w+1) := convert(x.trailer, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_common_rt) return slc_common_rt is
      variable y : slc_common_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.header);
         y.header := convert(x(u to u+w-1), tpl.header);
         u := u + w;
         w := width(tpl.slcid);
         y.slcid := convert(x(u to u+w-1), tpl.slcid);
         u := u + w;
         w := width(tpl.tcsent);
         y.tcsent := convert(x(u to u+w-1), tpl.tcsent);
         u := u + w;
         w := width(tpl.poseta);
         y.poseta := convert(x(u to u+w-1), tpl.poseta);
         u := u + w;
         w := width(tpl.posphi);
         y.posphi := convert(x(u to u+w-1), tpl.posphi);
         u := u + w;
         w := width(tpl.sl_pt);
         y.sl_pt := convert(x(u to u+w-1), tpl.sl_pt);
         u := u + w;
         w := width(tpl.sl_ptthresh);
         y.sl_ptthresh := convert(x(u to u+w-1), tpl.sl_ptthresh);
         u := u + w;
         w := width(tpl.sl_charge);
         y.sl_charge := convert(x(u to u+w-1), tpl.sl_charge);
         u := u + w;
         w := width(tpl.cointype);
         y.cointype := convert(x(u to u+w-1), tpl.cointype);
         u := u + w;
         w := width(tpl.trailer);
         y.trailer := convert(x(u to u+w-1), tpl.trailer);
      else
         w := width(tpl.header);
         y.header := convert(x(u downto u-w+1), tpl.header);
         u := u - w;
         w := width(tpl.slcid);
         y.slcid := convert(x(u downto u-w+1), tpl.slcid);
         u := u - w;
         w := width(tpl.tcsent);
         y.tcsent := convert(x(u downto u-w+1), tpl.tcsent);
         u := u - w;
         w := width(tpl.poseta);
         y.poseta := convert(x(u downto u-w+1), tpl.poseta);
         u := u - w;
         w := width(tpl.posphi);
         y.posphi := convert(x(u downto u-w+1), tpl.posphi);
         u := u - w;
         w := width(tpl.sl_pt);
         y.sl_pt := convert(x(u downto u-w+1), tpl.sl_pt);
         u := u - w;
         w := width(tpl.sl_ptthresh);
         y.sl_ptthresh := convert(x(u downto u-w+1), tpl.sl_ptthresh);
         u := u - w;
         w := width(tpl.sl_charge);
         y.sl_charge := convert(x(u downto u-w+1), tpl.sl_charge);
         u := u - w;
         w := width(tpl.cointype);
         y.cointype := convert(x(u downto u-w+1), tpl.cointype);
         u := u - w;
         w := width(tpl.trailer);
         y.trailer := convert(x(u downto u-w+1), tpl.trailer);
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_common_rt) return slc_common_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: slc_endcap_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.e_reserved);
      w := w + width(x.nswseg_mon);
      w := w + width(x.nswseg_angdtheta);
      w := w + width(x.nswseg_posphi);
      w := w + width(x.nswseg_poseta);
      w := w + width(x.seg_angdphi);
      w := w + width(x.seg_angdtheta);
      return w;
   end function width;
   function convert(x: slc_endcap_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.e_reserved);
         y(u to u+w-1) := convert(x.e_reserved, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_mon);
         y(u to u+w-1) := convert(x.nswseg_mon, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_angdtheta);
         y(u to u+w-1) := convert(x.nswseg_angdtheta, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_posphi);
         y(u to u+w-1) := convert(x.nswseg_posphi, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_poseta);
         y(u to u+w-1) := convert(x.nswseg_poseta, y(u to u+w-1));
         u := u + w;
         w := width(x.seg_angdphi);
         y(u to u+w-1) := convert(x.seg_angdphi, y(u to u+w-1));
         u := u + w;
         w := width(x.seg_angdtheta);
         y(u to u+w-1) := convert(x.seg_angdtheta, y(u to u+w-1));
      else
         w := width(x.e_reserved);
         y(u downto u-w+1) := convert(x.e_reserved, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_mon);
         y(u downto u-w+1) := convert(x.nswseg_mon, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_angdtheta);
         y(u downto u-w+1) := convert(x.nswseg_angdtheta, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_posphi);
         y(u downto u-w+1) := convert(x.nswseg_posphi, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_poseta);
         y(u downto u-w+1) := convert(x.nswseg_poseta, y(u downto u-w+1));
         u := u - w;
         w := width(x.seg_angdphi);
         y(u downto u-w+1) := convert(x.seg_angdphi, y(u downto u-w+1));
         u := u - w;
         w := width(x.seg_angdtheta);
         y(u downto u-w+1) := convert(x.seg_angdtheta, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_endcap_rt) return slc_endcap_rt is
      variable y : slc_endcap_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.e_reserved);
         y.e_reserved := convert(x(u to u+w-1), tpl.e_reserved);
         u := u + w;
         w := width(tpl.nswseg_mon);
         y.nswseg_mon := convert(x(u to u+w-1), tpl.nswseg_mon);
         u := u + w;
         w := width(tpl.nswseg_angdtheta);
         y.nswseg_angdtheta := convert(x(u to u+w-1), tpl.nswseg_angdtheta);
         u := u + w;
         w := width(tpl.nswseg_posphi);
         y.nswseg_posphi := convert(x(u to u+w-1), tpl.nswseg_posphi);
         u := u + w;
         w := width(tpl.nswseg_poseta);
         y.nswseg_poseta := convert(x(u to u+w-1), tpl.nswseg_poseta);
         u := u + w;
         w := width(tpl.seg_angdphi);
         y.seg_angdphi := convert(x(u to u+w-1), tpl.seg_angdphi);
         u := u + w;
         w := width(tpl.seg_angdtheta);
         y.seg_angdtheta := convert(x(u to u+w-1), tpl.seg_angdtheta);
      else
         w := width(tpl.e_reserved);
         y.e_reserved := convert(x(u downto u-w+1), tpl.e_reserved);
         u := u - w;
         w := width(tpl.nswseg_mon);
         y.nswseg_mon := convert(x(u downto u-w+1), tpl.nswseg_mon);
         u := u - w;
         w := width(tpl.nswseg_angdtheta);
         y.nswseg_angdtheta := convert(x(u downto u-w+1), tpl.nswseg_angdtheta);
         u := u - w;
         w := width(tpl.nswseg_posphi);
         y.nswseg_posphi := convert(x(u downto u-w+1), tpl.nswseg_posphi);
         u := u - w;
         w := width(tpl.nswseg_poseta);
         y.nswseg_poseta := convert(x(u downto u-w+1), tpl.nswseg_poseta);
         u := u - w;
         w := width(tpl.seg_angdphi);
         y.seg_angdphi := convert(x(u downto u-w+1), tpl.seg_angdphi);
         u := u - w;
         w := width(tpl.seg_angdtheta);
         y.seg_angdtheta := convert(x(u downto u-w+1), tpl.seg_angdtheta);
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_endcap_rt) return slc_endcap_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: slc_barrel_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rpc3_posz);
      w := w + width(x.rpc2_posz);
      w := w + width(x.rpc1_posz);
      w := w + width(x.rpc0_posz);
      return w;
   end function width;
   function convert(x: slc_barrel_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rpc3_posz);
         y(u to u+w-1) := convert(x.rpc3_posz, y(u to u+w-1));
         u := u + w;
         w := width(x.rpc2_posz);
         y(u to u+w-1) := convert(x.rpc2_posz, y(u to u+w-1));
         u := u + w;
         w := width(x.rpc1_posz);
         y(u to u+w-1) := convert(x.rpc1_posz, y(u to u+w-1));
         u := u + w;
         w := width(x.rpc0_posz);
         y(u to u+w-1) := convert(x.rpc0_posz, y(u to u+w-1));
      else
         w := width(x.rpc3_posz);
         y(u downto u-w+1) := convert(x.rpc3_posz, y(u downto u-w+1));
         u := u - w;
         w := width(x.rpc2_posz);
         y(u downto u-w+1) := convert(x.rpc2_posz, y(u downto u-w+1));
         u := u - w;
         w := width(x.rpc1_posz);
         y(u downto u-w+1) := convert(x.rpc1_posz, y(u downto u-w+1));
         u := u - w;
         w := width(x.rpc0_posz);
         y(u downto u-w+1) := convert(x.rpc0_posz, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_barrel_rt) return slc_barrel_rt is
      variable y : slc_barrel_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rpc3_posz);
         y.rpc3_posz := convert(x(u to u+w-1), tpl.rpc3_posz);
         u := u + w;
         w := width(tpl.rpc2_posz);
         y.rpc2_posz := convert(x(u to u+w-1), tpl.rpc2_posz);
         u := u + w;
         w := width(tpl.rpc1_posz);
         y.rpc1_posz := convert(x(u to u+w-1), tpl.rpc1_posz);
         u := u + w;
         w := width(tpl.rpc0_posz);
         y.rpc0_posz := convert(x(u to u+w-1), tpl.rpc0_posz);
      else
         w := width(tpl.rpc3_posz);
         y.rpc3_posz := convert(x(u downto u-w+1), tpl.rpc3_posz);
         u := u - w;
         w := width(tpl.rpc2_posz);
         y.rpc2_posz := convert(x(u downto u-w+1), tpl.rpc2_posz);
         u := u - w;
         w := width(tpl.rpc1_posz);
         y.rpc1_posz := convert(x(u downto u-w+1), tpl.rpc1_posz);
         u := u - w;
         w := width(tpl.rpc0_posz);
         y.rpc0_posz := convert(x(u downto u-w+1), tpl.rpc0_posz);
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_barrel_rt) return slc_barrel_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: slc_rx_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.common);
      w := w + width(x.specific);
      return w;
   end function width;
   function convert(x: slc_rx_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.common);
         y(u to u+w-1) := convert(x.common, y(u to u+w-1));
         u := u + w;
         w := width(x.specific);
         y(u to u+w-1) := convert(x.specific, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.common);
         y(u downto u-w+1) := convert(x.common, y(u downto u-w+1));
         u := u - w;
         w := width(x.specific);
         y(u downto u-w+1) := convert(x.specific, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_rx_rt) return slc_rx_rt is
      variable y : slc_rx_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.common);
         y.common := convert(x(u to u+w-1), tpl.common);
         u := u + w;
         w := width(tpl.specific);
         y.specific := convert(x(u to u+w-1), tpl.specific);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.common);
         y.common := convert(x(u downto u-w+1), tpl.common);
         u := u - w;
         w := width(tpl.specific);
         y.specific := convert(x(u downto u-w+1), tpl.specific);
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_rx_rt) return slc_rx_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: slc_muid_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.slcid);
      w := w + width(x.slid);
      w := w + width(x.bcid);
      return w;
   end function width;
   function convert(x: slc_muid_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.slcid);
         y(u to u+w-1) := convert(x.slcid, y(u to u+w-1));
         u := u + w;
         w := width(x.slid);
         y(u to u+w-1) := convert(x.slid, y(u to u+w-1));
         u := u + w;
         w := width(x.bcid);
         y(u to u+w-1) := convert(x.bcid, y(u to u+w-1));
      else
         w := width(x.slcid);
         y(u downto u-w+1) := convert(x.slcid, y(u downto u-w+1));
         u := u - w;
         w := width(x.slid);
         y(u downto u-w+1) := convert(x.slid, y(u downto u-w+1));
         u := u - w;
         w := width(x.bcid);
         y(u downto u-w+1) := convert(x.bcid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_muid_rt) return slc_muid_rt is
      variable y : slc_muid_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.slcid);
         y.slcid := convert(x(u to u+w-1), tpl.slcid);
         u := u + w;
         w := width(tpl.slid);
         y.slid := convert(x(u to u+w-1), tpl.slid);
         u := u + w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u to u+w-1), tpl.bcid);
      else
         w := width(tpl.slcid);
         y.slcid := convert(x(u downto u-w+1), tpl.slcid);
         u := u - w;
         w := width(tpl.slid);
         y.slid := convert(x(u downto u-w+1), tpl.slid);
         u := u - w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u downto u-w+1), tpl.bcid);
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_muid_rt) return slc_muid_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: vec_mdtid_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.chamber_id);
      w := w + width(x.chamber_ieta);
      return w;
   end function width;
   function convert(x: vec_mdtid_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.chamber_id);
         y(u to u+w-1) := convert(x.chamber_id, y(u to u+w-1));
         u := u + w;
         w := width(x.chamber_ieta);
         y(u to u+w-1) := convert(x.chamber_ieta, y(u to u+w-1));
      else
         w := width(x.chamber_id);
         y(u downto u-w+1) := convert(x.chamber_id, y(u downto u-w+1));
         u := u - w;
         w := width(x.chamber_ieta);
         y(u downto u-w+1) := convert(x.chamber_ieta, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: vec_mdtid_rt) return vec_mdtid_rt is
      variable y : vec_mdtid_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.chamber_id);
         y.chamber_id := convert(x(u to u+w-1), tpl.chamber_id);
         u := u + w;
         w := width(tpl.chamber_ieta);
         y.chamber_ieta := convert(x(u to u+w-1), tpl.chamber_ieta);
      else
         w := width(tpl.chamber_id);
         y.chamber_id := convert(x(u downto u-w+1), tpl.chamber_id);
         u := u - w;
         w := width(tpl.chamber_ieta);
         y.chamber_ieta := convert(x(u downto u-w+1), tpl.chamber_ieta);
      end if;
      return y;
   end function convert;
   function zero(tpl: vec_mdtid_rt) return vec_mdtid_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: tdc_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.chanid);
      w := w + width(x.edgemode);
      w := w + width(x.coarsetime);
      w := w + width(x.finetime);
      w := w + width(x.pulsewidth);
      return w;
   end function width;
   function convert(x: tdc_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.chanid);
         y(u to u+w-1) := convert(x.chanid, y(u to u+w-1));
         u := u + w;
         w := width(x.edgemode);
         y(u to u+w-1) := convert(x.edgemode, y(u to u+w-1));
         u := u + w;
         w := width(x.coarsetime);
         y(u to u+w-1) := convert(x.coarsetime, y(u to u+w-1));
         u := u + w;
         w := width(x.finetime);
         y(u to u+w-1) := convert(x.finetime, y(u to u+w-1));
         u := u + w;
         w := width(x.pulsewidth);
         y(u to u+w-1) := convert(x.pulsewidth, y(u to u+w-1));
      else
         w := width(x.chanid);
         y(u downto u-w+1) := convert(x.chanid, y(u downto u-w+1));
         u := u - w;
         w := width(x.edgemode);
         y(u downto u-w+1) := convert(x.edgemode, y(u downto u-w+1));
         u := u - w;
         w := width(x.coarsetime);
         y(u downto u-w+1) := convert(x.coarsetime, y(u downto u-w+1));
         u := u - w;
         w := width(x.finetime);
         y(u downto u-w+1) := convert(x.finetime, y(u downto u-w+1));
         u := u - w;
         w := width(x.pulsewidth);
         y(u downto u-w+1) := convert(x.pulsewidth, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: tdc_rt) return tdc_rt is
      variable y : tdc_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.chanid);
         y.chanid := convert(x(u to u+w-1), tpl.chanid);
         u := u + w;
         w := width(tpl.edgemode);
         y.edgemode := convert(x(u to u+w-1), tpl.edgemode);
         u := u + w;
         w := width(tpl.coarsetime);
         y.coarsetime := convert(x(u to u+w-1), tpl.coarsetime);
         u := u + w;
         w := width(tpl.finetime);
         y.finetime := convert(x(u to u+w-1), tpl.finetime);
         u := u + w;
         w := width(tpl.pulsewidth);
         y.pulsewidth := convert(x(u to u+w-1), tpl.pulsewidth);
      else
         w := width(tpl.chanid);
         y.chanid := convert(x(u downto u-w+1), tpl.chanid);
         u := u - w;
         w := width(tpl.edgemode);
         y.edgemode := convert(x(u downto u-w+1), tpl.edgemode);
         u := u - w;
         w := width(tpl.coarsetime);
         y.coarsetime := convert(x(u downto u-w+1), tpl.coarsetime);
         u := u - w;
         w := width(tpl.finetime);
         y.finetime := convert(x(u downto u-w+1), tpl.finetime);
         u := u - w;
         w := width(tpl.pulsewidth);
         y.pulsewidth := convert(x(u downto u-w+1), tpl.pulsewidth);
      end if;
      return y;
   end function convert;
   function zero(tpl: tdc_rt) return tdc_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: ucm2pl_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.busy);
      w := w + width(x.process_ch);
      w := w + width(x.common);
      w := w + width(x.phimod);
      w := w + width(x.nswseg_angdtheta);
      w := w + width(x.nswseg_posphi);
      w := w + width(x.nswseg_poseta);
      return w;
   end function width;
   function convert(x: ucm2pl_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.busy);
         y(u to u+w-1) := convert(x.busy, y(u to u+w-1));
         u := u + w;
         w := width(x.process_ch);
         y(u to u+w-1) := convert(x.process_ch, y(u to u+w-1));
         u := u + w;
         w := width(x.common);
         y(u to u+w-1) := convert(x.common, y(u to u+w-1));
         u := u + w;
         w := width(x.phimod);
         y(u to u+w-1) := convert(x.phimod, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_angdtheta);
         y(u to u+w-1) := convert(x.nswseg_angdtheta, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_posphi);
         y(u to u+w-1) := convert(x.nswseg_posphi, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_poseta);
         y(u to u+w-1) := convert(x.nswseg_poseta, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.busy);
         y(u downto u-w+1) := convert(x.busy, y(u downto u-w+1));
         u := u - w;
         w := width(x.process_ch);
         y(u downto u-w+1) := convert(x.process_ch, y(u downto u-w+1));
         u := u - w;
         w := width(x.common);
         y(u downto u-w+1) := convert(x.common, y(u downto u-w+1));
         u := u - w;
         w := width(x.phimod);
         y(u downto u-w+1) := convert(x.phimod, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_angdtheta);
         y(u downto u-w+1) := convert(x.nswseg_angdtheta, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_posphi);
         y(u downto u-w+1) := convert(x.nswseg_posphi, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_poseta);
         y(u downto u-w+1) := convert(x.nswseg_poseta, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm2pl_rt) return ucm2pl_rt is
      variable y : ucm2pl_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.busy);
         y.busy := convert(x(u to u+w-1), tpl.busy);
         u := u + w;
         w := width(tpl.process_ch);
         y.process_ch := convert(x(u to u+w-1), tpl.process_ch);
         u := u + w;
         w := width(tpl.common);
         y.common := convert(x(u to u+w-1), tpl.common);
         u := u + w;
         w := width(tpl.phimod);
         y.phimod := convert(x(u to u+w-1), tpl.phimod);
         u := u + w;
         w := width(tpl.nswseg_angdtheta);
         y.nswseg_angdtheta := convert(x(u to u+w-1), tpl.nswseg_angdtheta);
         u := u + w;
         w := width(tpl.nswseg_posphi);
         y.nswseg_posphi := convert(x(u to u+w-1), tpl.nswseg_posphi);
         u := u + w;
         w := width(tpl.nswseg_poseta);
         y.nswseg_poseta := convert(x(u to u+w-1), tpl.nswseg_poseta);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.busy);
         y.busy := convert(x(u downto u-w+1), tpl.busy);
         u := u - w;
         w := width(tpl.process_ch);
         y.process_ch := convert(x(u downto u-w+1), tpl.process_ch);
         u := u - w;
         w := width(tpl.common);
         y.common := convert(x(u downto u-w+1), tpl.common);
         u := u - w;
         w := width(tpl.phimod);
         y.phimod := convert(x(u downto u-w+1), tpl.phimod);
         u := u - w;
         w := width(tpl.nswseg_angdtheta);
         y.nswseg_angdtheta := convert(x(u downto u-w+1), tpl.nswseg_angdtheta);
         u := u - w;
         w := width(tpl.nswseg_posphi);
         y.nswseg_posphi := convert(x(u downto u-w+1), tpl.nswseg_posphi);
         u := u - w;
         w := width(tpl.nswseg_poseta);
         y.nswseg_poseta := convert(x(u downto u-w+1), tpl.nswseg_poseta);
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm2pl_rt) return ucm2pl_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: tdcpolmux2tar_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.tdc);
      w := w + width(x.csmid);
      w := w + width(x.tdcid);
      return w;
   end function width;
   function convert(x: tdcpolmux2tar_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.tdc);
         y(u to u+w-1) := convert(x.tdc, y(u to u+w-1));
         u := u + w;
         w := width(x.csmid);
         y(u to u+w-1) := convert(x.csmid, y(u to u+w-1));
         u := u + w;
         w := width(x.tdcid);
         y(u to u+w-1) := convert(x.tdcid, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.tdc);
         y(u downto u-w+1) := convert(x.tdc, y(u downto u-w+1));
         u := u - w;
         w := width(x.csmid);
         y(u downto u-w+1) := convert(x.csmid, y(u downto u-w+1));
         u := u - w;
         w := width(x.tdcid);
         y(u downto u-w+1) := convert(x.tdcid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: tdcpolmux2tar_rt) return tdcpolmux2tar_rt is
      variable y : tdcpolmux2tar_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.tdc);
         y.tdc := convert(x(u to u+w-1), tpl.tdc);
         u := u + w;
         w := width(tpl.csmid);
         y.csmid := convert(x(u to u+w-1), tpl.csmid);
         u := u + w;
         w := width(tpl.tdcid);
         y.tdcid := convert(x(u to u+w-1), tpl.tdcid);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.tdc);
         y.tdc := convert(x(u downto u-w+1), tpl.tdc);
         u := u - w;
         w := width(tpl.csmid);
         y.csmid := convert(x(u downto u-w+1), tpl.csmid);
         u := u - w;
         w := width(tpl.tdcid);
         y.tdcid := convert(x(u downto u-w+1), tpl.tdcid);
      end if;
      return y;
   end function convert;
   function zero(tpl: tdcpolmux2tar_rt) return tdcpolmux2tar_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: ucm2hps_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.muid);
      w := w + width(x.mdtseg_dest);
      w := w + width(x.mdtid);
      w := w + width(x.vec_pos);
      w := w + width(x.vec_ang);
      return w;
   end function width;
   function convert(x: ucm2hps_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.muid);
         y(u to u+w-1) := convert(x.muid, y(u to u+w-1));
         u := u + w;
         w := width(x.mdtseg_dest);
         y(u to u+w-1) := convert(x.mdtseg_dest, y(u to u+w-1));
         u := u + w;
         w := width(x.mdtid);
         y(u to u+w-1) := convert(x.mdtid, y(u to u+w-1));
         u := u + w;
         w := width(x.vec_pos);
         y(u to u+w-1) := convert(x.vec_pos, y(u to u+w-1));
         u := u + w;
         w := width(x.vec_ang);
         y(u to u+w-1) := convert(x.vec_ang, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.muid);
         y(u downto u-w+1) := convert(x.muid, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdtseg_dest);
         y(u downto u-w+1) := convert(x.mdtseg_dest, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdtid);
         y(u downto u-w+1) := convert(x.mdtid, y(u downto u-w+1));
         u := u - w;
         w := width(x.vec_pos);
         y(u downto u-w+1) := convert(x.vec_pos, y(u downto u-w+1));
         u := u - w;
         w := width(x.vec_ang);
         y(u downto u-w+1) := convert(x.vec_ang, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm2hps_rt) return ucm2hps_rt is
      variable y : ucm2hps_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.muid);
         y.muid := convert(x(u to u+w-1), tpl.muid);
         u := u + w;
         w := width(tpl.mdtseg_dest);
         y.mdtseg_dest := convert(x(u to u+w-1), tpl.mdtseg_dest);
         u := u + w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u to u+w-1), tpl.mdtid);
         u := u + w;
         w := width(tpl.vec_pos);
         y.vec_pos := convert(x(u to u+w-1), tpl.vec_pos);
         u := u + w;
         w := width(tpl.vec_ang);
         y.vec_ang := convert(x(u to u+w-1), tpl.vec_ang);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.muid);
         y.muid := convert(x(u downto u-w+1), tpl.muid);
         u := u - w;
         w := width(tpl.mdtseg_dest);
         y.mdtseg_dest := convert(x(u downto u-w+1), tpl.mdtseg_dest);
         u := u - w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u downto u-w+1), tpl.mdtid);
         u := u - w;
         w := width(tpl.vec_pos);
         y.vec_pos := convert(x(u downto u-w+1), tpl.vec_pos);
         u := u - w;
         w := width(tpl.vec_ang);
         y.vec_ang := convert(x(u downto u-w+1), tpl.vec_ang);
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm2hps_rt) return ucm2hps_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: heg2sfslc_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.muid);
      w := w + width(x.mdtseg_dest);
      w := w + width(x.mdtid);
      w := w + width(x.vec_pos);
      w := w + width(x.vec_ang);
      w := w + width(x.hewindow_pos);
      return w;
   end function width;
   function convert(x: heg2sfslc_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.muid);
         y(u to u+w-1) := convert(x.muid, y(u to u+w-1));
         u := u + w;
         w := width(x.mdtseg_dest);
         y(u to u+w-1) := convert(x.mdtseg_dest, y(u to u+w-1));
         u := u + w;
         w := width(x.mdtid);
         y(u to u+w-1) := convert(x.mdtid, y(u to u+w-1));
         u := u + w;
         w := width(x.vec_pos);
         y(u to u+w-1) := convert(x.vec_pos, y(u to u+w-1));
         u := u + w;
         w := width(x.vec_ang);
         y(u to u+w-1) := convert(x.vec_ang, y(u to u+w-1));
         u := u + w;
         w := width(x.hewindow_pos);
         y(u to u+w-1) := convert(x.hewindow_pos, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.muid);
         y(u downto u-w+1) := convert(x.muid, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdtseg_dest);
         y(u downto u-w+1) := convert(x.mdtseg_dest, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdtid);
         y(u downto u-w+1) := convert(x.mdtid, y(u downto u-w+1));
         u := u - w;
         w := width(x.vec_pos);
         y(u downto u-w+1) := convert(x.vec_pos, y(u downto u-w+1));
         u := u - w;
         w := width(x.vec_ang);
         y(u downto u-w+1) := convert(x.vec_ang, y(u downto u-w+1));
         u := u - w;
         w := width(x.hewindow_pos);
         y(u downto u-w+1) := convert(x.hewindow_pos, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: heg2sfslc_rt) return heg2sfslc_rt is
      variable y : heg2sfslc_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.muid);
         y.muid := convert(x(u to u+w-1), tpl.muid);
         u := u + w;
         w := width(tpl.mdtseg_dest);
         y.mdtseg_dest := convert(x(u to u+w-1), tpl.mdtseg_dest);
         u := u + w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u to u+w-1), tpl.mdtid);
         u := u + w;
         w := width(tpl.vec_pos);
         y.vec_pos := convert(x(u to u+w-1), tpl.vec_pos);
         u := u + w;
         w := width(tpl.vec_ang);
         y.vec_ang := convert(x(u to u+w-1), tpl.vec_ang);
         u := u + w;
         w := width(tpl.hewindow_pos);
         y.hewindow_pos := convert(x(u to u+w-1), tpl.hewindow_pos);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.muid);
         y.muid := convert(x(u downto u-w+1), tpl.muid);
         u := u - w;
         w := width(tpl.mdtseg_dest);
         y.mdtseg_dest := convert(x(u downto u-w+1), tpl.mdtseg_dest);
         u := u - w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u downto u-w+1), tpl.mdtid);
         u := u - w;
         w := width(tpl.vec_pos);
         y.vec_pos := convert(x(u downto u-w+1), tpl.vec_pos);
         u := u - w;
         w := width(tpl.vec_ang);
         y.vec_ang := convert(x(u downto u-w+1), tpl.vec_ang);
         u := u - w;
         w := width(tpl.hewindow_pos);
         y.hewindow_pos := convert(x(u downto u-w+1), tpl.hewindow_pos);
      end if;
      return y;
   end function convert;
   function zero(tpl: heg2sfslc_rt) return heg2sfslc_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: tar2hps_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.chamber_ieta);
      w := w + width(x.layer);
      w := w + width(x.tube);
      w := w + width(x.time);
      return w;
   end function width;
   function convert(x: tar2hps_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.chamber_ieta);
         y(u to u+w-1) := convert(x.chamber_ieta, y(u to u+w-1));
         u := u + w;
         w := width(x.layer);
         y(u to u+w-1) := convert(x.layer, y(u to u+w-1));
         u := u + w;
         w := width(x.tube);
         y(u to u+w-1) := convert(x.tube, y(u to u+w-1));
         u := u + w;
         w := width(x.time);
         y(u to u+w-1) := convert(x.time, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.chamber_ieta);
         y(u downto u-w+1) := convert(x.chamber_ieta, y(u downto u-w+1));
         u := u - w;
         w := width(x.layer);
         y(u downto u-w+1) := convert(x.layer, y(u downto u-w+1));
         u := u - w;
         w := width(x.tube);
         y(u downto u-w+1) := convert(x.tube, y(u downto u-w+1));
         u := u - w;
         w := width(x.time);
         y(u downto u-w+1) := convert(x.time, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: tar2hps_rt) return tar2hps_rt is
      variable y : tar2hps_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.chamber_ieta);
         y.chamber_ieta := convert(x(u to u+w-1), tpl.chamber_ieta);
         u := u + w;
         w := width(tpl.layer);
         y.layer := convert(x(u to u+w-1), tpl.layer);
         u := u + w;
         w := width(tpl.tube);
         y.tube := convert(x(u to u+w-1), tpl.tube);
         u := u + w;
         w := width(tpl.time);
         y.time := convert(x(u to u+w-1), tpl.time);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.chamber_ieta);
         y.chamber_ieta := convert(x(u downto u-w+1), tpl.chamber_ieta);
         u := u - w;
         w := width(tpl.layer);
         y.layer := convert(x(u downto u-w+1), tpl.layer);
         u := u - w;
         w := width(tpl.tube);
         y.tube := convert(x(u downto u-w+1), tpl.tube);
         u := u - w;
         w := width(tpl.time);
         y.time := convert(x(u downto u-w+1), tpl.time);
      end if;
      return y;
   end function convert;
   function zero(tpl: tar2hps_rt) return tar2hps_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: heg2sfhit_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.mlayer);
      w := w + width(x.localx);
      w := w + width(x.localy);
      w := w + width(x.radius);
      return w;
   end function width;
   function convert(x: heg2sfhit_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.mlayer);
         y(u to u+w-1) := convert(x.mlayer, y(u to u+w-1));
         u := u + w;
         w := width(x.localx);
         y(u to u+w-1) := convert(x.localx, y(u to u+w-1));
         u := u + w;
         w := width(x.localy);
         y(u to u+w-1) := convert(x.localy, y(u to u+w-1));
         u := u + w;
         w := width(x.radius);
         y(u to u+w-1) := convert(x.radius, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.mlayer);
         y(u downto u-w+1) := convert(x.mlayer, y(u downto u-w+1));
         u := u - w;
         w := width(x.localx);
         y(u downto u-w+1) := convert(x.localx, y(u downto u-w+1));
         u := u - w;
         w := width(x.localy);
         y(u downto u-w+1) := convert(x.localy, y(u downto u-w+1));
         u := u - w;
         w := width(x.radius);
         y(u downto u-w+1) := convert(x.radius, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: heg2sfhit_rt) return heg2sfhit_rt is
      variable y : heg2sfhit_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.mlayer);
         y.mlayer := convert(x(u to u+w-1), tpl.mlayer);
         u := u + w;
         w := width(tpl.localx);
         y.localx := convert(x(u to u+w-1), tpl.localx);
         u := u + w;
         w := width(tpl.localy);
         y.localy := convert(x(u to u+w-1), tpl.localy);
         u := u + w;
         w := width(tpl.radius);
         y.radius := convert(x(u to u+w-1), tpl.radius);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.mlayer);
         y.mlayer := convert(x(u downto u-w+1), tpl.mlayer);
         u := u - w;
         w := width(tpl.localx);
         y.localx := convert(x(u downto u-w+1), tpl.localx);
         u := u - w;
         w := width(tpl.localy);
         y.localy := convert(x(u downto u-w+1), tpl.localy);
         u := u - w;
         w := width(tpl.radius);
         y.radius := convert(x(u downto u-w+1), tpl.radius);
      end if;
      return y;
   end function convert;
   function zero(tpl: heg2sfhit_rt) return heg2sfhit_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: pl2ptcalc_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.muid);
      w := w + width(x.phimod);
      w := w + width(x.sl_charge);
      w := w + width(x.nswseg_poseta);
      w := w + width(x.nswseg_posphi);
      w := w + width(x.nswseg_angdtheta);
      return w;
   end function width;
   function convert(x: pl2ptcalc_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.muid);
         y(u to u+w-1) := convert(x.muid, y(u to u+w-1));
         u := u + w;
         w := width(x.phimod);
         y(u to u+w-1) := convert(x.phimod, y(u to u+w-1));
         u := u + w;
         w := width(x.sl_charge);
         y(u to u+w-1) := convert(x.sl_charge, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_poseta);
         y(u to u+w-1) := convert(x.nswseg_poseta, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_posphi);
         y(u to u+w-1) := convert(x.nswseg_posphi, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_angdtheta);
         y(u to u+w-1) := convert(x.nswseg_angdtheta, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.muid);
         y(u downto u-w+1) := convert(x.muid, y(u downto u-w+1));
         u := u - w;
         w := width(x.phimod);
         y(u downto u-w+1) := convert(x.phimod, y(u downto u-w+1));
         u := u - w;
         w := width(x.sl_charge);
         y(u downto u-w+1) := convert(x.sl_charge, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_poseta);
         y(u downto u-w+1) := convert(x.nswseg_poseta, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_posphi);
         y(u downto u-w+1) := convert(x.nswseg_posphi, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_angdtheta);
         y(u downto u-w+1) := convert(x.nswseg_angdtheta, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: pl2ptcalc_rt) return pl2ptcalc_rt is
      variable y : pl2ptcalc_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.muid);
         y.muid := convert(x(u to u+w-1), tpl.muid);
         u := u + w;
         w := width(tpl.phimod);
         y.phimod := convert(x(u to u+w-1), tpl.phimod);
         u := u + w;
         w := width(tpl.sl_charge);
         y.sl_charge := convert(x(u to u+w-1), tpl.sl_charge);
         u := u + w;
         w := width(tpl.nswseg_poseta);
         y.nswseg_poseta := convert(x(u to u+w-1), tpl.nswseg_poseta);
         u := u + w;
         w := width(tpl.nswseg_posphi);
         y.nswseg_posphi := convert(x(u to u+w-1), tpl.nswseg_posphi);
         u := u + w;
         w := width(tpl.nswseg_angdtheta);
         y.nswseg_angdtheta := convert(x(u to u+w-1), tpl.nswseg_angdtheta);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.muid);
         y.muid := convert(x(u downto u-w+1), tpl.muid);
         u := u - w;
         w := width(tpl.phimod);
         y.phimod := convert(x(u downto u-w+1), tpl.phimod);
         u := u - w;
         w := width(tpl.sl_charge);
         y.sl_charge := convert(x(u downto u-w+1), tpl.sl_charge);
         u := u - w;
         w := width(tpl.nswseg_poseta);
         y.nswseg_poseta := convert(x(u downto u-w+1), tpl.nswseg_poseta);
         u := u - w;
         w := width(tpl.nswseg_posphi);
         y.nswseg_posphi := convert(x(u downto u-w+1), tpl.nswseg_posphi);
         u := u - w;
         w := width(tpl.nswseg_angdtheta);
         y.nswseg_angdtheta := convert(x(u downto u-w+1), tpl.nswseg_angdtheta);
      end if;
      return y;
   end function convert;
   function zero(tpl: pl2ptcalc_rt) return pl2ptcalc_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: sf2ptcalc_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.muid);
      w := w + width(x.segpos);
      w := w + width(x.segangle);
      w := w + width(x.segquality);
      w := w + width(x.mdtid);
      return w;
   end function width;
   function convert(x: sf2ptcalc_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.muid);
         y(u to u+w-1) := convert(x.muid, y(u to u+w-1));
         u := u + w;
         w := width(x.segpos);
         y(u to u+w-1) := convert(x.segpos, y(u to u+w-1));
         u := u + w;
         w := width(x.segangle);
         y(u to u+w-1) := convert(x.segangle, y(u to u+w-1));
         u := u + w;
         w := width(x.segquality);
         y(u to u+w-1) := convert(x.segquality, y(u to u+w-1));
         u := u + w;
         w := width(x.mdtid);
         y(u to u+w-1) := convert(x.mdtid, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.muid);
         y(u downto u-w+1) := convert(x.muid, y(u downto u-w+1));
         u := u - w;
         w := width(x.segpos);
         y(u downto u-w+1) := convert(x.segpos, y(u downto u-w+1));
         u := u - w;
         w := width(x.segangle);
         y(u downto u-w+1) := convert(x.segangle, y(u downto u-w+1));
         u := u - w;
         w := width(x.segquality);
         y(u downto u-w+1) := convert(x.segquality, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdtid);
         y(u downto u-w+1) := convert(x.mdtid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: sf2ptcalc_rt) return sf2ptcalc_rt is
      variable y : sf2ptcalc_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.muid);
         y.muid := convert(x(u to u+w-1), tpl.muid);
         u := u + w;
         w := width(tpl.segpos);
         y.segpos := convert(x(u to u+w-1), tpl.segpos);
         u := u + w;
         w := width(tpl.segangle);
         y.segangle := convert(x(u to u+w-1), tpl.segangle);
         u := u + w;
         w := width(tpl.segquality);
         y.segquality := convert(x(u to u+w-1), tpl.segquality);
         u := u + w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u to u+w-1), tpl.mdtid);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.muid);
         y.muid := convert(x(u downto u-w+1), tpl.muid);
         u := u - w;
         w := width(tpl.segpos);
         y.segpos := convert(x(u downto u-w+1), tpl.segpos);
         u := u - w;
         w := width(tpl.segangle);
         y.segangle := convert(x(u downto u-w+1), tpl.segangle);
         u := u - w;
         w := width(tpl.segquality);
         y.segquality := convert(x(u downto u-w+1), tpl.segquality);
         u := u - w;
         w := width(tpl.mdtid);
         y.mdtid := convert(x(u downto u-w+1), tpl.mdtid);
      end if;
      return y;
   end function convert;
   function zero(tpl: sf2ptcalc_rt) return sf2ptcalc_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: ptcalc2mtc_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.muid);
      w := w + width(x.mdt_eta);
      w := w + width(x.mdt_pt);
      w := w + width(x.mdt_ptthresh);
      w := w + width(x.mdt_charge);
      w := w + width(x.mdt_nsegments);
      w := w + width(x.mdt_quality);
      return w;
   end function width;
   function convert(x: ptcalc2mtc_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.muid);
         y(u to u+w-1) := convert(x.muid, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_eta);
         y(u to u+w-1) := convert(x.mdt_eta, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_pt);
         y(u to u+w-1) := convert(x.mdt_pt, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_ptthresh);
         y(u to u+w-1) := convert(x.mdt_ptthresh, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_charge);
         y(u to u+w-1) := convert(x.mdt_charge, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_nsegments);
         y(u to u+w-1) := convert(x.mdt_nsegments, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_quality);
         y(u to u+w-1) := convert(x.mdt_quality, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.muid);
         y(u downto u-w+1) := convert(x.muid, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_eta);
         y(u downto u-w+1) := convert(x.mdt_eta, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_pt);
         y(u downto u-w+1) := convert(x.mdt_pt, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_ptthresh);
         y(u downto u-w+1) := convert(x.mdt_ptthresh, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_charge);
         y(u downto u-w+1) := convert(x.mdt_charge, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_nsegments);
         y(u downto u-w+1) := convert(x.mdt_nsegments, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_quality);
         y(u downto u-w+1) := convert(x.mdt_quality, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ptcalc2mtc_rt) return ptcalc2mtc_rt is
      variable y : ptcalc2mtc_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.muid);
         y.muid := convert(x(u to u+w-1), tpl.muid);
         u := u + w;
         w := width(tpl.mdt_eta);
         y.mdt_eta := convert(x(u to u+w-1), tpl.mdt_eta);
         u := u + w;
         w := width(tpl.mdt_pt);
         y.mdt_pt := convert(x(u to u+w-1), tpl.mdt_pt);
         u := u + w;
         w := width(tpl.mdt_ptthresh);
         y.mdt_ptthresh := convert(x(u to u+w-1), tpl.mdt_ptthresh);
         u := u + w;
         w := width(tpl.mdt_charge);
         y.mdt_charge := convert(x(u to u+w-1), tpl.mdt_charge);
         u := u + w;
         w := width(tpl.mdt_nsegments);
         y.mdt_nsegments := convert(x(u to u+w-1), tpl.mdt_nsegments);
         u := u + w;
         w := width(tpl.mdt_quality);
         y.mdt_quality := convert(x(u to u+w-1), tpl.mdt_quality);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.muid);
         y.muid := convert(x(u downto u-w+1), tpl.muid);
         u := u - w;
         w := width(tpl.mdt_eta);
         y.mdt_eta := convert(x(u downto u-w+1), tpl.mdt_eta);
         u := u - w;
         w := width(tpl.mdt_pt);
         y.mdt_pt := convert(x(u downto u-w+1), tpl.mdt_pt);
         u := u - w;
         w := width(tpl.mdt_ptthresh);
         y.mdt_ptthresh := convert(x(u downto u-w+1), tpl.mdt_ptthresh);
         u := u - w;
         w := width(tpl.mdt_charge);
         y.mdt_charge := convert(x(u downto u-w+1), tpl.mdt_charge);
         u := u - w;
         w := width(tpl.mdt_nsegments);
         y.mdt_nsegments := convert(x(u downto u-w+1), tpl.mdt_nsegments);
         u := u - w;
         w := width(tpl.mdt_quality);
         y.mdt_quality := convert(x(u downto u-w+1), tpl.mdt_quality);
      end if;
      return y;
   end function convert;
   function zero(tpl: ptcalc2mtc_rt) return ptcalc2mtc_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: pl2mtc_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.busy);
      w := w + width(x.process_ch);
      w := w + width(x.common);
      return w;
   end function width;
   function convert(x: pl2mtc_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.busy);
         y(u to u+w-1) := convert(x.busy, y(u to u+w-1));
         u := u + w;
         w := width(x.process_ch);
         y(u to u+w-1) := convert(x.process_ch, y(u to u+w-1));
         u := u + w;
         w := width(x.common);
         y(u to u+w-1) := convert(x.common, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.busy);
         y(u downto u-w+1) := convert(x.busy, y(u downto u-w+1));
         u := u - w;
         w := width(x.process_ch);
         y(u downto u-w+1) := convert(x.process_ch, y(u downto u-w+1));
         u := u - w;
         w := width(x.common);
         y(u downto u-w+1) := convert(x.common, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: pl2mtc_rt) return pl2mtc_rt is
      variable y : pl2mtc_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.busy);
         y.busy := convert(x(u to u+w-1), tpl.busy);
         u := u + w;
         w := width(tpl.process_ch);
         y.process_ch := convert(x(u to u+w-1), tpl.process_ch);
         u := u + w;
         w := width(tpl.common);
         y.common := convert(x(u to u+w-1), tpl.common);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.busy);
         y.busy := convert(x(u downto u-w+1), tpl.busy);
         u := u - w;
         w := width(tpl.process_ch);
         y.process_ch := convert(x(u downto u-w+1), tpl.process_ch);
         u := u - w;
         w := width(tpl.common);
         y.common := convert(x(u downto u-w+1), tpl.common);
      end if;
      return y;
   end function convert;
   function zero(tpl: pl2mtc_rt) return pl2mtc_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: mtc2sl_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.common);
      w := w + width(x.mdt_eta);
      w := w + width(x.mdt_pt);
      w := w + width(x.mdt_ptthresh);
      w := w + width(x.mdt_charge);
      w := w + width(x.mdt_procflags);
      w := w + width(x.mdt_nsegments);
      w := w + width(x.mdt_quality);
      w := w + width(x.m_reserved);
      return w;
   end function width;
   function convert(x: mtc2sl_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.common);
         y(u to u+w-1) := convert(x.common, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_eta);
         y(u to u+w-1) := convert(x.mdt_eta, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_pt);
         y(u to u+w-1) := convert(x.mdt_pt, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_ptthresh);
         y(u to u+w-1) := convert(x.mdt_ptthresh, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_charge);
         y(u to u+w-1) := convert(x.mdt_charge, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_procflags);
         y(u to u+w-1) := convert(x.mdt_procflags, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_nsegments);
         y(u to u+w-1) := convert(x.mdt_nsegments, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_quality);
         y(u to u+w-1) := convert(x.mdt_quality, y(u to u+w-1));
         u := u + w;
         w := width(x.m_reserved);
         y(u to u+w-1) := convert(x.m_reserved, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.common);
         y(u downto u-w+1) := convert(x.common, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_eta);
         y(u downto u-w+1) := convert(x.mdt_eta, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_pt);
         y(u downto u-w+1) := convert(x.mdt_pt, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_ptthresh);
         y(u downto u-w+1) := convert(x.mdt_ptthresh, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_charge);
         y(u downto u-w+1) := convert(x.mdt_charge, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_procflags);
         y(u downto u-w+1) := convert(x.mdt_procflags, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_nsegments);
         y(u downto u-w+1) := convert(x.mdt_nsegments, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_quality);
         y(u downto u-w+1) := convert(x.mdt_quality, y(u downto u-w+1));
         u := u - w;
         w := width(x.m_reserved);
         y(u downto u-w+1) := convert(x.m_reserved, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: mtc2sl_rt) return mtc2sl_rt is
      variable y : mtc2sl_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.common);
         y.common := convert(x(u to u+w-1), tpl.common);
         u := u + w;
         w := width(tpl.mdt_eta);
         y.mdt_eta := convert(x(u to u+w-1), tpl.mdt_eta);
         u := u + w;
         w := width(tpl.mdt_pt);
         y.mdt_pt := convert(x(u to u+w-1), tpl.mdt_pt);
         u := u + w;
         w := width(tpl.mdt_ptthresh);
         y.mdt_ptthresh := convert(x(u to u+w-1), tpl.mdt_ptthresh);
         u := u + w;
         w := width(tpl.mdt_charge);
         y.mdt_charge := convert(x(u to u+w-1), tpl.mdt_charge);
         u := u + w;
         w := width(tpl.mdt_procflags);
         y.mdt_procflags := convert(x(u to u+w-1), tpl.mdt_procflags);
         u := u + w;
         w := width(tpl.mdt_nsegments);
         y.mdt_nsegments := convert(x(u to u+w-1), tpl.mdt_nsegments);
         u := u + w;
         w := width(tpl.mdt_quality);
         y.mdt_quality := convert(x(u to u+w-1), tpl.mdt_quality);
         u := u + w;
         w := width(tpl.m_reserved);
         y.m_reserved := convert(x(u to u+w-1), tpl.m_reserved);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.common);
         y.common := convert(x(u downto u-w+1), tpl.common);
         u := u - w;
         w := width(tpl.mdt_eta);
         y.mdt_eta := convert(x(u downto u-w+1), tpl.mdt_eta);
         u := u - w;
         w := width(tpl.mdt_pt);
         y.mdt_pt := convert(x(u downto u-w+1), tpl.mdt_pt);
         u := u - w;
         w := width(tpl.mdt_ptthresh);
         y.mdt_ptthresh := convert(x(u downto u-w+1), tpl.mdt_ptthresh);
         u := u - w;
         w := width(tpl.mdt_charge);
         y.mdt_charge := convert(x(u downto u-w+1), tpl.mdt_charge);
         u := u - w;
         w := width(tpl.mdt_procflags);
         y.mdt_procflags := convert(x(u downto u-w+1), tpl.mdt_procflags);
         u := u - w;
         w := width(tpl.mdt_nsegments);
         y.mdt_nsegments := convert(x(u downto u-w+1), tpl.mdt_nsegments);
         u := u - w;
         w := width(tpl.mdt_quality);
         y.mdt_quality := convert(x(u downto u-w+1), tpl.mdt_quality);
         u := u - w;
         w := width(tpl.m_reserved);
         y.m_reserved := convert(x(u downto u-w+1), tpl.m_reserved);
      end if;
      return y;
   end function convert;
   function zero(tpl: mtc2sl_rt) return mtc2sl_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

end package body l0mdt_dataformats_pkg;
