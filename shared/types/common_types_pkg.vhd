-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;

package common_types_pkg is

  subtype bcid is unsigned(12-1 downto 0);

  subtype evid is unsigned(32-1 downto 0);

  subtype orid is unsigned(32-1 downto 0);

  type integer_bus is array(integer range <>) of integer;
  function len(x: integer_bus) return natural;
  function width(x: integer_bus) return natural;
  function vectorify(x: integer_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: integer_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: integer_bus) return integer_bus;
  function convert(x: std_logic_vector; t: integer_bus) return integer_bus;
  function nullify(x: integer_bus) return integer_bus;
  function zeroed(x: integer_bus) return integer_bus;

  type l0mdt_control is record
    clk : std_logic;
    rst : std_logic;
    bx : std_logic;
  end record l0mdt_control;
  function len(x: l0mdt_control) return natural;
  function width(x: l0mdt_control) return natural;
  function vectorify(x: l0mdt_control; t: std_logic_vector) return std_logic_vector;
  function convert(x: l0mdt_control; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: l0mdt_control) return l0mdt_control;
  function convert(x: in std_logic_vector; t: l0mdt_control) return l0mdt_control;
  function nullify(t: l0mdt_control) return l0mdt_control;
  function zeroed(t: l0mdt_control) return l0mdt_control;

  type l0mdt_ttc_rt is record
    bcr : std_logic;
    ocr : std_logic;
    ecr : std_logic;
    l0a : std_logic;
    l1a : std_logic;
    bcid : bcid;
    evid : evid;
    orid : orid;
  end record l0mdt_ttc_rt;
  function len(x: l0mdt_ttc_rt) return natural;
  function width(x: l0mdt_ttc_rt) return natural;
  function vectorify(x: l0mdt_ttc_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: l0mdt_ttc_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: l0mdt_ttc_rt) return l0mdt_ttc_rt;
  function convert(x: in std_logic_vector; t: l0mdt_ttc_rt) return l0mdt_ttc_rt;
  function nullify(t: l0mdt_ttc_rt) return l0mdt_ttc_rt;
  function zeroed(t: l0mdt_ttc_rt) return l0mdt_ttc_rt;

  subtype l0mdt_ttc_vt is std_logic_vector(81-1 downto 0);

  subtype slc_rx_vt is std_logic_vector(156-1 downto 0);

  type slc_rx_art is array(integer range <>) of slc_rx_rt;
  function len(x: slc_rx_art) return natural;
  function width(x: slc_rx_art) return natural;
  function vectorify(x: slc_rx_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_rx_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: slc_rx_art) return slc_rx_art;
  function convert(x: std_logic_vector; t: slc_rx_art) return slc_rx_art;
  function nullify(x: slc_rx_art) return slc_rx_art;
  function zeroed(x: slc_rx_art) return slc_rx_art;

  type slc_rx_avt is array(integer range <>) of slc_rx_vt;
  function len(x: slc_rx_avt) return natural;
  function width(x: slc_rx_avt) return natural;
  function vectorify(x: slc_rx_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_rx_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: slc_rx_avt) return slc_rx_avt;
  function convert(x: std_logic_vector; t: slc_rx_avt) return slc_rx_avt;
  function nullify(x: slc_rx_avt) return slc_rx_avt;
  function zeroed(x: slc_rx_avt) return slc_rx_avt;

  subtype slc_endcap_vt is std_logic_vector(48-1 downto 0);

  type slc_endcap_art is array(integer range <>) of slc_endcap_rt;
  function len(x: slc_endcap_art) return natural;
  function width(x: slc_endcap_art) return natural;
  function vectorify(x: slc_endcap_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_endcap_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: slc_endcap_art) return slc_endcap_art;
  function convert(x: std_logic_vector; t: slc_endcap_art) return slc_endcap_art;
  function nullify(x: slc_endcap_art) return slc_endcap_art;
  function zeroed(x: slc_endcap_art) return slc_endcap_art;

  type slc_endcap_avt is array(integer range <>) of slc_endcap_vt;
  function len(x: slc_endcap_avt) return natural;
  function width(x: slc_endcap_avt) return natural;
  function vectorify(x: slc_endcap_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_endcap_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: slc_endcap_avt) return slc_endcap_avt;
  function convert(x: std_logic_vector; t: slc_endcap_avt) return slc_endcap_avt;
  function nullify(x: slc_endcap_avt) return slc_endcap_avt;
  function zeroed(x: slc_endcap_avt) return slc_endcap_avt;

  subtype tdcpolmux2tar_vt is std_logic_vector(42-1 downto 0);

  type tdcpolmux2tar_art is array(integer range <>) of tdcpolmux2tar_rt;
  function len(x: tdcpolmux2tar_art) return natural;
  function width(x: tdcpolmux2tar_art) return natural;
  function vectorify(x: tdcpolmux2tar_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: tdcpolmux2tar_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: tdcpolmux2tar_art) return tdcpolmux2tar_art;
  function convert(x: std_logic_vector; t: tdcpolmux2tar_art) return tdcpolmux2tar_art;
  function nullify(x: tdcpolmux2tar_art) return tdcpolmux2tar_art;
  function zeroed(x: tdcpolmux2tar_art) return tdcpolmux2tar_art;

  type tdcpolmux2tar_avt is array(integer range <>) of tdcpolmux2tar_vt;
  function len(x: tdcpolmux2tar_avt) return natural;
  function width(x: tdcpolmux2tar_avt) return natural;
  function vectorify(x: tdcpolmux2tar_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: tdcpolmux2tar_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: tdcpolmux2tar_avt) return tdcpolmux2tar_avt;
  function convert(x: std_logic_vector; t: tdcpolmux2tar_avt) return tdcpolmux2tar_avt;
  function nullify(x: tdcpolmux2tar_avt) return tdcpolmux2tar_avt;
  function zeroed(x: tdcpolmux2tar_avt) return tdcpolmux2tar_avt;

  subtype tar2hps_vt is std_logic_vector(36-1 downto 0);

  type tar2hps_art is array(integer range <>) of tar2hps_rt;
  function len(x: tar2hps_art) return natural;
  function width(x: tar2hps_art) return natural;
  function vectorify(x: tar2hps_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: tar2hps_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: tar2hps_art) return tar2hps_art;
  function convert(x: std_logic_vector; t: tar2hps_art) return tar2hps_art;
  function nullify(x: tar2hps_art) return tar2hps_art;
  function zeroed(x: tar2hps_art) return tar2hps_art;

  type tar2hps_avt is array(integer range <>) of tar2hps_vt;
  function len(x: tar2hps_avt) return natural;
  function width(x: tar2hps_avt) return natural;
  function vectorify(x: tar2hps_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: tar2hps_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: tar2hps_avt) return tar2hps_avt;
  function convert(x: std_logic_vector; t: tar2hps_avt) return tar2hps_avt;
  function nullify(x: tar2hps_avt) return tar2hps_avt;
  function zeroed(x: tar2hps_avt) return tar2hps_avt;

  subtype ucm2hps_vt is std_logic_vector(58-1 downto 0);

  type ucm2hps_art is array(integer range <>) of ucm2hps_rt;
  function len(x: ucm2hps_art) return natural;
  function width(x: ucm2hps_art) return natural;
  function vectorify(x: ucm2hps_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm2hps_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm2hps_art) return ucm2hps_art;
  function convert(x: std_logic_vector; t: ucm2hps_art) return ucm2hps_art;
  function nullify(x: ucm2hps_art) return ucm2hps_art;
  function zeroed(x: ucm2hps_art) return ucm2hps_art;

  type ucm2hps_avt is array(integer range <>) of ucm2hps_vt;
  function len(x: ucm2hps_avt) return natural;
  function width(x: ucm2hps_avt) return natural;
  function vectorify(x: ucm2hps_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm2hps_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm2hps_avt) return ucm2hps_avt;
  function convert(x: std_logic_vector; t: ucm2hps_avt) return ucm2hps_avt;
  function nullify(x: ucm2hps_avt) return ucm2hps_avt;
  function zeroed(x: ucm2hps_avt) return ucm2hps_avt;

  subtype heg2sfslc_vt is std_logic_vector(77-1 downto 0);

  type heg2sfslc_art is array(integer range <>) of heg2sfslc_rt;
  function len(x: heg2sfslc_art) return natural;
  function width(x: heg2sfslc_art) return natural;
  function vectorify(x: heg2sfslc_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg2sfslc_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg2sfslc_art) return heg2sfslc_art;
  function convert(x: std_logic_vector; t: heg2sfslc_art) return heg2sfslc_art;
  function nullify(x: heg2sfslc_art) return heg2sfslc_art;
  function zeroed(x: heg2sfslc_art) return heg2sfslc_art;

  type heg2sfslc_avt is array(integer range <>) of heg2sfslc_vt;
  function len(x: heg2sfslc_avt) return natural;
  function width(x: heg2sfslc_avt) return natural;
  function vectorify(x: heg2sfslc_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg2sfslc_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg2sfslc_avt) return heg2sfslc_avt;
  function convert(x: std_logic_vector; t: heg2sfslc_avt) return heg2sfslc_avt;
  function nullify(x: heg2sfslc_avt) return heg2sfslc_avt;
  function zeroed(x: heg2sfslc_avt) return heg2sfslc_avt;

  subtype heg2sfhit_vt is std_logic_vector(41-1 downto 0);

  type heg2sfhit_art is array(integer range <>) of heg2sfhit_rt;
  function len(x: heg2sfhit_art) return natural;
  function width(x: heg2sfhit_art) return natural;
  function vectorify(x: heg2sfhit_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg2sfhit_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg2sfhit_art) return heg2sfhit_art;
  function convert(x: std_logic_vector; t: heg2sfhit_art) return heg2sfhit_art;
  function nullify(x: heg2sfhit_art) return heg2sfhit_art;
  function zeroed(x: heg2sfhit_art) return heg2sfhit_art;

  type heg2sfhit_avt is array(integer range <>) of heg2sfhit_vt;
  function len(x: heg2sfhit_avt) return natural;
  function width(x: heg2sfhit_avt) return natural;
  function vectorify(x: heg2sfhit_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg2sfhit_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg2sfhit_avt) return heg2sfhit_avt;
  function convert(x: std_logic_vector; t: heg2sfhit_avt) return heg2sfhit_avt;
  function nullify(x: heg2sfhit_avt) return heg2sfhit_avt;
  function zeroed(x: heg2sfhit_avt) return heg2sfhit_avt;

  subtype sf2ptcalc_vt is std_logic_vector(64-1 downto 0);

  type sf2ptcalc_art is array(integer range <>) of sf2ptcalc_rt;
  function len(x: sf2ptcalc_art) return natural;
  function width(x: sf2ptcalc_art) return natural;
  function vectorify(x: sf2ptcalc_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: sf2ptcalc_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: sf2ptcalc_art) return sf2ptcalc_art;
  function convert(x: std_logic_vector; t: sf2ptcalc_art) return sf2ptcalc_art;
  function nullify(x: sf2ptcalc_art) return sf2ptcalc_art;
  function zeroed(x: sf2ptcalc_art) return sf2ptcalc_art;

  type sf2ptcalc_avt is array(integer range <>) of sf2ptcalc_vt;
  function len(x: sf2ptcalc_avt) return natural;
  function width(x: sf2ptcalc_avt) return natural;
  function vectorify(x: sf2ptcalc_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: sf2ptcalc_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: sf2ptcalc_avt) return sf2ptcalc_avt;
  function convert(x: std_logic_vector; t: sf2ptcalc_avt) return sf2ptcalc_avt;
  function nullify(x: sf2ptcalc_avt) return sf2ptcalc_avt;
  function zeroed(x: sf2ptcalc_avt) return sf2ptcalc_avt;

  subtype ucm2pl_vt is std_logic_vector(148-1 downto 0);

  type ucm2pl_art is array(integer range <>) of ucm2pl_rt;
  function len(x: ucm2pl_art) return natural;
  function width(x: ucm2pl_art) return natural;
  function vectorify(x: ucm2pl_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm2pl_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm2pl_art) return ucm2pl_art;
  function convert(x: std_logic_vector; t: ucm2pl_art) return ucm2pl_art;
  function nullify(x: ucm2pl_art) return ucm2pl_art;
  function zeroed(x: ucm2pl_art) return ucm2pl_art;

  type ucm2pl_avt is array(integer range <>) of ucm2pl_vt;
  function len(x: ucm2pl_avt) return natural;
  function width(x: ucm2pl_avt) return natural;
  function vectorify(x: ucm2pl_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm2pl_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm2pl_avt) return ucm2pl_avt;
  function convert(x: std_logic_vector; t: ucm2pl_avt) return ucm2pl_avt;
  function nullify(x: ucm2pl_avt) return ucm2pl_avt;
  function zeroed(x: ucm2pl_avt) return ucm2pl_avt;

  subtype pl2pt_vt is std_logic_vector(58-1 downto 0);

  type pl2pt_art is array(integer range <>) of pl2ptcalc_rt;
  function len(x: pl2pt_art) return natural;
  function width(x: pl2pt_art) return natural;
  function vectorify(x: pl2pt_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: pl2pt_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: pl2pt_art) return pl2pt_art;
  function convert(x: std_logic_vector; t: pl2pt_art) return pl2pt_art;
  function nullify(x: pl2pt_art) return pl2pt_art;
  function zeroed(x: pl2pt_art) return pl2pt_art;

  type pl2pt_avt is array(integer range <>) of pl2pt_vt;
  function len(x: pl2pt_avt) return natural;
  function width(x: pl2pt_avt) return natural;
  function vectorify(x: pl2pt_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: pl2pt_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: pl2pt_avt) return pl2pt_avt;
  function convert(x: std_logic_vector; t: pl2pt_avt) return pl2pt_avt;
  function nullify(x: pl2pt_avt) return pl2pt_avt;
  function zeroed(x: pl2pt_avt) return pl2pt_avt;

  subtype pl2mtc_vt is std_logic_vector(113-1 downto 0);

  type pl2mtc_art is array(integer range <>) of pl2mtc_rt;
  function len(x: pl2mtc_art) return natural;
  function width(x: pl2mtc_art) return natural;
  function vectorify(x: pl2mtc_art; t: std_logic_vector) return std_logic_vector;
  function convert(x: pl2mtc_art; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: pl2mtc_art) return pl2mtc_art;
  function convert(x: std_logic_vector; t: pl2mtc_art) return pl2mtc_art;
  function nullify(x: pl2mtc_art) return pl2mtc_art;
  function zeroed(x: pl2mtc_art) return pl2mtc_art;

  type pl2mtc_avt is array(integer range <>) of pl2mtc_vt;
  function len(x: pl2mtc_avt) return natural;
  function width(x: pl2mtc_avt) return natural;
  function vectorify(x: pl2mtc_avt; t: std_logic_vector) return std_logic_vector;
  function convert(x: pl2mtc_avt; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: pl2mtc_avt) return pl2mtc_avt;
  function convert(x: std_logic_vector; t: pl2mtc_avt) return pl2mtc_avt;
  function nullify(x: pl2mtc_avt) return pl2mtc_avt;
  function zeroed(x: pl2mtc_avt) return pl2mtc_avt;

  type tf2mtc_bus is array(integer range <>) of ptcalc2mtc_rt;
  function len(x: tf2mtc_bus) return natural;
  function width(x: tf2mtc_bus) return natural;
  function vectorify(x: tf2mtc_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: tf2mtc_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: tf2mtc_bus) return tf2mtc_bus;
  function convert(x: std_logic_vector; t: tf2mtc_bus) return tf2mtc_bus;
  function nullify(x: tf2mtc_bus) return tf2mtc_bus;
  function zeroed(x: tf2mtc_bus) return tf2mtc_bus;

  type mtc_out_bus is array(integer range <>) of mtc2sl_rt;
  function len(x: mtc_out_bus) return natural;
  function width(x: mtc_out_bus) return natural;
  function vectorify(x: mtc_out_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: mtc_out_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: mtc_out_bus) return mtc_out_bus;
  function convert(x: std_logic_vector; t: mtc_out_bus) return mtc_out_bus;
  function nullify(x: mtc_out_bus) return mtc_out_bus;
  function zeroed(x: mtc_out_bus) return mtc_out_bus;

  type mtc2nsp_bus is array(integer range <>) of mtc2sl_rt;
  function len(x: mtc2nsp_bus) return natural;
  function width(x: mtc2nsp_bus) return natural;
  function vectorify(x: mtc2nsp_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: mtc2nsp_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: mtc2nsp_bus) return mtc2nsp_bus;
  function convert(x: std_logic_vector; t: mtc2nsp_bus) return mtc2nsp_bus;
  function nullify(x: mtc2nsp_bus) return mtc2nsp_bus;
  function zeroed(x: mtc2nsp_bus) return mtc2nsp_bus;

  subtype felix_data is std_logic_vector(250-1 downto 0);

  type felix_stream is record
    valid : std_logic;
    data : felix_data;
  end record felix_stream;
  function len(x: felix_stream) return natural;
  function width(x: felix_stream) return natural;
  function vectorify(x: felix_stream; t: std_logic_vector) return std_logic_vector;
  function convert(x: felix_stream; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: felix_stream) return felix_stream;
  function convert(x: in std_logic_vector; t: felix_stream) return felix_stream;
  function nullify(t: felix_stream) return felix_stream;
  function zeroed(t: felix_stream) return felix_stream;

  type felix_stream_bus is array(integer range <>) of felix_stream;
  function len(x: felix_stream_bus) return natural;
  function width(x: felix_stream_bus) return natural;
  function vectorify(x: felix_stream_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: felix_stream_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: felix_stream_bus) return felix_stream_bus;
  function convert(x: std_logic_vector; t: felix_stream_bus) return felix_stream_bus;
  function nullify(x: felix_stream_bus) return felix_stream_bus;
  function zeroed(x: felix_stream_bus) return felix_stream_bus;

end package common_types_pkg;

------------------------------------------------------------

package body common_types_pkg is

  function len(x: integer_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * 32;
    return l;
  end function len;
  function width(x: integer_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * 32;
    return l;
  end function width;
  function vectorify(x: integer_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: integer_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: integer_bus) return integer_bus is
    variable y : integer_bus(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: integer_bus) return integer_bus is
    variable y : integer_bus(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: integer_bus) return integer_bus is
    variable y : integer_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: integer_bus) return integer_bus is
    variable y : integer_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: l0mdt_control) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.clk);
    l := l + len(x.rst);
    l := l + len(x.bx);
    return l;
  end function len;
  function width(x: l0mdt_control) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.clk);
    l := l + width(x.rst);
    l := l + width(x.bx);
    return l;
  end function width;
  function vectorify(x: l0mdt_control; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.clk)-1), vectorify(x.clk, y(left to left+len(x.clk)-1)));
      left := left + len(x.clk);
      assign(y(left to left+len(x.rst)-1), vectorify(x.rst, y(left to left+len(x.rst)-1)));
      left := left + len(x.rst);
      assign(y(left to left+len(x.bx)-1), vectorify(x.bx, y(left to left+len(x.bx)-1)));
    else
      assign(y(left downto left-len(x.clk)+1), vectorify(x.clk, y(left downto left-len(x.clk)+1)));
      left := left - len(x.clk);
      assign(y(left downto left-len(x.rst)+1), vectorify(x.rst, y(left downto left-len(x.rst)+1)));
      left := left - len(x.rst);
      assign(y(left downto left-len(x.bx)+1), vectorify(x.bx, y(left downto left-len(x.bx)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: l0mdt_control; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.clk)-1), convert(x.clk, y(left to left+len(x.clk)-1)));
      left := left + len(x.clk);
      assign(y(left to left+len(x.rst)-1), convert(x.rst, y(left to left+len(x.rst)-1)));
      left := left + len(x.rst);
      assign(y(left to left+len(x.bx)-1), convert(x.bx, y(left to left+len(x.bx)-1)));
    else
      assign(y(left downto left-len(x.clk)+1), convert(x.clk, y(left downto left-len(x.clk)+1)));
      left := left - len(x.clk);
      assign(y(left downto left-len(x.rst)+1), convert(x.rst, y(left downto left-len(x.rst)+1)));
      left := left - len(x.rst);
      assign(y(left downto left-len(x.bx)+1), convert(x.bx, y(left downto left-len(x.bx)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: l0mdt_control) return l0mdt_control is
    variable y: l0mdt_control;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.clk := structify(x(left to left+len(y.clk)-1), y.clk);
      left := left + len(y.clk);
      y.rst := structify(x(left to left+len(y.rst)-1), y.rst);
      left := left + len(y.rst);
      y.bx := structify(x(left to left+len(y.bx)-1), y.bx);
    else
      y.clk := structify(x(left downto left-len(y.clk)+1), y.clk);
      left := left - len(y.clk);
      y.rst := structify(x(left downto left-len(y.rst)+1), y.rst);
      left := left - len(y.rst);
      y.bx := structify(x(left downto left-len(y.bx)+1), y.bx);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: l0mdt_control) return l0mdt_control is
    variable y: l0mdt_control;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.clk := convert(x(left to left+len(y.clk)-1), y.clk);
      left := left + len(y.clk);
      y.rst := convert(x(left to left+len(y.rst)-1), y.rst);
      left := left + len(y.rst);
      y.bx := convert(x(left to left+len(y.bx)-1), y.bx);
    else
      y.clk := convert(x(left downto left-len(y.clk)+1), y.clk);
      left := left - len(y.clk);
      y.rst := convert(x(left downto left-len(y.rst)+1), y.rst);
      left := left - len(y.rst);
      y.bx := convert(x(left downto left-len(y.bx)+1), y.bx);
    end if;
    return y;
  end function convert;
  function nullify(t: l0mdt_control) return l0mdt_control is
  variable y: l0mdt_control;
  begin
    y.clk := nullify(t.clk);
    y.rst := nullify(t.rst);
    y.bx := nullify(t.bx);
    return y;
  end function nullify;
  function zeroed(t: l0mdt_control) return l0mdt_control is
  variable y: l0mdt_control;
  begin
    y.clk := zeroed(t.clk);
    y.rst := zeroed(t.rst);
    y.bx := zeroed(t.bx);
    return y;
  end function zeroed;

  function len(x: l0mdt_ttc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.bcr);
    l := l + len(x.ocr);
    l := l + len(x.ecr);
    l := l + len(x.l0a);
    l := l + len(x.l1a);
    l := l + len(x.bcid);
    l := l + len(x.evid);
    l := l + len(x.orid);
    return l;
  end function len;
  function width(x: l0mdt_ttc_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.bcr);
    l := l + width(x.ocr);
    l := l + width(x.ecr);
    l := l + width(x.l0a);
    l := l + width(x.l1a);
    l := l + width(x.bcid);
    l := l + width(x.evid);
    l := l + width(x.orid);
    return l;
  end function width;
  function vectorify(x: l0mdt_ttc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcr)-1), vectorify(x.bcr, y(left to left+len(x.bcr)-1)));
      left := left + len(x.bcr);
      assign(y(left to left+len(x.ocr)-1), vectorify(x.ocr, y(left to left+len(x.ocr)-1)));
      left := left + len(x.ocr);
      assign(y(left to left+len(x.ecr)-1), vectorify(x.ecr, y(left to left+len(x.ecr)-1)));
      left := left + len(x.ecr);
      assign(y(left to left+len(x.l0a)-1), vectorify(x.l0a, y(left to left+len(x.l0a)-1)));
      left := left + len(x.l0a);
      assign(y(left to left+len(x.l1a)-1), vectorify(x.l1a, y(left to left+len(x.l1a)-1)));
      left := left + len(x.l1a);
      assign(y(left to left+len(x.bcid)-1), vectorify(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.evid)-1), vectorify(x.evid, y(left to left+len(x.evid)-1)));
      left := left + len(x.evid);
      assign(y(left to left+len(x.orid)-1), vectorify(x.orid, y(left to left+len(x.orid)-1)));
    else
      assign(y(left downto left-len(x.bcr)+1), vectorify(x.bcr, y(left downto left-len(x.bcr)+1)));
      left := left - len(x.bcr);
      assign(y(left downto left-len(x.ocr)+1), vectorify(x.ocr, y(left downto left-len(x.ocr)+1)));
      left := left - len(x.ocr);
      assign(y(left downto left-len(x.ecr)+1), vectorify(x.ecr, y(left downto left-len(x.ecr)+1)));
      left := left - len(x.ecr);
      assign(y(left downto left-len(x.l0a)+1), vectorify(x.l0a, y(left downto left-len(x.l0a)+1)));
      left := left - len(x.l0a);
      assign(y(left downto left-len(x.l1a)+1), vectorify(x.l1a, y(left downto left-len(x.l1a)+1)));
      left := left - len(x.l1a);
      assign(y(left downto left-len(x.bcid)+1), vectorify(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.evid)+1), vectorify(x.evid, y(left downto left-len(x.evid)+1)));
      left := left - len(x.evid);
      assign(y(left downto left-len(x.orid)+1), vectorify(x.orid, y(left downto left-len(x.orid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: l0mdt_ttc_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcr)-1), convert(x.bcr, y(left to left+len(x.bcr)-1)));
      left := left + len(x.bcr);
      assign(y(left to left+len(x.ocr)-1), convert(x.ocr, y(left to left+len(x.ocr)-1)));
      left := left + len(x.ocr);
      assign(y(left to left+len(x.ecr)-1), convert(x.ecr, y(left to left+len(x.ecr)-1)));
      left := left + len(x.ecr);
      assign(y(left to left+len(x.l0a)-1), convert(x.l0a, y(left to left+len(x.l0a)-1)));
      left := left + len(x.l0a);
      assign(y(left to left+len(x.l1a)-1), convert(x.l1a, y(left to left+len(x.l1a)-1)));
      left := left + len(x.l1a);
      assign(y(left to left+len(x.bcid)-1), convert(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.evid)-1), convert(x.evid, y(left to left+len(x.evid)-1)));
      left := left + len(x.evid);
      assign(y(left to left+len(x.orid)-1), convert(x.orid, y(left to left+len(x.orid)-1)));
    else
      assign(y(left downto left-len(x.bcr)+1), convert(x.bcr, y(left downto left-len(x.bcr)+1)));
      left := left - len(x.bcr);
      assign(y(left downto left-len(x.ocr)+1), convert(x.ocr, y(left downto left-len(x.ocr)+1)));
      left := left - len(x.ocr);
      assign(y(left downto left-len(x.ecr)+1), convert(x.ecr, y(left downto left-len(x.ecr)+1)));
      left := left - len(x.ecr);
      assign(y(left downto left-len(x.l0a)+1), convert(x.l0a, y(left downto left-len(x.l0a)+1)));
      left := left - len(x.l0a);
      assign(y(left downto left-len(x.l1a)+1), convert(x.l1a, y(left downto left-len(x.l1a)+1)));
      left := left - len(x.l1a);
      assign(y(left downto left-len(x.bcid)+1), convert(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.evid)+1), convert(x.evid, y(left downto left-len(x.evid)+1)));
      left := left - len(x.evid);
      assign(y(left downto left-len(x.orid)+1), convert(x.orid, y(left downto left-len(x.orid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: l0mdt_ttc_rt) return l0mdt_ttc_rt is
    variable y: l0mdt_ttc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcr := structify(x(left to left+len(y.bcr)-1), y.bcr);
      left := left + len(y.bcr);
      y.ocr := structify(x(left to left+len(y.ocr)-1), y.ocr);
      left := left + len(y.ocr);
      y.ecr := structify(x(left to left+len(y.ecr)-1), y.ecr);
      left := left + len(y.ecr);
      y.l0a := structify(x(left to left+len(y.l0a)-1), y.l0a);
      left := left + len(y.l0a);
      y.l1a := structify(x(left to left+len(y.l1a)-1), y.l1a);
      left := left + len(y.l1a);
      y.bcid := structify(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.evid := structify(x(left to left+len(y.evid)-1), y.evid);
      left := left + len(y.evid);
      y.orid := structify(x(left to left+len(y.orid)-1), y.orid);
    else
      y.bcr := structify(x(left downto left-len(y.bcr)+1), y.bcr);
      left := left - len(y.bcr);
      y.ocr := structify(x(left downto left-len(y.ocr)+1), y.ocr);
      left := left - len(y.ocr);
      y.ecr := structify(x(left downto left-len(y.ecr)+1), y.ecr);
      left := left - len(y.ecr);
      y.l0a := structify(x(left downto left-len(y.l0a)+1), y.l0a);
      left := left - len(y.l0a);
      y.l1a := structify(x(left downto left-len(y.l1a)+1), y.l1a);
      left := left - len(y.l1a);
      y.bcid := structify(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.evid := structify(x(left downto left-len(y.evid)+1), y.evid);
      left := left - len(y.evid);
      y.orid := structify(x(left downto left-len(y.orid)+1), y.orid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: l0mdt_ttc_rt) return l0mdt_ttc_rt is
    variable y: l0mdt_ttc_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcr := convert(x(left to left+len(y.bcr)-1), y.bcr);
      left := left + len(y.bcr);
      y.ocr := convert(x(left to left+len(y.ocr)-1), y.ocr);
      left := left + len(y.ocr);
      y.ecr := convert(x(left to left+len(y.ecr)-1), y.ecr);
      left := left + len(y.ecr);
      y.l0a := convert(x(left to left+len(y.l0a)-1), y.l0a);
      left := left + len(y.l0a);
      y.l1a := convert(x(left to left+len(y.l1a)-1), y.l1a);
      left := left + len(y.l1a);
      y.bcid := convert(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.evid := convert(x(left to left+len(y.evid)-1), y.evid);
      left := left + len(y.evid);
      y.orid := convert(x(left to left+len(y.orid)-1), y.orid);
    else
      y.bcr := convert(x(left downto left-len(y.bcr)+1), y.bcr);
      left := left - len(y.bcr);
      y.ocr := convert(x(left downto left-len(y.ocr)+1), y.ocr);
      left := left - len(y.ocr);
      y.ecr := convert(x(left downto left-len(y.ecr)+1), y.ecr);
      left := left - len(y.ecr);
      y.l0a := convert(x(left downto left-len(y.l0a)+1), y.l0a);
      left := left - len(y.l0a);
      y.l1a := convert(x(left downto left-len(y.l1a)+1), y.l1a);
      left := left - len(y.l1a);
      y.bcid := convert(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.evid := convert(x(left downto left-len(y.evid)+1), y.evid);
      left := left - len(y.evid);
      y.orid := convert(x(left downto left-len(y.orid)+1), y.orid);
    end if;
    return y;
  end function convert;
  function nullify(t: l0mdt_ttc_rt) return l0mdt_ttc_rt is
  variable y: l0mdt_ttc_rt;
  begin
    y.bcr := nullify(t.bcr);
    y.ocr := nullify(t.ocr);
    y.ecr := nullify(t.ecr);
    y.l0a := nullify(t.l0a);
    y.l1a := nullify(t.l1a);
    y.bcid := nullify(t.bcid);
    y.evid := nullify(t.evid);
    y.orid := nullify(t.orid);
    return y;
  end function nullify;
  function zeroed(t: l0mdt_ttc_rt) return l0mdt_ttc_rt is
  variable y: l0mdt_ttc_rt;
  begin
    y.bcr := zeroed(t.bcr);
    y.ocr := zeroed(t.ocr);
    y.ecr := zeroed(t.ecr);
    y.l0a := zeroed(t.l0a);
    y.l1a := zeroed(t.l1a);
    y.bcid := zeroed(t.bcid);
    y.evid := zeroed(t.evid);
    y.orid := zeroed(t.orid);
    return y;
  end function zeroed;

  function len(x: slc_rx_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: slc_rx_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: slc_rx_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_rx_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: slc_rx_art) return slc_rx_art is
    variable y : slc_rx_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: slc_rx_art) return slc_rx_art is
    variable y : slc_rx_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: slc_rx_art) return slc_rx_art is
    variable y : slc_rx_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: slc_rx_art) return slc_rx_art is
    variable y : slc_rx_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: slc_rx_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: slc_rx_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: slc_rx_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_rx_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: slc_rx_avt) return slc_rx_avt is
    variable y : slc_rx_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: slc_rx_avt) return slc_rx_avt is
    variable y : slc_rx_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: slc_rx_avt) return slc_rx_avt is
    variable y : slc_rx_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: slc_rx_avt) return slc_rx_avt is
    variable y : slc_rx_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: slc_endcap_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: slc_endcap_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: slc_endcap_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_endcap_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: slc_endcap_art) return slc_endcap_art is
    variable y : slc_endcap_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: slc_endcap_art) return slc_endcap_art is
    variable y : slc_endcap_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: slc_endcap_art) return slc_endcap_art is
    variable y : slc_endcap_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: slc_endcap_art) return slc_endcap_art is
    variable y : slc_endcap_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: slc_endcap_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: slc_endcap_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: slc_endcap_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_endcap_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: slc_endcap_avt) return slc_endcap_avt is
    variable y : slc_endcap_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: slc_endcap_avt) return slc_endcap_avt is
    variable y : slc_endcap_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: slc_endcap_avt) return slc_endcap_avt is
    variable y : slc_endcap_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: slc_endcap_avt) return slc_endcap_avt is
    variable y : slc_endcap_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: tdcpolmux2tar_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: tdcpolmux2tar_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: tdcpolmux2tar_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: tdcpolmux2tar_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: tdcpolmux2tar_art) return tdcpolmux2tar_art is
    variable y : tdcpolmux2tar_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: tdcpolmux2tar_art) return tdcpolmux2tar_art is
    variable y : tdcpolmux2tar_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: tdcpolmux2tar_art) return tdcpolmux2tar_art is
    variable y : tdcpolmux2tar_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: tdcpolmux2tar_art) return tdcpolmux2tar_art is
    variable y : tdcpolmux2tar_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: tdcpolmux2tar_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: tdcpolmux2tar_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: tdcpolmux2tar_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: tdcpolmux2tar_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: tdcpolmux2tar_avt) return tdcpolmux2tar_avt is
    variable y : tdcpolmux2tar_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: tdcpolmux2tar_avt) return tdcpolmux2tar_avt is
    variable y : tdcpolmux2tar_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: tdcpolmux2tar_avt) return tdcpolmux2tar_avt is
    variable y : tdcpolmux2tar_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: tdcpolmux2tar_avt) return tdcpolmux2tar_avt is
    variable y : tdcpolmux2tar_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: tar2hps_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: tar2hps_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: tar2hps_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: tar2hps_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: tar2hps_art) return tar2hps_art is
    variable y : tar2hps_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: tar2hps_art) return tar2hps_art is
    variable y : tar2hps_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: tar2hps_art) return tar2hps_art is
    variable y : tar2hps_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: tar2hps_art) return tar2hps_art is
    variable y : tar2hps_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: tar2hps_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: tar2hps_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: tar2hps_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: tar2hps_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: tar2hps_avt) return tar2hps_avt is
    variable y : tar2hps_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: tar2hps_avt) return tar2hps_avt is
    variable y : tar2hps_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: tar2hps_avt) return tar2hps_avt is
    variable y : tar2hps_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: tar2hps_avt) return tar2hps_avt is
    variable y : tar2hps_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm2hps_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm2hps_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm2hps_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm2hps_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm2hps_art) return ucm2hps_art is
    variable y : ucm2hps_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm2hps_art) return ucm2hps_art is
    variable y : ucm2hps_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm2hps_art) return ucm2hps_art is
    variable y : ucm2hps_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm2hps_art) return ucm2hps_art is
    variable y : ucm2hps_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm2hps_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm2hps_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm2hps_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm2hps_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm2hps_avt) return ucm2hps_avt is
    variable y : ucm2hps_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm2hps_avt) return ucm2hps_avt is
    variable y : ucm2hps_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm2hps_avt) return ucm2hps_avt is
    variable y : ucm2hps_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm2hps_avt) return ucm2hps_avt is
    variable y : ucm2hps_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg2sfslc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg2sfslc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg2sfslc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg2sfslc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg2sfslc_art) return heg2sfslc_art is
    variable y : heg2sfslc_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg2sfslc_art) return heg2sfslc_art is
    variable y : heg2sfslc_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg2sfslc_art) return heg2sfslc_art is
    variable y : heg2sfslc_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg2sfslc_art) return heg2sfslc_art is
    variable y : heg2sfslc_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg2sfslc_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg2sfslc_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg2sfslc_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg2sfslc_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg2sfslc_avt) return heg2sfslc_avt is
    variable y : heg2sfslc_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg2sfslc_avt) return heg2sfslc_avt is
    variable y : heg2sfslc_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg2sfslc_avt) return heg2sfslc_avt is
    variable y : heg2sfslc_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg2sfslc_avt) return heg2sfslc_avt is
    variable y : heg2sfslc_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg2sfhit_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg2sfhit_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg2sfhit_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg2sfhit_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg2sfhit_art) return heg2sfhit_art is
    variable y : heg2sfhit_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg2sfhit_art) return heg2sfhit_art is
    variable y : heg2sfhit_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg2sfhit_art) return heg2sfhit_art is
    variable y : heg2sfhit_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg2sfhit_art) return heg2sfhit_art is
    variable y : heg2sfhit_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg2sfhit_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg2sfhit_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg2sfhit_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg2sfhit_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg2sfhit_avt) return heg2sfhit_avt is
    variable y : heg2sfhit_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg2sfhit_avt) return heg2sfhit_avt is
    variable y : heg2sfhit_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg2sfhit_avt) return heg2sfhit_avt is
    variable y : heg2sfhit_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg2sfhit_avt) return heg2sfhit_avt is
    variable y : heg2sfhit_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: sf2ptcalc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: sf2ptcalc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: sf2ptcalc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: sf2ptcalc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: sf2ptcalc_art) return sf2ptcalc_art is
    variable y : sf2ptcalc_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: sf2ptcalc_art) return sf2ptcalc_art is
    variable y : sf2ptcalc_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: sf2ptcalc_art) return sf2ptcalc_art is
    variable y : sf2ptcalc_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: sf2ptcalc_art) return sf2ptcalc_art is
    variable y : sf2ptcalc_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: sf2ptcalc_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: sf2ptcalc_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: sf2ptcalc_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: sf2ptcalc_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: sf2ptcalc_avt) return sf2ptcalc_avt is
    variable y : sf2ptcalc_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: sf2ptcalc_avt) return sf2ptcalc_avt is
    variable y : sf2ptcalc_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: sf2ptcalc_avt) return sf2ptcalc_avt is
    variable y : sf2ptcalc_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: sf2ptcalc_avt) return sf2ptcalc_avt is
    variable y : sf2ptcalc_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm2pl_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm2pl_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm2pl_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm2pl_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm2pl_art) return ucm2pl_art is
    variable y : ucm2pl_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm2pl_art) return ucm2pl_art is
    variable y : ucm2pl_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm2pl_art) return ucm2pl_art is
    variable y : ucm2pl_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm2pl_art) return ucm2pl_art is
    variable y : ucm2pl_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm2pl_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm2pl_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm2pl_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm2pl_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm2pl_avt) return ucm2pl_avt is
    variable y : ucm2pl_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm2pl_avt) return ucm2pl_avt is
    variable y : ucm2pl_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm2pl_avt) return ucm2pl_avt is
    variable y : ucm2pl_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm2pl_avt) return ucm2pl_avt is
    variable y : ucm2pl_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: pl2pt_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: pl2pt_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: pl2pt_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: pl2pt_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: pl2pt_art) return pl2pt_art is
    variable y : pl2pt_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: pl2pt_art) return pl2pt_art is
    variable y : pl2pt_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: pl2pt_art) return pl2pt_art is
    variable y : pl2pt_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: pl2pt_art) return pl2pt_art is
    variable y : pl2pt_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: pl2pt_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: pl2pt_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: pl2pt_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: pl2pt_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: pl2pt_avt) return pl2pt_avt is
    variable y : pl2pt_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: pl2pt_avt) return pl2pt_avt is
    variable y : pl2pt_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: pl2pt_avt) return pl2pt_avt is
    variable y : pl2pt_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: pl2pt_avt) return pl2pt_avt is
    variable y : pl2pt_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: pl2mtc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: pl2mtc_art) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: pl2mtc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: pl2mtc_art; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: pl2mtc_art) return pl2mtc_art is
    variable y : pl2mtc_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: pl2mtc_art) return pl2mtc_art is
    variable y : pl2mtc_art(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: pl2mtc_art) return pl2mtc_art is
    variable y : pl2mtc_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: pl2mtc_art) return pl2mtc_art is
    variable y : pl2mtc_art(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: pl2mtc_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: pl2mtc_avt) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: pl2mtc_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: pl2mtc_avt; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: pl2mtc_avt) return pl2mtc_avt is
    variable y : pl2mtc_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: pl2mtc_avt) return pl2mtc_avt is
    variable y : pl2mtc_avt(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: pl2mtc_avt) return pl2mtc_avt is
    variable y : pl2mtc_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: pl2mtc_avt) return pl2mtc_avt is
    variable y : pl2mtc_avt(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: tf2mtc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: tf2mtc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: tf2mtc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: tf2mtc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: tf2mtc_bus) return tf2mtc_bus is
    variable y : tf2mtc_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: tf2mtc_bus) return tf2mtc_bus is
    variable y : tf2mtc_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: tf2mtc_bus) return tf2mtc_bus is
    variable y : tf2mtc_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: tf2mtc_bus) return tf2mtc_bus is
    variable y : tf2mtc_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: mtc_out_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: mtc_out_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: mtc_out_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: mtc_out_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: mtc_out_bus) return mtc_out_bus is
    variable y : mtc_out_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: mtc_out_bus) return mtc_out_bus is
    variable y : mtc_out_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: mtc_out_bus) return mtc_out_bus is
    variable y : mtc_out_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: mtc_out_bus) return mtc_out_bus is
    variable y : mtc_out_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: mtc2nsp_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: mtc2nsp_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: mtc2nsp_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: mtc2nsp_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: mtc2nsp_bus) return mtc2nsp_bus is
    variable y : mtc2nsp_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: mtc2nsp_bus) return mtc2nsp_bus is
    variable y : mtc2nsp_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: mtc2nsp_bus) return mtc2nsp_bus is
    variable y : mtc2nsp_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: mtc2nsp_bus) return mtc2nsp_bus is
    variable y : mtc2nsp_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: felix_stream) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.valid);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: felix_stream) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.valid);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: felix_stream; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), vectorify(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), vectorify(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: felix_stream; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), convert(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), convert(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: felix_stream) return felix_stream is
    variable y: felix_stream;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := structify(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.valid := structify(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: felix_stream) return felix_stream is
    variable y: felix_stream;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := convert(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.valid := convert(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: felix_stream) return felix_stream is
  variable y: felix_stream;
  begin
    y.valid := nullify(t.valid);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: felix_stream) return felix_stream is
  variable y: felix_stream;
  begin
    y.valid := zeroed(t.valid);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: felix_stream_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: felix_stream_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: felix_stream_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: felix_stream_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: felix_stream_bus) return felix_stream_bus is
    variable y : felix_stream_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: felix_stream_bus) return felix_stream_bus is
    variable y : felix_stream_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: felix_stream_bus) return felix_stream_bus is
    variable y : felix_stream_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: felix_stream_bus) return felix_stream_bus is
    variable y : felix_stream_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

end package body common_types_pkg;
