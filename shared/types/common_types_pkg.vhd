-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library shared_lib;

use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;

package common_types_pkg is

  subtype bcid is unsigned(12-1 downto 0);

  subtype evid is unsigned(32-1 downto 0);

  subtype orid is unsigned(32-1 downto 0);

  type integer_bus is array(integer range <>) of integer;
  function len(x: integer_bus) return natural;
  function width(x: integer_bus) return natural;
  function vectorify(x: integer_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: integer_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: integer_bus) return integer_bus;
  function convert(x: std_logic_vector; t: integer_bus) return integer_bus;
  function nullify(x: integer_bus) return integer_bus;
  function zeroed(x: integer_bus) return integer_bus;

  type l0mdt_control is record
    clk : std_logic;
    rst : std_logic;
    bx : std_logic;
  end record l0mdt_control;
  function len(x: l0mdt_control) return natural;
  function width(x: l0mdt_control) return natural;
  function vectorify(x: l0mdt_control; t: std_logic_vector) return std_logic_vector;
  function convert(x: l0mdt_control; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: l0mdt_control) return l0mdt_control;
  function convert(x: in std_logic_vector; t: l0mdt_control) return l0mdt_control;
  function nullify(t: l0mdt_control) return l0mdt_control;
  function zeroed(t: l0mdt_control) return l0mdt_control;

  type l0mdt_ttc is record
    bcr : std_logic;
    ocr : std_logic;
    ecr : std_logic;
    l0a : std_logic;
    l1a : std_logic;
    bcid : bcid;
    evid : evid;
    orid : orid;
  end record l0mdt_ttc;
  function len(x: l0mdt_ttc) return natural;
  function width(x: l0mdt_ttc) return natural;
  function vectorify(x: l0mdt_ttc; t: std_logic_vector) return std_logic_vector;
  function convert(x: l0mdt_ttc; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: l0mdt_ttc) return l0mdt_ttc;
  function convert(x: in std_logic_vector; t: l0mdt_ttc) return l0mdt_ttc;
  function nullify(t: l0mdt_ttc) return l0mdt_ttc;
  function zeroed(t: l0mdt_ttc) return l0mdt_ttc;

  type slc_rx_bus is array(integer range <>) of slc_rx;
  function len(x: slc_rx_bus) return natural;
  function width(x: slc_rx_bus) return natural;
  function vectorify(x: slc_rx_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_rx_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: slc_rx_bus) return slc_rx_bus;
  function convert(x: std_logic_vector; t: slc_rx_bus) return slc_rx_bus;
  function nullify(x: slc_rx_bus) return slc_rx_bus;
  function zeroed(x: slc_rx_bus) return slc_rx_bus;

  type slc_endcap_bus is array(integer range <>) of slc_endcap;
  function len(x: slc_endcap_bus) return natural;
  function width(x: slc_endcap_bus) return natural;
  function vectorify(x: slc_endcap_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: slc_endcap_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: slc_endcap_bus) return slc_endcap_bus;
  function convert(x: std_logic_vector; t: slc_endcap_bus) return slc_endcap_bus;
  function nullify(x: slc_endcap_bus) return slc_endcap_bus;
  function zeroed(x: slc_endcap_bus) return slc_endcap_bus;

  type mdt_polmux_bus is array(integer range <>) of tdcpolmux2tar;
  function len(x: mdt_polmux_bus) return natural;
  function width(x: mdt_polmux_bus) return natural;
  function vectorify(x: mdt_polmux_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: mdt_polmux_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: mdt_polmux_bus) return mdt_polmux_bus;
  function convert(x: std_logic_vector; t: mdt_polmux_bus) return mdt_polmux_bus;
  function nullify(x: mdt_polmux_bus) return mdt_polmux_bus;
  function zeroed(x: mdt_polmux_bus) return mdt_polmux_bus;

  type tar2hps_bus is array(integer range <>) of tar2hps;
  function len(x: tar2hps_bus) return natural;
  function width(x: tar2hps_bus) return natural;
  function vectorify(x: tar2hps_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: tar2hps_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: tar2hps_bus) return tar2hps_bus;
  function convert(x: std_logic_vector; t: tar2hps_bus) return tar2hps_bus;
  function nullify(x: tar2hps_bus) return tar2hps_bus;
  function zeroed(x: tar2hps_bus) return tar2hps_bus;

  type ucm2hps_bus is array(integer range <>) of ucm2hps;
  function len(x: ucm2hps_bus) return natural;
  function width(x: ucm2hps_bus) return natural;
  function vectorify(x: ucm2hps_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm2hps_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm2hps_bus) return ucm2hps_bus;
  function convert(x: std_logic_vector; t: ucm2hps_bus) return ucm2hps_bus;
  function nullify(x: ucm2hps_bus) return ucm2hps_bus;
  function zeroed(x: ucm2hps_bus) return ucm2hps_bus;

  type heg2sfslc_bus is array(integer range <>) of heg2sfslc;
  function len(x: heg2sfslc_bus) return natural;
  function width(x: heg2sfslc_bus) return natural;
  function vectorify(x: heg2sfslc_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg2sfslc_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg2sfslc_bus) return heg2sfslc_bus;
  function convert(x: std_logic_vector; t: heg2sfslc_bus) return heg2sfslc_bus;
  function nullify(x: heg2sfslc_bus) return heg2sfslc_bus;
  function zeroed(x: heg2sfslc_bus) return heg2sfslc_bus;

  type heg2sfhit_bus is array(integer range <>) of heg2sfhit;
  function len(x: heg2sfhit_bus) return natural;
  function width(x: heg2sfhit_bus) return natural;
  function vectorify(x: heg2sfhit_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: heg2sfhit_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: heg2sfhit_bus) return heg2sfhit_bus;
  function convert(x: std_logic_vector; t: heg2sfhit_bus) return heg2sfhit_bus;
  function nullify(x: heg2sfhit_bus) return heg2sfhit_bus;
  function zeroed(x: heg2sfhit_bus) return heg2sfhit_bus;

  type sf2pt_bus is array(integer range <>) of sf2ptcalc;
  function len(x: sf2pt_bus) return natural;
  function width(x: sf2pt_bus) return natural;
  function vectorify(x: sf2pt_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: sf2pt_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: sf2pt_bus) return sf2pt_bus;
  function convert(x: std_logic_vector; t: sf2pt_bus) return sf2pt_bus;
  function nullify(x: sf2pt_bus) return sf2pt_bus;
  function zeroed(x: sf2pt_bus) return sf2pt_bus;

  type ucm2pl_bus is array(integer range <>) of ucm2pl;
  function len(x: ucm2pl_bus) return natural;
  function width(x: ucm2pl_bus) return natural;
  function vectorify(x: ucm2pl_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: ucm2pl_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ucm2pl_bus) return ucm2pl_bus;
  function convert(x: std_logic_vector; t: ucm2pl_bus) return ucm2pl_bus;
  function nullify(x: ucm2pl_bus) return ucm2pl_bus;
  function zeroed(x: ucm2pl_bus) return ucm2pl_bus;

  type pl2pt_bus is array(integer range <>) of pl2ptcalc;
  function len(x: pl2pt_bus) return natural;
  function width(x: pl2pt_bus) return natural;
  function vectorify(x: pl2pt_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: pl2pt_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: pl2pt_bus) return pl2pt_bus;
  function convert(x: std_logic_vector; t: pl2pt_bus) return pl2pt_bus;
  function nullify(x: pl2pt_bus) return pl2pt_bus;
  function zeroed(x: pl2pt_bus) return pl2pt_bus;

  type pl2mtc_bus is array(integer range <>) of pl2mtc;
  function len(x: pl2mtc_bus) return natural;
  function width(x: pl2mtc_bus) return natural;
  function vectorify(x: pl2mtc_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: pl2mtc_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: pl2mtc_bus) return pl2mtc_bus;
  function convert(x: std_logic_vector; t: pl2mtc_bus) return pl2mtc_bus;
  function nullify(x: pl2mtc_bus) return pl2mtc_bus;
  function zeroed(x: pl2mtc_bus) return pl2mtc_bus;

  type tf2mtc_bus is array(integer range <>) of ptcalc2mtc;
  function len(x: tf2mtc_bus) return natural;
  function width(x: tf2mtc_bus) return natural;
  function vectorify(x: tf2mtc_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: tf2mtc_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: tf2mtc_bus) return tf2mtc_bus;
  function convert(x: std_logic_vector; t: tf2mtc_bus) return tf2mtc_bus;
  function nullify(x: tf2mtc_bus) return tf2mtc_bus;
  function zeroed(x: tf2mtc_bus) return tf2mtc_bus;

  type mtc_out_bus is array(integer range <>) of mtc2sl;
  function len(x: mtc_out_bus) return natural;
  function width(x: mtc_out_bus) return natural;
  function vectorify(x: mtc_out_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: mtc_out_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: mtc_out_bus) return mtc_out_bus;
  function convert(x: std_logic_vector; t: mtc_out_bus) return mtc_out_bus;
  function nullify(x: mtc_out_bus) return mtc_out_bus;
  function zeroed(x: mtc_out_bus) return mtc_out_bus;

  type mtc2nsp_bus is array(integer range <>) of mtc2sl;
  function len(x: mtc2nsp_bus) return natural;
  function width(x: mtc2nsp_bus) return natural;
  function vectorify(x: mtc2nsp_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: mtc2nsp_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: mtc2nsp_bus) return mtc2nsp_bus;
  function convert(x: std_logic_vector; t: mtc2nsp_bus) return mtc2nsp_bus;
  function nullify(x: mtc2nsp_bus) return mtc2nsp_bus;
  function zeroed(x: mtc2nsp_bus) return mtc2nsp_bus;

  subtype felix_data is std_logic_vector(250-1 downto 0);

  type felix_stream is record
    valid : std_logic;
    data : felix_data;
  end record felix_stream;
  function len(x: felix_stream) return natural;
  function width(x: felix_stream) return natural;
  function vectorify(x: felix_stream; t: std_logic_vector) return std_logic_vector;
  function convert(x: felix_stream; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: felix_stream) return felix_stream;
  function convert(x: in std_logic_vector; t: felix_stream) return felix_stream;
  function nullify(t: felix_stream) return felix_stream;
  function zeroed(t: felix_stream) return felix_stream;

  type felix_stream_bus is array(integer range <>) of felix_stream;
  function len(x: felix_stream_bus) return natural;
  function width(x: felix_stream_bus) return natural;
  function vectorify(x: felix_stream_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: felix_stream_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: felix_stream_bus) return felix_stream_bus;
  function convert(x: std_logic_vector; t: felix_stream_bus) return felix_stream_bus;
  function nullify(x: felix_stream_bus) return felix_stream_bus;
  function zeroed(x: felix_stream_bus) return felix_stream_bus;

end package common_types_pkg;

------------------------------------------------------------

package body common_types_pkg is

  function len(x: integer_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * 32;
    return l;
  end function len;
  function width(x: integer_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * 32;
    return l;
  end function width;
  function vectorify(x: integer_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: integer_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: integer_bus) return integer_bus is
    variable y : integer_bus(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: integer_bus) return integer_bus is
    variable y : integer_bus(t'range);
    constant l : integer := 32;
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: integer_bus) return integer_bus is
    variable y : integer_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: integer_bus) return integer_bus is
    variable y : integer_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: l0mdt_control) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.clk);
    l := l + len(x.rst);
    l := l + len(x.bx);
    return l;
  end function len;
  function width(x: l0mdt_control) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.clk);
    l := l + width(x.rst);
    l := l + width(x.bx);
    return l;
  end function width;
  function vectorify(x: l0mdt_control; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.clk)-1), vectorify(x.clk, y(left to left+len(x.clk)-1)));
      left := left + len(x.clk);
      assign(y(left to left+len(x.rst)-1), vectorify(x.rst, y(left to left+len(x.rst)-1)));
      left := left + len(x.rst);
      assign(y(left to left+len(x.bx)-1), vectorify(x.bx, y(left to left+len(x.bx)-1)));
    else
      assign(y(left downto left-len(x.clk)+1), vectorify(x.clk, y(left downto left-len(x.clk)+1)));
      left := left - len(x.clk);
      assign(y(left downto left-len(x.rst)+1), vectorify(x.rst, y(left downto left-len(x.rst)+1)));
      left := left - len(x.rst);
      assign(y(left downto left-len(x.bx)+1), vectorify(x.bx, y(left downto left-len(x.bx)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: l0mdt_control; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.clk)-1), convert(x.clk, y(left to left+len(x.clk)-1)));
      left := left + len(x.clk);
      assign(y(left to left+len(x.rst)-1), convert(x.rst, y(left to left+len(x.rst)-1)));
      left := left + len(x.rst);
      assign(y(left to left+len(x.bx)-1), convert(x.bx, y(left to left+len(x.bx)-1)));
    else
      assign(y(left downto left-len(x.clk)+1), convert(x.clk, y(left downto left-len(x.clk)+1)));
      left := left - len(x.clk);
      assign(y(left downto left-len(x.rst)+1), convert(x.rst, y(left downto left-len(x.rst)+1)));
      left := left - len(x.rst);
      assign(y(left downto left-len(x.bx)+1), convert(x.bx, y(left downto left-len(x.bx)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: l0mdt_control) return l0mdt_control is
    variable y: l0mdt_control;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.clk := structify(x(left to left+len(y.clk)-1), y.clk);
      left := left + len(y.clk);
      y.rst := structify(x(left to left+len(y.rst)-1), y.rst);
      left := left + len(y.rst);
      y.bx := structify(x(left to left+len(y.bx)-1), y.bx);
    else
      y.clk := structify(x(left downto left-len(y.clk)+1), y.clk);
      left := left - len(y.clk);
      y.rst := structify(x(left downto left-len(y.rst)+1), y.rst);
      left := left - len(y.rst);
      y.bx := structify(x(left downto left-len(y.bx)+1), y.bx);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: l0mdt_control) return l0mdt_control is
    variable y: l0mdt_control;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.clk := convert(x(left to left+len(y.clk)-1), y.clk);
      left := left + len(y.clk);
      y.rst := convert(x(left to left+len(y.rst)-1), y.rst);
      left := left + len(y.rst);
      y.bx := convert(x(left to left+len(y.bx)-1), y.bx);
    else
      y.clk := convert(x(left downto left-len(y.clk)+1), y.clk);
      left := left - len(y.clk);
      y.rst := convert(x(left downto left-len(y.rst)+1), y.rst);
      left := left - len(y.rst);
      y.bx := convert(x(left downto left-len(y.bx)+1), y.bx);
    end if;
    return y;
  end function convert;
  function nullify(t: l0mdt_control) return l0mdt_control is
  variable y: l0mdt_control;
  begin
    y.clk := nullify(t.clk);
    y.rst := nullify(t.rst);
    y.bx := nullify(t.bx);
    return y;
  end function nullify;
  function zeroed(t: l0mdt_control) return l0mdt_control is
  variable y: l0mdt_control;
  begin
    y.clk := zeroed(t.clk);
    y.rst := zeroed(t.rst);
    y.bx := zeroed(t.bx);
    return y;
  end function zeroed;

  function len(x: l0mdt_ttc) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.bcr);
    l := l + len(x.ocr);
    l := l + len(x.ecr);
    l := l + len(x.l0a);
    l := l + len(x.l1a);
    l := l + len(x.bcid);
    l := l + len(x.evid);
    l := l + len(x.orid);
    return l;
  end function len;
  function width(x: l0mdt_ttc) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.bcr);
    l := l + width(x.ocr);
    l := l + width(x.ecr);
    l := l + width(x.l0a);
    l := l + width(x.l1a);
    l := l + width(x.bcid);
    l := l + width(x.evid);
    l := l + width(x.orid);
    return l;
  end function width;
  function vectorify(x: l0mdt_ttc; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcr)-1), vectorify(x.bcr, y(left to left+len(x.bcr)-1)));
      left := left + len(x.bcr);
      assign(y(left to left+len(x.ocr)-1), vectorify(x.ocr, y(left to left+len(x.ocr)-1)));
      left := left + len(x.ocr);
      assign(y(left to left+len(x.ecr)-1), vectorify(x.ecr, y(left to left+len(x.ecr)-1)));
      left := left + len(x.ecr);
      assign(y(left to left+len(x.l0a)-1), vectorify(x.l0a, y(left to left+len(x.l0a)-1)));
      left := left + len(x.l0a);
      assign(y(left to left+len(x.l1a)-1), vectorify(x.l1a, y(left to left+len(x.l1a)-1)));
      left := left + len(x.l1a);
      assign(y(left to left+len(x.bcid)-1), vectorify(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.evid)-1), vectorify(x.evid, y(left to left+len(x.evid)-1)));
      left := left + len(x.evid);
      assign(y(left to left+len(x.orid)-1), vectorify(x.orid, y(left to left+len(x.orid)-1)));
    else
      assign(y(left downto left-len(x.bcr)+1), vectorify(x.bcr, y(left downto left-len(x.bcr)+1)));
      left := left - len(x.bcr);
      assign(y(left downto left-len(x.ocr)+1), vectorify(x.ocr, y(left downto left-len(x.ocr)+1)));
      left := left - len(x.ocr);
      assign(y(left downto left-len(x.ecr)+1), vectorify(x.ecr, y(left downto left-len(x.ecr)+1)));
      left := left - len(x.ecr);
      assign(y(left downto left-len(x.l0a)+1), vectorify(x.l0a, y(left downto left-len(x.l0a)+1)));
      left := left - len(x.l0a);
      assign(y(left downto left-len(x.l1a)+1), vectorify(x.l1a, y(left downto left-len(x.l1a)+1)));
      left := left - len(x.l1a);
      assign(y(left downto left-len(x.bcid)+1), vectorify(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.evid)+1), vectorify(x.evid, y(left downto left-len(x.evid)+1)));
      left := left - len(x.evid);
      assign(y(left downto left-len(x.orid)+1), vectorify(x.orid, y(left downto left-len(x.orid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: l0mdt_ttc; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcr)-1), convert(x.bcr, y(left to left+len(x.bcr)-1)));
      left := left + len(x.bcr);
      assign(y(left to left+len(x.ocr)-1), convert(x.ocr, y(left to left+len(x.ocr)-1)));
      left := left + len(x.ocr);
      assign(y(left to left+len(x.ecr)-1), convert(x.ecr, y(left to left+len(x.ecr)-1)));
      left := left + len(x.ecr);
      assign(y(left to left+len(x.l0a)-1), convert(x.l0a, y(left to left+len(x.l0a)-1)));
      left := left + len(x.l0a);
      assign(y(left to left+len(x.l1a)-1), convert(x.l1a, y(left to left+len(x.l1a)-1)));
      left := left + len(x.l1a);
      assign(y(left to left+len(x.bcid)-1), convert(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.evid)-1), convert(x.evid, y(left to left+len(x.evid)-1)));
      left := left + len(x.evid);
      assign(y(left to left+len(x.orid)-1), convert(x.orid, y(left to left+len(x.orid)-1)));
    else
      assign(y(left downto left-len(x.bcr)+1), convert(x.bcr, y(left downto left-len(x.bcr)+1)));
      left := left - len(x.bcr);
      assign(y(left downto left-len(x.ocr)+1), convert(x.ocr, y(left downto left-len(x.ocr)+1)));
      left := left - len(x.ocr);
      assign(y(left downto left-len(x.ecr)+1), convert(x.ecr, y(left downto left-len(x.ecr)+1)));
      left := left - len(x.ecr);
      assign(y(left downto left-len(x.l0a)+1), convert(x.l0a, y(left downto left-len(x.l0a)+1)));
      left := left - len(x.l0a);
      assign(y(left downto left-len(x.l1a)+1), convert(x.l1a, y(left downto left-len(x.l1a)+1)));
      left := left - len(x.l1a);
      assign(y(left downto left-len(x.bcid)+1), convert(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.evid)+1), convert(x.evid, y(left downto left-len(x.evid)+1)));
      left := left - len(x.evid);
      assign(y(left downto left-len(x.orid)+1), convert(x.orid, y(left downto left-len(x.orid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: l0mdt_ttc) return l0mdt_ttc is
    variable y: l0mdt_ttc;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcr := structify(x(left to left+len(y.bcr)-1), y.bcr);
      left := left + len(y.bcr);
      y.ocr := structify(x(left to left+len(y.ocr)-1), y.ocr);
      left := left + len(y.ocr);
      y.ecr := structify(x(left to left+len(y.ecr)-1), y.ecr);
      left := left + len(y.ecr);
      y.l0a := structify(x(left to left+len(y.l0a)-1), y.l0a);
      left := left + len(y.l0a);
      y.l1a := structify(x(left to left+len(y.l1a)-1), y.l1a);
      left := left + len(y.l1a);
      y.bcid := structify(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.evid := structify(x(left to left+len(y.evid)-1), y.evid);
      left := left + len(y.evid);
      y.orid := structify(x(left to left+len(y.orid)-1), y.orid);
    else
      y.bcr := structify(x(left downto left-len(y.bcr)+1), y.bcr);
      left := left - len(y.bcr);
      y.ocr := structify(x(left downto left-len(y.ocr)+1), y.ocr);
      left := left - len(y.ocr);
      y.ecr := structify(x(left downto left-len(y.ecr)+1), y.ecr);
      left := left - len(y.ecr);
      y.l0a := structify(x(left downto left-len(y.l0a)+1), y.l0a);
      left := left - len(y.l0a);
      y.l1a := structify(x(left downto left-len(y.l1a)+1), y.l1a);
      left := left - len(y.l1a);
      y.bcid := structify(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.evid := structify(x(left downto left-len(y.evid)+1), y.evid);
      left := left - len(y.evid);
      y.orid := structify(x(left downto left-len(y.orid)+1), y.orid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: l0mdt_ttc) return l0mdt_ttc is
    variable y: l0mdt_ttc;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcr := convert(x(left to left+len(y.bcr)-1), y.bcr);
      left := left + len(y.bcr);
      y.ocr := convert(x(left to left+len(y.ocr)-1), y.ocr);
      left := left + len(y.ocr);
      y.ecr := convert(x(left to left+len(y.ecr)-1), y.ecr);
      left := left + len(y.ecr);
      y.l0a := convert(x(left to left+len(y.l0a)-1), y.l0a);
      left := left + len(y.l0a);
      y.l1a := convert(x(left to left+len(y.l1a)-1), y.l1a);
      left := left + len(y.l1a);
      y.bcid := convert(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.evid := convert(x(left to left+len(y.evid)-1), y.evid);
      left := left + len(y.evid);
      y.orid := convert(x(left to left+len(y.orid)-1), y.orid);
    else
      y.bcr := convert(x(left downto left-len(y.bcr)+1), y.bcr);
      left := left - len(y.bcr);
      y.ocr := convert(x(left downto left-len(y.ocr)+1), y.ocr);
      left := left - len(y.ocr);
      y.ecr := convert(x(left downto left-len(y.ecr)+1), y.ecr);
      left := left - len(y.ecr);
      y.l0a := convert(x(left downto left-len(y.l0a)+1), y.l0a);
      left := left - len(y.l0a);
      y.l1a := convert(x(left downto left-len(y.l1a)+1), y.l1a);
      left := left - len(y.l1a);
      y.bcid := convert(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.evid := convert(x(left downto left-len(y.evid)+1), y.evid);
      left := left - len(y.evid);
      y.orid := convert(x(left downto left-len(y.orid)+1), y.orid);
    end if;
    return y;
  end function convert;
  function nullify(t: l0mdt_ttc) return l0mdt_ttc is
  variable y: l0mdt_ttc;
  begin
    y.bcr := nullify(t.bcr);
    y.ocr := nullify(t.ocr);
    y.ecr := nullify(t.ecr);
    y.l0a := nullify(t.l0a);
    y.l1a := nullify(t.l1a);
    y.bcid := nullify(t.bcid);
    y.evid := nullify(t.evid);
    y.orid := nullify(t.orid);
    return y;
  end function nullify;
  function zeroed(t: l0mdt_ttc) return l0mdt_ttc is
  variable y: l0mdt_ttc;
  begin
    y.bcr := zeroed(t.bcr);
    y.ocr := zeroed(t.ocr);
    y.ecr := zeroed(t.ecr);
    y.l0a := zeroed(t.l0a);
    y.l1a := zeroed(t.l1a);
    y.bcid := zeroed(t.bcid);
    y.evid := zeroed(t.evid);
    y.orid := zeroed(t.orid);
    return y;
  end function zeroed;

  function len(x: slc_rx_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: slc_rx_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: slc_rx_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_rx_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: slc_rx_bus) return slc_rx_bus is
    variable y : slc_rx_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: slc_rx_bus) return slc_rx_bus is
    variable y : slc_rx_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: slc_rx_bus) return slc_rx_bus is
    variable y : slc_rx_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: slc_rx_bus) return slc_rx_bus is
    variable y : slc_rx_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: slc_endcap_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: slc_endcap_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: slc_endcap_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: slc_endcap_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: slc_endcap_bus) return slc_endcap_bus is
    variable y : slc_endcap_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: slc_endcap_bus) return slc_endcap_bus is
    variable y : slc_endcap_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: slc_endcap_bus) return slc_endcap_bus is
    variable y : slc_endcap_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: slc_endcap_bus) return slc_endcap_bus is
    variable y : slc_endcap_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: mdt_polmux_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: mdt_polmux_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: mdt_polmux_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: mdt_polmux_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: mdt_polmux_bus) return mdt_polmux_bus is
    variable y : mdt_polmux_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: mdt_polmux_bus) return mdt_polmux_bus is
    variable y : mdt_polmux_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: mdt_polmux_bus) return mdt_polmux_bus is
    variable y : mdt_polmux_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: mdt_polmux_bus) return mdt_polmux_bus is
    variable y : mdt_polmux_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: tar2hps_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: tar2hps_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: tar2hps_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: tar2hps_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: tar2hps_bus) return tar2hps_bus is
    variable y : tar2hps_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: tar2hps_bus) return tar2hps_bus is
    variable y : tar2hps_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: tar2hps_bus) return tar2hps_bus is
    variable y : tar2hps_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: tar2hps_bus) return tar2hps_bus is
    variable y : tar2hps_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm2hps_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm2hps_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm2hps_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm2hps_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm2hps_bus) return ucm2hps_bus is
    variable y : ucm2hps_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm2hps_bus) return ucm2hps_bus is
    variable y : ucm2hps_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm2hps_bus) return ucm2hps_bus is
    variable y : ucm2hps_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm2hps_bus) return ucm2hps_bus is
    variable y : ucm2hps_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg2sfslc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg2sfslc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg2sfslc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg2sfslc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg2sfslc_bus) return heg2sfslc_bus is
    variable y : heg2sfslc_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg2sfslc_bus) return heg2sfslc_bus is
    variable y : heg2sfslc_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg2sfslc_bus) return heg2sfslc_bus is
    variable y : heg2sfslc_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg2sfslc_bus) return heg2sfslc_bus is
    variable y : heg2sfslc_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: heg2sfhit_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: heg2sfhit_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: heg2sfhit_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: heg2sfhit_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: heg2sfhit_bus) return heg2sfhit_bus is
    variable y : heg2sfhit_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: heg2sfhit_bus) return heg2sfhit_bus is
    variable y : heg2sfhit_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: heg2sfhit_bus) return heg2sfhit_bus is
    variable y : heg2sfhit_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: heg2sfhit_bus) return heg2sfhit_bus is
    variable y : heg2sfhit_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: sf2pt_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: sf2pt_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: sf2pt_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: sf2pt_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: sf2pt_bus) return sf2pt_bus is
    variable y : sf2pt_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: sf2pt_bus) return sf2pt_bus is
    variable y : sf2pt_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: sf2pt_bus) return sf2pt_bus is
    variable y : sf2pt_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: sf2pt_bus) return sf2pt_bus is
    variable y : sf2pt_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ucm2pl_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ucm2pl_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ucm2pl_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ucm2pl_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ucm2pl_bus) return ucm2pl_bus is
    variable y : ucm2pl_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ucm2pl_bus) return ucm2pl_bus is
    variable y : ucm2pl_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ucm2pl_bus) return ucm2pl_bus is
    variable y : ucm2pl_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ucm2pl_bus) return ucm2pl_bus is
    variable y : ucm2pl_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: pl2pt_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: pl2pt_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: pl2pt_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: pl2pt_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: pl2pt_bus) return pl2pt_bus is
    variable y : pl2pt_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: pl2pt_bus) return pl2pt_bus is
    variable y : pl2pt_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: pl2pt_bus) return pl2pt_bus is
    variable y : pl2pt_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: pl2pt_bus) return pl2pt_bus is
    variable y : pl2pt_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: pl2mtc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: pl2mtc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: pl2mtc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: pl2mtc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: pl2mtc_bus) return pl2mtc_bus is
    variable y : pl2mtc_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: pl2mtc_bus) return pl2mtc_bus is
    variable y : pl2mtc_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: pl2mtc_bus) return pl2mtc_bus is
    variable y : pl2mtc_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: pl2mtc_bus) return pl2mtc_bus is
    variable y : pl2mtc_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: tf2mtc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: tf2mtc_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: tf2mtc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: tf2mtc_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: tf2mtc_bus) return tf2mtc_bus is
    variable y : tf2mtc_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: tf2mtc_bus) return tf2mtc_bus is
    variable y : tf2mtc_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: tf2mtc_bus) return tf2mtc_bus is
    variable y : tf2mtc_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: tf2mtc_bus) return tf2mtc_bus is
    variable y : tf2mtc_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: mtc_out_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: mtc_out_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: mtc_out_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: mtc_out_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: mtc_out_bus) return mtc_out_bus is
    variable y : mtc_out_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: mtc_out_bus) return mtc_out_bus is
    variable y : mtc_out_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: mtc_out_bus) return mtc_out_bus is
    variable y : mtc_out_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: mtc_out_bus) return mtc_out_bus is
    variable y : mtc_out_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: mtc2nsp_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: mtc2nsp_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: mtc2nsp_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: mtc2nsp_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: mtc2nsp_bus) return mtc2nsp_bus is
    variable y : mtc2nsp_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: mtc2nsp_bus) return mtc2nsp_bus is
    variable y : mtc2nsp_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: mtc2nsp_bus) return mtc2nsp_bus is
    variable y : mtc2nsp_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: mtc2nsp_bus) return mtc2nsp_bus is
    variable y : mtc2nsp_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: felix_stream) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.valid);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: felix_stream) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.valid);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: felix_stream; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), vectorify(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), vectorify(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: felix_stream; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.valid)-1), convert(x.valid, y(left to left+len(x.valid)-1)));
      left := left + len(x.valid);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.valid)+1), convert(x.valid, y(left downto left-len(x.valid)+1)));
      left := left - len(x.valid);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: felix_stream) return felix_stream is
    variable y: felix_stream;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := structify(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.valid := structify(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: felix_stream) return felix_stream is
    variable y: felix_stream;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.valid := convert(x(left to left+len(y.valid)-1), y.valid);
      left := left + len(y.valid);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.valid := convert(x(left downto left-len(y.valid)+1), y.valid);
      left := left - len(y.valid);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: felix_stream) return felix_stream is
  variable y: felix_stream;
  begin
    y.valid := nullify(t.valid);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: felix_stream) return felix_stream is
  variable y: felix_stream;
  begin
    y.valid := zeroed(t.valid);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: felix_stream_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: felix_stream_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: felix_stream_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: felix_stream_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: felix_stream_bus) return felix_stream_bus is
    variable y : felix_stream_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: felix_stream_bus) return felix_stream_bus is
    variable y : felix_stream_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: felix_stream_bus) return felix_stream_bus is
    variable y : felix_stream_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: felix_stream_bus) return felix_stream_bus is
    variable y : felix_stream_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

end package body common_types_pkg;
