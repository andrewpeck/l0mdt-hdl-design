-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;

package common_types_pkg is

   -- Custom types and functions --

   subtype bcid is unsigned(12-1 downto 0);
   attribute w of bcid : subtype is 12;

   subtype evid is unsigned(32-1 downto 0);
   attribute w of evid : subtype is 32;

   subtype orid is unsigned(32-1 downto 0);
   attribute w of orid : subtype is 32;

   type integer_bus is array(integer range <>) of integer;
   function width(x: integer_bus) return integer;
   function convert(x: integer_bus; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: integer_bus) return integer_bus;
   function zero(tpl: integer_bus) return integer_bus;
   function convert(x: integer_bus; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: integer_bus) return integer_bus;

   type l0mdt_control_rt is record
      clk : std_logic;
      rst : std_logic;
      bx : std_logic;
   end record l0mdt_control_rt;
   attribute w of l0mdt_control_rt : type is 3;
   function width(x: l0mdt_control_rt) return natural;
   function convert(x: l0mdt_control_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: l0mdt_control_rt) return l0mdt_control_rt;
   function zero(tpl: l0mdt_control_rt) return l0mdt_control_rt;

   subtype l0mdt_control_vt is std_logic_vector(l0mdt_control_rt'w-1 downto 0);
   attribute w of l0mdt_control_vt : subtype is 3;

   type l0mdt_ttc_rt is record
      bcr : std_logic;
      ocr : std_logic;
      ecr : std_logic;
      l0a : std_logic;
      l1a : std_logic;
      bcid : bcid;
      evid : evid;
      orid : orid;
   end record l0mdt_ttc_rt;
   attribute w of l0mdt_ttc_rt : type is 81;
   function width(x: l0mdt_ttc_rt) return natural;
   function convert(x: l0mdt_ttc_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: l0mdt_ttc_rt) return l0mdt_ttc_rt;
   function zero(tpl: l0mdt_ttc_rt) return l0mdt_ttc_rt;

   subtype l0mdt_ttc_vt is std_logic_vector(l0mdt_ttc_rt'w-1 downto 0);
   attribute w of l0mdt_ttc_vt : subtype is 81;

   subtype slc_rx_vt is std_logic_vector(slc_rx_rt'w-1 downto 0);
   attribute w of slc_rx_vt : subtype is 156;

   type slc_rx_art is array(integer range <>) of slc_rx_rt;
   function width(x: slc_rx_art) return integer;
   function convert(x: slc_rx_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_rx_art) return slc_rx_art;
   function zero(tpl: slc_rx_art) return slc_rx_art;
   function convert(x: slc_rx_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: slc_rx_art) return slc_rx_art;

   type slc_rx_avt is array(integer range <>) of slc_rx_vt;
   function width(x: slc_rx_avt) return integer;
   function convert(x: slc_rx_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_rx_avt) return slc_rx_avt;
   function zero(tpl: slc_rx_avt) return slc_rx_avt;
   function convert(x: slc_rx_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: slc_rx_avt) return slc_rx_avt;

   subtype slc_endcap_vt is std_logic_vector(slc_endcap_rt'w-1 downto 0);
   attribute w of slc_endcap_vt : subtype is 48;

   type slc_endcap_art is array(integer range <>) of slc_endcap_rt;
   function width(x: slc_endcap_art) return integer;
   function convert(x: slc_endcap_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_endcap_art) return slc_endcap_art;
   function zero(tpl: slc_endcap_art) return slc_endcap_art;
   function convert(x: slc_endcap_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: slc_endcap_art) return slc_endcap_art;

   type slc_endcap_avt is array(integer range <>) of slc_endcap_vt;
   function width(x: slc_endcap_avt) return integer;
   function convert(x: slc_endcap_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_endcap_avt) return slc_endcap_avt;
   function zero(tpl: slc_endcap_avt) return slc_endcap_avt;
   function convert(x: slc_endcap_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: slc_endcap_avt) return slc_endcap_avt;

   subtype slc_barrel_vt is std_logic_vector(slc_barrel_rt'w-1 downto 0);
   attribute w of slc_barrel_vt : subtype is 48;

   type slc_barrel_art is array(integer range <>) of slc_barrel_rt;
   function width(x: slc_barrel_art) return integer;
   function convert(x: slc_barrel_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_barrel_art) return slc_barrel_art;
   function zero(tpl: slc_barrel_art) return slc_barrel_art;
   function convert(x: slc_barrel_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: slc_barrel_art) return slc_barrel_art;

   type slc_barrel_avt is array(integer range <>) of slc_barrel_vt;
   function width(x: slc_barrel_avt) return integer;
   function convert(x: slc_barrel_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: slc_barrel_avt) return slc_barrel_avt;
   function zero(tpl: slc_barrel_avt) return slc_barrel_avt;
   function convert(x: slc_barrel_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: slc_barrel_avt) return slc_barrel_avt;

   subtype tdcpolmux2tar_vt is std_logic_vector(tdcpolmux2tar_rt'w-1 downto 0);
   attribute w of tdcpolmux2tar_vt : subtype is 42;

   type tdcpolmux2tar_art is array(integer range <>) of tdcpolmux2tar_rt;
   function width(x: tdcpolmux2tar_art) return integer;
   function convert(x: tdcpolmux2tar_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: tdcpolmux2tar_art) return tdcpolmux2tar_art;
   function zero(tpl: tdcpolmux2tar_art) return tdcpolmux2tar_art;
   function convert(x: tdcpolmux2tar_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: tdcpolmux2tar_art) return tdcpolmux2tar_art;

   type tdcpolmux2tar_avt is array(integer range <>) of tdcpolmux2tar_vt;
   function width(x: tdcpolmux2tar_avt) return integer;
   function convert(x: tdcpolmux2tar_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: tdcpolmux2tar_avt) return tdcpolmux2tar_avt;
   function zero(tpl: tdcpolmux2tar_avt) return tdcpolmux2tar_avt;
   function convert(x: tdcpolmux2tar_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: tdcpolmux2tar_avt) return tdcpolmux2tar_avt;

   subtype tar2hps_vt is std_logic_vector(tar2hps_rt'w-1 downto 0);
   attribute w of tar2hps_vt : subtype is 36;

   type tar2hps_art is array(integer range <>) of tar2hps_rt;
   function width(x: tar2hps_art) return integer;
   function convert(x: tar2hps_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: tar2hps_art) return tar2hps_art;
   function zero(tpl: tar2hps_art) return tar2hps_art;
   function convert(x: tar2hps_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: tar2hps_art) return tar2hps_art;

   type tar2hps_avt is array(integer range <>) of tar2hps_vt;
   function width(x: tar2hps_avt) return integer;
   function convert(x: tar2hps_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: tar2hps_avt) return tar2hps_avt;
   function zero(tpl: tar2hps_avt) return tar2hps_avt;
   function convert(x: tar2hps_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: tar2hps_avt) return tar2hps_avt;

   subtype ucm2tar_vt is std_logic_vector(ucm2tar_rt'w-1 downto 0);
   attribute w of ucm2tar_vt : subtype is 15;

   type ucm2tar_art is array(integer range <>) of ucm2tar_rt;
   function width(x: ucm2tar_art) return integer;
   function convert(x: ucm2tar_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm2tar_art) return ucm2tar_art;
   function zero(tpl: ucm2tar_art) return ucm2tar_art;
   function convert(x: ucm2tar_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm2tar_art) return ucm2tar_art;

   type ucm2tar_avt is array(integer range <>) of ucm2tar_vt;
   function width(x: ucm2tar_avt) return integer;
   function convert(x: ucm2tar_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm2tar_avt) return ucm2tar_avt;
   function zero(tpl: ucm2tar_avt) return ucm2tar_avt;
   function convert(x: ucm2tar_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm2tar_avt) return ucm2tar_avt;

   subtype ucm2hps_vt is std_logic_vector(ucm2hps_rt'w-1 downto 0);
   attribute w of ucm2hps_vt : subtype is 66;

   type ucm2hps_art is array(integer range <>) of ucm2hps_rt;
   function width(x: ucm2hps_art) return integer;
   function convert(x: ucm2hps_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm2hps_art) return ucm2hps_art;
   function zero(tpl: ucm2hps_art) return ucm2hps_art;
   function convert(x: ucm2hps_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm2hps_art) return ucm2hps_art;

   type ucm2hps_avt is array(integer range <>) of ucm2hps_vt;
   function width(x: ucm2hps_avt) return integer;
   function convert(x: ucm2hps_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm2hps_avt) return ucm2hps_avt;
   function zero(tpl: ucm2hps_avt) return ucm2hps_avt;
   function convert(x: ucm2hps_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm2hps_avt) return ucm2hps_avt;

   subtype heg2sfslc_vt is std_logic_vector(heg2sfslc_rt'w-1 downto 0);
   attribute w of heg2sfslc_vt : subtype is 77;

   type heg2sfslc_art is array(integer range <>) of heg2sfslc_rt;
   function width(x: heg2sfslc_art) return integer;
   function convert(x: heg2sfslc_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: heg2sfslc_art) return heg2sfslc_art;
   function zero(tpl: heg2sfslc_art) return heg2sfslc_art;
   function convert(x: heg2sfslc_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: heg2sfslc_art) return heg2sfslc_art;

   type heg2sfslc_avt is array(integer range <>) of heg2sfslc_vt;
   function width(x: heg2sfslc_avt) return integer;
   function convert(x: heg2sfslc_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: heg2sfslc_avt) return heg2sfslc_avt;
   function zero(tpl: heg2sfslc_avt) return heg2sfslc_avt;
   function convert(x: heg2sfslc_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: heg2sfslc_avt) return heg2sfslc_avt;

   subtype heg2sfhit_vt is std_logic_vector(heg2sfhit_rt'w-1 downto 0);
   attribute w of heg2sfhit_vt : subtype is 41;

   type heg2sfhit_art is array(integer range <>) of heg2sfhit_rt;
   function width(x: heg2sfhit_art) return integer;
   function convert(x: heg2sfhit_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: heg2sfhit_art) return heg2sfhit_art;
   function zero(tpl: heg2sfhit_art) return heg2sfhit_art;
   function convert(x: heg2sfhit_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: heg2sfhit_art) return heg2sfhit_art;

   type heg2sfhit_avt is array(integer range <>) of heg2sfhit_vt;
   function width(x: heg2sfhit_avt) return integer;
   function convert(x: heg2sfhit_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: heg2sfhit_avt) return heg2sfhit_avt;
   function zero(tpl: heg2sfhit_avt) return heg2sfhit_avt;
   function convert(x: heg2sfhit_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: heg2sfhit_avt) return heg2sfhit_avt;

   subtype sf2ptcalc_vt is std_logic_vector(sf2ptcalc_rt'w-1 downto 0);
   attribute w of sf2ptcalc_vt : subtype is 64;

   type sf2ptcalc_art is array(integer range <>) of sf2ptcalc_rt;
   function width(x: sf2ptcalc_art) return integer;
   function convert(x: sf2ptcalc_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: sf2ptcalc_art) return sf2ptcalc_art;
   function zero(tpl: sf2ptcalc_art) return sf2ptcalc_art;
   function convert(x: sf2ptcalc_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: sf2ptcalc_art) return sf2ptcalc_art;

   type sf2ptcalc_avt is array(integer range <>) of sf2ptcalc_vt;
   function width(x: sf2ptcalc_avt) return integer;
   function convert(x: sf2ptcalc_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: sf2ptcalc_avt) return sf2ptcalc_avt;
   function zero(tpl: sf2ptcalc_avt) return sf2ptcalc_avt;
   function convert(x: sf2ptcalc_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: sf2ptcalc_avt) return sf2ptcalc_avt;

   subtype ucm2pl_vt is std_logic_vector(ucm2pl_rt'w-1 downto 0);
   attribute w of ucm2pl_vt : subtype is 148;

   type ucm2pl_art is array(integer range <>) of ucm2pl_rt;
   function width(x: ucm2pl_art) return integer;
   function convert(x: ucm2pl_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm2pl_art) return ucm2pl_art;
   function zero(tpl: ucm2pl_art) return ucm2pl_art;
   function convert(x: ucm2pl_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm2pl_art) return ucm2pl_art;

   type ucm2pl_avt is array(integer range <>) of ucm2pl_vt;
   function width(x: ucm2pl_avt) return integer;
   function convert(x: ucm2pl_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ucm2pl_avt) return ucm2pl_avt;
   function zero(tpl: ucm2pl_avt) return ucm2pl_avt;
   function convert(x: ucm2pl_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ucm2pl_avt) return ucm2pl_avt;

   subtype pl2ptcalc_vt is std_logic_vector(pl2ptcalc_rt'w-1 downto 0);
   attribute w of pl2ptcalc_vt : subtype is 58;

   type pl2ptcalc_art is array(integer range <>) of pl2ptcalc_rt;
   function width(x: pl2ptcalc_art) return integer;
   function convert(x: pl2ptcalc_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: pl2ptcalc_art) return pl2ptcalc_art;
   function zero(tpl: pl2ptcalc_art) return pl2ptcalc_art;
   function convert(x: pl2ptcalc_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: pl2ptcalc_art) return pl2ptcalc_art;

   type pl2ptcalc_avt is array(integer range <>) of pl2ptcalc_vt;
   function width(x: pl2ptcalc_avt) return integer;
   function convert(x: pl2ptcalc_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: pl2ptcalc_avt) return pl2ptcalc_avt;
   function zero(tpl: pl2ptcalc_avt) return pl2ptcalc_avt;
   function convert(x: pl2ptcalc_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: pl2ptcalc_avt) return pl2ptcalc_avt;

   subtype pl2mtc_vt is std_logic_vector(pl2mtc_rt'w-1 downto 0);
   attribute w of pl2mtc_vt : subtype is 113;

   type pl2mtc_art is array(integer range <>) of pl2mtc_rt;
   function width(x: pl2mtc_art) return integer;
   function convert(x: pl2mtc_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: pl2mtc_art) return pl2mtc_art;
   function zero(tpl: pl2mtc_art) return pl2mtc_art;
   function convert(x: pl2mtc_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: pl2mtc_art) return pl2mtc_art;

   type pl2mtc_avt is array(integer range <>) of pl2mtc_vt;
   function width(x: pl2mtc_avt) return integer;
   function convert(x: pl2mtc_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: pl2mtc_avt) return pl2mtc_avt;
   function zero(tpl: pl2mtc_avt) return pl2mtc_avt;
   function convert(x: pl2mtc_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: pl2mtc_avt) return pl2mtc_avt;

   subtype ptcalc2mtc_vt is std_logic_vector(ptcalc2mtc_rt'w-1 downto 0);
   attribute w of ptcalc2mtc_vt : subtype is 54;

   type ptcalc2mtc_art is array(integer range <>) of ptcalc2mtc_rt;
   function width(x: ptcalc2mtc_art) return integer;
   function convert(x: ptcalc2mtc_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ptcalc2mtc_art) return ptcalc2mtc_art;
   function zero(tpl: ptcalc2mtc_art) return ptcalc2mtc_art;
   function convert(x: ptcalc2mtc_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ptcalc2mtc_art) return ptcalc2mtc_art;

   type ptcalc2mtc_avt is array(integer range <>) of ptcalc2mtc_vt;
   function width(x: ptcalc2mtc_avt) return integer;
   function convert(x: ptcalc2mtc_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: ptcalc2mtc_avt) return ptcalc2mtc_avt;
   function zero(tpl: ptcalc2mtc_avt) return ptcalc2mtc_avt;
   function convert(x: ptcalc2mtc_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: ptcalc2mtc_avt) return ptcalc2mtc_avt;

   subtype mtc2sl_vt is std_logic_vector(mtc2sl_rt'w-1 downto 0);
   attribute w of mtc2sl_vt : subtype is 193;

   type mtc_out_art is array(integer range <>) of mtc2sl_rt;
   function width(x: mtc_out_art) return integer;
   function convert(x: mtc_out_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: mtc_out_art) return mtc_out_art;
   function zero(tpl: mtc_out_art) return mtc_out_art;
   function convert(x: mtc_out_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: mtc_out_art) return mtc_out_art;

   type mtc_out_avt is array(integer range <>) of mtc2sl_vt;
   function width(x: mtc_out_avt) return integer;
   function convert(x: mtc_out_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: mtc_out_avt) return mtc_out_avt;
   function zero(tpl: mtc_out_avt) return mtc_out_avt;
   function convert(x: mtc_out_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: mtc_out_avt) return mtc_out_avt;

   type mtc2nsp_art is array(integer range <>) of mtc2sl_rt;
   function width(x: mtc2nsp_art) return integer;
   function convert(x: mtc2nsp_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: mtc2nsp_art) return mtc2nsp_art;
   function zero(tpl: mtc2nsp_art) return mtc2nsp_art;
   function convert(x: mtc2nsp_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: mtc2nsp_art) return mtc2nsp_art;

   type mtc2nsp_avt is array(integer range <>) of mtc2sl_vt;
   function width(x: mtc2nsp_avt) return integer;
   function convert(x: mtc2nsp_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: mtc2nsp_avt) return mtc2nsp_avt;
   function zero(tpl: mtc2nsp_avt) return mtc2nsp_avt;
   function convert(x: mtc2nsp_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: mtc2nsp_avt) return mtc2nsp_avt;

   subtype felix_data is std_logic_vector(34-1 downto 0);
   attribute w of felix_data : subtype is 34;

   type felix_data_avt is array(integer range <>) of felix_data;
   function width(x: felix_data_avt) return integer;
   function convert(x: felix_data_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: felix_data_avt) return felix_data_avt;
   function zero(tpl: felix_data_avt) return felix_data_avt;
   function convert(x: felix_data_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: felix_data_avt) return felix_data_avt;

   type felix_stream_rt is record
      valid : std_logic;
      data : felix_data;
   end record felix_stream_rt;
   attribute w of felix_stream_rt : type is 35;
   function width(x: felix_stream_rt) return natural;
   function convert(x: felix_stream_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: felix_stream_rt) return felix_stream_rt;
   function zero(tpl: felix_stream_rt) return felix_stream_rt;

   subtype felix_stream_vt is std_logic_vector(felix_stream_rt'w-1 downto 0);
   attribute w of felix_stream_vt : subtype is 35;

   type felix_stream_art is array(integer range <>) of felix_stream_rt;
   function width(x: felix_stream_art) return integer;
   function convert(x: felix_stream_art; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: felix_stream_art) return felix_stream_art;
   function zero(tpl: felix_stream_art) return felix_stream_art;
   function convert(x: felix_stream_art; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: felix_stream_art) return felix_stream_art;

   type felix_stream_avt is array(integer range <>) of felix_stream_vt;
   function width(x: felix_stream_avt) return integer;
   function convert(x: felix_stream_avt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: felix_stream_avt) return felix_stream_avt;
   function zero(tpl: felix_stream_avt) return felix_stream_avt;
   function convert(x: felix_stream_avt; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: felix_stream_avt) return felix_stream_avt;

end package common_types_pkg;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;

package body common_types_pkg is

   -- Custom types and functions --

   function width(x: integer_bus) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: integer_bus; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: integer_bus) return integer_bus is
      variable y : integer_bus(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: integer_bus) return integer_bus is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: integer_bus; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: integer_bus) return integer_bus is
      variable y : integer_bus(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: l0mdt_control_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.clk);
      w := w + width(x.rst);
      w := w + width(x.bx);
      return w;
   end function width;
   function convert(x: l0mdt_control_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.clk);
         y(u to u+w-1) := convert(x.clk, y(u to u+w-1));
         u := u + w;
         w := width(x.rst);
         y(u to u+w-1) := convert(x.rst, y(u to u+w-1));
         u := u + w;
         w := width(x.bx);
         y(u to u+w-1) := convert(x.bx, y(u to u+w-1));
      else
         w := width(x.clk);
         y(u downto u-w+1) := convert(x.clk, y(u downto u-w+1));
         u := u - w;
         w := width(x.rst);
         y(u downto u-w+1) := convert(x.rst, y(u downto u-w+1));
         u := u - w;
         w := width(x.bx);
         y(u downto u-w+1) := convert(x.bx, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: l0mdt_control_rt) return l0mdt_control_rt is
      variable y : l0mdt_control_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.clk);
         y.clk := convert(x(u to u+w-1), tpl.clk);
         u := u + w;
         w := width(tpl.rst);
         y.rst := convert(x(u to u+w-1), tpl.rst);
         u := u + w;
         w := width(tpl.bx);
         y.bx := convert(x(u to u+w-1), tpl.bx);
      else
         w := width(tpl.clk);
         y.clk := convert(x(u downto u-w+1), tpl.clk);
         u := u - w;
         w := width(tpl.rst);
         y.rst := convert(x(u downto u-w+1), tpl.rst);
         u := u - w;
         w := width(tpl.bx);
         y.bx := convert(x(u downto u-w+1), tpl.bx);
      end if;
      return y;
   end function convert;
   function zero(tpl: l0mdt_control_rt) return l0mdt_control_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: l0mdt_ttc_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.bcr);
      w := w + width(x.ocr);
      w := w + width(x.ecr);
      w := w + width(x.l0a);
      w := w + width(x.l1a);
      w := w + width(x.bcid);
      w := w + width(x.evid);
      w := w + width(x.orid);
      return w;
   end function width;
   function convert(x: l0mdt_ttc_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.bcr);
         y(u to u+w-1) := convert(x.bcr, y(u to u+w-1));
         u := u + w;
         w := width(x.ocr);
         y(u to u+w-1) := convert(x.ocr, y(u to u+w-1));
         u := u + w;
         w := width(x.ecr);
         y(u to u+w-1) := convert(x.ecr, y(u to u+w-1));
         u := u + w;
         w := width(x.l0a);
         y(u to u+w-1) := convert(x.l0a, y(u to u+w-1));
         u := u + w;
         w := width(x.l1a);
         y(u to u+w-1) := convert(x.l1a, y(u to u+w-1));
         u := u + w;
         w := width(x.bcid);
         y(u to u+w-1) := convert(x.bcid, y(u to u+w-1));
         u := u + w;
         w := width(x.evid);
         y(u to u+w-1) := convert(x.evid, y(u to u+w-1));
         u := u + w;
         w := width(x.orid);
         y(u to u+w-1) := convert(x.orid, y(u to u+w-1));
      else
         w := width(x.bcr);
         y(u downto u-w+1) := convert(x.bcr, y(u downto u-w+1));
         u := u - w;
         w := width(x.ocr);
         y(u downto u-w+1) := convert(x.ocr, y(u downto u-w+1));
         u := u - w;
         w := width(x.ecr);
         y(u downto u-w+1) := convert(x.ecr, y(u downto u-w+1));
         u := u - w;
         w := width(x.l0a);
         y(u downto u-w+1) := convert(x.l0a, y(u downto u-w+1));
         u := u - w;
         w := width(x.l1a);
         y(u downto u-w+1) := convert(x.l1a, y(u downto u-w+1));
         u := u - w;
         w := width(x.bcid);
         y(u downto u-w+1) := convert(x.bcid, y(u downto u-w+1));
         u := u - w;
         w := width(x.evid);
         y(u downto u-w+1) := convert(x.evid, y(u downto u-w+1));
         u := u - w;
         w := width(x.orid);
         y(u downto u-w+1) := convert(x.orid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: l0mdt_ttc_rt) return l0mdt_ttc_rt is
      variable y : l0mdt_ttc_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.bcr);
         y.bcr := convert(x(u to u+w-1), tpl.bcr);
         u := u + w;
         w := width(tpl.ocr);
         y.ocr := convert(x(u to u+w-1), tpl.ocr);
         u := u + w;
         w := width(tpl.ecr);
         y.ecr := convert(x(u to u+w-1), tpl.ecr);
         u := u + w;
         w := width(tpl.l0a);
         y.l0a := convert(x(u to u+w-1), tpl.l0a);
         u := u + w;
         w := width(tpl.l1a);
         y.l1a := convert(x(u to u+w-1), tpl.l1a);
         u := u + w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u to u+w-1), tpl.bcid);
         u := u + w;
         w := width(tpl.evid);
         y.evid := convert(x(u to u+w-1), tpl.evid);
         u := u + w;
         w := width(tpl.orid);
         y.orid := convert(x(u to u+w-1), tpl.orid);
      else
         w := width(tpl.bcr);
         y.bcr := convert(x(u downto u-w+1), tpl.bcr);
         u := u - w;
         w := width(tpl.ocr);
         y.ocr := convert(x(u downto u-w+1), tpl.ocr);
         u := u - w;
         w := width(tpl.ecr);
         y.ecr := convert(x(u downto u-w+1), tpl.ecr);
         u := u - w;
         w := width(tpl.l0a);
         y.l0a := convert(x(u downto u-w+1), tpl.l0a);
         u := u - w;
         w := width(tpl.l1a);
         y.l1a := convert(x(u downto u-w+1), tpl.l1a);
         u := u - w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u downto u-w+1), tpl.bcid);
         u := u - w;
         w := width(tpl.evid);
         y.evid := convert(x(u downto u-w+1), tpl.evid);
         u := u - w;
         w := width(tpl.orid);
         y.orid := convert(x(u downto u-w+1), tpl.orid);
      end if;
      return y;
   end function convert;
   function zero(tpl: l0mdt_ttc_rt) return l0mdt_ttc_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: slc_rx_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: slc_rx_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_rx_art) return slc_rx_art is
      variable y : slc_rx_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_rx_art) return slc_rx_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: slc_rx_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: slc_rx_art) return slc_rx_art is
      variable y : slc_rx_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: slc_rx_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: slc_rx_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_rx_avt) return slc_rx_avt is
      variable y : slc_rx_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_rx_avt) return slc_rx_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: slc_rx_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: slc_rx_avt) return slc_rx_avt is
      variable y : slc_rx_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: slc_endcap_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: slc_endcap_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_endcap_art) return slc_endcap_art is
      variable y : slc_endcap_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_endcap_art) return slc_endcap_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: slc_endcap_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: slc_endcap_art) return slc_endcap_art is
      variable y : slc_endcap_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: slc_endcap_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: slc_endcap_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_endcap_avt) return slc_endcap_avt is
      variable y : slc_endcap_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_endcap_avt) return slc_endcap_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: slc_endcap_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: slc_endcap_avt) return slc_endcap_avt is
      variable y : slc_endcap_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: slc_barrel_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: slc_barrel_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_barrel_art) return slc_barrel_art is
      variable y : slc_barrel_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_barrel_art) return slc_barrel_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: slc_barrel_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: slc_barrel_art) return slc_barrel_art is
      variable y : slc_barrel_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: slc_barrel_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: slc_barrel_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: slc_barrel_avt) return slc_barrel_avt is
      variable y : slc_barrel_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: slc_barrel_avt) return slc_barrel_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: slc_barrel_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: slc_barrel_avt) return slc_barrel_avt is
      variable y : slc_barrel_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: tdcpolmux2tar_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: tdcpolmux2tar_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: tdcpolmux2tar_art) return tdcpolmux2tar_art is
      variable y : tdcpolmux2tar_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: tdcpolmux2tar_art) return tdcpolmux2tar_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: tdcpolmux2tar_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: tdcpolmux2tar_art) return tdcpolmux2tar_art is
      variable y : tdcpolmux2tar_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: tdcpolmux2tar_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: tdcpolmux2tar_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: tdcpolmux2tar_avt) return tdcpolmux2tar_avt is
      variable y : tdcpolmux2tar_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: tdcpolmux2tar_avt) return tdcpolmux2tar_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: tdcpolmux2tar_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: tdcpolmux2tar_avt) return tdcpolmux2tar_avt is
      variable y : tdcpolmux2tar_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: tar2hps_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: tar2hps_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: tar2hps_art) return tar2hps_art is
      variable y : tar2hps_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: tar2hps_art) return tar2hps_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: tar2hps_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: tar2hps_art) return tar2hps_art is
      variable y : tar2hps_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: tar2hps_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: tar2hps_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: tar2hps_avt) return tar2hps_avt is
      variable y : tar2hps_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: tar2hps_avt) return tar2hps_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: tar2hps_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: tar2hps_avt) return tar2hps_avt is
      variable y : tar2hps_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm2tar_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: ucm2tar_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm2tar_art) return ucm2tar_art is
      variable y : ucm2tar_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm2tar_art) return ucm2tar_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm2tar_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm2tar_art) return ucm2tar_art is
      variable y : ucm2tar_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm2tar_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: ucm2tar_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm2tar_avt) return ucm2tar_avt is
      variable y : ucm2tar_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm2tar_avt) return ucm2tar_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm2tar_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm2tar_avt) return ucm2tar_avt is
      variable y : ucm2tar_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm2hps_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: ucm2hps_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm2hps_art) return ucm2hps_art is
      variable y : ucm2hps_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm2hps_art) return ucm2hps_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm2hps_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm2hps_art) return ucm2hps_art is
      variable y : ucm2hps_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm2hps_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: ucm2hps_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm2hps_avt) return ucm2hps_avt is
      variable y : ucm2hps_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm2hps_avt) return ucm2hps_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm2hps_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm2hps_avt) return ucm2hps_avt is
      variable y : ucm2hps_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: heg2sfslc_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: heg2sfslc_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: heg2sfslc_art) return heg2sfslc_art is
      variable y : heg2sfslc_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: heg2sfslc_art) return heg2sfslc_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: heg2sfslc_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: heg2sfslc_art) return heg2sfslc_art is
      variable y : heg2sfslc_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: heg2sfslc_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: heg2sfslc_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: heg2sfslc_avt) return heg2sfslc_avt is
      variable y : heg2sfslc_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: heg2sfslc_avt) return heg2sfslc_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: heg2sfslc_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: heg2sfslc_avt) return heg2sfslc_avt is
      variable y : heg2sfslc_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: heg2sfhit_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: heg2sfhit_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: heg2sfhit_art) return heg2sfhit_art is
      variable y : heg2sfhit_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: heg2sfhit_art) return heg2sfhit_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: heg2sfhit_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: heg2sfhit_art) return heg2sfhit_art is
      variable y : heg2sfhit_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: heg2sfhit_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: heg2sfhit_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: heg2sfhit_avt) return heg2sfhit_avt is
      variable y : heg2sfhit_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: heg2sfhit_avt) return heg2sfhit_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: heg2sfhit_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: heg2sfhit_avt) return heg2sfhit_avt is
      variable y : heg2sfhit_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: sf2ptcalc_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: sf2ptcalc_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: sf2ptcalc_art) return sf2ptcalc_art is
      variable y : sf2ptcalc_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: sf2ptcalc_art) return sf2ptcalc_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: sf2ptcalc_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: sf2ptcalc_art) return sf2ptcalc_art is
      variable y : sf2ptcalc_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: sf2ptcalc_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: sf2ptcalc_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: sf2ptcalc_avt) return sf2ptcalc_avt is
      variable y : sf2ptcalc_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: sf2ptcalc_avt) return sf2ptcalc_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: sf2ptcalc_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: sf2ptcalc_avt) return sf2ptcalc_avt is
      variable y : sf2ptcalc_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm2pl_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: ucm2pl_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm2pl_art) return ucm2pl_art is
      variable y : ucm2pl_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm2pl_art) return ucm2pl_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm2pl_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm2pl_art) return ucm2pl_art is
      variable y : ucm2pl_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ucm2pl_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: ucm2pl_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ucm2pl_avt) return ucm2pl_avt is
      variable y : ucm2pl_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ucm2pl_avt) return ucm2pl_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ucm2pl_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ucm2pl_avt) return ucm2pl_avt is
      variable y : ucm2pl_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: pl2ptcalc_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: pl2ptcalc_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: pl2ptcalc_art) return pl2ptcalc_art is
      variable y : pl2ptcalc_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: pl2ptcalc_art) return pl2ptcalc_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: pl2ptcalc_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: pl2ptcalc_art) return pl2ptcalc_art is
      variable y : pl2ptcalc_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: pl2ptcalc_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: pl2ptcalc_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: pl2ptcalc_avt) return pl2ptcalc_avt is
      variable y : pl2ptcalc_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: pl2ptcalc_avt) return pl2ptcalc_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: pl2ptcalc_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: pl2ptcalc_avt) return pl2ptcalc_avt is
      variable y : pl2ptcalc_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: pl2mtc_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: pl2mtc_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: pl2mtc_art) return pl2mtc_art is
      variable y : pl2mtc_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: pl2mtc_art) return pl2mtc_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: pl2mtc_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: pl2mtc_art) return pl2mtc_art is
      variable y : pl2mtc_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: pl2mtc_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: pl2mtc_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: pl2mtc_avt) return pl2mtc_avt is
      variable y : pl2mtc_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: pl2mtc_avt) return pl2mtc_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: pl2mtc_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: pl2mtc_avt) return pl2mtc_avt is
      variable y : pl2mtc_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ptcalc2mtc_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: ptcalc2mtc_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ptcalc2mtc_art) return ptcalc2mtc_art is
      variable y : ptcalc2mtc_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ptcalc2mtc_art) return ptcalc2mtc_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ptcalc2mtc_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ptcalc2mtc_art) return ptcalc2mtc_art is
      variable y : ptcalc2mtc_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: ptcalc2mtc_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: ptcalc2mtc_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: ptcalc2mtc_avt) return ptcalc2mtc_avt is
      variable y : ptcalc2mtc_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: ptcalc2mtc_avt) return ptcalc2mtc_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: ptcalc2mtc_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: ptcalc2mtc_avt) return ptcalc2mtc_avt is
      variable y : ptcalc2mtc_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: mtc_out_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: mtc_out_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: mtc_out_art) return mtc_out_art is
      variable y : mtc_out_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: mtc_out_art) return mtc_out_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: mtc_out_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: mtc_out_art) return mtc_out_art is
      variable y : mtc_out_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: mtc_out_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: mtc_out_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: mtc_out_avt) return mtc_out_avt is
      variable y : mtc_out_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: mtc_out_avt) return mtc_out_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: mtc_out_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: mtc_out_avt) return mtc_out_avt is
      variable y : mtc_out_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: mtc2nsp_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: mtc2nsp_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: mtc2nsp_art) return mtc2nsp_art is
      variable y : mtc2nsp_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: mtc2nsp_art) return mtc2nsp_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: mtc2nsp_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: mtc2nsp_art) return mtc2nsp_art is
      variable y : mtc2nsp_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: mtc2nsp_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: mtc2nsp_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: mtc2nsp_avt) return mtc2nsp_avt is
      variable y : mtc2nsp_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: mtc2nsp_avt) return mtc2nsp_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: mtc2nsp_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: mtc2nsp_avt) return mtc2nsp_avt is
      variable y : mtc2nsp_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: felix_data_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: felix_data_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: felix_data_avt) return felix_data_avt is
      variable y : felix_data_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: felix_data_avt) return felix_data_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: felix_data_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: felix_data_avt) return felix_data_avt is
      variable y : felix_data_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: felix_stream_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.valid);
      w := w + width(x.data);
      return w;
   end function width;
   function convert(x: felix_stream_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.valid);
         y(u to u+w-1) := convert(x.valid, y(u to u+w-1));
         u := u + w;
         w := width(x.data);
         y(u to u+w-1) := convert(x.data, y(u to u+w-1));
      else
         w := width(x.valid);
         y(u downto u-w+1) := convert(x.valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.data);
         y(u downto u-w+1) := convert(x.data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: felix_stream_rt) return felix_stream_rt is
      variable y : felix_stream_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.valid);
         y.valid := convert(x(u to u+w-1), tpl.valid);
         u := u + w;
         w := width(tpl.data);
         y.data := convert(x(u to u+w-1), tpl.data);
      else
         w := width(tpl.valid);
         y.valid := convert(x(u downto u-w+1), tpl.valid);
         u := u - w;
         w := width(tpl.data);
         y.data := convert(x(u downto u-w+1), tpl.data);
      end if;
      return y;
   end function convert;
   function zero(tpl: felix_stream_rt) return felix_stream_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: felix_stream_art) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: felix_stream_art; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: felix_stream_art) return felix_stream_art is
      variable y : felix_stream_art(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: felix_stream_art) return felix_stream_art is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: felix_stream_art; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: felix_stream_art) return felix_stream_art is
      variable y : felix_stream_art(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: felix_stream_avt) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: felix_stream_avt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: felix_stream_avt) return felix_stream_avt is
      variable y : felix_stream_avt(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: felix_stream_avt) return felix_stream_avt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: felix_stream_avt; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: felix_stream_avt) return felix_stream_avt is
      variable y : felix_stream_avt(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

end package body common_types_pkg;
