-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.sl2mdt_constants_pkg.all;

package sl2mdt_dataformats_pkg is

   -- Custom types and functions --

   type SL2MDT_header_rt is record
      h_reserved : std_logic_vector(SL2MDT_HEADER_H_RESERVED_LEN-1 downto 0);
      tcoverflow : std_logic;
      nmtc_sl : unsigned(SL2MDT_HEADER_NMTC_SL_LEN-1 downto 0);
      nmtc_mdt : unsigned(SL2MDT_HEADER_NMTC_MDT_LEN-1 downto 0);
      nslc : unsigned(SL2MDT_HEADER_NSLC_SLC_LEN-1 downto 0);
      bcid : unsigned(SL2MDT_HEADER_BCID_LEN-1 downto 0);
   end record SL2MDT_header_rt;
   attribute w of SL2MDT_header_rt : type is 32;
   function width(x: SL2MDT_header_rt) return natural;
   function convert(x: SL2MDT_header_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: SL2MDT_header_rt) return SL2MDT_header_rt;
   function zero(tpl: SL2MDT_header_rt) return SL2MDT_header_rt;

   type SL2MDT_trailer_rt is record
      t_reserved : std_logic_vector(SL2MDT_TRAILER_T_RESERVED_LEN-1 downto 0);
      crc : std_logic_vector(SL2MDT_TRAILER_CRC_LEN-1 downto 0);
      fiberid : unsigned(SL2MDT_TRAILER_FIBERID_LEN-1 downto 0);
      slid : unsigned(SL2MDT_TRAILER_SLID_LEN-1 downto 0);
      comma : std_logic_vector(SL2MDT_TRAILER_COMMA_LEN-1 downto 0);
   end record SL2MDT_trailer_rt;
   attribute w of SL2MDT_trailer_rt : type is 32;
   function width(x: SL2MDT_trailer_rt) return natural;
   function convert(x: SL2MDT_trailer_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: SL2MDT_trailer_rt) return SL2MDT_trailer_rt;
   function zero(tpl: SL2MDT_trailer_rt) return SL2MDT_trailer_rt;

   type SL2MDT_slc_common_rt is record
      header : SL2MDT_header_rt;
      slcid : unsigned(SL2MDT_SLC_COMMON_SLCID_LEN-1 downto 0);
      tcsent : std_logic;
      poseta : signed(SL2MDT_SLC_COMMON_POSETA_LEN-1 downto 0);
      posphi : unsigned(SL2MDT_SLC_COMMON_POSPHI_LEN-1 downto 0);
      SL2MDT_pt : unsigned(SL2MDT_SLC_COMMON_SL_PT_LEN-1 downto 0);
      SL2MDT_ptthresh : unsigned(SL2MDT_SLC_COMMON_SL_PTTHRESH_LEN-1 downto 0);
      SL2MDT_charge : std_logic;
      cointype : std_logic_vector(SL2MDT_SLC_COMMON_COINTYPE_LEN-1 downto 0);
      trailer : SL2MDT_trailer_rt;
   end record SL2MDT_slc_common_rt;
   attribute w of SL2MDT_slc_common_rt : type is 108;
   function width(x: SL2MDT_slc_common_rt) return natural;
   function convert(x: SL2MDT_slc_common_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_common_rt) return SL2MDT_slc_common_rt;
   function zero(tpl: SL2MDT_slc_common_rt) return SL2MDT_slc_common_rt;

   type SL2MDT_slc_endcap_rt is record
      e_reserved : std_logic_vector(SL2MDT_SLC_ENDCAP_E_RESERVED_LEN-1 downto 0);
      nswseg_mon : std_logic;
      nswseg_angdtheta : signed(SL2MDT_SLC_ENDCAP_NSWSEG_ANGDTHETA_LEN-1 downto 0);
      nswseg_posphi : unsigned(SL2MDT_SLC_ENDCAP_NSWSEG_POSPHI_LEN-1 downto 0);
      nswseg_poseta : unsigned(SL2MDT_SLC_ENDCAP_NSWSEG_POSETA_LEN-1 downto 0);
      seg_angdphi : signed(SL2MDT_SLC_ENDCAP_SEG_ANGDPHI_LEN-1 downto 0);
      seg_angdtheta : signed(SL2MDT_SLC_ENDCAP_SEG_ANGDTHETA_LEN-1 downto 0);
   end record SL2MDT_slc_endcap_rt;
   attribute w of SL2MDT_slc_endcap_rt : type is 85;
   function width(x: SL2MDT_slc_endcap_rt) return natural;
   function convert(x: SL2MDT_slc_endcap_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_endcap_rt) return SL2MDT_slc_endcap_rt;
   function zero(tpl: SL2MDT_slc_endcap_rt) return SL2MDT_slc_endcap_rt;

   type SL2MDT_slc_barrel_rt is record
      b_reserved : std_logic_vector(SL2MDT_SLC_BARREL_B_RESERVED_LEN-1 downto 0);
      rpc3_posz : signed(SL2MDT_SLC_BARREL_RPC3_POSZ_LEN-1 downto 0);
      rpc2_posz : signed(SL2MDT_SLC_BARREL_RPC2_POSZ_LEN-1 downto 0);
      rpc1_posz : signed(SL2MDT_SLC_BARREL_RPC1_POSZ_LEN-1 downto 0);
      rpc0_posz : signed(SL2MDT_SLC_BARREL_RPC0_POSZ_LEN-1 downto 0);
   end record SL2MDT_slc_barrel_rt;
   attribute w of SL2MDT_slc_barrel_rt : type is 85;
   function width(x: SL2MDT_slc_barrel_rt) return natural;
   function convert(x: SL2MDT_slc_barrel_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_barrel_rt) return SL2MDT_slc_barrel_rt;
   function zero(tpl: SL2MDT_slc_barrel_rt) return SL2MDT_slc_barrel_rt;

   type SL2MDT_slc_rx_rt is record
      data_valid : std_logic;
      common : SL2MDT_slc_common_rt;
      specific : std_logic_vector(SL2MDT_SLC_RX_SPECIFIC_LEN-1 downto 0);
   end record SL2MDT_slc_rx_rt;
   attribute w of SL2MDT_slc_rx_rt : type is 194;
   function width(x: SL2MDT_slc_rx_rt) return natural;
   function convert(x: SL2MDT_slc_rx_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_rx_rt) return SL2MDT_slc_rx_rt;
   function zero(tpl: SL2MDT_slc_rx_rt) return SL2MDT_slc_rx_rt;

   type SL2MDT_slc_rx_bus is array(integer range <>) of SL2MDT_slc_rx_rt;
   function width(x: SL2MDT_slc_rx_bus) return integer;
   function convert(x: SL2MDT_slc_rx_bus; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus;
   function zero(tpl: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus;
   function convert(x: SL2MDT_slc_rx_bus; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus;

   type SL2MDT_slc_endcap_bus is array(integer range <>) of SL2MDT_slc_endcap_rt;
   function width(x: SL2MDT_slc_endcap_bus) return integer;
   function convert(x: SL2MDT_slc_endcap_bus; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus;
   function zero(tpl: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus;
   function convert(x: SL2MDT_slc_endcap_bus; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus;

   type SL2MDT_slc_muid_rt is record
      slcid : unsigned(SL2MDT_SLC_COMMON_SLCID_LEN-1 downto 0);
      slid : unsigned(SL2MDT_TRAILER_SLID_LEN-1 downto 0);
      bcid : unsigned(SL2MDT_HEADER_BCID_LEN-1 downto 0);
   end record SL2MDT_slc_muid_rt;
   attribute w of SL2MDT_slc_muid_rt : type is 21;
   function width(x: SL2MDT_slc_muid_rt) return natural;
   function convert(x: SL2MDT_slc_muid_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_muid_rt) return SL2MDT_slc_muid_rt;
   function zero(tpl: SL2MDT_slc_muid_rt) return SL2MDT_slc_muid_rt;

   type vec_mdtid_rt is record
      chamber_id : unsigned(SL2MDT_VEC_MDTID_CHAMBER_ID_LEN-1 downto 0);
      chamber_ieta : unsigned(SL2MDT_VEC_MDTID_CHAMBER_IETA_LEN-1 downto 0);
   end record vec_mdtid_rt;
   attribute w of vec_mdtid_rt : type is 9;
   function width(x: vec_mdtid_rt) return natural;
   function convert(x: vec_mdtid_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: vec_mdtid_rt) return vec_mdtid_rt;
   function zero(tpl: vec_mdtid_rt) return vec_mdtid_rt;

   type sl2mdt_mtc2sl_rt is record
      data_valid : std_logic;
      common : slc_common_rt;
      mdt_eta : signed(PTCALC2MTC_MDT_ETA_LEN-1 downto 0);
      mdt_pt : unsigned(PTCALC2MTC_MDT_PT_LEN-1 downto 0);
      mdt_ptthresh : unsigned(PTCALC2MTC_MDT_PTTHRESH_LEN-1 downto 0);
      mdt_charge : std_logic;
      mdt_procflags : std_logic_vector(SL2MDT_MTC2SL_MDT_PROCFLAGS_LEN-1 downto 0);
      mdt_nsegments : unsigned(PTCALC2MTC_MDT_NSEGMENTS_LEN-1 downto 0);
      mdt_quality : std_logic_vector(PTCALC2MTC_MDT_QUALITY_LEN-1 downto 0);
      m_reserved : std_logic_vector(SL2MDT_MTC2SL_M_RESERVED_LEN-1 downto 0);
   end record sl2mdt_mtc2sl_rt;
   attribute w of sl2mdt_mtc2sl_rt : type is 193;
   function width(x: sl2mdt_mtc2sl_rt) return natural;
   function convert(x: sl2mdt_mtc2sl_rt; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: sl2mdt_mtc2sl_rt) return sl2mdt_mtc2sl_rt;
   function zero(tpl: sl2mdt_mtc2sl_rt) return sl2mdt_mtc2sl_rt;

   type sl2mdt_mtc_out_bus is array(integer range <>) of sl2mdt_mtc2sl_rt;
   function width(x: sl2mdt_mtc_out_bus) return integer;
   function convert(x: sl2mdt_mtc_out_bus; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus;
   function zero(tpl: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus;
   function convert(x: sl2mdt_mtc_out_bus; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus;

end package sl2mdt_dataformats_pkg;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.sl2mdt_constants_pkg.all;

package body sl2mdt_dataformats_pkg is

   -- Custom types and functions --

   function width(x: SL2MDT_header_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.h_reserved);
      w := w + width(x.tcoverflow);
      w := w + width(x.nmtc_sl);
      w := w + width(x.nmtc_mdt);
      w := w + width(x.nslc);
      w := w + width(x.bcid);
      return w;
   end function width;
   function convert(x: SL2MDT_header_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.h_reserved);
         y(u to u+w-1) := convert(x.h_reserved, y(u to u+w-1));
         u := u + w;
         w := width(x.tcoverflow);
         y(u to u+w-1) := convert(x.tcoverflow, y(u to u+w-1));
         u := u + w;
         w := width(x.nmtc_sl);
         y(u to u+w-1) := convert(x.nmtc_sl, y(u to u+w-1));
         u := u + w;
         w := width(x.nmtc_mdt);
         y(u to u+w-1) := convert(x.nmtc_mdt, y(u to u+w-1));
         u := u + w;
         w := width(x.nslc);
         y(u to u+w-1) := convert(x.nslc, y(u to u+w-1));
         u := u + w;
         w := width(x.bcid);
         y(u to u+w-1) := convert(x.bcid, y(u to u+w-1));
      else
         w := width(x.h_reserved);
         y(u downto u-w+1) := convert(x.h_reserved, y(u downto u-w+1));
         u := u - w;
         w := width(x.tcoverflow);
         y(u downto u-w+1) := convert(x.tcoverflow, y(u downto u-w+1));
         u := u - w;
         w := width(x.nmtc_sl);
         y(u downto u-w+1) := convert(x.nmtc_sl, y(u downto u-w+1));
         u := u - w;
         w := width(x.nmtc_mdt);
         y(u downto u-w+1) := convert(x.nmtc_mdt, y(u downto u-w+1));
         u := u - w;
         w := width(x.nslc);
         y(u downto u-w+1) := convert(x.nslc, y(u downto u-w+1));
         u := u - w;
         w := width(x.bcid);
         y(u downto u-w+1) := convert(x.bcid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: SL2MDT_header_rt) return SL2MDT_header_rt is
      variable y : SL2MDT_header_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.h_reserved);
         y.h_reserved := convert(x(u to u+w-1), tpl.h_reserved);
         u := u + w;
         w := width(tpl.tcoverflow);
         y.tcoverflow := convert(x(u to u+w-1), tpl.tcoverflow);
         u := u + w;
         w := width(tpl.nmtc_sl);
         y.nmtc_sl := convert(x(u to u+w-1), tpl.nmtc_sl);
         u := u + w;
         w := width(tpl.nmtc_mdt);
         y.nmtc_mdt := convert(x(u to u+w-1), tpl.nmtc_mdt);
         u := u + w;
         w := width(tpl.nslc);
         y.nslc := convert(x(u to u+w-1), tpl.nslc);
         u := u + w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u to u+w-1), tpl.bcid);
      else
         w := width(tpl.h_reserved);
         y.h_reserved := convert(x(u downto u-w+1), tpl.h_reserved);
         u := u - w;
         w := width(tpl.tcoverflow);
         y.tcoverflow := convert(x(u downto u-w+1), tpl.tcoverflow);
         u := u - w;
         w := width(tpl.nmtc_sl);
         y.nmtc_sl := convert(x(u downto u-w+1), tpl.nmtc_sl);
         u := u - w;
         w := width(tpl.nmtc_mdt);
         y.nmtc_mdt := convert(x(u downto u-w+1), tpl.nmtc_mdt);
         u := u - w;
         w := width(tpl.nslc);
         y.nslc := convert(x(u downto u-w+1), tpl.nslc);
         u := u - w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u downto u-w+1), tpl.bcid);
      end if;
      return y;
   end function convert;
   function zero(tpl: SL2MDT_header_rt) return SL2MDT_header_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: SL2MDT_trailer_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.t_reserved);
      w := w + width(x.crc);
      w := w + width(x.fiberid);
      w := w + width(x.slid);
      w := w + width(x.comma);
      return w;
   end function width;
   function convert(x: SL2MDT_trailer_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.t_reserved);
         y(u to u+w-1) := convert(x.t_reserved, y(u to u+w-1));
         u := u + w;
         w := width(x.crc);
         y(u to u+w-1) := convert(x.crc, y(u to u+w-1));
         u := u + w;
         w := width(x.fiberid);
         y(u to u+w-1) := convert(x.fiberid, y(u to u+w-1));
         u := u + w;
         w := width(x.slid);
         y(u to u+w-1) := convert(x.slid, y(u to u+w-1));
         u := u + w;
         w := width(x.comma);
         y(u to u+w-1) := convert(x.comma, y(u to u+w-1));
      else
         w := width(x.t_reserved);
         y(u downto u-w+1) := convert(x.t_reserved, y(u downto u-w+1));
         u := u - w;
         w := width(x.crc);
         y(u downto u-w+1) := convert(x.crc, y(u downto u-w+1));
         u := u - w;
         w := width(x.fiberid);
         y(u downto u-w+1) := convert(x.fiberid, y(u downto u-w+1));
         u := u - w;
         w := width(x.slid);
         y(u downto u-w+1) := convert(x.slid, y(u downto u-w+1));
         u := u - w;
         w := width(x.comma);
         y(u downto u-w+1) := convert(x.comma, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: SL2MDT_trailer_rt) return SL2MDT_trailer_rt is
      variable y : SL2MDT_trailer_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.t_reserved);
         y.t_reserved := convert(x(u to u+w-1), tpl.t_reserved);
         u := u + w;
         w := width(tpl.crc);
         y.crc := convert(x(u to u+w-1), tpl.crc);
         u := u + w;
         w := width(tpl.fiberid);
         y.fiberid := convert(x(u to u+w-1), tpl.fiberid);
         u := u + w;
         w := width(tpl.slid);
         y.slid := convert(x(u to u+w-1), tpl.slid);
         u := u + w;
         w := width(tpl.comma);
         y.comma := convert(x(u to u+w-1), tpl.comma);
      else
         w := width(tpl.t_reserved);
         y.t_reserved := convert(x(u downto u-w+1), tpl.t_reserved);
         u := u - w;
         w := width(tpl.crc);
         y.crc := convert(x(u downto u-w+1), tpl.crc);
         u := u - w;
         w := width(tpl.fiberid);
         y.fiberid := convert(x(u downto u-w+1), tpl.fiberid);
         u := u - w;
         w := width(tpl.slid);
         y.slid := convert(x(u downto u-w+1), tpl.slid);
         u := u - w;
         w := width(tpl.comma);
         y.comma := convert(x(u downto u-w+1), tpl.comma);
      end if;
      return y;
   end function convert;
   function zero(tpl: SL2MDT_trailer_rt) return SL2MDT_trailer_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: SL2MDT_slc_common_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.header);
      w := w + width(x.slcid);
      w := w + width(x.tcsent);
      w := w + width(x.poseta);
      w := w + width(x.posphi);
      w := w + width(x.SL2MDT_pt);
      w := w + width(x.SL2MDT_ptthresh);
      w := w + width(x.SL2MDT_charge);
      w := w + width(x.cointype);
      w := w + width(x.trailer);
      return w;
   end function width;
   function convert(x: SL2MDT_slc_common_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.header);
         y(u to u+w-1) := convert(x.header, y(u to u+w-1));
         u := u + w;
         w := width(x.slcid);
         y(u to u+w-1) := convert(x.slcid, y(u to u+w-1));
         u := u + w;
         w := width(x.tcsent);
         y(u to u+w-1) := convert(x.tcsent, y(u to u+w-1));
         u := u + w;
         w := width(x.poseta);
         y(u to u+w-1) := convert(x.poseta, y(u to u+w-1));
         u := u + w;
         w := width(x.posphi);
         y(u to u+w-1) := convert(x.posphi, y(u to u+w-1));
         u := u + w;
         w := width(x.SL2MDT_pt);
         y(u to u+w-1) := convert(x.SL2MDT_pt, y(u to u+w-1));
         u := u + w;
         w := width(x.SL2MDT_ptthresh);
         y(u to u+w-1) := convert(x.SL2MDT_ptthresh, y(u to u+w-1));
         u := u + w;
         w := width(x.SL2MDT_charge);
         y(u to u+w-1) := convert(x.SL2MDT_charge, y(u to u+w-1));
         u := u + w;
         w := width(x.cointype);
         y(u to u+w-1) := convert(x.cointype, y(u to u+w-1));
         u := u + w;
         w := width(x.trailer);
         y(u to u+w-1) := convert(x.trailer, y(u to u+w-1));
      else
         w := width(x.header);
         y(u downto u-w+1) := convert(x.header, y(u downto u-w+1));
         u := u - w;
         w := width(x.slcid);
         y(u downto u-w+1) := convert(x.slcid, y(u downto u-w+1));
         u := u - w;
         w := width(x.tcsent);
         y(u downto u-w+1) := convert(x.tcsent, y(u downto u-w+1));
         u := u - w;
         w := width(x.poseta);
         y(u downto u-w+1) := convert(x.poseta, y(u downto u-w+1));
         u := u - w;
         w := width(x.posphi);
         y(u downto u-w+1) := convert(x.posphi, y(u downto u-w+1));
         u := u - w;
         w := width(x.SL2MDT_pt);
         y(u downto u-w+1) := convert(x.SL2MDT_pt, y(u downto u-w+1));
         u := u - w;
         w := width(x.SL2MDT_ptthresh);
         y(u downto u-w+1) := convert(x.SL2MDT_ptthresh, y(u downto u-w+1));
         u := u - w;
         w := width(x.SL2MDT_charge);
         y(u downto u-w+1) := convert(x.SL2MDT_charge, y(u downto u-w+1));
         u := u - w;
         w := width(x.cointype);
         y(u downto u-w+1) := convert(x.cointype, y(u downto u-w+1));
         u := u - w;
         w := width(x.trailer);
         y(u downto u-w+1) := convert(x.trailer, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_common_rt) return SL2MDT_slc_common_rt is
      variable y : SL2MDT_slc_common_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.header);
         y.header := convert(x(u to u+w-1), tpl.header);
         u := u + w;
         w := width(tpl.slcid);
         y.slcid := convert(x(u to u+w-1), tpl.slcid);
         u := u + w;
         w := width(tpl.tcsent);
         y.tcsent := convert(x(u to u+w-1), tpl.tcsent);
         u := u + w;
         w := width(tpl.poseta);
         y.poseta := convert(x(u to u+w-1), tpl.poseta);
         u := u + w;
         w := width(tpl.posphi);
         y.posphi := convert(x(u to u+w-1), tpl.posphi);
         u := u + w;
         w := width(tpl.SL2MDT_pt);
         y.SL2MDT_pt := convert(x(u to u+w-1), tpl.SL2MDT_pt);
         u := u + w;
         w := width(tpl.SL2MDT_ptthresh);
         y.SL2MDT_ptthresh := convert(x(u to u+w-1), tpl.SL2MDT_ptthresh);
         u := u + w;
         w := width(tpl.SL2MDT_charge);
         y.SL2MDT_charge := convert(x(u to u+w-1), tpl.SL2MDT_charge);
         u := u + w;
         w := width(tpl.cointype);
         y.cointype := convert(x(u to u+w-1), tpl.cointype);
         u := u + w;
         w := width(tpl.trailer);
         y.trailer := convert(x(u to u+w-1), tpl.trailer);
      else
         w := width(tpl.header);
         y.header := convert(x(u downto u-w+1), tpl.header);
         u := u - w;
         w := width(tpl.slcid);
         y.slcid := convert(x(u downto u-w+1), tpl.slcid);
         u := u - w;
         w := width(tpl.tcsent);
         y.tcsent := convert(x(u downto u-w+1), tpl.tcsent);
         u := u - w;
         w := width(tpl.poseta);
         y.poseta := convert(x(u downto u-w+1), tpl.poseta);
         u := u - w;
         w := width(tpl.posphi);
         y.posphi := convert(x(u downto u-w+1), tpl.posphi);
         u := u - w;
         w := width(tpl.SL2MDT_pt);
         y.SL2MDT_pt := convert(x(u downto u-w+1), tpl.SL2MDT_pt);
         u := u - w;
         w := width(tpl.SL2MDT_ptthresh);
         y.SL2MDT_ptthresh := convert(x(u downto u-w+1), tpl.SL2MDT_ptthresh);
         u := u - w;
         w := width(tpl.SL2MDT_charge);
         y.SL2MDT_charge := convert(x(u downto u-w+1), tpl.SL2MDT_charge);
         u := u - w;
         w := width(tpl.cointype);
         y.cointype := convert(x(u downto u-w+1), tpl.cointype);
         u := u - w;
         w := width(tpl.trailer);
         y.trailer := convert(x(u downto u-w+1), tpl.trailer);
      end if;
      return y;
   end function convert;
   function zero(tpl: SL2MDT_slc_common_rt) return SL2MDT_slc_common_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: SL2MDT_slc_endcap_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.e_reserved);
      w := w + width(x.nswseg_mon);
      w := w + width(x.nswseg_angdtheta);
      w := w + width(x.nswseg_posphi);
      w := w + width(x.nswseg_poseta);
      w := w + width(x.seg_angdphi);
      w := w + width(x.seg_angdtheta);
      return w;
   end function width;
   function convert(x: SL2MDT_slc_endcap_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.e_reserved);
         y(u to u+w-1) := convert(x.e_reserved, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_mon);
         y(u to u+w-1) := convert(x.nswseg_mon, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_angdtheta);
         y(u to u+w-1) := convert(x.nswseg_angdtheta, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_posphi);
         y(u to u+w-1) := convert(x.nswseg_posphi, y(u to u+w-1));
         u := u + w;
         w := width(x.nswseg_poseta);
         y(u to u+w-1) := convert(x.nswseg_poseta, y(u to u+w-1));
         u := u + w;
         w := width(x.seg_angdphi);
         y(u to u+w-1) := convert(x.seg_angdphi, y(u to u+w-1));
         u := u + w;
         w := width(x.seg_angdtheta);
         y(u to u+w-1) := convert(x.seg_angdtheta, y(u to u+w-1));
      else
         w := width(x.e_reserved);
         y(u downto u-w+1) := convert(x.e_reserved, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_mon);
         y(u downto u-w+1) := convert(x.nswseg_mon, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_angdtheta);
         y(u downto u-w+1) := convert(x.nswseg_angdtheta, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_posphi);
         y(u downto u-w+1) := convert(x.nswseg_posphi, y(u downto u-w+1));
         u := u - w;
         w := width(x.nswseg_poseta);
         y(u downto u-w+1) := convert(x.nswseg_poseta, y(u downto u-w+1));
         u := u - w;
         w := width(x.seg_angdphi);
         y(u downto u-w+1) := convert(x.seg_angdphi, y(u downto u-w+1));
         u := u - w;
         w := width(x.seg_angdtheta);
         y(u downto u-w+1) := convert(x.seg_angdtheta, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_endcap_rt) return SL2MDT_slc_endcap_rt is
      variable y : SL2MDT_slc_endcap_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.e_reserved);
         y.e_reserved := convert(x(u to u+w-1), tpl.e_reserved);
         u := u + w;
         w := width(tpl.nswseg_mon);
         y.nswseg_mon := convert(x(u to u+w-1), tpl.nswseg_mon);
         u := u + w;
         w := width(tpl.nswseg_angdtheta);
         y.nswseg_angdtheta := convert(x(u to u+w-1), tpl.nswseg_angdtheta);
         u := u + w;
         w := width(tpl.nswseg_posphi);
         y.nswseg_posphi := convert(x(u to u+w-1), tpl.nswseg_posphi);
         u := u + w;
         w := width(tpl.nswseg_poseta);
         y.nswseg_poseta := convert(x(u to u+w-1), tpl.nswseg_poseta);
         u := u + w;
         w := width(tpl.seg_angdphi);
         y.seg_angdphi := convert(x(u to u+w-1), tpl.seg_angdphi);
         u := u + w;
         w := width(tpl.seg_angdtheta);
         y.seg_angdtheta := convert(x(u to u+w-1), tpl.seg_angdtheta);
      else
         w := width(tpl.e_reserved);
         y.e_reserved := convert(x(u downto u-w+1), tpl.e_reserved);
         u := u - w;
         w := width(tpl.nswseg_mon);
         y.nswseg_mon := convert(x(u downto u-w+1), tpl.nswseg_mon);
         u := u - w;
         w := width(tpl.nswseg_angdtheta);
         y.nswseg_angdtheta := convert(x(u downto u-w+1), tpl.nswseg_angdtheta);
         u := u - w;
         w := width(tpl.nswseg_posphi);
         y.nswseg_posphi := convert(x(u downto u-w+1), tpl.nswseg_posphi);
         u := u - w;
         w := width(tpl.nswseg_poseta);
         y.nswseg_poseta := convert(x(u downto u-w+1), tpl.nswseg_poseta);
         u := u - w;
         w := width(tpl.seg_angdphi);
         y.seg_angdphi := convert(x(u downto u-w+1), tpl.seg_angdphi);
         u := u - w;
         w := width(tpl.seg_angdtheta);
         y.seg_angdtheta := convert(x(u downto u-w+1), tpl.seg_angdtheta);
      end if;
      return y;
   end function convert;
   function zero(tpl: SL2MDT_slc_endcap_rt) return SL2MDT_slc_endcap_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: SL2MDT_slc_barrel_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.b_reserved);
      w := w + width(x.rpc3_posz);
      w := w + width(x.rpc2_posz);
      w := w + width(x.rpc1_posz);
      w := w + width(x.rpc0_posz);
      return w;
   end function width;
   function convert(x: SL2MDT_slc_barrel_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.b_reserved);
         y(u to u+w-1) := convert(x.b_reserved, y(u to u+w-1));
         u := u + w;
         w := width(x.rpc3_posz);
         y(u to u+w-1) := convert(x.rpc3_posz, y(u to u+w-1));
         u := u + w;
         w := width(x.rpc2_posz);
         y(u to u+w-1) := convert(x.rpc2_posz, y(u to u+w-1));
         u := u + w;
         w := width(x.rpc1_posz);
         y(u to u+w-1) := convert(x.rpc1_posz, y(u to u+w-1));
         u := u + w;
         w := width(x.rpc0_posz);
         y(u to u+w-1) := convert(x.rpc0_posz, y(u to u+w-1));
      else
         w := width(x.b_reserved);
         y(u downto u-w+1) := convert(x.b_reserved, y(u downto u-w+1));
         u := u - w;
         w := width(x.rpc3_posz);
         y(u downto u-w+1) := convert(x.rpc3_posz, y(u downto u-w+1));
         u := u - w;
         w := width(x.rpc2_posz);
         y(u downto u-w+1) := convert(x.rpc2_posz, y(u downto u-w+1));
         u := u - w;
         w := width(x.rpc1_posz);
         y(u downto u-w+1) := convert(x.rpc1_posz, y(u downto u-w+1));
         u := u - w;
         w := width(x.rpc0_posz);
         y(u downto u-w+1) := convert(x.rpc0_posz, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_barrel_rt) return SL2MDT_slc_barrel_rt is
      variable y : SL2MDT_slc_barrel_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.b_reserved);
         y.b_reserved := convert(x(u to u+w-1), tpl.b_reserved);
         u := u + w;
         w := width(tpl.rpc3_posz);
         y.rpc3_posz := convert(x(u to u+w-1), tpl.rpc3_posz);
         u := u + w;
         w := width(tpl.rpc2_posz);
         y.rpc2_posz := convert(x(u to u+w-1), tpl.rpc2_posz);
         u := u + w;
         w := width(tpl.rpc1_posz);
         y.rpc1_posz := convert(x(u to u+w-1), tpl.rpc1_posz);
         u := u + w;
         w := width(tpl.rpc0_posz);
         y.rpc0_posz := convert(x(u to u+w-1), tpl.rpc0_posz);
      else
         w := width(tpl.b_reserved);
         y.b_reserved := convert(x(u downto u-w+1), tpl.b_reserved);
         u := u - w;
         w := width(tpl.rpc3_posz);
         y.rpc3_posz := convert(x(u downto u-w+1), tpl.rpc3_posz);
         u := u - w;
         w := width(tpl.rpc2_posz);
         y.rpc2_posz := convert(x(u downto u-w+1), tpl.rpc2_posz);
         u := u - w;
         w := width(tpl.rpc1_posz);
         y.rpc1_posz := convert(x(u downto u-w+1), tpl.rpc1_posz);
         u := u - w;
         w := width(tpl.rpc0_posz);
         y.rpc0_posz := convert(x(u downto u-w+1), tpl.rpc0_posz);
      end if;
      return y;
   end function convert;
   function zero(tpl: SL2MDT_slc_barrel_rt) return SL2MDT_slc_barrel_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: SL2MDT_slc_rx_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.common);
      w := w + width(x.specific);
      return w;
   end function width;
   function convert(x: SL2MDT_slc_rx_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.common);
         y(u to u+w-1) := convert(x.common, y(u to u+w-1));
         u := u + w;
         w := width(x.specific);
         y(u to u+w-1) := convert(x.specific, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.common);
         y(u downto u-w+1) := convert(x.common, y(u downto u-w+1));
         u := u - w;
         w := width(x.specific);
         y(u downto u-w+1) := convert(x.specific, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_rx_rt) return SL2MDT_slc_rx_rt is
      variable y : SL2MDT_slc_rx_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.common);
         y.common := convert(x(u to u+w-1), tpl.common);
         u := u + w;
         w := width(tpl.specific);
         y.specific := convert(x(u to u+w-1), tpl.specific);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.common);
         y.common := convert(x(u downto u-w+1), tpl.common);
         u := u - w;
         w := width(tpl.specific);
         y.specific := convert(x(u downto u-w+1), tpl.specific);
      end if;
      return y;
   end function convert;
   function zero(tpl: SL2MDT_slc_rx_rt) return SL2MDT_slc_rx_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: SL2MDT_slc_rx_bus) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: SL2MDT_slc_rx_bus; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus is
      variable y : SL2MDT_slc_rx_bus(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: SL2MDT_slc_rx_bus; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus is
      variable y : SL2MDT_slc_rx_bus(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: SL2MDT_slc_endcap_bus) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: SL2MDT_slc_endcap_bus; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus is
      variable y : SL2MDT_slc_endcap_bus(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: SL2MDT_slc_endcap_bus; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus is
      variable y : SL2MDT_slc_endcap_bus(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: SL2MDT_slc_muid_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.slcid);
      w := w + width(x.slid);
      w := w + width(x.bcid);
      return w;
   end function width;
   function convert(x: SL2MDT_slc_muid_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.slcid);
         y(u to u+w-1) := convert(x.slcid, y(u to u+w-1));
         u := u + w;
         w := width(x.slid);
         y(u to u+w-1) := convert(x.slid, y(u to u+w-1));
         u := u + w;
         w := width(x.bcid);
         y(u to u+w-1) := convert(x.bcid, y(u to u+w-1));
      else
         w := width(x.slcid);
         y(u downto u-w+1) := convert(x.slcid, y(u downto u-w+1));
         u := u - w;
         w := width(x.slid);
         y(u downto u-w+1) := convert(x.slid, y(u downto u-w+1));
         u := u - w;
         w := width(x.bcid);
         y(u downto u-w+1) := convert(x.bcid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: SL2MDT_slc_muid_rt) return SL2MDT_slc_muid_rt is
      variable y : SL2MDT_slc_muid_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.slcid);
         y.slcid := convert(x(u to u+w-1), tpl.slcid);
         u := u + w;
         w := width(tpl.slid);
         y.slid := convert(x(u to u+w-1), tpl.slid);
         u := u + w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u to u+w-1), tpl.bcid);
      else
         w := width(tpl.slcid);
         y.slcid := convert(x(u downto u-w+1), tpl.slcid);
         u := u - w;
         w := width(tpl.slid);
         y.slid := convert(x(u downto u-w+1), tpl.slid);
         u := u - w;
         w := width(tpl.bcid);
         y.bcid := convert(x(u downto u-w+1), tpl.bcid);
      end if;
      return y;
   end function convert;
   function zero(tpl: SL2MDT_slc_muid_rt) return SL2MDT_slc_muid_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: vec_mdtid_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.chamber_id);
      w := w + width(x.chamber_ieta);
      return w;
   end function width;
   function convert(x: vec_mdtid_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.chamber_id);
         y(u to u+w-1) := convert(x.chamber_id, y(u to u+w-1));
         u := u + w;
         w := width(x.chamber_ieta);
         y(u to u+w-1) := convert(x.chamber_ieta, y(u to u+w-1));
      else
         w := width(x.chamber_id);
         y(u downto u-w+1) := convert(x.chamber_id, y(u downto u-w+1));
         u := u - w;
         w := width(x.chamber_ieta);
         y(u downto u-w+1) := convert(x.chamber_ieta, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: vec_mdtid_rt) return vec_mdtid_rt is
      variable y : vec_mdtid_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.chamber_id);
         y.chamber_id := convert(x(u to u+w-1), tpl.chamber_id);
         u := u + w;
         w := width(tpl.chamber_ieta);
         y.chamber_ieta := convert(x(u to u+w-1), tpl.chamber_ieta);
      else
         w := width(tpl.chamber_id);
         y.chamber_id := convert(x(u downto u-w+1), tpl.chamber_id);
         u := u - w;
         w := width(tpl.chamber_ieta);
         y.chamber_ieta := convert(x(u downto u-w+1), tpl.chamber_ieta);
      end if;
      return y;
   end function convert;
   function zero(tpl: vec_mdtid_rt) return vec_mdtid_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: sl2mdt_mtc2sl_rt) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.data_valid);
      w := w + width(x.common);
      w := w + width(x.mdt_eta);
      w := w + width(x.mdt_pt);
      w := w + width(x.mdt_ptthresh);
      w := w + width(x.mdt_charge);
      w := w + width(x.mdt_procflags);
      w := w + width(x.mdt_nsegments);
      w := w + width(x.mdt_quality);
      w := w + width(x.m_reserved);
      return w;
   end function width;
   function convert(x: sl2mdt_mtc2sl_rt; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.data_valid);
         y(u to u+w-1) := convert(x.data_valid, y(u to u+w-1));
         u := u + w;
         w := width(x.common);
         y(u to u+w-1) := convert(x.common, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_eta);
         y(u to u+w-1) := convert(x.mdt_eta, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_pt);
         y(u to u+w-1) := convert(x.mdt_pt, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_ptthresh);
         y(u to u+w-1) := convert(x.mdt_ptthresh, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_charge);
         y(u to u+w-1) := convert(x.mdt_charge, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_procflags);
         y(u to u+w-1) := convert(x.mdt_procflags, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_nsegments);
         y(u to u+w-1) := convert(x.mdt_nsegments, y(u to u+w-1));
         u := u + w;
         w := width(x.mdt_quality);
         y(u to u+w-1) := convert(x.mdt_quality, y(u to u+w-1));
         u := u + w;
         w := width(x.m_reserved);
         y(u to u+w-1) := convert(x.m_reserved, y(u to u+w-1));
      else
         w := width(x.data_valid);
         y(u downto u-w+1) := convert(x.data_valid, y(u downto u-w+1));
         u := u - w;
         w := width(x.common);
         y(u downto u-w+1) := convert(x.common, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_eta);
         y(u downto u-w+1) := convert(x.mdt_eta, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_pt);
         y(u downto u-w+1) := convert(x.mdt_pt, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_ptthresh);
         y(u downto u-w+1) := convert(x.mdt_ptthresh, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_charge);
         y(u downto u-w+1) := convert(x.mdt_charge, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_procflags);
         y(u downto u-w+1) := convert(x.mdt_procflags, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_nsegments);
         y(u downto u-w+1) := convert(x.mdt_nsegments, y(u downto u-w+1));
         u := u - w;
         w := width(x.mdt_quality);
         y(u downto u-w+1) := convert(x.mdt_quality, y(u downto u-w+1));
         u := u - w;
         w := width(x.m_reserved);
         y(u downto u-w+1) := convert(x.m_reserved, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: sl2mdt_mtc2sl_rt) return sl2mdt_mtc2sl_rt is
      variable y : sl2mdt_mtc2sl_rt;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u to u+w-1), tpl.data_valid);
         u := u + w;
         w := width(tpl.common);
         y.common := convert(x(u to u+w-1), tpl.common);
         u := u + w;
         w := width(tpl.mdt_eta);
         y.mdt_eta := convert(x(u to u+w-1), tpl.mdt_eta);
         u := u + w;
         w := width(tpl.mdt_pt);
         y.mdt_pt := convert(x(u to u+w-1), tpl.mdt_pt);
         u := u + w;
         w := width(tpl.mdt_ptthresh);
         y.mdt_ptthresh := convert(x(u to u+w-1), tpl.mdt_ptthresh);
         u := u + w;
         w := width(tpl.mdt_charge);
         y.mdt_charge := convert(x(u to u+w-1), tpl.mdt_charge);
         u := u + w;
         w := width(tpl.mdt_procflags);
         y.mdt_procflags := convert(x(u to u+w-1), tpl.mdt_procflags);
         u := u + w;
         w := width(tpl.mdt_nsegments);
         y.mdt_nsegments := convert(x(u to u+w-1), tpl.mdt_nsegments);
         u := u + w;
         w := width(tpl.mdt_quality);
         y.mdt_quality := convert(x(u to u+w-1), tpl.mdt_quality);
         u := u + w;
         w := width(tpl.m_reserved);
         y.m_reserved := convert(x(u to u+w-1), tpl.m_reserved);
      else
         w := width(tpl.data_valid);
         y.data_valid := convert(x(u downto u-w+1), tpl.data_valid);
         u := u - w;
         w := width(tpl.common);
         y.common := convert(x(u downto u-w+1), tpl.common);
         u := u - w;
         w := width(tpl.mdt_eta);
         y.mdt_eta := convert(x(u downto u-w+1), tpl.mdt_eta);
         u := u - w;
         w := width(tpl.mdt_pt);
         y.mdt_pt := convert(x(u downto u-w+1), tpl.mdt_pt);
         u := u - w;
         w := width(tpl.mdt_ptthresh);
         y.mdt_ptthresh := convert(x(u downto u-w+1), tpl.mdt_ptthresh);
         u := u - w;
         w := width(tpl.mdt_charge);
         y.mdt_charge := convert(x(u downto u-w+1), tpl.mdt_charge);
         u := u - w;
         w := width(tpl.mdt_procflags);
         y.mdt_procflags := convert(x(u downto u-w+1), tpl.mdt_procflags);
         u := u - w;
         w := width(tpl.mdt_nsegments);
         y.mdt_nsegments := convert(x(u downto u-w+1), tpl.mdt_nsegments);
         u := u - w;
         w := width(tpl.mdt_quality);
         y.mdt_quality := convert(x(u downto u-w+1), tpl.mdt_quality);
         u := u - w;
         w := width(tpl.m_reserved);
         y.m_reserved := convert(x(u downto u-w+1), tpl.m_reserved);
      end if;
      return y;
   end function convert;
   function zero(tpl: sl2mdt_mtc2sl_rt) return sl2mdt_mtc2sl_rt is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: sl2mdt_mtc_out_bus) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: sl2mdt_mtc_out_bus; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus is
      variable y : sl2mdt_mtc_out_bus(tpl'range);
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: sl2mdt_mtc_out_bus; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus is
      variable y : sl2mdt_mtc_out_bus(tpl'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

end package body sl2mdt_dataformats_pkg;
