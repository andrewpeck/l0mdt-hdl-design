-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;
use shared_lib.l0mdt_constants_pkg.all;
use shared_lib.l0mdt_dataformats_pkg.all;
use shared_lib.common_constants_pkg.all;
use shared_lib.sl2mdt_constants_pkg.all;

package sl2mdt_dataformats_pkg is

  type SL2MDT_header is record
    h_reserved : std_logic_vector(SL2MDT_HEADER_H_RESERVED_LEN-1 downto 0);
    tcoverflow : std_logic;
    nmtc_sl : unsigned(SL2MDT_HEADER_NMTC_SL_LEN-1 downto 0);
    nmtc_mdt : unsigned(SL2MDT_HEADER_NMTC_MDT_LEN-1 downto 0);
    nslc : unsigned(SL2MDT_HEADER_NSLC_SLC_LEN-1 downto 0);
    bcid : unsigned(SL2MDT_HEADER_BCID_LEN-1 downto 0);
  end record SL2MDT_header;
  function len(x: SL2MDT_header) return natural;
  function width(x: SL2MDT_header) return natural;
  function vectorify(x: SL2MDT_header; t: std_logic_vector) return std_logic_vector;
  function convert(x: SL2MDT_header; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: SL2MDT_header) return SL2MDT_header;
  function convert(x: in std_logic_vector; t: SL2MDT_header) return SL2MDT_header;
  function nullify(t: SL2MDT_header) return SL2MDT_header;
  function zeroed(t: SL2MDT_header) return SL2MDT_header;

  type SL2MDT_trailer is record
    t_reserved : std_logic_vector(SL2MDT_TRAILER_T_RESERVED_LEN-1 downto 0);
    crc : std_logic_vector(SL2MDT_TRAILER_CRC_LEN-1 downto 0);
    fiberid : unsigned(SL2MDT_TRAILER_FIBERID_LEN-1 downto 0);
    slid : unsigned(SL2MDT_TRAILER_SLID_LEN-1 downto 0);
    comma : std_logic_vector(SL2MDT_TRAILER_COMMA_LEN-1 downto 0);
  end record SL2MDT_trailer;
  function len(x: SL2MDT_trailer) return natural;
  function width(x: SL2MDT_trailer) return natural;
  function vectorify(x: SL2MDT_trailer; t: std_logic_vector) return std_logic_vector;
  function convert(x: SL2MDT_trailer; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: SL2MDT_trailer) return SL2MDT_trailer;
  function convert(x: in std_logic_vector; t: SL2MDT_trailer) return SL2MDT_trailer;
  function nullify(t: SL2MDT_trailer) return SL2MDT_trailer;
  function zeroed(t: SL2MDT_trailer) return SL2MDT_trailer;

  type SL2MDT_slc_common is record
    header : SL2MDT_header;
    slcid : unsigned(SL2MDT_SLC_COMMON_SLCID_LEN-1 downto 0);
    tcsent : std_logic;
    poseta : signed(SL2MDT_SLC_COMMON_POSETA_LEN-1 downto 0);
    posphi : unsigned(SL2MDT_SLC_COMMON_POSPHI_LEN-1 downto 0);
    SL2MDT_pt : unsigned(SL2MDT_SLC_COMMON_SL_PT_LEN-1 downto 0);
    SL2MDT_ptthresh : unsigned(SL2MDT_SLC_COMMON_SL_PTTHRESH_LEN-1 downto 0);
    SL2MDT_charge : std_logic;
    cointype : std_logic_vector(SL2MDT_SLC_COMMON_COINTYPE_LEN-1 downto 0);
    trailer : SL2MDT_trailer;
  end record SL2MDT_slc_common;
  function len(x: SL2MDT_slc_common) return natural;
  function width(x: SL2MDT_slc_common) return natural;
  function vectorify(x: SL2MDT_slc_common; t: std_logic_vector) return std_logic_vector;
  function convert(x: SL2MDT_slc_common; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_common) return SL2MDT_slc_common;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_common) return SL2MDT_slc_common;
  function nullify(t: SL2MDT_slc_common) return SL2MDT_slc_common;
  function zeroed(t: SL2MDT_slc_common) return SL2MDT_slc_common;

  type SL2MDT_slc_endcap is record
    e_reserved : std_logic_vector(SL2MDT_SLC_ENDCAP_E_RESERVED_LEN-1 downto 0);
    nswseg_mon : std_logic;
    nswseg_angdtheta : signed(SL2MDT_SLC_ENDCAP_NSWSEG_ANGDTHETA_LEN-1 downto 0);
    nswseg_posphi : unsigned(SL2MDT_SLC_ENDCAP_NSWSEG_POSPHI_LEN-1 downto 0);
    nswseg_poseta : unsigned(SL2MDT_SLC_ENDCAP_NSWSEG_POSETA_LEN-1 downto 0);
    seg_angdphi : signed(SL2MDT_SLC_ENDCAP_SEG_ANGDPHI_LEN-1 downto 0);
    seg_angdtheta : signed(SL2MDT_SLC_ENDCAP_SEG_ANGDTHETA_LEN-1 downto 0);
  end record SL2MDT_slc_endcap;
  function len(x: SL2MDT_slc_endcap) return natural;
  function width(x: SL2MDT_slc_endcap) return natural;
  function vectorify(x: SL2MDT_slc_endcap; t: std_logic_vector) return std_logic_vector;
  function convert(x: SL2MDT_slc_endcap; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_endcap) return SL2MDT_slc_endcap;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_endcap) return SL2MDT_slc_endcap;
  function nullify(t: SL2MDT_slc_endcap) return SL2MDT_slc_endcap;
  function zeroed(t: SL2MDT_slc_endcap) return SL2MDT_slc_endcap;

  type SL2MDT_slc_barrel is record
    b_reserved : std_logic_vector(SL2MDT_SLC_BARREL_B_RESERVED_LEN-1 downto 0);
    rpc3_posz : signed(SL2MDT_SLC_BARREL_RPC3_POSZ_LEN-1 downto 0);
    rpc2_posz : signed(SL2MDT_SLC_BARREL_RPC2_POSZ_LEN-1 downto 0);
    rpc1_posz : signed(SL2MDT_SLC_BARREL_RPC1_POSZ_LEN-1 downto 0);
    rpc0_posz : signed(SL2MDT_SLC_BARREL_RPC0_POSZ_LEN-1 downto 0);
  end record SL2MDT_slc_barrel;
  function len(x: SL2MDT_slc_barrel) return natural;
  function width(x: SL2MDT_slc_barrel) return natural;
  function vectorify(x: SL2MDT_slc_barrel; t: std_logic_vector) return std_logic_vector;
  function convert(x: SL2MDT_slc_barrel; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_barrel) return SL2MDT_slc_barrel;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_barrel) return SL2MDT_slc_barrel;
  function nullify(t: SL2MDT_slc_barrel) return SL2MDT_slc_barrel;
  function zeroed(t: SL2MDT_slc_barrel) return SL2MDT_slc_barrel;

  type SL2MDT_slc_rx is record
    data_valid : std_logic;
    common : SL2MDT_slc_common;
    specific : std_logic_vector(SL2MDT_SLC_RX_SPECIFIC_LEN-1 downto 0);
  end record SL2MDT_slc_rx;
  function len(x: SL2MDT_slc_rx) return natural;
  function width(x: SL2MDT_slc_rx) return natural;
  function vectorify(x: SL2MDT_slc_rx; t: std_logic_vector) return std_logic_vector;
  function convert(x: SL2MDT_slc_rx; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_rx) return SL2MDT_slc_rx;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_rx) return SL2MDT_slc_rx;
  function nullify(t: SL2MDT_slc_rx) return SL2MDT_slc_rx;
  function zeroed(t: SL2MDT_slc_rx) return SL2MDT_slc_rx;

  type SL2MDT_slc_rx_bus is array(integer range <>) of SL2MDT_slc_rx;
  function len(x: SL2MDT_slc_rx_bus) return natural;
  function width(x: SL2MDT_slc_rx_bus) return natural;
  function vectorify(x: SL2MDT_slc_rx_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: SL2MDT_slc_rx_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus;
  function convert(x: std_logic_vector; t: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus;
  function nullify(x: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus;
  function zeroed(x: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus;

  type SL2MDT_slc_endcap_bus is array(integer range <>) of SL2MDT_slc_endcap;
  function len(x: SL2MDT_slc_endcap_bus) return natural;
  function width(x: SL2MDT_slc_endcap_bus) return natural;
  function vectorify(x: SL2MDT_slc_endcap_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: SL2MDT_slc_endcap_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus;
  function convert(x: std_logic_vector; t: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus;
  function nullify(x: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus;
  function zeroed(x: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus;

  type SL2MDT_slc_muid is record
    slcid : unsigned(SL2MDT_SLC_COMMON_SLCID_LEN-1 downto 0);
    slid : unsigned(SL2MDT_TRAILER_SLID_LEN-1 downto 0);
    bcid : unsigned(SL2MDT_HEADER_BCID_LEN-1 downto 0);
  end record SL2MDT_slc_muid;
  function len(x: SL2MDT_slc_muid) return natural;
  function width(x: SL2MDT_slc_muid) return natural;
  function vectorify(x: SL2MDT_slc_muid; t: std_logic_vector) return std_logic_vector;
  function convert(x: SL2MDT_slc_muid; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_muid) return SL2MDT_slc_muid;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_muid) return SL2MDT_slc_muid;
  function nullify(t: SL2MDT_slc_muid) return SL2MDT_slc_muid;
  function zeroed(t: SL2MDT_slc_muid) return SL2MDT_slc_muid;

  type vec_mdtid is record
    chamber_id : unsigned(SL2MDT_VEC_MDTID_CHAMBER_ID_LEN-1 downto 0);
    chamber_ieta : unsigned(SL2MDT_VEC_MDTID_CHAMBER_IETA_LEN-1 downto 0);
  end record vec_mdtid;
  function len(x: vec_mdtid) return natural;
  function width(x: vec_mdtid) return natural;
  function vectorify(x: vec_mdtid; t: std_logic_vector) return std_logic_vector;
  function convert(x: vec_mdtid; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: vec_mdtid) return vec_mdtid;
  function convert(x: in std_logic_vector; t: vec_mdtid) return vec_mdtid;
  function nullify(t: vec_mdtid) return vec_mdtid;
  function zeroed(t: vec_mdtid) return vec_mdtid;

  type sl2mdt_mtc2sl is record
    data_valid : std_logic;
    common : slc_common_rt;
    mdt_eta : signed(PTCALC2MTC_MDT_ETA_LEN-1 downto 0);
    mdt_pt : unsigned(PTCALC2MTC_MDT_PT_LEN-1 downto 0);
    mdt_ptthresh : unsigned(PTCALC2MTC_MDT_PTTHRESH_LEN-1 downto 0);
    mdt_charge : std_logic;
    mdt_procflags : std_logic_vector(SL2MDT_MTC2SL_MDT_PROCFLAGS_LEN-1 downto 0);
    mdt_nsegments : unsigned(PTCALC2MTC_MDT_NSEGMENTS_LEN-1 downto 0);
    mdt_quality : std_logic_vector(PTCALC2MTC_MDT_QUALITY_LEN-1 downto 0);
    m_reserved : std_logic_vector(SL2MDT_MTC2SL_M_RESERVED_LEN-1 downto 0);
  end record sl2mdt_mtc2sl;
  function len(x: sl2mdt_mtc2sl) return natural;
  function width(x: sl2mdt_mtc2sl) return natural;
  function vectorify(x: sl2mdt_mtc2sl; t: std_logic_vector) return std_logic_vector;
  function convert(x: sl2mdt_mtc2sl; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: sl2mdt_mtc2sl) return sl2mdt_mtc2sl;
  function convert(x: in std_logic_vector; t: sl2mdt_mtc2sl) return sl2mdt_mtc2sl;
  function nullify(t: sl2mdt_mtc2sl) return sl2mdt_mtc2sl;
  function zeroed(t: sl2mdt_mtc2sl) return sl2mdt_mtc2sl;

  type sl2mdt_mtc_out_bus is array(integer range <>) of sl2mdt_mtc2sl;
  function len(x: sl2mdt_mtc_out_bus) return natural;
  function width(x: sl2mdt_mtc_out_bus) return natural;
  function vectorify(x: sl2mdt_mtc_out_bus; t: std_logic_vector) return std_logic_vector;
  function convert(x: sl2mdt_mtc_out_bus; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus;
  function convert(x: std_logic_vector; t: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus;
  function nullify(x: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus;
  function zeroed(x: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus;

end package sl2mdt_dataformats_pkg;

------------------------------------------------------------

package body sl2mdt_dataformats_pkg is

  function len(x: SL2MDT_header) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.h_reserved);
    l := l + len(x.tcoverflow);
    l := l + len(x.nmtc_sl);
    l := l + len(x.nmtc_mdt);
    l := l + len(x.nslc);
    l := l + len(x.bcid);
    return l;
  end function len;
  function width(x: SL2MDT_header) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.h_reserved);
    l := l + width(x.tcoverflow);
    l := l + width(x.nmtc_sl);
    l := l + width(x.nmtc_mdt);
    l := l + width(x.nslc);
    l := l + width(x.bcid);
    return l;
  end function width;
  function vectorify(x: SL2MDT_header; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.h_reserved)-1), vectorify(x.h_reserved, y(left to left+len(x.h_reserved)-1)));
      left := left + len(x.h_reserved);
      assign(y(left to left+len(x.tcoverflow)-1), vectorify(x.tcoverflow, y(left to left+len(x.tcoverflow)-1)));
      left := left + len(x.tcoverflow);
      assign(y(left to left+len(x.nmtc_sl)-1), vectorify(x.nmtc_sl, y(left to left+len(x.nmtc_sl)-1)));
      left := left + len(x.nmtc_sl);
      assign(y(left to left+len(x.nmtc_mdt)-1), vectorify(x.nmtc_mdt, y(left to left+len(x.nmtc_mdt)-1)));
      left := left + len(x.nmtc_mdt);
      assign(y(left to left+len(x.nslc)-1), vectorify(x.nslc, y(left to left+len(x.nslc)-1)));
      left := left + len(x.nslc);
      assign(y(left to left+len(x.bcid)-1), vectorify(x.bcid, y(left to left+len(x.bcid)-1)));
    else
      assign(y(left downto left-len(x.h_reserved)+1), vectorify(x.h_reserved, y(left downto left-len(x.h_reserved)+1)));
      left := left - len(x.h_reserved);
      assign(y(left downto left-len(x.tcoverflow)+1), vectorify(x.tcoverflow, y(left downto left-len(x.tcoverflow)+1)));
      left := left - len(x.tcoverflow);
      assign(y(left downto left-len(x.nmtc_sl)+1), vectorify(x.nmtc_sl, y(left downto left-len(x.nmtc_sl)+1)));
      left := left - len(x.nmtc_sl);
      assign(y(left downto left-len(x.nmtc_mdt)+1), vectorify(x.nmtc_mdt, y(left downto left-len(x.nmtc_mdt)+1)));
      left := left - len(x.nmtc_mdt);
      assign(y(left downto left-len(x.nslc)+1), vectorify(x.nslc, y(left downto left-len(x.nslc)+1)));
      left := left - len(x.nslc);
      assign(y(left downto left-len(x.bcid)+1), vectorify(x.bcid, y(left downto left-len(x.bcid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: SL2MDT_header; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.h_reserved)-1), convert(x.h_reserved, y(left to left+len(x.h_reserved)-1)));
      left := left + len(x.h_reserved);
      assign(y(left to left+len(x.tcoverflow)-1), convert(x.tcoverflow, y(left to left+len(x.tcoverflow)-1)));
      left := left + len(x.tcoverflow);
      assign(y(left to left+len(x.nmtc_sl)-1), convert(x.nmtc_sl, y(left to left+len(x.nmtc_sl)-1)));
      left := left + len(x.nmtc_sl);
      assign(y(left to left+len(x.nmtc_mdt)-1), convert(x.nmtc_mdt, y(left to left+len(x.nmtc_mdt)-1)));
      left := left + len(x.nmtc_mdt);
      assign(y(left to left+len(x.nslc)-1), convert(x.nslc, y(left to left+len(x.nslc)-1)));
      left := left + len(x.nslc);
      assign(y(left to left+len(x.bcid)-1), convert(x.bcid, y(left to left+len(x.bcid)-1)));
    else
      assign(y(left downto left-len(x.h_reserved)+1), convert(x.h_reserved, y(left downto left-len(x.h_reserved)+1)));
      left := left - len(x.h_reserved);
      assign(y(left downto left-len(x.tcoverflow)+1), convert(x.tcoverflow, y(left downto left-len(x.tcoverflow)+1)));
      left := left - len(x.tcoverflow);
      assign(y(left downto left-len(x.nmtc_sl)+1), convert(x.nmtc_sl, y(left downto left-len(x.nmtc_sl)+1)));
      left := left - len(x.nmtc_sl);
      assign(y(left downto left-len(x.nmtc_mdt)+1), convert(x.nmtc_mdt, y(left downto left-len(x.nmtc_mdt)+1)));
      left := left - len(x.nmtc_mdt);
      assign(y(left downto left-len(x.nslc)+1), convert(x.nslc, y(left downto left-len(x.nslc)+1)));
      left := left - len(x.nslc);
      assign(y(left downto left-len(x.bcid)+1), convert(x.bcid, y(left downto left-len(x.bcid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: SL2MDT_header) return SL2MDT_header is
    variable y: SL2MDT_header;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.h_reserved := structify(x(left to left+len(y.h_reserved)-1), y.h_reserved);
      left := left + len(y.h_reserved);
      y.tcoverflow := structify(x(left to left+len(y.tcoverflow)-1), y.tcoverflow);
      left := left + len(y.tcoverflow);
      y.nmtc_sl := structify(x(left to left+len(y.nmtc_sl)-1), y.nmtc_sl);
      left := left + len(y.nmtc_sl);
      y.nmtc_mdt := structify(x(left to left+len(y.nmtc_mdt)-1), y.nmtc_mdt);
      left := left + len(y.nmtc_mdt);
      y.nslc := structify(x(left to left+len(y.nslc)-1), y.nslc);
      left := left + len(y.nslc);
      y.bcid := structify(x(left to left+len(y.bcid)-1), y.bcid);
    else
      y.h_reserved := structify(x(left downto left-len(y.h_reserved)+1), y.h_reserved);
      left := left - len(y.h_reserved);
      y.tcoverflow := structify(x(left downto left-len(y.tcoverflow)+1), y.tcoverflow);
      left := left - len(y.tcoverflow);
      y.nmtc_sl := structify(x(left downto left-len(y.nmtc_sl)+1), y.nmtc_sl);
      left := left - len(y.nmtc_sl);
      y.nmtc_mdt := structify(x(left downto left-len(y.nmtc_mdt)+1), y.nmtc_mdt);
      left := left - len(y.nmtc_mdt);
      y.nslc := structify(x(left downto left-len(y.nslc)+1), y.nslc);
      left := left - len(y.nslc);
      y.bcid := structify(x(left downto left-len(y.bcid)+1), y.bcid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: SL2MDT_header) return SL2MDT_header is
    variable y: SL2MDT_header;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.h_reserved := convert(x(left to left+len(y.h_reserved)-1), y.h_reserved);
      left := left + len(y.h_reserved);
      y.tcoverflow := convert(x(left to left+len(y.tcoverflow)-1), y.tcoverflow);
      left := left + len(y.tcoverflow);
      y.nmtc_sl := convert(x(left to left+len(y.nmtc_sl)-1), y.nmtc_sl);
      left := left + len(y.nmtc_sl);
      y.nmtc_mdt := convert(x(left to left+len(y.nmtc_mdt)-1), y.nmtc_mdt);
      left := left + len(y.nmtc_mdt);
      y.nslc := convert(x(left to left+len(y.nslc)-1), y.nslc);
      left := left + len(y.nslc);
      y.bcid := convert(x(left to left+len(y.bcid)-1), y.bcid);
    else
      y.h_reserved := convert(x(left downto left-len(y.h_reserved)+1), y.h_reserved);
      left := left - len(y.h_reserved);
      y.tcoverflow := convert(x(left downto left-len(y.tcoverflow)+1), y.tcoverflow);
      left := left - len(y.tcoverflow);
      y.nmtc_sl := convert(x(left downto left-len(y.nmtc_sl)+1), y.nmtc_sl);
      left := left - len(y.nmtc_sl);
      y.nmtc_mdt := convert(x(left downto left-len(y.nmtc_mdt)+1), y.nmtc_mdt);
      left := left - len(y.nmtc_mdt);
      y.nslc := convert(x(left downto left-len(y.nslc)+1), y.nslc);
      left := left - len(y.nslc);
      y.bcid := convert(x(left downto left-len(y.bcid)+1), y.bcid);
    end if;
    return y;
  end function convert;
  function nullify(t: SL2MDT_header) return SL2MDT_header is
  variable y: SL2MDT_header;
  begin
    y.h_reserved := nullify(t.h_reserved);
    y.tcoverflow := nullify(t.tcoverflow);
    y.nmtc_sl := nullify(t.nmtc_sl);
    y.nmtc_mdt := nullify(t.nmtc_mdt);
    y.nslc := nullify(t.nslc);
    y.bcid := nullify(t.bcid);
    return y;
  end function nullify;
  function zeroed(t: SL2MDT_header) return SL2MDT_header is
  variable y: SL2MDT_header;
  begin
    y.h_reserved := zeroed(t.h_reserved);
    y.tcoverflow := zeroed(t.tcoverflow);
    y.nmtc_sl := zeroed(t.nmtc_sl);
    y.nmtc_mdt := zeroed(t.nmtc_mdt);
    y.nslc := zeroed(t.nslc);
    y.bcid := zeroed(t.bcid);
    return y;
  end function zeroed;

  function len(x: SL2MDT_trailer) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.t_reserved);
    l := l + len(x.crc);
    l := l + len(x.fiberid);
    l := l + len(x.slid);
    l := l + len(x.comma);
    return l;
  end function len;
  function width(x: SL2MDT_trailer) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.t_reserved);
    l := l + width(x.crc);
    l := l + width(x.fiberid);
    l := l + width(x.slid);
    l := l + width(x.comma);
    return l;
  end function width;
  function vectorify(x: SL2MDT_trailer; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.t_reserved)-1), vectorify(x.t_reserved, y(left to left+len(x.t_reserved)-1)));
      left := left + len(x.t_reserved);
      assign(y(left to left+len(x.crc)-1), vectorify(x.crc, y(left to left+len(x.crc)-1)));
      left := left + len(x.crc);
      assign(y(left to left+len(x.fiberid)-1), vectorify(x.fiberid, y(left to left+len(x.fiberid)-1)));
      left := left + len(x.fiberid);
      assign(y(left to left+len(x.slid)-1), vectorify(x.slid, y(left to left+len(x.slid)-1)));
      left := left + len(x.slid);
      assign(y(left to left+len(x.comma)-1), vectorify(x.comma, y(left to left+len(x.comma)-1)));
    else
      assign(y(left downto left-len(x.t_reserved)+1), vectorify(x.t_reserved, y(left downto left-len(x.t_reserved)+1)));
      left := left - len(x.t_reserved);
      assign(y(left downto left-len(x.crc)+1), vectorify(x.crc, y(left downto left-len(x.crc)+1)));
      left := left - len(x.crc);
      assign(y(left downto left-len(x.fiberid)+1), vectorify(x.fiberid, y(left downto left-len(x.fiberid)+1)));
      left := left - len(x.fiberid);
      assign(y(left downto left-len(x.slid)+1), vectorify(x.slid, y(left downto left-len(x.slid)+1)));
      left := left - len(x.slid);
      assign(y(left downto left-len(x.comma)+1), vectorify(x.comma, y(left downto left-len(x.comma)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: SL2MDT_trailer; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.t_reserved)-1), convert(x.t_reserved, y(left to left+len(x.t_reserved)-1)));
      left := left + len(x.t_reserved);
      assign(y(left to left+len(x.crc)-1), convert(x.crc, y(left to left+len(x.crc)-1)));
      left := left + len(x.crc);
      assign(y(left to left+len(x.fiberid)-1), convert(x.fiberid, y(left to left+len(x.fiberid)-1)));
      left := left + len(x.fiberid);
      assign(y(left to left+len(x.slid)-1), convert(x.slid, y(left to left+len(x.slid)-1)));
      left := left + len(x.slid);
      assign(y(left to left+len(x.comma)-1), convert(x.comma, y(left to left+len(x.comma)-1)));
    else
      assign(y(left downto left-len(x.t_reserved)+1), convert(x.t_reserved, y(left downto left-len(x.t_reserved)+1)));
      left := left - len(x.t_reserved);
      assign(y(left downto left-len(x.crc)+1), convert(x.crc, y(left downto left-len(x.crc)+1)));
      left := left - len(x.crc);
      assign(y(left downto left-len(x.fiberid)+1), convert(x.fiberid, y(left downto left-len(x.fiberid)+1)));
      left := left - len(x.fiberid);
      assign(y(left downto left-len(x.slid)+1), convert(x.slid, y(left downto left-len(x.slid)+1)));
      left := left - len(x.slid);
      assign(y(left downto left-len(x.comma)+1), convert(x.comma, y(left downto left-len(x.comma)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: SL2MDT_trailer) return SL2MDT_trailer is
    variable y: SL2MDT_trailer;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.t_reserved := structify(x(left to left+len(y.t_reserved)-1), y.t_reserved);
      left := left + len(y.t_reserved);
      y.crc := structify(x(left to left+len(y.crc)-1), y.crc);
      left := left + len(y.crc);
      y.fiberid := structify(x(left to left+len(y.fiberid)-1), y.fiberid);
      left := left + len(y.fiberid);
      y.slid := structify(x(left to left+len(y.slid)-1), y.slid);
      left := left + len(y.slid);
      y.comma := structify(x(left to left+len(y.comma)-1), y.comma);
    else
      y.t_reserved := structify(x(left downto left-len(y.t_reserved)+1), y.t_reserved);
      left := left - len(y.t_reserved);
      y.crc := structify(x(left downto left-len(y.crc)+1), y.crc);
      left := left - len(y.crc);
      y.fiberid := structify(x(left downto left-len(y.fiberid)+1), y.fiberid);
      left := left - len(y.fiberid);
      y.slid := structify(x(left downto left-len(y.slid)+1), y.slid);
      left := left - len(y.slid);
      y.comma := structify(x(left downto left-len(y.comma)+1), y.comma);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: SL2MDT_trailer) return SL2MDT_trailer is
    variable y: SL2MDT_trailer;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.t_reserved := convert(x(left to left+len(y.t_reserved)-1), y.t_reserved);
      left := left + len(y.t_reserved);
      y.crc := convert(x(left to left+len(y.crc)-1), y.crc);
      left := left + len(y.crc);
      y.fiberid := convert(x(left to left+len(y.fiberid)-1), y.fiberid);
      left := left + len(y.fiberid);
      y.slid := convert(x(left to left+len(y.slid)-1), y.slid);
      left := left + len(y.slid);
      y.comma := convert(x(left to left+len(y.comma)-1), y.comma);
    else
      y.t_reserved := convert(x(left downto left-len(y.t_reserved)+1), y.t_reserved);
      left := left - len(y.t_reserved);
      y.crc := convert(x(left downto left-len(y.crc)+1), y.crc);
      left := left - len(y.crc);
      y.fiberid := convert(x(left downto left-len(y.fiberid)+1), y.fiberid);
      left := left - len(y.fiberid);
      y.slid := convert(x(left downto left-len(y.slid)+1), y.slid);
      left := left - len(y.slid);
      y.comma := convert(x(left downto left-len(y.comma)+1), y.comma);
    end if;
    return y;
  end function convert;
  function nullify(t: SL2MDT_trailer) return SL2MDT_trailer is
  variable y: SL2MDT_trailer;
  begin
    y.t_reserved := nullify(t.t_reserved);
    y.crc := nullify(t.crc);
    y.fiberid := nullify(t.fiberid);
    y.slid := nullify(t.slid);
    y.comma := nullify(t.comma);
    return y;
  end function nullify;
  function zeroed(t: SL2MDT_trailer) return SL2MDT_trailer is
  variable y: SL2MDT_trailer;
  begin
    y.t_reserved := zeroed(t.t_reserved);
    y.crc := zeroed(t.crc);
    y.fiberid := zeroed(t.fiberid);
    y.slid := zeroed(t.slid);
    y.comma := zeroed(t.comma);
    return y;
  end function zeroed;

  function len(x: SL2MDT_slc_common) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.header);
    l := l + len(x.slcid);
    l := l + len(x.tcsent);
    l := l + len(x.poseta);
    l := l + len(x.posphi);
    l := l + len(x.SL2MDT_pt);
    l := l + len(x.SL2MDT_ptthresh);
    l := l + len(x.SL2MDT_charge);
    l := l + len(x.cointype);
    l := l + len(x.trailer);
    return l;
  end function len;
  function width(x: SL2MDT_slc_common) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.header);
    l := l + width(x.slcid);
    l := l + width(x.tcsent);
    l := l + width(x.poseta);
    l := l + width(x.posphi);
    l := l + width(x.SL2MDT_pt);
    l := l + width(x.SL2MDT_ptthresh);
    l := l + width(x.SL2MDT_charge);
    l := l + width(x.cointype);
    l := l + width(x.trailer);
    return l;
  end function width;
  function vectorify(x: SL2MDT_slc_common; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.header)-1), vectorify(x.header, y(left to left+len(x.header)-1)));
      left := left + len(x.header);
      assign(y(left to left+len(x.slcid)-1), vectorify(x.slcid, y(left to left+len(x.slcid)-1)));
      left := left + len(x.slcid);
      assign(y(left to left+len(x.tcsent)-1), vectorify(x.tcsent, y(left to left+len(x.tcsent)-1)));
      left := left + len(x.tcsent);
      assign(y(left to left+len(x.poseta)-1), vectorify(x.poseta, y(left to left+len(x.poseta)-1)));
      left := left + len(x.poseta);
      assign(y(left to left+len(x.posphi)-1), vectorify(x.posphi, y(left to left+len(x.posphi)-1)));
      left := left + len(x.posphi);
      assign(y(left to left+len(x.SL2MDT_pt)-1), vectorify(x.SL2MDT_pt, y(left to left+len(x.SL2MDT_pt)-1)));
      left := left + len(x.SL2MDT_pt);
      assign(y(left to left+len(x.SL2MDT_ptthresh)-1), vectorify(x.SL2MDT_ptthresh, y(left to left+len(x.SL2MDT_ptthresh)-1)));
      left := left + len(x.SL2MDT_ptthresh);
      assign(y(left to left+len(x.SL2MDT_charge)-1), vectorify(x.SL2MDT_charge, y(left to left+len(x.SL2MDT_charge)-1)));
      left := left + len(x.SL2MDT_charge);
      assign(y(left to left+len(x.cointype)-1), vectorify(x.cointype, y(left to left+len(x.cointype)-1)));
      left := left + len(x.cointype);
      assign(y(left to left+len(x.trailer)-1), vectorify(x.trailer, y(left to left+len(x.trailer)-1)));
    else
      assign(y(left downto left-len(x.header)+1), vectorify(x.header, y(left downto left-len(x.header)+1)));
      left := left - len(x.header);
      assign(y(left downto left-len(x.slcid)+1), vectorify(x.slcid, y(left downto left-len(x.slcid)+1)));
      left := left - len(x.slcid);
      assign(y(left downto left-len(x.tcsent)+1), vectorify(x.tcsent, y(left downto left-len(x.tcsent)+1)));
      left := left - len(x.tcsent);
      assign(y(left downto left-len(x.poseta)+1), vectorify(x.poseta, y(left downto left-len(x.poseta)+1)));
      left := left - len(x.poseta);
      assign(y(left downto left-len(x.posphi)+1), vectorify(x.posphi, y(left downto left-len(x.posphi)+1)));
      left := left - len(x.posphi);
      assign(y(left downto left-len(x.SL2MDT_pt)+1), vectorify(x.SL2MDT_pt, y(left downto left-len(x.SL2MDT_pt)+1)));
      left := left - len(x.SL2MDT_pt);
      assign(y(left downto left-len(x.SL2MDT_ptthresh)+1), vectorify(x.SL2MDT_ptthresh, y(left downto left-len(x.SL2MDT_ptthresh)+1)));
      left := left - len(x.SL2MDT_ptthresh);
      assign(y(left downto left-len(x.SL2MDT_charge)+1), vectorify(x.SL2MDT_charge, y(left downto left-len(x.SL2MDT_charge)+1)));
      left := left - len(x.SL2MDT_charge);
      assign(y(left downto left-len(x.cointype)+1), vectorify(x.cointype, y(left downto left-len(x.cointype)+1)));
      left := left - len(x.cointype);
      assign(y(left downto left-len(x.trailer)+1), vectorify(x.trailer, y(left downto left-len(x.trailer)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: SL2MDT_slc_common; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.header)-1), convert(x.header, y(left to left+len(x.header)-1)));
      left := left + len(x.header);
      assign(y(left to left+len(x.slcid)-1), convert(x.slcid, y(left to left+len(x.slcid)-1)));
      left := left + len(x.slcid);
      assign(y(left to left+len(x.tcsent)-1), convert(x.tcsent, y(left to left+len(x.tcsent)-1)));
      left := left + len(x.tcsent);
      assign(y(left to left+len(x.poseta)-1), convert(x.poseta, y(left to left+len(x.poseta)-1)));
      left := left + len(x.poseta);
      assign(y(left to left+len(x.posphi)-1), convert(x.posphi, y(left to left+len(x.posphi)-1)));
      left := left + len(x.posphi);
      assign(y(left to left+len(x.SL2MDT_pt)-1), convert(x.SL2MDT_pt, y(left to left+len(x.SL2MDT_pt)-1)));
      left := left + len(x.SL2MDT_pt);
      assign(y(left to left+len(x.SL2MDT_ptthresh)-1), convert(x.SL2MDT_ptthresh, y(left to left+len(x.SL2MDT_ptthresh)-1)));
      left := left + len(x.SL2MDT_ptthresh);
      assign(y(left to left+len(x.SL2MDT_charge)-1), convert(x.SL2MDT_charge, y(left to left+len(x.SL2MDT_charge)-1)));
      left := left + len(x.SL2MDT_charge);
      assign(y(left to left+len(x.cointype)-1), convert(x.cointype, y(left to left+len(x.cointype)-1)));
      left := left + len(x.cointype);
      assign(y(left to left+len(x.trailer)-1), convert(x.trailer, y(left to left+len(x.trailer)-1)));
    else
      assign(y(left downto left-len(x.header)+1), convert(x.header, y(left downto left-len(x.header)+1)));
      left := left - len(x.header);
      assign(y(left downto left-len(x.slcid)+1), convert(x.slcid, y(left downto left-len(x.slcid)+1)));
      left := left - len(x.slcid);
      assign(y(left downto left-len(x.tcsent)+1), convert(x.tcsent, y(left downto left-len(x.tcsent)+1)));
      left := left - len(x.tcsent);
      assign(y(left downto left-len(x.poseta)+1), convert(x.poseta, y(left downto left-len(x.poseta)+1)));
      left := left - len(x.poseta);
      assign(y(left downto left-len(x.posphi)+1), convert(x.posphi, y(left downto left-len(x.posphi)+1)));
      left := left - len(x.posphi);
      assign(y(left downto left-len(x.SL2MDT_pt)+1), convert(x.SL2MDT_pt, y(left downto left-len(x.SL2MDT_pt)+1)));
      left := left - len(x.SL2MDT_pt);
      assign(y(left downto left-len(x.SL2MDT_ptthresh)+1), convert(x.SL2MDT_ptthresh, y(left downto left-len(x.SL2MDT_ptthresh)+1)));
      left := left - len(x.SL2MDT_ptthresh);
      assign(y(left downto left-len(x.SL2MDT_charge)+1), convert(x.SL2MDT_charge, y(left downto left-len(x.SL2MDT_charge)+1)));
      left := left - len(x.SL2MDT_charge);
      assign(y(left downto left-len(x.cointype)+1), convert(x.cointype, y(left downto left-len(x.cointype)+1)));
      left := left - len(x.cointype);
      assign(y(left downto left-len(x.trailer)+1), convert(x.trailer, y(left downto left-len(x.trailer)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_common) return SL2MDT_slc_common is
    variable y: SL2MDT_slc_common;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.header := structify(x(left to left+len(y.header)-1), y.header);
      left := left + len(y.header);
      y.slcid := structify(x(left to left+len(y.slcid)-1), y.slcid);
      left := left + len(y.slcid);
      y.tcsent := structify(x(left to left+len(y.tcsent)-1), y.tcsent);
      left := left + len(y.tcsent);
      y.poseta := structify(x(left to left+len(y.poseta)-1), y.poseta);
      left := left + len(y.poseta);
      y.posphi := structify(x(left to left+len(y.posphi)-1), y.posphi);
      left := left + len(y.posphi);
      y.SL2MDT_pt := structify(x(left to left+len(y.SL2MDT_pt)-1), y.SL2MDT_pt);
      left := left + len(y.SL2MDT_pt);
      y.SL2MDT_ptthresh := structify(x(left to left+len(y.SL2MDT_ptthresh)-1), y.SL2MDT_ptthresh);
      left := left + len(y.SL2MDT_ptthresh);
      y.SL2MDT_charge := structify(x(left to left+len(y.SL2MDT_charge)-1), y.SL2MDT_charge);
      left := left + len(y.SL2MDT_charge);
      y.cointype := structify(x(left to left+len(y.cointype)-1), y.cointype);
      left := left + len(y.cointype);
      y.trailer := structify(x(left to left+len(y.trailer)-1), y.trailer);
    else
      y.header := structify(x(left downto left-len(y.header)+1), y.header);
      left := left - len(y.header);
      y.slcid := structify(x(left downto left-len(y.slcid)+1), y.slcid);
      left := left - len(y.slcid);
      y.tcsent := structify(x(left downto left-len(y.tcsent)+1), y.tcsent);
      left := left - len(y.tcsent);
      y.poseta := structify(x(left downto left-len(y.poseta)+1), y.poseta);
      left := left - len(y.poseta);
      y.posphi := structify(x(left downto left-len(y.posphi)+1), y.posphi);
      left := left - len(y.posphi);
      y.SL2MDT_pt := structify(x(left downto left-len(y.SL2MDT_pt)+1), y.SL2MDT_pt);
      left := left - len(y.SL2MDT_pt);
      y.SL2MDT_ptthresh := structify(x(left downto left-len(y.SL2MDT_ptthresh)+1), y.SL2MDT_ptthresh);
      left := left - len(y.SL2MDT_ptthresh);
      y.SL2MDT_charge := structify(x(left downto left-len(y.SL2MDT_charge)+1), y.SL2MDT_charge);
      left := left - len(y.SL2MDT_charge);
      y.cointype := structify(x(left downto left-len(y.cointype)+1), y.cointype);
      left := left - len(y.cointype);
      y.trailer := structify(x(left downto left-len(y.trailer)+1), y.trailer);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_common) return SL2MDT_slc_common is
    variable y: SL2MDT_slc_common;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.header := convert(x(left to left+len(y.header)-1), y.header);
      left := left + len(y.header);
      y.slcid := convert(x(left to left+len(y.slcid)-1), y.slcid);
      left := left + len(y.slcid);
      y.tcsent := convert(x(left to left+len(y.tcsent)-1), y.tcsent);
      left := left + len(y.tcsent);
      y.poseta := convert(x(left to left+len(y.poseta)-1), y.poseta);
      left := left + len(y.poseta);
      y.posphi := convert(x(left to left+len(y.posphi)-1), y.posphi);
      left := left + len(y.posphi);
      y.SL2MDT_pt := convert(x(left to left+len(y.SL2MDT_pt)-1), y.SL2MDT_pt);
      left := left + len(y.SL2MDT_pt);
      y.SL2MDT_ptthresh := convert(x(left to left+len(y.SL2MDT_ptthresh)-1), y.SL2MDT_ptthresh);
      left := left + len(y.SL2MDT_ptthresh);
      y.SL2MDT_charge := convert(x(left to left+len(y.SL2MDT_charge)-1), y.SL2MDT_charge);
      left := left + len(y.SL2MDT_charge);
      y.cointype := convert(x(left to left+len(y.cointype)-1), y.cointype);
      left := left + len(y.cointype);
      y.trailer := convert(x(left to left+len(y.trailer)-1), y.trailer);
    else
      y.header := convert(x(left downto left-len(y.header)+1), y.header);
      left := left - len(y.header);
      y.slcid := convert(x(left downto left-len(y.slcid)+1), y.slcid);
      left := left - len(y.slcid);
      y.tcsent := convert(x(left downto left-len(y.tcsent)+1), y.tcsent);
      left := left - len(y.tcsent);
      y.poseta := convert(x(left downto left-len(y.poseta)+1), y.poseta);
      left := left - len(y.poseta);
      y.posphi := convert(x(left downto left-len(y.posphi)+1), y.posphi);
      left := left - len(y.posphi);
      y.SL2MDT_pt := convert(x(left downto left-len(y.SL2MDT_pt)+1), y.SL2MDT_pt);
      left := left - len(y.SL2MDT_pt);
      y.SL2MDT_ptthresh := convert(x(left downto left-len(y.SL2MDT_ptthresh)+1), y.SL2MDT_ptthresh);
      left := left - len(y.SL2MDT_ptthresh);
      y.SL2MDT_charge := convert(x(left downto left-len(y.SL2MDT_charge)+1), y.SL2MDT_charge);
      left := left - len(y.SL2MDT_charge);
      y.cointype := convert(x(left downto left-len(y.cointype)+1), y.cointype);
      left := left - len(y.cointype);
      y.trailer := convert(x(left downto left-len(y.trailer)+1), y.trailer);
    end if;
    return y;
  end function convert;
  function nullify(t: SL2MDT_slc_common) return SL2MDT_slc_common is
  variable y: SL2MDT_slc_common;
  begin
    y.header := nullify(t.header);
    y.slcid := nullify(t.slcid);
    y.tcsent := nullify(t.tcsent);
    y.poseta := nullify(t.poseta);
    y.posphi := nullify(t.posphi);
    y.SL2MDT_pt := nullify(t.SL2MDT_pt);
    y.SL2MDT_ptthresh := nullify(t.SL2MDT_ptthresh);
    y.SL2MDT_charge := nullify(t.SL2MDT_charge);
    y.cointype := nullify(t.cointype);
    y.trailer := nullify(t.trailer);
    return y;
  end function nullify;
  function zeroed(t: SL2MDT_slc_common) return SL2MDT_slc_common is
  variable y: SL2MDT_slc_common;
  begin
    y.header := zeroed(t.header);
    y.slcid := zeroed(t.slcid);
    y.tcsent := zeroed(t.tcsent);
    y.poseta := zeroed(t.poseta);
    y.posphi := zeroed(t.posphi);
    y.SL2MDT_pt := zeroed(t.SL2MDT_pt);
    y.SL2MDT_ptthresh := zeroed(t.SL2MDT_ptthresh);
    y.SL2MDT_charge := zeroed(t.SL2MDT_charge);
    y.cointype := zeroed(t.cointype);
    y.trailer := zeroed(t.trailer);
    return y;
  end function zeroed;

  function len(x: SL2MDT_slc_endcap) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.e_reserved);
    l := l + len(x.nswseg_mon);
    l := l + len(x.nswseg_angdtheta);
    l := l + len(x.nswseg_posphi);
    l := l + len(x.nswseg_poseta);
    l := l + len(x.seg_angdphi);
    l := l + len(x.seg_angdtheta);
    return l;
  end function len;
  function width(x: SL2MDT_slc_endcap) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.e_reserved);
    l := l + width(x.nswseg_mon);
    l := l + width(x.nswseg_angdtheta);
    l := l + width(x.nswseg_posphi);
    l := l + width(x.nswseg_poseta);
    l := l + width(x.seg_angdphi);
    l := l + width(x.seg_angdtheta);
    return l;
  end function width;
  function vectorify(x: SL2MDT_slc_endcap; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.e_reserved)-1), vectorify(x.e_reserved, y(left to left+len(x.e_reserved)-1)));
      left := left + len(x.e_reserved);
      assign(y(left to left+len(x.nswseg_mon)-1), vectorify(x.nswseg_mon, y(left to left+len(x.nswseg_mon)-1)));
      left := left + len(x.nswseg_mon);
      assign(y(left to left+len(x.nswseg_angdtheta)-1), vectorify(x.nswseg_angdtheta, y(left to left+len(x.nswseg_angdtheta)-1)));
      left := left + len(x.nswseg_angdtheta);
      assign(y(left to left+len(x.nswseg_posphi)-1), vectorify(x.nswseg_posphi, y(left to left+len(x.nswseg_posphi)-1)));
      left := left + len(x.nswseg_posphi);
      assign(y(left to left+len(x.nswseg_poseta)-1), vectorify(x.nswseg_poseta, y(left to left+len(x.nswseg_poseta)-1)));
      left := left + len(x.nswseg_poseta);
      assign(y(left to left+len(x.seg_angdphi)-1), vectorify(x.seg_angdphi, y(left to left+len(x.seg_angdphi)-1)));
      left := left + len(x.seg_angdphi);
      assign(y(left to left+len(x.seg_angdtheta)-1), vectorify(x.seg_angdtheta, y(left to left+len(x.seg_angdtheta)-1)));
    else
      assign(y(left downto left-len(x.e_reserved)+1), vectorify(x.e_reserved, y(left downto left-len(x.e_reserved)+1)));
      left := left - len(x.e_reserved);
      assign(y(left downto left-len(x.nswseg_mon)+1), vectorify(x.nswseg_mon, y(left downto left-len(x.nswseg_mon)+1)));
      left := left - len(x.nswseg_mon);
      assign(y(left downto left-len(x.nswseg_angdtheta)+1), vectorify(x.nswseg_angdtheta, y(left downto left-len(x.nswseg_angdtheta)+1)));
      left := left - len(x.nswseg_angdtheta);
      assign(y(left downto left-len(x.nswseg_posphi)+1), vectorify(x.nswseg_posphi, y(left downto left-len(x.nswseg_posphi)+1)));
      left := left - len(x.nswseg_posphi);
      assign(y(left downto left-len(x.nswseg_poseta)+1), vectorify(x.nswseg_poseta, y(left downto left-len(x.nswseg_poseta)+1)));
      left := left - len(x.nswseg_poseta);
      assign(y(left downto left-len(x.seg_angdphi)+1), vectorify(x.seg_angdphi, y(left downto left-len(x.seg_angdphi)+1)));
      left := left - len(x.seg_angdphi);
      assign(y(left downto left-len(x.seg_angdtheta)+1), vectorify(x.seg_angdtheta, y(left downto left-len(x.seg_angdtheta)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: SL2MDT_slc_endcap; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.e_reserved)-1), convert(x.e_reserved, y(left to left+len(x.e_reserved)-1)));
      left := left + len(x.e_reserved);
      assign(y(left to left+len(x.nswseg_mon)-1), convert(x.nswseg_mon, y(left to left+len(x.nswseg_mon)-1)));
      left := left + len(x.nswseg_mon);
      assign(y(left to left+len(x.nswseg_angdtheta)-1), convert(x.nswseg_angdtheta, y(left to left+len(x.nswseg_angdtheta)-1)));
      left := left + len(x.nswseg_angdtheta);
      assign(y(left to left+len(x.nswseg_posphi)-1), convert(x.nswseg_posphi, y(left to left+len(x.nswseg_posphi)-1)));
      left := left + len(x.nswseg_posphi);
      assign(y(left to left+len(x.nswseg_poseta)-1), convert(x.nswseg_poseta, y(left to left+len(x.nswseg_poseta)-1)));
      left := left + len(x.nswseg_poseta);
      assign(y(left to left+len(x.seg_angdphi)-1), convert(x.seg_angdphi, y(left to left+len(x.seg_angdphi)-1)));
      left := left + len(x.seg_angdphi);
      assign(y(left to left+len(x.seg_angdtheta)-1), convert(x.seg_angdtheta, y(left to left+len(x.seg_angdtheta)-1)));
    else
      assign(y(left downto left-len(x.e_reserved)+1), convert(x.e_reserved, y(left downto left-len(x.e_reserved)+1)));
      left := left - len(x.e_reserved);
      assign(y(left downto left-len(x.nswseg_mon)+1), convert(x.nswseg_mon, y(left downto left-len(x.nswseg_mon)+1)));
      left := left - len(x.nswseg_mon);
      assign(y(left downto left-len(x.nswseg_angdtheta)+1), convert(x.nswseg_angdtheta, y(left downto left-len(x.nswseg_angdtheta)+1)));
      left := left - len(x.nswseg_angdtheta);
      assign(y(left downto left-len(x.nswseg_posphi)+1), convert(x.nswseg_posphi, y(left downto left-len(x.nswseg_posphi)+1)));
      left := left - len(x.nswseg_posphi);
      assign(y(left downto left-len(x.nswseg_poseta)+1), convert(x.nswseg_poseta, y(left downto left-len(x.nswseg_poseta)+1)));
      left := left - len(x.nswseg_poseta);
      assign(y(left downto left-len(x.seg_angdphi)+1), convert(x.seg_angdphi, y(left downto left-len(x.seg_angdphi)+1)));
      left := left - len(x.seg_angdphi);
      assign(y(left downto left-len(x.seg_angdtheta)+1), convert(x.seg_angdtheta, y(left downto left-len(x.seg_angdtheta)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_endcap) return SL2MDT_slc_endcap is
    variable y: SL2MDT_slc_endcap;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.e_reserved := structify(x(left to left+len(y.e_reserved)-1), y.e_reserved);
      left := left + len(y.e_reserved);
      y.nswseg_mon := structify(x(left to left+len(y.nswseg_mon)-1), y.nswseg_mon);
      left := left + len(y.nswseg_mon);
      y.nswseg_angdtheta := structify(x(left to left+len(y.nswseg_angdtheta)-1), y.nswseg_angdtheta);
      left := left + len(y.nswseg_angdtheta);
      y.nswseg_posphi := structify(x(left to left+len(y.nswseg_posphi)-1), y.nswseg_posphi);
      left := left + len(y.nswseg_posphi);
      y.nswseg_poseta := structify(x(left to left+len(y.nswseg_poseta)-1), y.nswseg_poseta);
      left := left + len(y.nswseg_poseta);
      y.seg_angdphi := structify(x(left to left+len(y.seg_angdphi)-1), y.seg_angdphi);
      left := left + len(y.seg_angdphi);
      y.seg_angdtheta := structify(x(left to left+len(y.seg_angdtheta)-1), y.seg_angdtheta);
    else
      y.e_reserved := structify(x(left downto left-len(y.e_reserved)+1), y.e_reserved);
      left := left - len(y.e_reserved);
      y.nswseg_mon := structify(x(left downto left-len(y.nswseg_mon)+1), y.nswseg_mon);
      left := left - len(y.nswseg_mon);
      y.nswseg_angdtheta := structify(x(left downto left-len(y.nswseg_angdtheta)+1), y.nswseg_angdtheta);
      left := left - len(y.nswseg_angdtheta);
      y.nswseg_posphi := structify(x(left downto left-len(y.nswseg_posphi)+1), y.nswseg_posphi);
      left := left - len(y.nswseg_posphi);
      y.nswseg_poseta := structify(x(left downto left-len(y.nswseg_poseta)+1), y.nswseg_poseta);
      left := left - len(y.nswseg_poseta);
      y.seg_angdphi := structify(x(left downto left-len(y.seg_angdphi)+1), y.seg_angdphi);
      left := left - len(y.seg_angdphi);
      y.seg_angdtheta := structify(x(left downto left-len(y.seg_angdtheta)+1), y.seg_angdtheta);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_endcap) return SL2MDT_slc_endcap is
    variable y: SL2MDT_slc_endcap;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.e_reserved := convert(x(left to left+len(y.e_reserved)-1), y.e_reserved);
      left := left + len(y.e_reserved);
      y.nswseg_mon := convert(x(left to left+len(y.nswseg_mon)-1), y.nswseg_mon);
      left := left + len(y.nswseg_mon);
      y.nswseg_angdtheta := convert(x(left to left+len(y.nswseg_angdtheta)-1), y.nswseg_angdtheta);
      left := left + len(y.nswseg_angdtheta);
      y.nswseg_posphi := convert(x(left to left+len(y.nswseg_posphi)-1), y.nswseg_posphi);
      left := left + len(y.nswseg_posphi);
      y.nswseg_poseta := convert(x(left to left+len(y.nswseg_poseta)-1), y.nswseg_poseta);
      left := left + len(y.nswseg_poseta);
      y.seg_angdphi := convert(x(left to left+len(y.seg_angdphi)-1), y.seg_angdphi);
      left := left + len(y.seg_angdphi);
      y.seg_angdtheta := convert(x(left to left+len(y.seg_angdtheta)-1), y.seg_angdtheta);
    else
      y.e_reserved := convert(x(left downto left-len(y.e_reserved)+1), y.e_reserved);
      left := left - len(y.e_reserved);
      y.nswseg_mon := convert(x(left downto left-len(y.nswseg_mon)+1), y.nswseg_mon);
      left := left - len(y.nswseg_mon);
      y.nswseg_angdtheta := convert(x(left downto left-len(y.nswseg_angdtheta)+1), y.nswseg_angdtheta);
      left := left - len(y.nswseg_angdtheta);
      y.nswseg_posphi := convert(x(left downto left-len(y.nswseg_posphi)+1), y.nswseg_posphi);
      left := left - len(y.nswseg_posphi);
      y.nswseg_poseta := convert(x(left downto left-len(y.nswseg_poseta)+1), y.nswseg_poseta);
      left := left - len(y.nswseg_poseta);
      y.seg_angdphi := convert(x(left downto left-len(y.seg_angdphi)+1), y.seg_angdphi);
      left := left - len(y.seg_angdphi);
      y.seg_angdtheta := convert(x(left downto left-len(y.seg_angdtheta)+1), y.seg_angdtheta);
    end if;
    return y;
  end function convert;
  function nullify(t: SL2MDT_slc_endcap) return SL2MDT_slc_endcap is
  variable y: SL2MDT_slc_endcap;
  begin
    y.e_reserved := nullify(t.e_reserved);
    y.nswseg_mon := nullify(t.nswseg_mon);
    y.nswseg_angdtheta := nullify(t.nswseg_angdtheta);
    y.nswseg_posphi := nullify(t.nswseg_posphi);
    y.nswseg_poseta := nullify(t.nswseg_poseta);
    y.seg_angdphi := nullify(t.seg_angdphi);
    y.seg_angdtheta := nullify(t.seg_angdtheta);
    return y;
  end function nullify;
  function zeroed(t: SL2MDT_slc_endcap) return SL2MDT_slc_endcap is
  variable y: SL2MDT_slc_endcap;
  begin
    y.e_reserved := zeroed(t.e_reserved);
    y.nswseg_mon := zeroed(t.nswseg_mon);
    y.nswseg_angdtheta := zeroed(t.nswseg_angdtheta);
    y.nswseg_posphi := zeroed(t.nswseg_posphi);
    y.nswseg_poseta := zeroed(t.nswseg_poseta);
    y.seg_angdphi := zeroed(t.seg_angdphi);
    y.seg_angdtheta := zeroed(t.seg_angdtheta);
    return y;
  end function zeroed;

  function len(x: SL2MDT_slc_barrel) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.b_reserved);
    l := l + len(x.rpc3_posz);
    l := l + len(x.rpc2_posz);
    l := l + len(x.rpc1_posz);
    l := l + len(x.rpc0_posz);
    return l;
  end function len;
  function width(x: SL2MDT_slc_barrel) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.b_reserved);
    l := l + width(x.rpc3_posz);
    l := l + width(x.rpc2_posz);
    l := l + width(x.rpc1_posz);
    l := l + width(x.rpc0_posz);
    return l;
  end function width;
  function vectorify(x: SL2MDT_slc_barrel; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.b_reserved)-1), vectorify(x.b_reserved, y(left to left+len(x.b_reserved)-1)));
      left := left + len(x.b_reserved);
      assign(y(left to left+len(x.rpc3_posz)-1), vectorify(x.rpc3_posz, y(left to left+len(x.rpc3_posz)-1)));
      left := left + len(x.rpc3_posz);
      assign(y(left to left+len(x.rpc2_posz)-1), vectorify(x.rpc2_posz, y(left to left+len(x.rpc2_posz)-1)));
      left := left + len(x.rpc2_posz);
      assign(y(left to left+len(x.rpc1_posz)-1), vectorify(x.rpc1_posz, y(left to left+len(x.rpc1_posz)-1)));
      left := left + len(x.rpc1_posz);
      assign(y(left to left+len(x.rpc0_posz)-1), vectorify(x.rpc0_posz, y(left to left+len(x.rpc0_posz)-1)));
    else
      assign(y(left downto left-len(x.b_reserved)+1), vectorify(x.b_reserved, y(left downto left-len(x.b_reserved)+1)));
      left := left - len(x.b_reserved);
      assign(y(left downto left-len(x.rpc3_posz)+1), vectorify(x.rpc3_posz, y(left downto left-len(x.rpc3_posz)+1)));
      left := left - len(x.rpc3_posz);
      assign(y(left downto left-len(x.rpc2_posz)+1), vectorify(x.rpc2_posz, y(left downto left-len(x.rpc2_posz)+1)));
      left := left - len(x.rpc2_posz);
      assign(y(left downto left-len(x.rpc1_posz)+1), vectorify(x.rpc1_posz, y(left downto left-len(x.rpc1_posz)+1)));
      left := left - len(x.rpc1_posz);
      assign(y(left downto left-len(x.rpc0_posz)+1), vectorify(x.rpc0_posz, y(left downto left-len(x.rpc0_posz)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: SL2MDT_slc_barrel; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.b_reserved)-1), convert(x.b_reserved, y(left to left+len(x.b_reserved)-1)));
      left := left + len(x.b_reserved);
      assign(y(left to left+len(x.rpc3_posz)-1), convert(x.rpc3_posz, y(left to left+len(x.rpc3_posz)-1)));
      left := left + len(x.rpc3_posz);
      assign(y(left to left+len(x.rpc2_posz)-1), convert(x.rpc2_posz, y(left to left+len(x.rpc2_posz)-1)));
      left := left + len(x.rpc2_posz);
      assign(y(left to left+len(x.rpc1_posz)-1), convert(x.rpc1_posz, y(left to left+len(x.rpc1_posz)-1)));
      left := left + len(x.rpc1_posz);
      assign(y(left to left+len(x.rpc0_posz)-1), convert(x.rpc0_posz, y(left to left+len(x.rpc0_posz)-1)));
    else
      assign(y(left downto left-len(x.b_reserved)+1), convert(x.b_reserved, y(left downto left-len(x.b_reserved)+1)));
      left := left - len(x.b_reserved);
      assign(y(left downto left-len(x.rpc3_posz)+1), convert(x.rpc3_posz, y(left downto left-len(x.rpc3_posz)+1)));
      left := left - len(x.rpc3_posz);
      assign(y(left downto left-len(x.rpc2_posz)+1), convert(x.rpc2_posz, y(left downto left-len(x.rpc2_posz)+1)));
      left := left - len(x.rpc2_posz);
      assign(y(left downto left-len(x.rpc1_posz)+1), convert(x.rpc1_posz, y(left downto left-len(x.rpc1_posz)+1)));
      left := left - len(x.rpc1_posz);
      assign(y(left downto left-len(x.rpc0_posz)+1), convert(x.rpc0_posz, y(left downto left-len(x.rpc0_posz)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_barrel) return SL2MDT_slc_barrel is
    variable y: SL2MDT_slc_barrel;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.b_reserved := structify(x(left to left+len(y.b_reserved)-1), y.b_reserved);
      left := left + len(y.b_reserved);
      y.rpc3_posz := structify(x(left to left+len(y.rpc3_posz)-1), y.rpc3_posz);
      left := left + len(y.rpc3_posz);
      y.rpc2_posz := structify(x(left to left+len(y.rpc2_posz)-1), y.rpc2_posz);
      left := left + len(y.rpc2_posz);
      y.rpc1_posz := structify(x(left to left+len(y.rpc1_posz)-1), y.rpc1_posz);
      left := left + len(y.rpc1_posz);
      y.rpc0_posz := structify(x(left to left+len(y.rpc0_posz)-1), y.rpc0_posz);
    else
      y.b_reserved := structify(x(left downto left-len(y.b_reserved)+1), y.b_reserved);
      left := left - len(y.b_reserved);
      y.rpc3_posz := structify(x(left downto left-len(y.rpc3_posz)+1), y.rpc3_posz);
      left := left - len(y.rpc3_posz);
      y.rpc2_posz := structify(x(left downto left-len(y.rpc2_posz)+1), y.rpc2_posz);
      left := left - len(y.rpc2_posz);
      y.rpc1_posz := structify(x(left downto left-len(y.rpc1_posz)+1), y.rpc1_posz);
      left := left - len(y.rpc1_posz);
      y.rpc0_posz := structify(x(left downto left-len(y.rpc0_posz)+1), y.rpc0_posz);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_barrel) return SL2MDT_slc_barrel is
    variable y: SL2MDT_slc_barrel;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.b_reserved := convert(x(left to left+len(y.b_reserved)-1), y.b_reserved);
      left := left + len(y.b_reserved);
      y.rpc3_posz := convert(x(left to left+len(y.rpc3_posz)-1), y.rpc3_posz);
      left := left + len(y.rpc3_posz);
      y.rpc2_posz := convert(x(left to left+len(y.rpc2_posz)-1), y.rpc2_posz);
      left := left + len(y.rpc2_posz);
      y.rpc1_posz := convert(x(left to left+len(y.rpc1_posz)-1), y.rpc1_posz);
      left := left + len(y.rpc1_posz);
      y.rpc0_posz := convert(x(left to left+len(y.rpc0_posz)-1), y.rpc0_posz);
    else
      y.b_reserved := convert(x(left downto left-len(y.b_reserved)+1), y.b_reserved);
      left := left - len(y.b_reserved);
      y.rpc3_posz := convert(x(left downto left-len(y.rpc3_posz)+1), y.rpc3_posz);
      left := left - len(y.rpc3_posz);
      y.rpc2_posz := convert(x(left downto left-len(y.rpc2_posz)+1), y.rpc2_posz);
      left := left - len(y.rpc2_posz);
      y.rpc1_posz := convert(x(left downto left-len(y.rpc1_posz)+1), y.rpc1_posz);
      left := left - len(y.rpc1_posz);
      y.rpc0_posz := convert(x(left downto left-len(y.rpc0_posz)+1), y.rpc0_posz);
    end if;
    return y;
  end function convert;
  function nullify(t: SL2MDT_slc_barrel) return SL2MDT_slc_barrel is
  variable y: SL2MDT_slc_barrel;
  begin
    y.b_reserved := nullify(t.b_reserved);
    y.rpc3_posz := nullify(t.rpc3_posz);
    y.rpc2_posz := nullify(t.rpc2_posz);
    y.rpc1_posz := nullify(t.rpc1_posz);
    y.rpc0_posz := nullify(t.rpc0_posz);
    return y;
  end function nullify;
  function zeroed(t: SL2MDT_slc_barrel) return SL2MDT_slc_barrel is
  variable y: SL2MDT_slc_barrel;
  begin
    y.b_reserved := zeroed(t.b_reserved);
    y.rpc3_posz := zeroed(t.rpc3_posz);
    y.rpc2_posz := zeroed(t.rpc2_posz);
    y.rpc1_posz := zeroed(t.rpc1_posz);
    y.rpc0_posz := zeroed(t.rpc0_posz);
    return y;
  end function zeroed;

  function len(x: SL2MDT_slc_rx) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.common);
    l := l + len(x.specific);
    return l;
  end function len;
  function width(x: SL2MDT_slc_rx) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.common);
    l := l + width(x.specific);
    return l;
  end function width;
  function vectorify(x: SL2MDT_slc_rx; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.common)-1), vectorify(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.specific)-1), vectorify(x.specific, y(left to left+len(x.specific)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.common)+1), vectorify(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.specific)+1), vectorify(x.specific, y(left downto left-len(x.specific)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: SL2MDT_slc_rx; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.common)-1), convert(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.specific)-1), convert(x.specific, y(left to left+len(x.specific)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.common)+1), convert(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.specific)+1), convert(x.specific, y(left downto left-len(x.specific)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_rx) return SL2MDT_slc_rx is
    variable y: SL2MDT_slc_rx;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.common := structify(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.specific := structify(x(left to left+len(y.specific)-1), y.specific);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.common := structify(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.specific := structify(x(left downto left-len(y.specific)+1), y.specific);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_rx) return SL2MDT_slc_rx is
    variable y: SL2MDT_slc_rx;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.common := convert(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.specific := convert(x(left to left+len(y.specific)-1), y.specific);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.common := convert(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.specific := convert(x(left downto left-len(y.specific)+1), y.specific);
    end if;
    return y;
  end function convert;
  function nullify(t: SL2MDT_slc_rx) return SL2MDT_slc_rx is
  variable y: SL2MDT_slc_rx;
  begin
    y.data_valid := nullify(t.data_valid);
    y.common := nullify(t.common);
    y.specific := nullify(t.specific);
    return y;
  end function nullify;
  function zeroed(t: SL2MDT_slc_rx) return SL2MDT_slc_rx is
  variable y: SL2MDT_slc_rx;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.common := zeroed(t.common);
    y.specific := zeroed(t.specific);
    return y;
  end function zeroed;

  function len(x: SL2MDT_slc_rx_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: SL2MDT_slc_rx_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: SL2MDT_slc_rx_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: SL2MDT_slc_rx_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus is
    variable y : SL2MDT_slc_rx_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus is
    variable y : SL2MDT_slc_rx_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus is
    variable y : SL2MDT_slc_rx_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: SL2MDT_slc_rx_bus) return SL2MDT_slc_rx_bus is
    variable y : SL2MDT_slc_rx_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: SL2MDT_slc_endcap_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: SL2MDT_slc_endcap_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: SL2MDT_slc_endcap_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: SL2MDT_slc_endcap_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus is
    variable y : SL2MDT_slc_endcap_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus is
    variable y : SL2MDT_slc_endcap_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus is
    variable y : SL2MDT_slc_endcap_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: SL2MDT_slc_endcap_bus) return SL2MDT_slc_endcap_bus is
    variable y : SL2MDT_slc_endcap_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: SL2MDT_slc_muid) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.slcid);
    l := l + len(x.slid);
    l := l + len(x.bcid);
    return l;
  end function len;
  function width(x: SL2MDT_slc_muid) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.slcid);
    l := l + width(x.slid);
    l := l + width(x.bcid);
    return l;
  end function width;
  function vectorify(x: SL2MDT_slc_muid; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.slcid)-1), vectorify(x.slcid, y(left to left+len(x.slcid)-1)));
      left := left + len(x.slcid);
      assign(y(left to left+len(x.slid)-1), vectorify(x.slid, y(left to left+len(x.slid)-1)));
      left := left + len(x.slid);
      assign(y(left to left+len(x.bcid)-1), vectorify(x.bcid, y(left to left+len(x.bcid)-1)));
    else
      assign(y(left downto left-len(x.slcid)+1), vectorify(x.slcid, y(left downto left-len(x.slcid)+1)));
      left := left - len(x.slcid);
      assign(y(left downto left-len(x.slid)+1), vectorify(x.slid, y(left downto left-len(x.slid)+1)));
      left := left - len(x.slid);
      assign(y(left downto left-len(x.bcid)+1), vectorify(x.bcid, y(left downto left-len(x.bcid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: SL2MDT_slc_muid; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.slcid)-1), convert(x.slcid, y(left to left+len(x.slcid)-1)));
      left := left + len(x.slcid);
      assign(y(left to left+len(x.slid)-1), convert(x.slid, y(left to left+len(x.slid)-1)));
      left := left + len(x.slid);
      assign(y(left to left+len(x.bcid)-1), convert(x.bcid, y(left to left+len(x.bcid)-1)));
    else
      assign(y(left downto left-len(x.slcid)+1), convert(x.slcid, y(left downto left-len(x.slcid)+1)));
      left := left - len(x.slcid);
      assign(y(left downto left-len(x.slid)+1), convert(x.slid, y(left downto left-len(x.slid)+1)));
      left := left - len(x.slid);
      assign(y(left downto left-len(x.bcid)+1), convert(x.bcid, y(left downto left-len(x.bcid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: SL2MDT_slc_muid) return SL2MDT_slc_muid is
    variable y: SL2MDT_slc_muid;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.slcid := structify(x(left to left+len(y.slcid)-1), y.slcid);
      left := left + len(y.slcid);
      y.slid := structify(x(left to left+len(y.slid)-1), y.slid);
      left := left + len(y.slid);
      y.bcid := structify(x(left to left+len(y.bcid)-1), y.bcid);
    else
      y.slcid := structify(x(left downto left-len(y.slcid)+1), y.slcid);
      left := left - len(y.slcid);
      y.slid := structify(x(left downto left-len(y.slid)+1), y.slid);
      left := left - len(y.slid);
      y.bcid := structify(x(left downto left-len(y.bcid)+1), y.bcid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: SL2MDT_slc_muid) return SL2MDT_slc_muid is
    variable y: SL2MDT_slc_muid;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.slcid := convert(x(left to left+len(y.slcid)-1), y.slcid);
      left := left + len(y.slcid);
      y.slid := convert(x(left to left+len(y.slid)-1), y.slid);
      left := left + len(y.slid);
      y.bcid := convert(x(left to left+len(y.bcid)-1), y.bcid);
    else
      y.slcid := convert(x(left downto left-len(y.slcid)+1), y.slcid);
      left := left - len(y.slcid);
      y.slid := convert(x(left downto left-len(y.slid)+1), y.slid);
      left := left - len(y.slid);
      y.bcid := convert(x(left downto left-len(y.bcid)+1), y.bcid);
    end if;
    return y;
  end function convert;
  function nullify(t: SL2MDT_slc_muid) return SL2MDT_slc_muid is
  variable y: SL2MDT_slc_muid;
  begin
    y.slcid := nullify(t.slcid);
    y.slid := nullify(t.slid);
    y.bcid := nullify(t.bcid);
    return y;
  end function nullify;
  function zeroed(t: SL2MDT_slc_muid) return SL2MDT_slc_muid is
  variable y: SL2MDT_slc_muid;
  begin
    y.slcid := zeroed(t.slcid);
    y.slid := zeroed(t.slid);
    y.bcid := zeroed(t.bcid);
    return y;
  end function zeroed;

  function len(x: vec_mdtid) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.chamber_id);
    l := l + len(x.chamber_ieta);
    return l;
  end function len;
  function width(x: vec_mdtid) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.chamber_id);
    l := l + width(x.chamber_ieta);
    return l;
  end function width;
  function vectorify(x: vec_mdtid; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.chamber_id)-1), vectorify(x.chamber_id, y(left to left+len(x.chamber_id)-1)));
      left := left + len(x.chamber_id);
      assign(y(left to left+len(x.chamber_ieta)-1), vectorify(x.chamber_ieta, y(left to left+len(x.chamber_ieta)-1)));
    else
      assign(y(left downto left-len(x.chamber_id)+1), vectorify(x.chamber_id, y(left downto left-len(x.chamber_id)+1)));
      left := left - len(x.chamber_id);
      assign(y(left downto left-len(x.chamber_ieta)+1), vectorify(x.chamber_ieta, y(left downto left-len(x.chamber_ieta)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: vec_mdtid; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.chamber_id)-1), convert(x.chamber_id, y(left to left+len(x.chamber_id)-1)));
      left := left + len(x.chamber_id);
      assign(y(left to left+len(x.chamber_ieta)-1), convert(x.chamber_ieta, y(left to left+len(x.chamber_ieta)-1)));
    else
      assign(y(left downto left-len(x.chamber_id)+1), convert(x.chamber_id, y(left downto left-len(x.chamber_id)+1)));
      left := left - len(x.chamber_id);
      assign(y(left downto left-len(x.chamber_ieta)+1), convert(x.chamber_ieta, y(left downto left-len(x.chamber_ieta)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: vec_mdtid) return vec_mdtid is
    variable y: vec_mdtid;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.chamber_id := structify(x(left to left+len(y.chamber_id)-1), y.chamber_id);
      left := left + len(y.chamber_id);
      y.chamber_ieta := structify(x(left to left+len(y.chamber_ieta)-1), y.chamber_ieta);
    else
      y.chamber_id := structify(x(left downto left-len(y.chamber_id)+1), y.chamber_id);
      left := left - len(y.chamber_id);
      y.chamber_ieta := structify(x(left downto left-len(y.chamber_ieta)+1), y.chamber_ieta);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: vec_mdtid) return vec_mdtid is
    variable y: vec_mdtid;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.chamber_id := convert(x(left to left+len(y.chamber_id)-1), y.chamber_id);
      left := left + len(y.chamber_id);
      y.chamber_ieta := convert(x(left to left+len(y.chamber_ieta)-1), y.chamber_ieta);
    else
      y.chamber_id := convert(x(left downto left-len(y.chamber_id)+1), y.chamber_id);
      left := left - len(y.chamber_id);
      y.chamber_ieta := convert(x(left downto left-len(y.chamber_ieta)+1), y.chamber_ieta);
    end if;
    return y;
  end function convert;
  function nullify(t: vec_mdtid) return vec_mdtid is
  variable y: vec_mdtid;
  begin
    y.chamber_id := nullify(t.chamber_id);
    y.chamber_ieta := nullify(t.chamber_ieta);
    return y;
  end function nullify;
  function zeroed(t: vec_mdtid) return vec_mdtid is
  variable y: vec_mdtid;
  begin
    y.chamber_id := zeroed(t.chamber_id);
    y.chamber_ieta := zeroed(t.chamber_ieta);
    return y;
  end function zeroed;

  function len(x: sl2mdt_mtc2sl) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.data_valid);
    l := l + len(x.common);
    l := l + len(x.mdt_eta);
    l := l + len(x.mdt_pt);
    l := l + len(x.mdt_ptthresh);
    l := l + len(x.mdt_charge);
    l := l + len(x.mdt_procflags);
    l := l + len(x.mdt_nsegments);
    l := l + len(x.mdt_quality);
    l := l + len(x.m_reserved);
    return l;
  end function len;
  function width(x: sl2mdt_mtc2sl) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.data_valid);
    l := l + width(x.common);
    l := l + width(x.mdt_eta);
    l := l + width(x.mdt_pt);
    l := l + width(x.mdt_ptthresh);
    l := l + width(x.mdt_charge);
    l := l + width(x.mdt_procflags);
    l := l + width(x.mdt_nsegments);
    l := l + width(x.mdt_quality);
    l := l + width(x.m_reserved);
    return l;
  end function width;
  function vectorify(x: sl2mdt_mtc2sl; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), vectorify(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.common)-1), vectorify(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.mdt_eta)-1), vectorify(x.mdt_eta, y(left to left+len(x.mdt_eta)-1)));
      left := left + len(x.mdt_eta);
      assign(y(left to left+len(x.mdt_pt)-1), vectorify(x.mdt_pt, y(left to left+len(x.mdt_pt)-1)));
      left := left + len(x.mdt_pt);
      assign(y(left to left+len(x.mdt_ptthresh)-1), vectorify(x.mdt_ptthresh, y(left to left+len(x.mdt_ptthresh)-1)));
      left := left + len(x.mdt_ptthresh);
      assign(y(left to left+len(x.mdt_charge)-1), vectorify(x.mdt_charge, y(left to left+len(x.mdt_charge)-1)));
      left := left + len(x.mdt_charge);
      assign(y(left to left+len(x.mdt_procflags)-1), vectorify(x.mdt_procflags, y(left to left+len(x.mdt_procflags)-1)));
      left := left + len(x.mdt_procflags);
      assign(y(left to left+len(x.mdt_nsegments)-1), vectorify(x.mdt_nsegments, y(left to left+len(x.mdt_nsegments)-1)));
      left := left + len(x.mdt_nsegments);
      assign(y(left to left+len(x.mdt_quality)-1), vectorify(x.mdt_quality, y(left to left+len(x.mdt_quality)-1)));
      left := left + len(x.mdt_quality);
      assign(y(left to left+len(x.m_reserved)-1), vectorify(x.m_reserved, y(left to left+len(x.m_reserved)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), vectorify(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.common)+1), vectorify(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.mdt_eta)+1), vectorify(x.mdt_eta, y(left downto left-len(x.mdt_eta)+1)));
      left := left - len(x.mdt_eta);
      assign(y(left downto left-len(x.mdt_pt)+1), vectorify(x.mdt_pt, y(left downto left-len(x.mdt_pt)+1)));
      left := left - len(x.mdt_pt);
      assign(y(left downto left-len(x.mdt_ptthresh)+1), vectorify(x.mdt_ptthresh, y(left downto left-len(x.mdt_ptthresh)+1)));
      left := left - len(x.mdt_ptthresh);
      assign(y(left downto left-len(x.mdt_charge)+1), vectorify(x.mdt_charge, y(left downto left-len(x.mdt_charge)+1)));
      left := left - len(x.mdt_charge);
      assign(y(left downto left-len(x.mdt_procflags)+1), vectorify(x.mdt_procflags, y(left downto left-len(x.mdt_procflags)+1)));
      left := left - len(x.mdt_procflags);
      assign(y(left downto left-len(x.mdt_nsegments)+1), vectorify(x.mdt_nsegments, y(left downto left-len(x.mdt_nsegments)+1)));
      left := left - len(x.mdt_nsegments);
      assign(y(left downto left-len(x.mdt_quality)+1), vectorify(x.mdt_quality, y(left downto left-len(x.mdt_quality)+1)));
      left := left - len(x.mdt_quality);
      assign(y(left downto left-len(x.m_reserved)+1), vectorify(x.m_reserved, y(left downto left-len(x.m_reserved)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: sl2mdt_mtc2sl; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.data_valid)-1), convert(x.data_valid, y(left to left+len(x.data_valid)-1)));
      left := left + len(x.data_valid);
      assign(y(left to left+len(x.common)-1), convert(x.common, y(left to left+len(x.common)-1)));
      left := left + len(x.common);
      assign(y(left to left+len(x.mdt_eta)-1), convert(x.mdt_eta, y(left to left+len(x.mdt_eta)-1)));
      left := left + len(x.mdt_eta);
      assign(y(left to left+len(x.mdt_pt)-1), convert(x.mdt_pt, y(left to left+len(x.mdt_pt)-1)));
      left := left + len(x.mdt_pt);
      assign(y(left to left+len(x.mdt_ptthresh)-1), convert(x.mdt_ptthresh, y(left to left+len(x.mdt_ptthresh)-1)));
      left := left + len(x.mdt_ptthresh);
      assign(y(left to left+len(x.mdt_charge)-1), convert(x.mdt_charge, y(left to left+len(x.mdt_charge)-1)));
      left := left + len(x.mdt_charge);
      assign(y(left to left+len(x.mdt_procflags)-1), convert(x.mdt_procflags, y(left to left+len(x.mdt_procflags)-1)));
      left := left + len(x.mdt_procflags);
      assign(y(left to left+len(x.mdt_nsegments)-1), convert(x.mdt_nsegments, y(left to left+len(x.mdt_nsegments)-1)));
      left := left + len(x.mdt_nsegments);
      assign(y(left to left+len(x.mdt_quality)-1), convert(x.mdt_quality, y(left to left+len(x.mdt_quality)-1)));
      left := left + len(x.mdt_quality);
      assign(y(left to left+len(x.m_reserved)-1), convert(x.m_reserved, y(left to left+len(x.m_reserved)-1)));
    else
      assign(y(left downto left-len(x.data_valid)+1), convert(x.data_valid, y(left downto left-len(x.data_valid)+1)));
      left := left - len(x.data_valid);
      assign(y(left downto left-len(x.common)+1), convert(x.common, y(left downto left-len(x.common)+1)));
      left := left - len(x.common);
      assign(y(left downto left-len(x.mdt_eta)+1), convert(x.mdt_eta, y(left downto left-len(x.mdt_eta)+1)));
      left := left - len(x.mdt_eta);
      assign(y(left downto left-len(x.mdt_pt)+1), convert(x.mdt_pt, y(left downto left-len(x.mdt_pt)+1)));
      left := left - len(x.mdt_pt);
      assign(y(left downto left-len(x.mdt_ptthresh)+1), convert(x.mdt_ptthresh, y(left downto left-len(x.mdt_ptthresh)+1)));
      left := left - len(x.mdt_ptthresh);
      assign(y(left downto left-len(x.mdt_charge)+1), convert(x.mdt_charge, y(left downto left-len(x.mdt_charge)+1)));
      left := left - len(x.mdt_charge);
      assign(y(left downto left-len(x.mdt_procflags)+1), convert(x.mdt_procflags, y(left downto left-len(x.mdt_procflags)+1)));
      left := left - len(x.mdt_procflags);
      assign(y(left downto left-len(x.mdt_nsegments)+1), convert(x.mdt_nsegments, y(left downto left-len(x.mdt_nsegments)+1)));
      left := left - len(x.mdt_nsegments);
      assign(y(left downto left-len(x.mdt_quality)+1), convert(x.mdt_quality, y(left downto left-len(x.mdt_quality)+1)));
      left := left - len(x.mdt_quality);
      assign(y(left downto left-len(x.m_reserved)+1), convert(x.m_reserved, y(left downto left-len(x.m_reserved)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: sl2mdt_mtc2sl) return sl2mdt_mtc2sl is
    variable y: sl2mdt_mtc2sl;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := structify(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.common := structify(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.mdt_eta := structify(x(left to left+len(y.mdt_eta)-1), y.mdt_eta);
      left := left + len(y.mdt_eta);
      y.mdt_pt := structify(x(left to left+len(y.mdt_pt)-1), y.mdt_pt);
      left := left + len(y.mdt_pt);
      y.mdt_ptthresh := structify(x(left to left+len(y.mdt_ptthresh)-1), y.mdt_ptthresh);
      left := left + len(y.mdt_ptthresh);
      y.mdt_charge := structify(x(left to left+len(y.mdt_charge)-1), y.mdt_charge);
      left := left + len(y.mdt_charge);
      y.mdt_procflags := structify(x(left to left+len(y.mdt_procflags)-1), y.mdt_procflags);
      left := left + len(y.mdt_procflags);
      y.mdt_nsegments := structify(x(left to left+len(y.mdt_nsegments)-1), y.mdt_nsegments);
      left := left + len(y.mdt_nsegments);
      y.mdt_quality := structify(x(left to left+len(y.mdt_quality)-1), y.mdt_quality);
      left := left + len(y.mdt_quality);
      y.m_reserved := structify(x(left to left+len(y.m_reserved)-1), y.m_reserved);
    else
      y.data_valid := structify(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.common := structify(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.mdt_eta := structify(x(left downto left-len(y.mdt_eta)+1), y.mdt_eta);
      left := left - len(y.mdt_eta);
      y.mdt_pt := structify(x(left downto left-len(y.mdt_pt)+1), y.mdt_pt);
      left := left - len(y.mdt_pt);
      y.mdt_ptthresh := structify(x(left downto left-len(y.mdt_ptthresh)+1), y.mdt_ptthresh);
      left := left - len(y.mdt_ptthresh);
      y.mdt_charge := structify(x(left downto left-len(y.mdt_charge)+1), y.mdt_charge);
      left := left - len(y.mdt_charge);
      y.mdt_procflags := structify(x(left downto left-len(y.mdt_procflags)+1), y.mdt_procflags);
      left := left - len(y.mdt_procflags);
      y.mdt_nsegments := structify(x(left downto left-len(y.mdt_nsegments)+1), y.mdt_nsegments);
      left := left - len(y.mdt_nsegments);
      y.mdt_quality := structify(x(left downto left-len(y.mdt_quality)+1), y.mdt_quality);
      left := left - len(y.mdt_quality);
      y.m_reserved := structify(x(left downto left-len(y.m_reserved)+1), y.m_reserved);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: sl2mdt_mtc2sl) return sl2mdt_mtc2sl is
    variable y: sl2mdt_mtc2sl;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.data_valid := convert(x(left to left+len(y.data_valid)-1), y.data_valid);
      left := left + len(y.data_valid);
      y.common := convert(x(left to left+len(y.common)-1), y.common);
      left := left + len(y.common);
      y.mdt_eta := convert(x(left to left+len(y.mdt_eta)-1), y.mdt_eta);
      left := left + len(y.mdt_eta);
      y.mdt_pt := convert(x(left to left+len(y.mdt_pt)-1), y.mdt_pt);
      left := left + len(y.mdt_pt);
      y.mdt_ptthresh := convert(x(left to left+len(y.mdt_ptthresh)-1), y.mdt_ptthresh);
      left := left + len(y.mdt_ptthresh);
      y.mdt_charge := convert(x(left to left+len(y.mdt_charge)-1), y.mdt_charge);
      left := left + len(y.mdt_charge);
      y.mdt_procflags := convert(x(left to left+len(y.mdt_procflags)-1), y.mdt_procflags);
      left := left + len(y.mdt_procflags);
      y.mdt_nsegments := convert(x(left to left+len(y.mdt_nsegments)-1), y.mdt_nsegments);
      left := left + len(y.mdt_nsegments);
      y.mdt_quality := convert(x(left to left+len(y.mdt_quality)-1), y.mdt_quality);
      left := left + len(y.mdt_quality);
      y.m_reserved := convert(x(left to left+len(y.m_reserved)-1), y.m_reserved);
    else
      y.data_valid := convert(x(left downto left-len(y.data_valid)+1), y.data_valid);
      left := left - len(y.data_valid);
      y.common := convert(x(left downto left-len(y.common)+1), y.common);
      left := left - len(y.common);
      y.mdt_eta := convert(x(left downto left-len(y.mdt_eta)+1), y.mdt_eta);
      left := left - len(y.mdt_eta);
      y.mdt_pt := convert(x(left downto left-len(y.mdt_pt)+1), y.mdt_pt);
      left := left - len(y.mdt_pt);
      y.mdt_ptthresh := convert(x(left downto left-len(y.mdt_ptthresh)+1), y.mdt_ptthresh);
      left := left - len(y.mdt_ptthresh);
      y.mdt_charge := convert(x(left downto left-len(y.mdt_charge)+1), y.mdt_charge);
      left := left - len(y.mdt_charge);
      y.mdt_procflags := convert(x(left downto left-len(y.mdt_procflags)+1), y.mdt_procflags);
      left := left - len(y.mdt_procflags);
      y.mdt_nsegments := convert(x(left downto left-len(y.mdt_nsegments)+1), y.mdt_nsegments);
      left := left - len(y.mdt_nsegments);
      y.mdt_quality := convert(x(left downto left-len(y.mdt_quality)+1), y.mdt_quality);
      left := left - len(y.mdt_quality);
      y.m_reserved := convert(x(left downto left-len(y.m_reserved)+1), y.m_reserved);
    end if;
    return y;
  end function convert;
  function nullify(t: sl2mdt_mtc2sl) return sl2mdt_mtc2sl is
  variable y: sl2mdt_mtc2sl;
  begin
    y.data_valid := nullify(t.data_valid);
    y.common := nullify(t.common);
    y.mdt_eta := nullify(t.mdt_eta);
    y.mdt_pt := nullify(t.mdt_pt);
    y.mdt_ptthresh := nullify(t.mdt_ptthresh);
    y.mdt_charge := nullify(t.mdt_charge);
    y.mdt_procflags := nullify(t.mdt_procflags);
    y.mdt_nsegments := nullify(t.mdt_nsegments);
    y.mdt_quality := nullify(t.mdt_quality);
    y.m_reserved := nullify(t.m_reserved);
    return y;
  end function nullify;
  function zeroed(t: sl2mdt_mtc2sl) return sl2mdt_mtc2sl is
  variable y: sl2mdt_mtc2sl;
  begin
    y.data_valid := zeroed(t.data_valid);
    y.common := zeroed(t.common);
    y.mdt_eta := zeroed(t.mdt_eta);
    y.mdt_pt := zeroed(t.mdt_pt);
    y.mdt_ptthresh := zeroed(t.mdt_ptthresh);
    y.mdt_charge := zeroed(t.mdt_charge);
    y.mdt_procflags := zeroed(t.mdt_procflags);
    y.mdt_nsegments := zeroed(t.mdt_nsegments);
    y.mdt_quality := zeroed(t.mdt_quality);
    y.m_reserved := zeroed(t.m_reserved);
    return y;
  end function zeroed;

  function len(x: sl2mdt_mtc_out_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: sl2mdt_mtc_out_bus) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: sl2mdt_mtc_out_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: sl2mdt_mtc_out_bus; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus is
    variable y : sl2mdt_mtc_out_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus is
    variable y : sl2mdt_mtc_out_bus(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus is
    variable y : sl2mdt_mtc_out_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: sl2mdt_mtc_out_bus) return sl2mdt_mtc_out_bus is
    variable y : sl2mdt_mtc_out_bus(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

end package body sl2mdt_dataformats_pkg;
