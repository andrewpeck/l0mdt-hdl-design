
////////////////////////////////////////////////////////////////////////////////////////////////////
// autogenerated file
// created by tb create on: 30-Nov-2020 (16:11:21)
// created by tb create for test: mtc_auto
////////////////////////////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ps
`default_nettype wire

module TopLevel_mtc_auto #(
    parameter DATA_WIDTH = 256, //65,
    parameter FIFO_DEPTH = 6,
    parameter N_OUTPUTS = 3,
    parameter N_INPUTS = 6

) (
    input wire clock,
    input wire reset_n,
    input wire [DATA_WIDTH-1:0] input_data [6],
    output wire [DATA_WIDTH-1:0] output_data [3]
);

    //
    // Here define the signals to connect the input and output Spy+FIFO
    // blocks with the input and output of the DUT.
    // Here we define one for each of the FIFO signals, but the test
    // creator should remove unnecessary signals.
    //

    wire BLOCK_input_write_enable [6];
    wire [DATA_WIDTH-1:0] BLOCK_input_data [6];
    wire BLOCK_input_read_enable [6];
    wire BLOCK_input_almost_full [6];
    wire BLOCK_input_empty [6];

    wire BLOCK_output_write_enable [3];
    wire [DATA_WIDTH-1:0] BLOCK_output_data [3];
    wire BLOCK_output_read_enable [3];
    wire BLOCK_output_almost_full [3];
    wire BLOCK_output_empty [3];

   parameter SLCPIPELINE_WIDTH = PL2MTC_LEN;
   parameter PTCALC_LEN        = PTCALC2MTC_LEN;
   parameter MTC_LEN           = MTC2SL_LEN;
   parameter MAX_MTC_PER_BCID  = 3;
   parameter TOTAL_PTCALC_BLKS = 3;


   wire [SLCPIPELINE_WIDTH-1:0] slcpipeline [MAX_MTC_PER_BCID];
   wire [PTCALC_LEN-1:0] 	ptcalc [TOTAL_PTCALC_BLKS];
   wire [MTC_LEN-1:0] 		mtc_out [MAX_MTC_PER_BCID];

    //
    // Input buffers
    //
    generate
       for(genvar i = 0; i < 6; i++)
         begin:input_spybuffers
            SpyBuffer #(
			.DATA_WIDTH(DATA_WIDTH-1),
			.FC_FIFO_WIDTH(FIFO_DEPTH),
			.PASSTHROUGH(1)
			) spybuffer (
				     .rclock(clock),
				     .wclock(clock),
				     .rresetbar(reset_n),
				     .wresetbar(reset_n),
				     .write_data(input_data[i]),
				     .write_enable(BLOCK_input_write_enable[i]),
				     .read_data(BLOCK_input_data[i]),
				     .read_enable(BLOCK_input_read_enable[i]),
				     .almost_full(BLOCK_input_almost_full[i]),
				     .empty(BLOCK_input_empty[i]),
				     .freeze(0),
				     .playback(0)
				     );
         end
    endgenerate // end input_spybuffers generate

    //
    // Here place the DUT block(s)
    //
   for(genvar i=0; i<6;i++)
     begin
	if(i<MAX_MTC_PER_BCID)
	  assign slcpipeline[i] = BLOCK_input_data[i];
	else
	  assign ptcalc[i-MAX_MTC_PER_BCID]      = BLOCK_input_data[i];
     end

   mtc_builder_verilog#(
			.PTCALC_WIDTH(PTCALC_LEN),
			.SLCPIPELINE_WIDTH(SLCPIPELINE_WIDTH),
			.TOTAL_PTCALC_BLKS(TOTAL_PTCALC_BLKS)
			)
   mtc_builder_inst(
    		    .clock(clock),
		    .rst(~reset_n),
		    .srst(~reset_n),
		    .ptcalc(ptcalc),
		    .slcpipeline(slcpipeline),
		    .mtc(mtc_out)
		    );

    //
    // Output buffers
    //
   for(genvar i=0; i<MAX_MTC_PER_BCID;i++)
     begin
	assign BLOCK_output_data[i][MTC_LEN-1:0]           = mtc_out[i];
	assign BLOCK_output_data[i][DATA_WIDTH-1:MTC_LEN]  = 0;
	assign BLOCK_output_write_enable[i]                = mtc_out[i][MTC_LEN-1];
     end
    //
    // Output buffers
    //
   generate
      for(genvar i = 0; i < 3; i++)
        begin:output_spybuffers
           SpyBuffer #(
		       .DATA_WIDTH(DATA_WIDTH-1),
		       .FC_FIFO_WIDTH(FIFO_DEPTH),
		       .PASSTHROUGH(1)
                       ) spybuffer (
				    .rclock(clock),
				    .wclock(clock),
				    .rresetbar(reset_n),
				    .wresetbar(reset_n),
				    .write_data(BLOCK_output_data[i]),
				    .write_enable(BLOCK_output_write_enable[i]),
				    .read_data(output_data[i]),
				    .read_enable(BLOCK_output_read_enable[i]),
				    .almost_full(BLOCK_output_almost_full[i]),
				    .empty(BLOCK_output_empty[i]),
				    .freeze(0),
				    .playback(0)
				    );
        end
   endgenerate // end output_spybuffers generate

endmodule // end TopLevel module definition
