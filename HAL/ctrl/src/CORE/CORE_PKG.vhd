-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package CORE_CTRL is

   -- Custom types and functions --

   type CORE_CLOCKING_MON_t is record
      MMCM_LOCKED : std_logic;
      CLK40_FREQ : std_logic_vector(32 - 1 downto 0);
      CLK320_FREQ : std_logic_vector(32 - 1 downto 0);
      CLK50_FREQ : std_logic_vector(32 - 1 downto 0);
   end record CORE_CLOCKING_MON_t;
   attribute w of CORE_CLOCKING_MON_t : type is 1+32+32+32;
   function width(x: CORE_CLOCKING_MON_t) return natural;
   function convert(x: CORE_CLOCKING_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_CLOCKING_MON_t) return CORE_CLOCKING_MON_t;
   function zero(tpl: CORE_CLOCKING_MON_t) return CORE_CLOCKING_MON_t;

   type CORE_CLOCKING_CTRL_t is record
      RESET_MMCM : std_logic;
   end record CORE_CLOCKING_CTRL_t;
   attribute w of CORE_CLOCKING_CTRL_t : type is 1;
   function width(x: CORE_CLOCKING_CTRL_t) return natural;
   function convert(x: CORE_CLOCKING_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_CLOCKING_CTRL_t) return CORE_CLOCKING_CTRL_t;
   function zero(tpl: CORE_CLOCKING_CTRL_t) return CORE_CLOCKING_CTRL_t;

   type CORE_MGT_MGT_STATUS_MON_t is record
      rxcdr_stable : std_logic;
      powergood : std_logic;
      rx_pma_reset_done : std_logic;
      tx_pma_reset_done : std_logic;
      tx_reset_done : std_logic;
      rx_reset_done : std_logic;
      buffbypass_tx_done_out : std_logic;
      buffbypass_tx_error_out : std_logic;
   end record CORE_MGT_MGT_STATUS_MON_t;
   attribute w of CORE_MGT_MGT_STATUS_MON_t : type is 1+1+1+1+1+1+1+1;
   function width(x: CORE_MGT_MGT_STATUS_MON_t) return natural;
   function convert(x: CORE_MGT_MGT_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_STATUS_MON_t) return CORE_MGT_MGT_STATUS_MON_t;
   function zero(tpl: CORE_MGT_MGT_STATUS_MON_t) return CORE_MGT_MGT_STATUS_MON_t;

   type CORE_MGT_MGT_DRP_MON_t is record
      rd_rdy : std_logic;
      rd_data : std_logic_vector(16 - 1 downto 0);
   end record CORE_MGT_MGT_DRP_MON_t;
   attribute w of CORE_MGT_MGT_DRP_MON_t : type is 1+16;
   function width(x: CORE_MGT_MGT_DRP_MON_t) return natural;
   function convert(x: CORE_MGT_MGT_DRP_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_DRP_MON_t) return CORE_MGT_MGT_DRP_MON_t;
   function zero(tpl: CORE_MGT_MGT_DRP_MON_t) return CORE_MGT_MGT_DRP_MON_t;

   type CORE_MGT_MGT_DRP_CTRL_t is record
      wr_en : std_logic;
      wr_addr : std_logic_vector(10 - 1 downto 0);
      en : std_logic;
      wr_data : std_logic_vector(16 - 1 downto 0);
   end record CORE_MGT_MGT_DRP_CTRL_t;
   attribute w of CORE_MGT_MGT_DRP_CTRL_t : type is 1+10+1+16;
   function width(x: CORE_MGT_MGT_DRP_CTRL_t) return natural;
   function convert(x: CORE_MGT_MGT_DRP_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_DRP_CTRL_t) return CORE_MGT_MGT_DRP_CTRL_t;
   function zero(tpl: CORE_MGT_MGT_DRP_CTRL_t) return CORE_MGT_MGT_DRP_CTRL_t;

   type CORE_MGT_MGT_TX_RESETS_CTRL_t is record
      reset_pll_and_datapath : std_logic;
      reset_datapath : std_logic;
      reset_bufbypass : std_logic;
   end record CORE_MGT_MGT_TX_RESETS_CTRL_t;
   attribute w of CORE_MGT_MGT_TX_RESETS_CTRL_t : type is 1+1+1;
   function width(x: CORE_MGT_MGT_TX_RESETS_CTRL_t) return natural;
   function convert(x: CORE_MGT_MGT_TX_RESETS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_TX_RESETS_CTRL_t) return CORE_MGT_MGT_TX_RESETS_CTRL_t;
   function zero(tpl: CORE_MGT_MGT_TX_RESETS_CTRL_t) return CORE_MGT_MGT_TX_RESETS_CTRL_t;

   type CORE_MGT_MGT_RX_RESETS_CTRL_t is record
      reset_pll_and_datapath : std_logic;
      reset_datapath : std_logic;
      reset_bufbypass : std_logic;
   end record CORE_MGT_MGT_RX_RESETS_CTRL_t;
   attribute w of CORE_MGT_MGT_RX_RESETS_CTRL_t : type is 1+1+1;
   function width(x: CORE_MGT_MGT_RX_RESETS_CTRL_t) return natural;
   function convert(x: CORE_MGT_MGT_RX_RESETS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_RX_RESETS_CTRL_t) return CORE_MGT_MGT_RX_RESETS_CTRL_t;
   function zero(tpl: CORE_MGT_MGT_RX_RESETS_CTRL_t) return CORE_MGT_MGT_RX_RESETS_CTRL_t;

   type CORE_MGT_MGT_CONFIG_MON_t is record
      mgt_type : std_logic_vector(3 - 1 downto 0);
      refclk : std_logic_vector(5 - 1 downto 0);
      gt_type : std_logic_vector(2 - 1 downto 0);
      x_loc : std_logic_vector(2 - 1 downto 0);
      y_loc : std_logic_vector(6 - 1 downto 0);
      is_active : std_logic;
   end record CORE_MGT_MGT_CONFIG_MON_t;
   attribute w of CORE_MGT_MGT_CONFIG_MON_t : type is 3+5+2+2+6+1;
   function width(x: CORE_MGT_MGT_CONFIG_MON_t) return natural;
   function convert(x: CORE_MGT_MGT_CONFIG_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_CONFIG_MON_t) return CORE_MGT_MGT_CONFIG_MON_t;
   function zero(tpl: CORE_MGT_MGT_CONFIG_MON_t) return CORE_MGT_MGT_CONFIG_MON_t;

   type CORE_MGT_MGT_MON_t is record
      STATUS : CORE_MGT_MGT_STATUS_MON_t;
      DRP : CORE_MGT_MGT_DRP_MON_t;
      CONFIG : CORE_MGT_MGT_CONFIG_MON_t;
   end record CORE_MGT_MGT_MON_t;
   attribute w of CORE_MGT_MGT_MON_t : type is CORE_MGT_MGT_STATUS_MON_t'w+CORE_MGT_MGT_DRP_MON_t'w+CORE_MGT_MGT_CONFIG_MON_t'w;
   function width(x: CORE_MGT_MGT_MON_t) return natural;
   function convert(x: CORE_MGT_MGT_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_MON_t) return CORE_MGT_MGT_MON_t;
   function zero(tpl: CORE_MGT_MGT_MON_t) return CORE_MGT_MGT_MON_t;

   type CORE_MGT_MGT_MON_t_ARRAY is array(128-1 downto 0) of CORE_MGT_MGT_MON_t;
   attribute w of CORE_MGT_MGT_MON_t_ARRAY : type is (128)*CORE_MGT_MGT_MON_t'w;
   function width(x: CORE_MGT_MGT_MON_t_ARRAY) return integer;
   function convert(x: CORE_MGT_MGT_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_MON_t_ARRAY) return CORE_MGT_MGT_MON_t_ARRAY;
   function zero(tpl: CORE_MGT_MGT_MON_t_ARRAY) return CORE_MGT_MGT_MON_t_ARRAY;
   function convert(x: CORE_MGT_MGT_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: CORE_MGT_MGT_MON_t_ARRAY) return CORE_MGT_MGT_MON_t_ARRAY;

   type CORE_MGT_MGT_CTRL_t is record
      RESET_ALL : std_logic;
      DRP : CORE_MGT_MGT_DRP_CTRL_t;
      TX_RESETS : CORE_MGT_MGT_TX_RESETS_CTRL_t;
      RX_RESETS : CORE_MGT_MGT_RX_RESETS_CTRL_t;
   end record CORE_MGT_MGT_CTRL_t;
   attribute w of CORE_MGT_MGT_CTRL_t : type is 1+CORE_MGT_MGT_DRP_CTRL_t'w+CORE_MGT_MGT_TX_RESETS_CTRL_t'w+CORE_MGT_MGT_RX_RESETS_CTRL_t'w;
   function width(x: CORE_MGT_MGT_CTRL_t) return natural;
   function convert(x: CORE_MGT_MGT_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_CTRL_t) return CORE_MGT_MGT_CTRL_t;
   function zero(tpl: CORE_MGT_MGT_CTRL_t) return CORE_MGT_MGT_CTRL_t;

   type CORE_MGT_MGT_CTRL_t_ARRAY is array(128-1 downto 0) of CORE_MGT_MGT_CTRL_t;
   attribute w of CORE_MGT_MGT_CTRL_t_ARRAY : type is (128)*CORE_MGT_MGT_CTRL_t'w;
   function width(x: CORE_MGT_MGT_CTRL_t_ARRAY) return integer;
   function convert(x: CORE_MGT_MGT_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_CTRL_t_ARRAY) return CORE_MGT_MGT_CTRL_t_ARRAY;
   function zero(tpl: CORE_MGT_MGT_CTRL_t_ARRAY) return CORE_MGT_MGT_CTRL_t_ARRAY;
   function convert(x: CORE_MGT_MGT_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: CORE_MGT_MGT_CTRL_t_ARRAY) return CORE_MGT_MGT_CTRL_t_ARRAY;

   type CORE_MGT_REFCLK_MON_t is record
      FREQ : std_logic_vector(29 - 1 downto 0);
      REFCLK_TYPE : std_logic_vector(3 - 1 downto 0);
   end record CORE_MGT_REFCLK_MON_t;
   attribute w of CORE_MGT_REFCLK_MON_t : type is 29+3;
   function width(x: CORE_MGT_REFCLK_MON_t) return natural;
   function convert(x: CORE_MGT_REFCLK_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_REFCLK_MON_t) return CORE_MGT_REFCLK_MON_t;
   function zero(tpl: CORE_MGT_REFCLK_MON_t) return CORE_MGT_REFCLK_MON_t;

   type CORE_MGT_REFCLK_MON_t_ARRAY is array(32-1 downto 0) of CORE_MGT_REFCLK_MON_t;
   attribute w of CORE_MGT_REFCLK_MON_t_ARRAY : type is (32)*CORE_MGT_REFCLK_MON_t'w;
   function width(x: CORE_MGT_REFCLK_MON_t_ARRAY) return integer;
   function convert(x: CORE_MGT_REFCLK_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_REFCLK_MON_t_ARRAY) return CORE_MGT_REFCLK_MON_t_ARRAY;
   function zero(tpl: CORE_MGT_REFCLK_MON_t_ARRAY) return CORE_MGT_REFCLK_MON_t_ARRAY;
   function convert(x: CORE_MGT_REFCLK_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: CORE_MGT_REFCLK_MON_t_ARRAY) return CORE_MGT_REFCLK_MON_t_ARRAY;

   type CORE_MGT_RECCLK_out_MON_t is record
      FREQ : std_logic_vector(29 - 1 downto 0);
      REFCLK_TYPE : std_logic_vector(3 - 1 downto 0);
   end record CORE_MGT_RECCLK_out_MON_t;
   attribute w of CORE_MGT_RECCLK_out_MON_t : type is 29+3;
   function width(x: CORE_MGT_RECCLK_out_MON_t) return natural;
   function convert(x: CORE_MGT_RECCLK_out_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_RECCLK_out_MON_t) return CORE_MGT_RECCLK_out_MON_t;
   function zero(tpl: CORE_MGT_RECCLK_out_MON_t) return CORE_MGT_RECCLK_out_MON_t;

   type CORE_MGT_MON_t is record
      MGT : CORE_MGT_MGT_MON_t_ARRAY;
      REFCLK : CORE_MGT_REFCLK_MON_t_ARRAY;
      RECCLK_out : CORE_MGT_RECCLK_out_MON_t;
   end record CORE_MGT_MON_t;
   attribute w of CORE_MGT_MON_t : type is CORE_MGT_MGT_MON_t_ARRAY'w+CORE_MGT_REFCLK_MON_t_ARRAY'w+CORE_MGT_RECCLK_out_MON_t'w;
   function width(x: CORE_MGT_MON_t) return natural;
   function convert(x: CORE_MGT_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MON_t) return CORE_MGT_MON_t;
   function zero(tpl: CORE_MGT_MON_t) return CORE_MGT_MON_t;

   type CORE_MGT_CTRL_t is record
      MGT : CORE_MGT_MGT_CTRL_t_ARRAY;
   end record CORE_MGT_CTRL_t;
   attribute w of CORE_MGT_CTRL_t : type is CORE_MGT_MGT_CTRL_t_ARRAY'w;
   function width(x: CORE_MGT_CTRL_t) return natural;
   function convert(x: CORE_MGT_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MGT_CTRL_t) return CORE_MGT_CTRL_t;
   function zero(tpl: CORE_MGT_CTRL_t) return CORE_MGT_CTRL_t;

   type CORE_MON_t is record
      CLOCKING : CORE_CLOCKING_MON_t;
      MGT : CORE_MGT_MON_t;
   end record CORE_MON_t;
   attribute w of CORE_MON_t : type is CORE_CLOCKING_MON_t'w+CORE_MGT_MON_t'w;
   function width(x: CORE_MON_t) return natural;
   function convert(x: CORE_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_MON_t) return CORE_MON_t;
   function zero(tpl: CORE_MON_t) return CORE_MON_t;

   type CORE_CTRL_t is record
      CLOCKING : CORE_CLOCKING_CTRL_t;
      MGT : CORE_MGT_CTRL_t;
   end record CORE_CTRL_t;
   attribute w of CORE_CTRL_t : type is CORE_CLOCKING_CTRL_t'w+CORE_MGT_CTRL_t'w;
   function width(x: CORE_CTRL_t) return natural;
   function convert(x: CORE_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: CORE_CTRL_t) return CORE_CTRL_t;
   function zero(tpl: CORE_CTRL_t) return CORE_CTRL_t;

end package CORE_CTRL;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package body CORE_CTRL is

   -- Custom types and functions --

   function width(x: CORE_CLOCKING_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MMCM_LOCKED);
      w := w + width(x.CLK40_FREQ);
      w := w + width(x.CLK320_FREQ);
      w := w + width(x.CLK50_FREQ);
      return w;
   end function width;
   function convert(x: CORE_CLOCKING_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MMCM_LOCKED);
         y(u to u+w-1) := convert(x.MMCM_LOCKED, y(u to u+w-1));
         u := u + w;
         w := width(x.CLK40_FREQ);
         y(u to u+w-1) := convert(x.CLK40_FREQ, y(u to u+w-1));
         u := u + w;
         w := width(x.CLK320_FREQ);
         y(u to u+w-1) := convert(x.CLK320_FREQ, y(u to u+w-1));
         u := u + w;
         w := width(x.CLK50_FREQ);
         y(u to u+w-1) := convert(x.CLK50_FREQ, y(u to u+w-1));
      else
         w := width(x.MMCM_LOCKED);
         y(u downto u-w+1) := convert(x.MMCM_LOCKED, y(u downto u-w+1));
         u := u - w;
         w := width(x.CLK40_FREQ);
         y(u downto u-w+1) := convert(x.CLK40_FREQ, y(u downto u-w+1));
         u := u - w;
         w := width(x.CLK320_FREQ);
         y(u downto u-w+1) := convert(x.CLK320_FREQ, y(u downto u-w+1));
         u := u - w;
         w := width(x.CLK50_FREQ);
         y(u downto u-w+1) := convert(x.CLK50_FREQ, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_CLOCKING_MON_t) return CORE_CLOCKING_MON_t is
      variable y : CORE_CLOCKING_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MMCM_LOCKED);
         y.MMCM_LOCKED := convert(x(u to u+w-1), tpl.MMCM_LOCKED);
         u := u + w;
         w := width(tpl.CLK40_FREQ);
         y.CLK40_FREQ := convert(x(u to u+w-1), tpl.CLK40_FREQ);
         u := u + w;
         w := width(tpl.CLK320_FREQ);
         y.CLK320_FREQ := convert(x(u to u+w-1), tpl.CLK320_FREQ);
         u := u + w;
         w := width(tpl.CLK50_FREQ);
         y.CLK50_FREQ := convert(x(u to u+w-1), tpl.CLK50_FREQ);
      else
         w := width(tpl.MMCM_LOCKED);
         y.MMCM_LOCKED := convert(x(u downto u-w+1), tpl.MMCM_LOCKED);
         u := u - w;
         w := width(tpl.CLK40_FREQ);
         y.CLK40_FREQ := convert(x(u downto u-w+1), tpl.CLK40_FREQ);
         u := u - w;
         w := width(tpl.CLK320_FREQ);
         y.CLK320_FREQ := convert(x(u downto u-w+1), tpl.CLK320_FREQ);
         u := u - w;
         w := width(tpl.CLK50_FREQ);
         y.CLK50_FREQ := convert(x(u downto u-w+1), tpl.CLK50_FREQ);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_CLOCKING_MON_t) return CORE_CLOCKING_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_CLOCKING_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET_MMCM);
      return w;
   end function width;
   function convert(x: CORE_CLOCKING_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET_MMCM);
         y(u to u+w-1) := convert(x.RESET_MMCM, y(u to u+w-1));
      else
         w := width(x.RESET_MMCM);
         y(u downto u-w+1) := convert(x.RESET_MMCM, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_CLOCKING_CTRL_t) return CORE_CLOCKING_CTRL_t is
      variable y : CORE_CLOCKING_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET_MMCM);
         y.RESET_MMCM := convert(x(u to u+w-1), tpl.RESET_MMCM);
      else
         w := width(tpl.RESET_MMCM);
         y.RESET_MMCM := convert(x(u downto u-w+1), tpl.RESET_MMCM);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_CLOCKING_CTRL_t) return CORE_CLOCKING_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MGT_STATUS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rxcdr_stable);
      w := w + width(x.powergood);
      w := w + width(x.rx_pma_reset_done);
      w := w + width(x.tx_pma_reset_done);
      w := w + width(x.tx_reset_done);
      w := w + width(x.rx_reset_done);
      w := w + width(x.buffbypass_tx_done_out);
      w := w + width(x.buffbypass_tx_error_out);
      return w;
   end function width;
   function convert(x: CORE_MGT_MGT_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rxcdr_stable);
         y(u to u+w-1) := convert(x.rxcdr_stable, y(u to u+w-1));
         u := u + w;
         w := width(x.powergood);
         y(u to u+w-1) := convert(x.powergood, y(u to u+w-1));
         u := u + w;
         w := width(x.rx_pma_reset_done);
         y(u to u+w-1) := convert(x.rx_pma_reset_done, y(u to u+w-1));
         u := u + w;
         w := width(x.tx_pma_reset_done);
         y(u to u+w-1) := convert(x.tx_pma_reset_done, y(u to u+w-1));
         u := u + w;
         w := width(x.tx_reset_done);
         y(u to u+w-1) := convert(x.tx_reset_done, y(u to u+w-1));
         u := u + w;
         w := width(x.rx_reset_done);
         y(u to u+w-1) := convert(x.rx_reset_done, y(u to u+w-1));
         u := u + w;
         w := width(x.buffbypass_tx_done_out);
         y(u to u+w-1) := convert(x.buffbypass_tx_done_out, y(u to u+w-1));
         u := u + w;
         w := width(x.buffbypass_tx_error_out);
         y(u to u+w-1) := convert(x.buffbypass_tx_error_out, y(u to u+w-1));
      else
         w := width(x.rxcdr_stable);
         y(u downto u-w+1) := convert(x.rxcdr_stable, y(u downto u-w+1));
         u := u - w;
         w := width(x.powergood);
         y(u downto u-w+1) := convert(x.powergood, y(u downto u-w+1));
         u := u - w;
         w := width(x.rx_pma_reset_done);
         y(u downto u-w+1) := convert(x.rx_pma_reset_done, y(u downto u-w+1));
         u := u - w;
         w := width(x.tx_pma_reset_done);
         y(u downto u-w+1) := convert(x.tx_pma_reset_done, y(u downto u-w+1));
         u := u - w;
         w := width(x.tx_reset_done);
         y(u downto u-w+1) := convert(x.tx_reset_done, y(u downto u-w+1));
         u := u - w;
         w := width(x.rx_reset_done);
         y(u downto u-w+1) := convert(x.rx_reset_done, y(u downto u-w+1));
         u := u - w;
         w := width(x.buffbypass_tx_done_out);
         y(u downto u-w+1) := convert(x.buffbypass_tx_done_out, y(u downto u-w+1));
         u := u - w;
         w := width(x.buffbypass_tx_error_out);
         y(u downto u-w+1) := convert(x.buffbypass_tx_error_out, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_STATUS_MON_t) return CORE_MGT_MGT_STATUS_MON_t is
      variable y : CORE_MGT_MGT_STATUS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rxcdr_stable);
         y.rxcdr_stable := convert(x(u to u+w-1), tpl.rxcdr_stable);
         u := u + w;
         w := width(tpl.powergood);
         y.powergood := convert(x(u to u+w-1), tpl.powergood);
         u := u + w;
         w := width(tpl.rx_pma_reset_done);
         y.rx_pma_reset_done := convert(x(u to u+w-1), tpl.rx_pma_reset_done);
         u := u + w;
         w := width(tpl.tx_pma_reset_done);
         y.tx_pma_reset_done := convert(x(u to u+w-1), tpl.tx_pma_reset_done);
         u := u + w;
         w := width(tpl.tx_reset_done);
         y.tx_reset_done := convert(x(u to u+w-1), tpl.tx_reset_done);
         u := u + w;
         w := width(tpl.rx_reset_done);
         y.rx_reset_done := convert(x(u to u+w-1), tpl.rx_reset_done);
         u := u + w;
         w := width(tpl.buffbypass_tx_done_out);
         y.buffbypass_tx_done_out := convert(x(u to u+w-1), tpl.buffbypass_tx_done_out);
         u := u + w;
         w := width(tpl.buffbypass_tx_error_out);
         y.buffbypass_tx_error_out := convert(x(u to u+w-1), tpl.buffbypass_tx_error_out);
      else
         w := width(tpl.rxcdr_stable);
         y.rxcdr_stable := convert(x(u downto u-w+1), tpl.rxcdr_stable);
         u := u - w;
         w := width(tpl.powergood);
         y.powergood := convert(x(u downto u-w+1), tpl.powergood);
         u := u - w;
         w := width(tpl.rx_pma_reset_done);
         y.rx_pma_reset_done := convert(x(u downto u-w+1), tpl.rx_pma_reset_done);
         u := u - w;
         w := width(tpl.tx_pma_reset_done);
         y.tx_pma_reset_done := convert(x(u downto u-w+1), tpl.tx_pma_reset_done);
         u := u - w;
         w := width(tpl.tx_reset_done);
         y.tx_reset_done := convert(x(u downto u-w+1), tpl.tx_reset_done);
         u := u - w;
         w := width(tpl.rx_reset_done);
         y.rx_reset_done := convert(x(u downto u-w+1), tpl.rx_reset_done);
         u := u - w;
         w := width(tpl.buffbypass_tx_done_out);
         y.buffbypass_tx_done_out := convert(x(u downto u-w+1), tpl.buffbypass_tx_done_out);
         u := u - w;
         w := width(tpl.buffbypass_tx_error_out);
         y.buffbypass_tx_error_out := convert(x(u downto u-w+1), tpl.buffbypass_tx_error_out);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_STATUS_MON_t) return CORE_MGT_MGT_STATUS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MGT_DRP_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_rdy);
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: CORE_MGT_MGT_DRP_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_rdy);
         y(u to u+w-1) := convert(x.rd_rdy, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.rd_rdy);
         y(u downto u-w+1) := convert(x.rd_rdy, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_DRP_MON_t) return CORE_MGT_MGT_DRP_MON_t is
      variable y : CORE_MGT_MGT_DRP_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u to u+w-1), tpl.rd_rdy);
         u := u + w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u to u+w-1), tpl.rd_data);
      else
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u downto u-w+1), tpl.rd_rdy);
         u := u - w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u downto u-w+1), tpl.rd_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_DRP_MON_t) return CORE_MGT_MGT_DRP_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MGT_DRP_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_en);
      w := w + width(x.wr_addr);
      w := w + width(x.en);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: CORE_MGT_MGT_DRP_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.wr_en);
         y(u to u+w-1) := convert(x.wr_en, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_addr);
         y(u to u+w-1) := convert(x.wr_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.en);
         y(u to u+w-1) := convert(x.en, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.wr_en);
         y(u downto u-w+1) := convert(x.wr_en, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_addr);
         y(u downto u-w+1) := convert(x.wr_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.en);
         y(u downto u-w+1) := convert(x.en, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_DRP_CTRL_t) return CORE_MGT_MGT_DRP_CTRL_t is
      variable y : CORE_MGT_MGT_DRP_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.wr_en);
         y.wr_en := convert(x(u to u+w-1), tpl.wr_en);
         u := u + w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u to u+w-1), tpl.wr_addr);
         u := u + w;
         w := width(tpl.en);
         y.en := convert(x(u to u+w-1), tpl.en);
         u := u + w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u to u+w-1), tpl.wr_data);
      else
         w := width(tpl.wr_en);
         y.wr_en := convert(x(u downto u-w+1), tpl.wr_en);
         u := u - w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u downto u-w+1), tpl.wr_addr);
         u := u - w;
         w := width(tpl.en);
         y.en := convert(x(u downto u-w+1), tpl.en);
         u := u - w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u downto u-w+1), tpl.wr_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_DRP_CTRL_t) return CORE_MGT_MGT_DRP_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MGT_TX_RESETS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.reset_pll_and_datapath);
      w := w + width(x.reset_datapath);
      w := w + width(x.reset_bufbypass);
      return w;
   end function width;
   function convert(x: CORE_MGT_MGT_TX_RESETS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.reset_pll_and_datapath);
         y(u to u+w-1) := convert(x.reset_pll_and_datapath, y(u to u+w-1));
         u := u + w;
         w := width(x.reset_datapath);
         y(u to u+w-1) := convert(x.reset_datapath, y(u to u+w-1));
         u := u + w;
         w := width(x.reset_bufbypass);
         y(u to u+w-1) := convert(x.reset_bufbypass, y(u to u+w-1));
      else
         w := width(x.reset_pll_and_datapath);
         y(u downto u-w+1) := convert(x.reset_pll_and_datapath, y(u downto u-w+1));
         u := u - w;
         w := width(x.reset_datapath);
         y(u downto u-w+1) := convert(x.reset_datapath, y(u downto u-w+1));
         u := u - w;
         w := width(x.reset_bufbypass);
         y(u downto u-w+1) := convert(x.reset_bufbypass, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_TX_RESETS_CTRL_t) return CORE_MGT_MGT_TX_RESETS_CTRL_t is
      variable y : CORE_MGT_MGT_TX_RESETS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.reset_pll_and_datapath);
         y.reset_pll_and_datapath := convert(x(u to u+w-1), tpl.reset_pll_and_datapath);
         u := u + w;
         w := width(tpl.reset_datapath);
         y.reset_datapath := convert(x(u to u+w-1), tpl.reset_datapath);
         u := u + w;
         w := width(tpl.reset_bufbypass);
         y.reset_bufbypass := convert(x(u to u+w-1), tpl.reset_bufbypass);
      else
         w := width(tpl.reset_pll_and_datapath);
         y.reset_pll_and_datapath := convert(x(u downto u-w+1), tpl.reset_pll_and_datapath);
         u := u - w;
         w := width(tpl.reset_datapath);
         y.reset_datapath := convert(x(u downto u-w+1), tpl.reset_datapath);
         u := u - w;
         w := width(tpl.reset_bufbypass);
         y.reset_bufbypass := convert(x(u downto u-w+1), tpl.reset_bufbypass);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_TX_RESETS_CTRL_t) return CORE_MGT_MGT_TX_RESETS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MGT_RX_RESETS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.reset_pll_and_datapath);
      w := w + width(x.reset_datapath);
      w := w + width(x.reset_bufbypass);
      return w;
   end function width;
   function convert(x: CORE_MGT_MGT_RX_RESETS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.reset_pll_and_datapath);
         y(u to u+w-1) := convert(x.reset_pll_and_datapath, y(u to u+w-1));
         u := u + w;
         w := width(x.reset_datapath);
         y(u to u+w-1) := convert(x.reset_datapath, y(u to u+w-1));
         u := u + w;
         w := width(x.reset_bufbypass);
         y(u to u+w-1) := convert(x.reset_bufbypass, y(u to u+w-1));
      else
         w := width(x.reset_pll_and_datapath);
         y(u downto u-w+1) := convert(x.reset_pll_and_datapath, y(u downto u-w+1));
         u := u - w;
         w := width(x.reset_datapath);
         y(u downto u-w+1) := convert(x.reset_datapath, y(u downto u-w+1));
         u := u - w;
         w := width(x.reset_bufbypass);
         y(u downto u-w+1) := convert(x.reset_bufbypass, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_RX_RESETS_CTRL_t) return CORE_MGT_MGT_RX_RESETS_CTRL_t is
      variable y : CORE_MGT_MGT_RX_RESETS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.reset_pll_and_datapath);
         y.reset_pll_and_datapath := convert(x(u to u+w-1), tpl.reset_pll_and_datapath);
         u := u + w;
         w := width(tpl.reset_datapath);
         y.reset_datapath := convert(x(u to u+w-1), tpl.reset_datapath);
         u := u + w;
         w := width(tpl.reset_bufbypass);
         y.reset_bufbypass := convert(x(u to u+w-1), tpl.reset_bufbypass);
      else
         w := width(tpl.reset_pll_and_datapath);
         y.reset_pll_and_datapath := convert(x(u downto u-w+1), tpl.reset_pll_and_datapath);
         u := u - w;
         w := width(tpl.reset_datapath);
         y.reset_datapath := convert(x(u downto u-w+1), tpl.reset_datapath);
         u := u - w;
         w := width(tpl.reset_bufbypass);
         y.reset_bufbypass := convert(x(u downto u-w+1), tpl.reset_bufbypass);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_RX_RESETS_CTRL_t) return CORE_MGT_MGT_RX_RESETS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MGT_CONFIG_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.mgt_type);
      w := w + width(x.refclk);
      w := w + width(x.gt_type);
      w := w + width(x.x_loc);
      w := w + width(x.y_loc);
      w := w + width(x.is_active);
      return w;
   end function width;
   function convert(x: CORE_MGT_MGT_CONFIG_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.mgt_type);
         y(u to u+w-1) := convert(x.mgt_type, y(u to u+w-1));
         u := u + w;
         w := width(x.refclk);
         y(u to u+w-1) := convert(x.refclk, y(u to u+w-1));
         u := u + w;
         w := width(x.gt_type);
         y(u to u+w-1) := convert(x.gt_type, y(u to u+w-1));
         u := u + w;
         w := width(x.x_loc);
         y(u to u+w-1) := convert(x.x_loc, y(u to u+w-1));
         u := u + w;
         w := width(x.y_loc);
         y(u to u+w-1) := convert(x.y_loc, y(u to u+w-1));
         u := u + w;
         w := width(x.is_active);
         y(u to u+w-1) := convert(x.is_active, y(u to u+w-1));
      else
         w := width(x.mgt_type);
         y(u downto u-w+1) := convert(x.mgt_type, y(u downto u-w+1));
         u := u - w;
         w := width(x.refclk);
         y(u downto u-w+1) := convert(x.refclk, y(u downto u-w+1));
         u := u - w;
         w := width(x.gt_type);
         y(u downto u-w+1) := convert(x.gt_type, y(u downto u-w+1));
         u := u - w;
         w := width(x.x_loc);
         y(u downto u-w+1) := convert(x.x_loc, y(u downto u-w+1));
         u := u - w;
         w := width(x.y_loc);
         y(u downto u-w+1) := convert(x.y_loc, y(u downto u-w+1));
         u := u - w;
         w := width(x.is_active);
         y(u downto u-w+1) := convert(x.is_active, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_CONFIG_MON_t) return CORE_MGT_MGT_CONFIG_MON_t is
      variable y : CORE_MGT_MGT_CONFIG_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.mgt_type);
         y.mgt_type := convert(x(u to u+w-1), tpl.mgt_type);
         u := u + w;
         w := width(tpl.refclk);
         y.refclk := convert(x(u to u+w-1), tpl.refclk);
         u := u + w;
         w := width(tpl.gt_type);
         y.gt_type := convert(x(u to u+w-1), tpl.gt_type);
         u := u + w;
         w := width(tpl.x_loc);
         y.x_loc := convert(x(u to u+w-1), tpl.x_loc);
         u := u + w;
         w := width(tpl.y_loc);
         y.y_loc := convert(x(u to u+w-1), tpl.y_loc);
         u := u + w;
         w := width(tpl.is_active);
         y.is_active := convert(x(u to u+w-1), tpl.is_active);
      else
         w := width(tpl.mgt_type);
         y.mgt_type := convert(x(u downto u-w+1), tpl.mgt_type);
         u := u - w;
         w := width(tpl.refclk);
         y.refclk := convert(x(u downto u-w+1), tpl.refclk);
         u := u - w;
         w := width(tpl.gt_type);
         y.gt_type := convert(x(u downto u-w+1), tpl.gt_type);
         u := u - w;
         w := width(tpl.x_loc);
         y.x_loc := convert(x(u downto u-w+1), tpl.x_loc);
         u := u - w;
         w := width(tpl.y_loc);
         y.y_loc := convert(x(u downto u-w+1), tpl.y_loc);
         u := u - w;
         w := width(tpl.is_active);
         y.is_active := convert(x(u downto u-w+1), tpl.is_active);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_CONFIG_MON_t) return CORE_MGT_MGT_CONFIG_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MGT_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.STATUS);
      w := w + width(x.DRP);
      w := w + width(x.CONFIG);
      return w;
   end function width;
   function convert(x: CORE_MGT_MGT_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.STATUS);
         y(u to u+w-1) := convert(x.STATUS, y(u to u+w-1));
         u := u + w;
         w := width(x.DRP);
         y(u to u+w-1) := convert(x.DRP, y(u to u+w-1));
         u := u + w;
         w := width(x.CONFIG);
         y(u to u+w-1) := convert(x.CONFIG, y(u to u+w-1));
      else
         w := width(x.STATUS);
         y(u downto u-w+1) := convert(x.STATUS, y(u downto u-w+1));
         u := u - w;
         w := width(x.DRP);
         y(u downto u-w+1) := convert(x.DRP, y(u downto u-w+1));
         u := u - w;
         w := width(x.CONFIG);
         y(u downto u-w+1) := convert(x.CONFIG, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_MON_t) return CORE_MGT_MGT_MON_t is
      variable y : CORE_MGT_MGT_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u to u+w-1), tpl.STATUS);
         u := u + w;
         w := width(tpl.DRP);
         y.DRP := convert(x(u to u+w-1), tpl.DRP);
         u := u + w;
         w := width(tpl.CONFIG);
         y.CONFIG := convert(x(u to u+w-1), tpl.CONFIG);
      else
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u downto u-w+1), tpl.STATUS);
         u := u - w;
         w := width(tpl.DRP);
         y.DRP := convert(x(u downto u-w+1), tpl.DRP);
         u := u - w;
         w := width(tpl.CONFIG);
         y.CONFIG := convert(x(u downto u-w+1), tpl.CONFIG);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_MON_t) return CORE_MGT_MGT_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MGT_MON_t_ARRAY) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: CORE_MGT_MGT_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_MON_t_ARRAY) return CORE_MGT_MGT_MON_t_ARRAY is
      variable e : tpl'element;
      variable y : CORE_MGT_MGT_MON_t_ARRAY;
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_MON_t_ARRAY) return CORE_MGT_MGT_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: CORE_MGT_MGT_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable e : tpl'element;
      variable y : std_logic_vector_array(tpl'range)(e'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: CORE_MGT_MGT_MON_t_ARRAY) return CORE_MGT_MGT_MON_t_ARRAY is
      variable e : tpl'element;
      variable y : CORE_MGT_MGT_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: CORE_MGT_MGT_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET_ALL);
      w := w + width(x.DRP);
      w := w + width(x.TX_RESETS);
      w := w + width(x.RX_RESETS);
      return w;
   end function width;
   function convert(x: CORE_MGT_MGT_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET_ALL);
         y(u to u+w-1) := convert(x.RESET_ALL, y(u to u+w-1));
         u := u + w;
         w := width(x.DRP);
         y(u to u+w-1) := convert(x.DRP, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_RESETS);
         y(u to u+w-1) := convert(x.TX_RESETS, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_RESETS);
         y(u to u+w-1) := convert(x.RX_RESETS, y(u to u+w-1));
      else
         w := width(x.RESET_ALL);
         y(u downto u-w+1) := convert(x.RESET_ALL, y(u downto u-w+1));
         u := u - w;
         w := width(x.DRP);
         y(u downto u-w+1) := convert(x.DRP, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_RESETS);
         y(u downto u-w+1) := convert(x.TX_RESETS, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_RESETS);
         y(u downto u-w+1) := convert(x.RX_RESETS, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_CTRL_t) return CORE_MGT_MGT_CTRL_t is
      variable y : CORE_MGT_MGT_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET_ALL);
         y.RESET_ALL := convert(x(u to u+w-1), tpl.RESET_ALL);
         u := u + w;
         w := width(tpl.DRP);
         y.DRP := convert(x(u to u+w-1), tpl.DRP);
         u := u + w;
         w := width(tpl.TX_RESETS);
         y.TX_RESETS := convert(x(u to u+w-1), tpl.TX_RESETS);
         u := u + w;
         w := width(tpl.RX_RESETS);
         y.RX_RESETS := convert(x(u to u+w-1), tpl.RX_RESETS);
      else
         w := width(tpl.RESET_ALL);
         y.RESET_ALL := convert(x(u downto u-w+1), tpl.RESET_ALL);
         u := u - w;
         w := width(tpl.DRP);
         y.DRP := convert(x(u downto u-w+1), tpl.DRP);
         u := u - w;
         w := width(tpl.TX_RESETS);
         y.TX_RESETS := convert(x(u downto u-w+1), tpl.TX_RESETS);
         u := u - w;
         w := width(tpl.RX_RESETS);
         y.RX_RESETS := convert(x(u downto u-w+1), tpl.RX_RESETS);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_CTRL_t) return CORE_MGT_MGT_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MGT_CTRL_t_ARRAY) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: CORE_MGT_MGT_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MGT_CTRL_t_ARRAY) return CORE_MGT_MGT_CTRL_t_ARRAY is
      variable e : tpl'element;
      variable y : CORE_MGT_MGT_CTRL_t_ARRAY;
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MGT_CTRL_t_ARRAY) return CORE_MGT_MGT_CTRL_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: CORE_MGT_MGT_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable e : tpl'element;
      variable y : std_logic_vector_array(tpl'range)(e'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: CORE_MGT_MGT_CTRL_t_ARRAY) return CORE_MGT_MGT_CTRL_t_ARRAY is
      variable e : tpl'element;
      variable y : CORE_MGT_MGT_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: CORE_MGT_REFCLK_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.FREQ);
      w := w + width(x.REFCLK_TYPE);
      return w;
   end function width;
   function convert(x: CORE_MGT_REFCLK_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.FREQ);
         y(u to u+w-1) := convert(x.FREQ, y(u to u+w-1));
         u := u + w;
         w := width(x.REFCLK_TYPE);
         y(u to u+w-1) := convert(x.REFCLK_TYPE, y(u to u+w-1));
      else
         w := width(x.FREQ);
         y(u downto u-w+1) := convert(x.FREQ, y(u downto u-w+1));
         u := u - w;
         w := width(x.REFCLK_TYPE);
         y(u downto u-w+1) := convert(x.REFCLK_TYPE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_REFCLK_MON_t) return CORE_MGT_REFCLK_MON_t is
      variable y : CORE_MGT_REFCLK_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.FREQ);
         y.FREQ := convert(x(u to u+w-1), tpl.FREQ);
         u := u + w;
         w := width(tpl.REFCLK_TYPE);
         y.REFCLK_TYPE := convert(x(u to u+w-1), tpl.REFCLK_TYPE);
      else
         w := width(tpl.FREQ);
         y.FREQ := convert(x(u downto u-w+1), tpl.FREQ);
         u := u - w;
         w := width(tpl.REFCLK_TYPE);
         y.REFCLK_TYPE := convert(x(u downto u-w+1), tpl.REFCLK_TYPE);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_REFCLK_MON_t) return CORE_MGT_REFCLK_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_REFCLK_MON_t_ARRAY) return integer is
      variable aux : x'element;
      constant w : integer := width(aux);
   begin
      return x'length * w;
   end function width;
   function convert(x: CORE_MGT_REFCLK_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable aux : x'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in x'range loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_REFCLK_MON_t_ARRAY) return CORE_MGT_REFCLK_MON_t_ARRAY is
      variable e : tpl'element;
      variable y : CORE_MGT_REFCLK_MON_t_ARRAY;
      variable aux : y'element;
      constant W : natural := width(aux);
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in y'range loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_REFCLK_MON_t_ARRAY) return CORE_MGT_REFCLK_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: CORE_MGT_REFCLK_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable e : tpl'element;
      variable y : std_logic_vector_array(tpl'range)(e'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: CORE_MGT_REFCLK_MON_t_ARRAY) return CORE_MGT_REFCLK_MON_t_ARRAY is
      variable e : tpl'element;
      variable y : CORE_MGT_REFCLK_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: CORE_MGT_RECCLK_out_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.FREQ);
      w := w + width(x.REFCLK_TYPE);
      return w;
   end function width;
   function convert(x: CORE_MGT_RECCLK_out_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.FREQ);
         y(u to u+w-1) := convert(x.FREQ, y(u to u+w-1));
         u := u + w;
         w := width(x.REFCLK_TYPE);
         y(u to u+w-1) := convert(x.REFCLK_TYPE, y(u to u+w-1));
      else
         w := width(x.FREQ);
         y(u downto u-w+1) := convert(x.FREQ, y(u downto u-w+1));
         u := u - w;
         w := width(x.REFCLK_TYPE);
         y(u downto u-w+1) := convert(x.REFCLK_TYPE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_RECCLK_out_MON_t) return CORE_MGT_RECCLK_out_MON_t is
      variable y : CORE_MGT_RECCLK_out_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.FREQ);
         y.FREQ := convert(x(u to u+w-1), tpl.FREQ);
         u := u + w;
         w := width(tpl.REFCLK_TYPE);
         y.REFCLK_TYPE := convert(x(u to u+w-1), tpl.REFCLK_TYPE);
      else
         w := width(tpl.FREQ);
         y.FREQ := convert(x(u downto u-w+1), tpl.FREQ);
         u := u - w;
         w := width(tpl.REFCLK_TYPE);
         y.REFCLK_TYPE := convert(x(u downto u-w+1), tpl.REFCLK_TYPE);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_RECCLK_out_MON_t) return CORE_MGT_RECCLK_out_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MGT);
      w := w + width(x.REFCLK);
      w := w + width(x.RECCLK_out);
      return w;
   end function width;
   function convert(x: CORE_MGT_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MGT);
         y(u to u+w-1) := convert(x.MGT, y(u to u+w-1));
         u := u + w;
         w := width(x.REFCLK);
         y(u to u+w-1) := convert(x.REFCLK, y(u to u+w-1));
         u := u + w;
         w := width(x.RECCLK_out);
         y(u to u+w-1) := convert(x.RECCLK_out, y(u to u+w-1));
      else
         w := width(x.MGT);
         y(u downto u-w+1) := convert(x.MGT, y(u downto u-w+1));
         u := u - w;
         w := width(x.REFCLK);
         y(u downto u-w+1) := convert(x.REFCLK, y(u downto u-w+1));
         u := u - w;
         w := width(x.RECCLK_out);
         y(u downto u-w+1) := convert(x.RECCLK_out, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_MON_t) return CORE_MGT_MON_t is
      variable y : CORE_MGT_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MGT);
         y.MGT := convert(x(u to u+w-1), tpl.MGT);
         u := u + w;
         w := width(tpl.REFCLK);
         y.REFCLK := convert(x(u to u+w-1), tpl.REFCLK);
         u := u + w;
         w := width(tpl.RECCLK_out);
         y.RECCLK_out := convert(x(u to u+w-1), tpl.RECCLK_out);
      else
         w := width(tpl.MGT);
         y.MGT := convert(x(u downto u-w+1), tpl.MGT);
         u := u - w;
         w := width(tpl.REFCLK);
         y.REFCLK := convert(x(u downto u-w+1), tpl.REFCLK);
         u := u - w;
         w := width(tpl.RECCLK_out);
         y.RECCLK_out := convert(x(u downto u-w+1), tpl.RECCLK_out);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_MON_t) return CORE_MGT_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MGT_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MGT);
      return w;
   end function width;
   function convert(x: CORE_MGT_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MGT);
         y(u to u+w-1) := convert(x.MGT, y(u to u+w-1));
      else
         w := width(x.MGT);
         y(u downto u-w+1) := convert(x.MGT, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MGT_CTRL_t) return CORE_MGT_CTRL_t is
      variable y : CORE_MGT_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MGT);
         y.MGT := convert(x(u to u+w-1), tpl.MGT);
      else
         w := width(tpl.MGT);
         y.MGT := convert(x(u downto u-w+1), tpl.MGT);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MGT_CTRL_t) return CORE_MGT_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CLOCKING);
      w := w + width(x.MGT);
      return w;
   end function width;
   function convert(x: CORE_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.CLOCKING);
         y(u to u+w-1) := convert(x.CLOCKING, y(u to u+w-1));
         u := u + w;
         w := width(x.MGT);
         y(u to u+w-1) := convert(x.MGT, y(u to u+w-1));
      else
         w := width(x.CLOCKING);
         y(u downto u-w+1) := convert(x.CLOCKING, y(u downto u-w+1));
         u := u - w;
         w := width(x.MGT);
         y(u downto u-w+1) := convert(x.MGT, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_MON_t) return CORE_MON_t is
      variable y : CORE_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.CLOCKING);
         y.CLOCKING := convert(x(u to u+w-1), tpl.CLOCKING);
         u := u + w;
         w := width(tpl.MGT);
         y.MGT := convert(x(u to u+w-1), tpl.MGT);
      else
         w := width(tpl.CLOCKING);
         y.CLOCKING := convert(x(u downto u-w+1), tpl.CLOCKING);
         u := u - w;
         w := width(tpl.MGT);
         y.MGT := convert(x(u downto u-w+1), tpl.MGT);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_MON_t) return CORE_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: CORE_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CLOCKING);
      w := w + width(x.MGT);
      return w;
   end function width;
   function convert(x: CORE_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.CLOCKING);
         y(u to u+w-1) := convert(x.CLOCKING, y(u to u+w-1));
         u := u + w;
         w := width(x.MGT);
         y(u to u+w-1) := convert(x.MGT, y(u to u+w-1));
      else
         w := width(x.CLOCKING);
         y(u downto u-w+1) := convert(x.CLOCKING, y(u downto u-w+1));
         u := u - w;
         w := width(x.MGT);
         y(u downto u-w+1) := convert(x.MGT, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: CORE_CTRL_t) return CORE_CTRL_t is
      variable y : CORE_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.CLOCKING);
         y.CLOCKING := convert(x(u to u+w-1), tpl.CLOCKING);
         u := u + w;
         w := width(tpl.MGT);
         y.MGT := convert(x(u to u+w-1), tpl.MGT);
      else
         w := width(tpl.CLOCKING);
         y.CLOCKING := convert(x(u downto u-w+1), tpl.CLOCKING);
         u := u - w;
         w := width(tpl.MGT);
         y.MGT := convert(x(u downto u-w+1), tpl.MGT);
      end if;
      return y;
   end function convert;
   function zero(tpl: CORE_CTRL_t) return CORE_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

end package body CORE_CTRL;
