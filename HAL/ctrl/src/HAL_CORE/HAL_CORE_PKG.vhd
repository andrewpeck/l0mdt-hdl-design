-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;

use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;

use shared_lib.common_ieee.all;

package HAL_CORE_CTRL is

  type HAL_CORE_CLOCKING_MON_t is record
    MMCM_LOCKED : std_logic;
  end record HAL_CORE_CLOCKING_MON_t;
  function len(x: HAL_CORE_CLOCKING_MON_t) return natural;
  function width(x: HAL_CORE_CLOCKING_MON_t) return natural;
  function vectorify(x: HAL_CORE_CLOCKING_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_CLOCKING_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_CLOCKING_MON_t) return HAL_CORE_CLOCKING_MON_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_CLOCKING_MON_t) return HAL_CORE_CLOCKING_MON_t;
  function nullify(t: HAL_CORE_CLOCKING_MON_t) return HAL_CORE_CLOCKING_MON_t;
  function zeroed(t: HAL_CORE_CLOCKING_MON_t) return HAL_CORE_CLOCKING_MON_t;

  type HAL_CORE_CLOCKING_CTRL_t is record
    RESET_MMCM : std_logic;
  end record HAL_CORE_CLOCKING_CTRL_t;
  function len(x: HAL_CORE_CLOCKING_CTRL_t) return natural;
  function width(x: HAL_CORE_CLOCKING_CTRL_t) return natural;
  function vectorify(x: HAL_CORE_CLOCKING_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_CLOCKING_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_CLOCKING_CTRL_t) return HAL_CORE_CLOCKING_CTRL_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_CLOCKING_CTRL_t) return HAL_CORE_CLOCKING_CTRL_t;
  function nullify(t: HAL_CORE_CLOCKING_CTRL_t) return HAL_CORE_CLOCKING_CTRL_t;
  function zeroed(t: HAL_CORE_CLOCKING_CTRL_t) return HAL_CORE_CLOCKING_CTRL_t;

  type HAL_CORE_MGT_MGT_STATUS_MON_t is record
    rxcdr_stable : std_logic;
    powergood : std_logic;
    txready : std_logic;
    rxready : std_logic;
    rx_pma_reset_done : std_logic;
    tx_pma_reset_done : std_logic;
    tx_reset_done : std_logic;
    rx_reset_done : std_logic;
    buffbypass_tx_done_out : std_logic;
    buffbypass_tx_error_out : std_logic;
    buffbypass_rx_done_out : std_logic;
    buffbypass_rx_error_out : std_logic;
  end record HAL_CORE_MGT_MGT_STATUS_MON_t;
  function len(x: HAL_CORE_MGT_MGT_STATUS_MON_t) return natural;
  function width(x: HAL_CORE_MGT_MGT_STATUS_MON_t) return natural;
  function vectorify(x: HAL_CORE_MGT_MGT_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MGT_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_STATUS_MON_t) return HAL_CORE_MGT_MGT_STATUS_MON_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_STATUS_MON_t) return HAL_CORE_MGT_MGT_STATUS_MON_t;
  function nullify(t: HAL_CORE_MGT_MGT_STATUS_MON_t) return HAL_CORE_MGT_MGT_STATUS_MON_t;
  function zeroed(t: HAL_CORE_MGT_MGT_STATUS_MON_t) return HAL_CORE_MGT_MGT_STATUS_MON_t;

  type HAL_CORE_MGT_MGT_DRP_MON_t is record
    rd_rdy : std_logic;
    rd_data : std_logic_vector(16-1 downto 0);
  end record HAL_CORE_MGT_MGT_DRP_MON_t;
  function len(x: HAL_CORE_MGT_MGT_DRP_MON_t) return natural;
  function width(x: HAL_CORE_MGT_MGT_DRP_MON_t) return natural;
  function vectorify(x: HAL_CORE_MGT_MGT_DRP_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MGT_DRP_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_DRP_MON_t) return HAL_CORE_MGT_MGT_DRP_MON_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_DRP_MON_t) return HAL_CORE_MGT_MGT_DRP_MON_t;
  function nullify(t: HAL_CORE_MGT_MGT_DRP_MON_t) return HAL_CORE_MGT_MGT_DRP_MON_t;
  function zeroed(t: HAL_CORE_MGT_MGT_DRP_MON_t) return HAL_CORE_MGT_MGT_DRP_MON_t;

  type HAL_CORE_MGT_MGT_DRP_CTRL_t is record
    wr_en : std_logic;
    wr_addr : std_logic_vector(10-1 downto 0);
    en : std_logic;
    wr_data : std_logic_vector(16-1 downto 0);
  end record HAL_CORE_MGT_MGT_DRP_CTRL_t;
  function len(x: HAL_CORE_MGT_MGT_DRP_CTRL_t) return natural;
  function width(x: HAL_CORE_MGT_MGT_DRP_CTRL_t) return natural;
  function vectorify(x: HAL_CORE_MGT_MGT_DRP_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MGT_DRP_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_DRP_CTRL_t) return HAL_CORE_MGT_MGT_DRP_CTRL_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_DRP_CTRL_t) return HAL_CORE_MGT_MGT_DRP_CTRL_t;
  function nullify(t: HAL_CORE_MGT_MGT_DRP_CTRL_t) return HAL_CORE_MGT_MGT_DRP_CTRL_t;
  function zeroed(t: HAL_CORE_MGT_MGT_DRP_CTRL_t) return HAL_CORE_MGT_MGT_DRP_CTRL_t;

  type HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t is record
    reset : std_logic;
    reset_pll_and_datapath : std_logic;
    reset_datapath : std_logic;
    reset_bufbypass : std_logic;
  end record HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;
  function len(x: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return natural;
  function width(x: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return natural;
  function vectorify(x: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;
  function nullify(t: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;
  function zeroed(t: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;

  type HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t is record
    reset : std_logic;
    reset_pll_and_datapath : std_logic;
    reset_datapath : std_logic;
    reset_bufbypass : std_logic;
  end record HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;
  function len(x: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return natural;
  function width(x: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return natural;
  function vectorify(x: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;
  function nullify(t: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;
  function zeroed(t: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;

  type HAL_CORE_MGT_MGT_MON_t is record
    STATUS : HAL_CORE_MGT_MGT_STATUS_MON_t;
    DRP : HAL_CORE_MGT_MGT_DRP_MON_t;
  end record HAL_CORE_MGT_MGT_MON_t;
  function len(x: HAL_CORE_MGT_MGT_MON_t) return natural;
  function width(x: HAL_CORE_MGT_MGT_MON_t) return natural;
  function vectorify(x: HAL_CORE_MGT_MGT_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MGT_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_MON_t) return HAL_CORE_MGT_MGT_MON_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_MON_t) return HAL_CORE_MGT_MGT_MON_t;
  function nullify(t: HAL_CORE_MGT_MGT_MON_t) return HAL_CORE_MGT_MGT_MON_t;
  function zeroed(t: HAL_CORE_MGT_MGT_MON_t) return HAL_CORE_MGT_MGT_MON_t;

  type HAL_CORE_MGT_MGT_MON_t_ARRAY is array(128-1 downto 0) of HAL_CORE_MGT_MGT_MON_t;
  function len(x: HAL_CORE_MGT_MGT_MON_t_ARRAY) return natural;
  function width(x: HAL_CORE_MGT_MGT_MON_t_ARRAY) return natural;
  function vectorify(x: HAL_CORE_MGT_MGT_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MGT_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HAL_CORE_MGT_MGT_MON_t_ARRAY) return HAL_CORE_MGT_MGT_MON_t_ARRAY;
  function convert(x: std_logic_vector; t: HAL_CORE_MGT_MGT_MON_t_ARRAY) return HAL_CORE_MGT_MGT_MON_t_ARRAY;
  function nullify(x: HAL_CORE_MGT_MGT_MON_t_ARRAY) return HAL_CORE_MGT_MGT_MON_t_ARRAY;
  function zeroed(x: HAL_CORE_MGT_MGT_MON_t_ARRAY) return HAL_CORE_MGT_MGT_MON_t_ARRAY;

  type HAL_CORE_MGT_MGT_CTRL_t is record
    DRP : HAL_CORE_MGT_MGT_DRP_CTRL_t;
    TX_RESETS : HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;
    RX_RESETS : HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;
  end record HAL_CORE_MGT_MGT_CTRL_t;
  function len(x: HAL_CORE_MGT_MGT_CTRL_t) return natural;
  function width(x: HAL_CORE_MGT_MGT_CTRL_t) return natural;
  function vectorify(x: HAL_CORE_MGT_MGT_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MGT_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_CTRL_t) return HAL_CORE_MGT_MGT_CTRL_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_CTRL_t) return HAL_CORE_MGT_MGT_CTRL_t;
  function nullify(t: HAL_CORE_MGT_MGT_CTRL_t) return HAL_CORE_MGT_MGT_CTRL_t;
  function zeroed(t: HAL_CORE_MGT_MGT_CTRL_t) return HAL_CORE_MGT_MGT_CTRL_t;

  type HAL_CORE_MGT_MGT_CTRL_t_ARRAY is array(128-1 downto 0) of HAL_CORE_MGT_MGT_CTRL_t;
  function len(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return natural;
  function width(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return natural;
  function vectorify(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return HAL_CORE_MGT_MGT_CTRL_t_ARRAY;
  function convert(x: std_logic_vector; t: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return HAL_CORE_MGT_MGT_CTRL_t_ARRAY;
  function nullify(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return HAL_CORE_MGT_MGT_CTRL_t_ARRAY;
  function zeroed(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return HAL_CORE_MGT_MGT_CTRL_t_ARRAY;

  type HAL_CORE_MGT_MON_t is record
    MGT : HAL_CORE_MGT_MGT_MON_t_ARRAY;
  end record HAL_CORE_MGT_MON_t;
  function len(x: HAL_CORE_MGT_MON_t) return natural;
  function width(x: HAL_CORE_MGT_MON_t) return natural;
  function vectorify(x: HAL_CORE_MGT_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MON_t) return HAL_CORE_MGT_MON_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MON_t) return HAL_CORE_MGT_MON_t;
  function nullify(t: HAL_CORE_MGT_MON_t) return HAL_CORE_MGT_MON_t;
  function zeroed(t: HAL_CORE_MGT_MON_t) return HAL_CORE_MGT_MON_t;

  type HAL_CORE_MGT_CTRL_t is record
    MGT : HAL_CORE_MGT_MGT_CTRL_t_ARRAY;
  end record HAL_CORE_MGT_CTRL_t;
  function len(x: HAL_CORE_MGT_CTRL_t) return natural;
  function width(x: HAL_CORE_MGT_CTRL_t) return natural;
  function vectorify(x: HAL_CORE_MGT_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MGT_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_CTRL_t) return HAL_CORE_MGT_CTRL_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_CTRL_t) return HAL_CORE_MGT_CTRL_t;
  function nullify(t: HAL_CORE_MGT_CTRL_t) return HAL_CORE_MGT_CTRL_t;
  function zeroed(t: HAL_CORE_MGT_CTRL_t) return HAL_CORE_MGT_CTRL_t;

  type HAL_CORE_MON_t is record
    CLOCKING : HAL_CORE_CLOCKING_MON_t;
    MGT : HAL_CORE_MGT_MON_t;
  end record HAL_CORE_MON_t;
  function len(x: HAL_CORE_MON_t) return natural;
  function width(x: HAL_CORE_MON_t) return natural;
  function vectorify(x: HAL_CORE_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_MON_t) return HAL_CORE_MON_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_MON_t) return HAL_CORE_MON_t;
  function nullify(t: HAL_CORE_MON_t) return HAL_CORE_MON_t;
  function zeroed(t: HAL_CORE_MON_t) return HAL_CORE_MON_t;

  type HAL_CORE_CTRL_t is record
    CLOCKING : HAL_CORE_CLOCKING_CTRL_t;
    MGT : HAL_CORE_MGT_CTRL_t;
  end record HAL_CORE_CTRL_t;
  function len(x: HAL_CORE_CTRL_t) return natural;
  function width(x: HAL_CORE_CTRL_t) return natural;
  function vectorify(x: HAL_CORE_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HAL_CORE_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HAL_CORE_CTRL_t) return HAL_CORE_CTRL_t;
  function convert(x: in std_logic_vector; t: HAL_CORE_CTRL_t) return HAL_CORE_CTRL_t;
  function nullify(t: HAL_CORE_CTRL_t) return HAL_CORE_CTRL_t;
  function zeroed(t: HAL_CORE_CTRL_t) return HAL_CORE_CTRL_t;

end package HAL_CORE_CTRL;

------------------------------------------------------------

package body HAL_CORE_CTRL is

  function len(x: HAL_CORE_CLOCKING_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MMCM_LOCKED);
    return l;
  end function len;
  function width(x: HAL_CORE_CLOCKING_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.MMCM_LOCKED);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_CLOCKING_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MMCM_LOCKED)-1), vectorify(x.MMCM_LOCKED, y(left to left+len(x.MMCM_LOCKED)-1)));
    else
      assign(y(left downto left-len(x.MMCM_LOCKED)+1), vectorify(x.MMCM_LOCKED, y(left downto left-len(x.MMCM_LOCKED)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_CLOCKING_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MMCM_LOCKED)-1), convert(x.MMCM_LOCKED, y(left to left+len(x.MMCM_LOCKED)-1)));
    else
      assign(y(left downto left-len(x.MMCM_LOCKED)+1), convert(x.MMCM_LOCKED, y(left downto left-len(x.MMCM_LOCKED)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_CLOCKING_MON_t) return HAL_CORE_CLOCKING_MON_t is
    variable y: HAL_CORE_CLOCKING_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MMCM_LOCKED := structify(x(left to left+len(y.MMCM_LOCKED)-1), y.MMCM_LOCKED);
    else
      y.MMCM_LOCKED := structify(x(left downto left-len(y.MMCM_LOCKED)+1), y.MMCM_LOCKED);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_CLOCKING_MON_t) return HAL_CORE_CLOCKING_MON_t is
    variable y: HAL_CORE_CLOCKING_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MMCM_LOCKED := convert(x(left to left+len(y.MMCM_LOCKED)-1), y.MMCM_LOCKED);
    else
      y.MMCM_LOCKED := convert(x(left downto left-len(y.MMCM_LOCKED)+1), y.MMCM_LOCKED);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_CLOCKING_MON_t) return HAL_CORE_CLOCKING_MON_t is
  variable y: HAL_CORE_CLOCKING_MON_t;
  begin
    y.MMCM_LOCKED := nullify(t.MMCM_LOCKED);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_CLOCKING_MON_t) return HAL_CORE_CLOCKING_MON_t is
  variable y: HAL_CORE_CLOCKING_MON_t;
  begin
    y.MMCM_LOCKED := zeroed(t.MMCM_LOCKED);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_CLOCKING_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.RESET_MMCM);
    return l;
  end function len;
  function width(x: HAL_CORE_CLOCKING_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.RESET_MMCM);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_CLOCKING_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET_MMCM)-1), vectorify(x.RESET_MMCM, y(left to left+len(x.RESET_MMCM)-1)));
    else
      assign(y(left downto left-len(x.RESET_MMCM)+1), vectorify(x.RESET_MMCM, y(left downto left-len(x.RESET_MMCM)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_CLOCKING_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET_MMCM)-1), convert(x.RESET_MMCM, y(left to left+len(x.RESET_MMCM)-1)));
    else
      assign(y(left downto left-len(x.RESET_MMCM)+1), convert(x.RESET_MMCM, y(left downto left-len(x.RESET_MMCM)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_CLOCKING_CTRL_t) return HAL_CORE_CLOCKING_CTRL_t is
    variable y: HAL_CORE_CLOCKING_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET_MMCM := structify(x(left to left+len(y.RESET_MMCM)-1), y.RESET_MMCM);
    else
      y.RESET_MMCM := structify(x(left downto left-len(y.RESET_MMCM)+1), y.RESET_MMCM);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_CLOCKING_CTRL_t) return HAL_CORE_CLOCKING_CTRL_t is
    variable y: HAL_CORE_CLOCKING_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET_MMCM := convert(x(left to left+len(y.RESET_MMCM)-1), y.RESET_MMCM);
    else
      y.RESET_MMCM := convert(x(left downto left-len(y.RESET_MMCM)+1), y.RESET_MMCM);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_CLOCKING_CTRL_t) return HAL_CORE_CLOCKING_CTRL_t is
  variable y: HAL_CORE_CLOCKING_CTRL_t;
  begin
    y.RESET_MMCM := nullify(t.RESET_MMCM);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_CLOCKING_CTRL_t) return HAL_CORE_CLOCKING_CTRL_t is
  variable y: HAL_CORE_CLOCKING_CTRL_t;
  begin
    y.RESET_MMCM := zeroed(t.RESET_MMCM);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MGT_STATUS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rxcdr_stable);
    l := l + len(x.powergood);
    l := l + len(x.txready);
    l := l + len(x.rxready);
    l := l + len(x.rx_pma_reset_done);
    l := l + len(x.tx_pma_reset_done);
    l := l + len(x.tx_reset_done);
    l := l + len(x.rx_reset_done);
    l := l + len(x.buffbypass_tx_done_out);
    l := l + len(x.buffbypass_tx_error_out);
    l := l + len(x.buffbypass_rx_done_out);
    l := l + len(x.buffbypass_rx_error_out);
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MGT_STATUS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rxcdr_stable);
    l := l + width(x.powergood);
    l := l + width(x.txready);
    l := l + width(x.rxready);
    l := l + width(x.rx_pma_reset_done);
    l := l + width(x.tx_pma_reset_done);
    l := l + width(x.tx_reset_done);
    l := l + width(x.rx_reset_done);
    l := l + width(x.buffbypass_tx_done_out);
    l := l + width(x.buffbypass_tx_error_out);
    l := l + width(x.buffbypass_rx_done_out);
    l := l + width(x.buffbypass_rx_error_out);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MGT_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rxcdr_stable)-1), vectorify(x.rxcdr_stable, y(left to left+len(x.rxcdr_stable)-1)));
      left := left + len(x.rxcdr_stable);
      assign(y(left to left+len(x.powergood)-1), vectorify(x.powergood, y(left to left+len(x.powergood)-1)));
      left := left + len(x.powergood);
      assign(y(left to left+len(x.txready)-1), vectorify(x.txready, y(left to left+len(x.txready)-1)));
      left := left + len(x.txready);
      assign(y(left to left+len(x.rxready)-1), vectorify(x.rxready, y(left to left+len(x.rxready)-1)));
      left := left + len(x.rxready);
      assign(y(left to left+len(x.rx_pma_reset_done)-1), vectorify(x.rx_pma_reset_done, y(left to left+len(x.rx_pma_reset_done)-1)));
      left := left + len(x.rx_pma_reset_done);
      assign(y(left to left+len(x.tx_pma_reset_done)-1), vectorify(x.tx_pma_reset_done, y(left to left+len(x.tx_pma_reset_done)-1)));
      left := left + len(x.tx_pma_reset_done);
      assign(y(left to left+len(x.tx_reset_done)-1), vectorify(x.tx_reset_done, y(left to left+len(x.tx_reset_done)-1)));
      left := left + len(x.tx_reset_done);
      assign(y(left to left+len(x.rx_reset_done)-1), vectorify(x.rx_reset_done, y(left to left+len(x.rx_reset_done)-1)));
      left := left + len(x.rx_reset_done);
      assign(y(left to left+len(x.buffbypass_tx_done_out)-1), vectorify(x.buffbypass_tx_done_out, y(left to left+len(x.buffbypass_tx_done_out)-1)));
      left := left + len(x.buffbypass_tx_done_out);
      assign(y(left to left+len(x.buffbypass_tx_error_out)-1), vectorify(x.buffbypass_tx_error_out, y(left to left+len(x.buffbypass_tx_error_out)-1)));
      left := left + len(x.buffbypass_tx_error_out);
      assign(y(left to left+len(x.buffbypass_rx_done_out)-1), vectorify(x.buffbypass_rx_done_out, y(left to left+len(x.buffbypass_rx_done_out)-1)));
      left := left + len(x.buffbypass_rx_done_out);
      assign(y(left to left+len(x.buffbypass_rx_error_out)-1), vectorify(x.buffbypass_rx_error_out, y(left to left+len(x.buffbypass_rx_error_out)-1)));
    else
      assign(y(left downto left-len(x.rxcdr_stable)+1), vectorify(x.rxcdr_stable, y(left downto left-len(x.rxcdr_stable)+1)));
      left := left - len(x.rxcdr_stable);
      assign(y(left downto left-len(x.powergood)+1), vectorify(x.powergood, y(left downto left-len(x.powergood)+1)));
      left := left - len(x.powergood);
      assign(y(left downto left-len(x.txready)+1), vectorify(x.txready, y(left downto left-len(x.txready)+1)));
      left := left - len(x.txready);
      assign(y(left downto left-len(x.rxready)+1), vectorify(x.rxready, y(left downto left-len(x.rxready)+1)));
      left := left - len(x.rxready);
      assign(y(left downto left-len(x.rx_pma_reset_done)+1), vectorify(x.rx_pma_reset_done, y(left downto left-len(x.rx_pma_reset_done)+1)));
      left := left - len(x.rx_pma_reset_done);
      assign(y(left downto left-len(x.tx_pma_reset_done)+1), vectorify(x.tx_pma_reset_done, y(left downto left-len(x.tx_pma_reset_done)+1)));
      left := left - len(x.tx_pma_reset_done);
      assign(y(left downto left-len(x.tx_reset_done)+1), vectorify(x.tx_reset_done, y(left downto left-len(x.tx_reset_done)+1)));
      left := left - len(x.tx_reset_done);
      assign(y(left downto left-len(x.rx_reset_done)+1), vectorify(x.rx_reset_done, y(left downto left-len(x.rx_reset_done)+1)));
      left := left - len(x.rx_reset_done);
      assign(y(left downto left-len(x.buffbypass_tx_done_out)+1), vectorify(x.buffbypass_tx_done_out, y(left downto left-len(x.buffbypass_tx_done_out)+1)));
      left := left - len(x.buffbypass_tx_done_out);
      assign(y(left downto left-len(x.buffbypass_tx_error_out)+1), vectorify(x.buffbypass_tx_error_out, y(left downto left-len(x.buffbypass_tx_error_out)+1)));
      left := left - len(x.buffbypass_tx_error_out);
      assign(y(left downto left-len(x.buffbypass_rx_done_out)+1), vectorify(x.buffbypass_rx_done_out, y(left downto left-len(x.buffbypass_rx_done_out)+1)));
      left := left - len(x.buffbypass_rx_done_out);
      assign(y(left downto left-len(x.buffbypass_rx_error_out)+1), vectorify(x.buffbypass_rx_error_out, y(left downto left-len(x.buffbypass_rx_error_out)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MGT_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rxcdr_stable)-1), convert(x.rxcdr_stable, y(left to left+len(x.rxcdr_stable)-1)));
      left := left + len(x.rxcdr_stable);
      assign(y(left to left+len(x.powergood)-1), convert(x.powergood, y(left to left+len(x.powergood)-1)));
      left := left + len(x.powergood);
      assign(y(left to left+len(x.txready)-1), convert(x.txready, y(left to left+len(x.txready)-1)));
      left := left + len(x.txready);
      assign(y(left to left+len(x.rxready)-1), convert(x.rxready, y(left to left+len(x.rxready)-1)));
      left := left + len(x.rxready);
      assign(y(left to left+len(x.rx_pma_reset_done)-1), convert(x.rx_pma_reset_done, y(left to left+len(x.rx_pma_reset_done)-1)));
      left := left + len(x.rx_pma_reset_done);
      assign(y(left to left+len(x.tx_pma_reset_done)-1), convert(x.tx_pma_reset_done, y(left to left+len(x.tx_pma_reset_done)-1)));
      left := left + len(x.tx_pma_reset_done);
      assign(y(left to left+len(x.tx_reset_done)-1), convert(x.tx_reset_done, y(left to left+len(x.tx_reset_done)-1)));
      left := left + len(x.tx_reset_done);
      assign(y(left to left+len(x.rx_reset_done)-1), convert(x.rx_reset_done, y(left to left+len(x.rx_reset_done)-1)));
      left := left + len(x.rx_reset_done);
      assign(y(left to left+len(x.buffbypass_tx_done_out)-1), convert(x.buffbypass_tx_done_out, y(left to left+len(x.buffbypass_tx_done_out)-1)));
      left := left + len(x.buffbypass_tx_done_out);
      assign(y(left to left+len(x.buffbypass_tx_error_out)-1), convert(x.buffbypass_tx_error_out, y(left to left+len(x.buffbypass_tx_error_out)-1)));
      left := left + len(x.buffbypass_tx_error_out);
      assign(y(left to left+len(x.buffbypass_rx_done_out)-1), convert(x.buffbypass_rx_done_out, y(left to left+len(x.buffbypass_rx_done_out)-1)));
      left := left + len(x.buffbypass_rx_done_out);
      assign(y(left to left+len(x.buffbypass_rx_error_out)-1), convert(x.buffbypass_rx_error_out, y(left to left+len(x.buffbypass_rx_error_out)-1)));
    else
      assign(y(left downto left-len(x.rxcdr_stable)+1), convert(x.rxcdr_stable, y(left downto left-len(x.rxcdr_stable)+1)));
      left := left - len(x.rxcdr_stable);
      assign(y(left downto left-len(x.powergood)+1), convert(x.powergood, y(left downto left-len(x.powergood)+1)));
      left := left - len(x.powergood);
      assign(y(left downto left-len(x.txready)+1), convert(x.txready, y(left downto left-len(x.txready)+1)));
      left := left - len(x.txready);
      assign(y(left downto left-len(x.rxready)+1), convert(x.rxready, y(left downto left-len(x.rxready)+1)));
      left := left - len(x.rxready);
      assign(y(left downto left-len(x.rx_pma_reset_done)+1), convert(x.rx_pma_reset_done, y(left downto left-len(x.rx_pma_reset_done)+1)));
      left := left - len(x.rx_pma_reset_done);
      assign(y(left downto left-len(x.tx_pma_reset_done)+1), convert(x.tx_pma_reset_done, y(left downto left-len(x.tx_pma_reset_done)+1)));
      left := left - len(x.tx_pma_reset_done);
      assign(y(left downto left-len(x.tx_reset_done)+1), convert(x.tx_reset_done, y(left downto left-len(x.tx_reset_done)+1)));
      left := left - len(x.tx_reset_done);
      assign(y(left downto left-len(x.rx_reset_done)+1), convert(x.rx_reset_done, y(left downto left-len(x.rx_reset_done)+1)));
      left := left - len(x.rx_reset_done);
      assign(y(left downto left-len(x.buffbypass_tx_done_out)+1), convert(x.buffbypass_tx_done_out, y(left downto left-len(x.buffbypass_tx_done_out)+1)));
      left := left - len(x.buffbypass_tx_done_out);
      assign(y(left downto left-len(x.buffbypass_tx_error_out)+1), convert(x.buffbypass_tx_error_out, y(left downto left-len(x.buffbypass_tx_error_out)+1)));
      left := left - len(x.buffbypass_tx_error_out);
      assign(y(left downto left-len(x.buffbypass_rx_done_out)+1), convert(x.buffbypass_rx_done_out, y(left downto left-len(x.buffbypass_rx_done_out)+1)));
      left := left - len(x.buffbypass_rx_done_out);
      assign(y(left downto left-len(x.buffbypass_rx_error_out)+1), convert(x.buffbypass_rx_error_out, y(left downto left-len(x.buffbypass_rx_error_out)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_STATUS_MON_t) return HAL_CORE_MGT_MGT_STATUS_MON_t is
    variable y: HAL_CORE_MGT_MGT_STATUS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rxcdr_stable := structify(x(left to left+len(y.rxcdr_stable)-1), y.rxcdr_stable);
      left := left + len(y.rxcdr_stable);
      y.powergood := structify(x(left to left+len(y.powergood)-1), y.powergood);
      left := left + len(y.powergood);
      y.txready := structify(x(left to left+len(y.txready)-1), y.txready);
      left := left + len(y.txready);
      y.rxready := structify(x(left to left+len(y.rxready)-1), y.rxready);
      left := left + len(y.rxready);
      y.rx_pma_reset_done := structify(x(left to left+len(y.rx_pma_reset_done)-1), y.rx_pma_reset_done);
      left := left + len(y.rx_pma_reset_done);
      y.tx_pma_reset_done := structify(x(left to left+len(y.tx_pma_reset_done)-1), y.tx_pma_reset_done);
      left := left + len(y.tx_pma_reset_done);
      y.tx_reset_done := structify(x(left to left+len(y.tx_reset_done)-1), y.tx_reset_done);
      left := left + len(y.tx_reset_done);
      y.rx_reset_done := structify(x(left to left+len(y.rx_reset_done)-1), y.rx_reset_done);
      left := left + len(y.rx_reset_done);
      y.buffbypass_tx_done_out := structify(x(left to left+len(y.buffbypass_tx_done_out)-1), y.buffbypass_tx_done_out);
      left := left + len(y.buffbypass_tx_done_out);
      y.buffbypass_tx_error_out := structify(x(left to left+len(y.buffbypass_tx_error_out)-1), y.buffbypass_tx_error_out);
      left := left + len(y.buffbypass_tx_error_out);
      y.buffbypass_rx_done_out := structify(x(left to left+len(y.buffbypass_rx_done_out)-1), y.buffbypass_rx_done_out);
      left := left + len(y.buffbypass_rx_done_out);
      y.buffbypass_rx_error_out := structify(x(left to left+len(y.buffbypass_rx_error_out)-1), y.buffbypass_rx_error_out);
    else
      y.rxcdr_stable := structify(x(left downto left-len(y.rxcdr_stable)+1), y.rxcdr_stable);
      left := left - len(y.rxcdr_stable);
      y.powergood := structify(x(left downto left-len(y.powergood)+1), y.powergood);
      left := left - len(y.powergood);
      y.txready := structify(x(left downto left-len(y.txready)+1), y.txready);
      left := left - len(y.txready);
      y.rxready := structify(x(left downto left-len(y.rxready)+1), y.rxready);
      left := left - len(y.rxready);
      y.rx_pma_reset_done := structify(x(left downto left-len(y.rx_pma_reset_done)+1), y.rx_pma_reset_done);
      left := left - len(y.rx_pma_reset_done);
      y.tx_pma_reset_done := structify(x(left downto left-len(y.tx_pma_reset_done)+1), y.tx_pma_reset_done);
      left := left - len(y.tx_pma_reset_done);
      y.tx_reset_done := structify(x(left downto left-len(y.tx_reset_done)+1), y.tx_reset_done);
      left := left - len(y.tx_reset_done);
      y.rx_reset_done := structify(x(left downto left-len(y.rx_reset_done)+1), y.rx_reset_done);
      left := left - len(y.rx_reset_done);
      y.buffbypass_tx_done_out := structify(x(left downto left-len(y.buffbypass_tx_done_out)+1), y.buffbypass_tx_done_out);
      left := left - len(y.buffbypass_tx_done_out);
      y.buffbypass_tx_error_out := structify(x(left downto left-len(y.buffbypass_tx_error_out)+1), y.buffbypass_tx_error_out);
      left := left - len(y.buffbypass_tx_error_out);
      y.buffbypass_rx_done_out := structify(x(left downto left-len(y.buffbypass_rx_done_out)+1), y.buffbypass_rx_done_out);
      left := left - len(y.buffbypass_rx_done_out);
      y.buffbypass_rx_error_out := structify(x(left downto left-len(y.buffbypass_rx_error_out)+1), y.buffbypass_rx_error_out);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_STATUS_MON_t) return HAL_CORE_MGT_MGT_STATUS_MON_t is
    variable y: HAL_CORE_MGT_MGT_STATUS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rxcdr_stable := convert(x(left to left+len(y.rxcdr_stable)-1), y.rxcdr_stable);
      left := left + len(y.rxcdr_stable);
      y.powergood := convert(x(left to left+len(y.powergood)-1), y.powergood);
      left := left + len(y.powergood);
      y.txready := convert(x(left to left+len(y.txready)-1), y.txready);
      left := left + len(y.txready);
      y.rxready := convert(x(left to left+len(y.rxready)-1), y.rxready);
      left := left + len(y.rxready);
      y.rx_pma_reset_done := convert(x(left to left+len(y.rx_pma_reset_done)-1), y.rx_pma_reset_done);
      left := left + len(y.rx_pma_reset_done);
      y.tx_pma_reset_done := convert(x(left to left+len(y.tx_pma_reset_done)-1), y.tx_pma_reset_done);
      left := left + len(y.tx_pma_reset_done);
      y.tx_reset_done := convert(x(left to left+len(y.tx_reset_done)-1), y.tx_reset_done);
      left := left + len(y.tx_reset_done);
      y.rx_reset_done := convert(x(left to left+len(y.rx_reset_done)-1), y.rx_reset_done);
      left := left + len(y.rx_reset_done);
      y.buffbypass_tx_done_out := convert(x(left to left+len(y.buffbypass_tx_done_out)-1), y.buffbypass_tx_done_out);
      left := left + len(y.buffbypass_tx_done_out);
      y.buffbypass_tx_error_out := convert(x(left to left+len(y.buffbypass_tx_error_out)-1), y.buffbypass_tx_error_out);
      left := left + len(y.buffbypass_tx_error_out);
      y.buffbypass_rx_done_out := convert(x(left to left+len(y.buffbypass_rx_done_out)-1), y.buffbypass_rx_done_out);
      left := left + len(y.buffbypass_rx_done_out);
      y.buffbypass_rx_error_out := convert(x(left to left+len(y.buffbypass_rx_error_out)-1), y.buffbypass_rx_error_out);
    else
      y.rxcdr_stable := convert(x(left downto left-len(y.rxcdr_stable)+1), y.rxcdr_stable);
      left := left - len(y.rxcdr_stable);
      y.powergood := convert(x(left downto left-len(y.powergood)+1), y.powergood);
      left := left - len(y.powergood);
      y.txready := convert(x(left downto left-len(y.txready)+1), y.txready);
      left := left - len(y.txready);
      y.rxready := convert(x(left downto left-len(y.rxready)+1), y.rxready);
      left := left - len(y.rxready);
      y.rx_pma_reset_done := convert(x(left downto left-len(y.rx_pma_reset_done)+1), y.rx_pma_reset_done);
      left := left - len(y.rx_pma_reset_done);
      y.tx_pma_reset_done := convert(x(left downto left-len(y.tx_pma_reset_done)+1), y.tx_pma_reset_done);
      left := left - len(y.tx_pma_reset_done);
      y.tx_reset_done := convert(x(left downto left-len(y.tx_reset_done)+1), y.tx_reset_done);
      left := left - len(y.tx_reset_done);
      y.rx_reset_done := convert(x(left downto left-len(y.rx_reset_done)+1), y.rx_reset_done);
      left := left - len(y.rx_reset_done);
      y.buffbypass_tx_done_out := convert(x(left downto left-len(y.buffbypass_tx_done_out)+1), y.buffbypass_tx_done_out);
      left := left - len(y.buffbypass_tx_done_out);
      y.buffbypass_tx_error_out := convert(x(left downto left-len(y.buffbypass_tx_error_out)+1), y.buffbypass_tx_error_out);
      left := left - len(y.buffbypass_tx_error_out);
      y.buffbypass_rx_done_out := convert(x(left downto left-len(y.buffbypass_rx_done_out)+1), y.buffbypass_rx_done_out);
      left := left - len(y.buffbypass_rx_done_out);
      y.buffbypass_rx_error_out := convert(x(left downto left-len(y.buffbypass_rx_error_out)+1), y.buffbypass_rx_error_out);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MGT_MGT_STATUS_MON_t) return HAL_CORE_MGT_MGT_STATUS_MON_t is
  variable y: HAL_CORE_MGT_MGT_STATUS_MON_t;
  begin
    y.rxcdr_stable := nullify(t.rxcdr_stable);
    y.powergood := nullify(t.powergood);
    y.txready := nullify(t.txready);
    y.rxready := nullify(t.rxready);
    y.rx_pma_reset_done := nullify(t.rx_pma_reset_done);
    y.tx_pma_reset_done := nullify(t.tx_pma_reset_done);
    y.tx_reset_done := nullify(t.tx_reset_done);
    y.rx_reset_done := nullify(t.rx_reset_done);
    y.buffbypass_tx_done_out := nullify(t.buffbypass_tx_done_out);
    y.buffbypass_tx_error_out := nullify(t.buffbypass_tx_error_out);
    y.buffbypass_rx_done_out := nullify(t.buffbypass_rx_done_out);
    y.buffbypass_rx_error_out := nullify(t.buffbypass_rx_error_out);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MGT_MGT_STATUS_MON_t) return HAL_CORE_MGT_MGT_STATUS_MON_t is
  variable y: HAL_CORE_MGT_MGT_STATUS_MON_t;
  begin
    y.rxcdr_stable := zeroed(t.rxcdr_stable);
    y.powergood := zeroed(t.powergood);
    y.txready := zeroed(t.txready);
    y.rxready := zeroed(t.rxready);
    y.rx_pma_reset_done := zeroed(t.rx_pma_reset_done);
    y.tx_pma_reset_done := zeroed(t.tx_pma_reset_done);
    y.tx_reset_done := zeroed(t.tx_reset_done);
    y.rx_reset_done := zeroed(t.rx_reset_done);
    y.buffbypass_tx_done_out := zeroed(t.buffbypass_tx_done_out);
    y.buffbypass_tx_error_out := zeroed(t.buffbypass_tx_error_out);
    y.buffbypass_rx_done_out := zeroed(t.buffbypass_rx_done_out);
    y.buffbypass_rx_error_out := zeroed(t.buffbypass_rx_error_out);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MGT_DRP_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_rdy);
    l := l + len(x.rd_data);
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MGT_DRP_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_rdy);
    l := l + width(x.rd_data);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MGT_DRP_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), vectorify(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), vectorify(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MGT_DRP_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), convert(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.rd_data)-1), convert(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), convert(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.rd_data)+1), convert(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_DRP_MON_t) return HAL_CORE_MGT_MGT_DRP_MON_t is
    variable y: HAL_CORE_MGT_MGT_DRP_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := structify(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.rd_rdy := structify(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_DRP_MON_t) return HAL_CORE_MGT_MGT_DRP_MON_t is
    variable y: HAL_CORE_MGT_MGT_DRP_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := convert(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.rd_data := convert(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.rd_rdy := convert(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.rd_data := convert(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MGT_MGT_DRP_MON_t) return HAL_CORE_MGT_MGT_DRP_MON_t is
  variable y: HAL_CORE_MGT_MGT_DRP_MON_t;
  begin
    y.rd_rdy := nullify(t.rd_rdy);
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MGT_MGT_DRP_MON_t) return HAL_CORE_MGT_MGT_DRP_MON_t is
  variable y: HAL_CORE_MGT_MGT_DRP_MON_t;
  begin
    y.rd_rdy := zeroed(t.rd_rdy);
    y.rd_data := zeroed(t.rd_data);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MGT_DRP_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_en);
    l := l + len(x.wr_addr);
    l := l + len(x.en);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MGT_DRP_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_en);
    l := l + width(x.wr_addr);
    l := l + width(x.en);
    l := l + width(x.wr_data);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MGT_DRP_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_en)-1), vectorify(x.wr_en, y(left to left+len(x.wr_en)-1)));
      left := left + len(x.wr_en);
      assign(y(left to left+len(x.wr_addr)-1), vectorify(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.en)-1), vectorify(x.en, y(left to left+len(x.en)-1)));
      left := left + len(x.en);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.wr_en)+1), vectorify(x.wr_en, y(left downto left-len(x.wr_en)+1)));
      left := left - len(x.wr_en);
      assign(y(left downto left-len(x.wr_addr)+1), vectorify(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.en)+1), vectorify(x.en, y(left downto left-len(x.en)+1)));
      left := left - len(x.en);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MGT_DRP_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_en)-1), convert(x.wr_en, y(left to left+len(x.wr_en)-1)));
      left := left + len(x.wr_en);
      assign(y(left to left+len(x.wr_addr)-1), convert(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.en)-1), convert(x.en, y(left to left+len(x.en)-1)));
      left := left + len(x.en);
      assign(y(left to left+len(x.wr_data)-1), convert(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.wr_en)+1), convert(x.wr_en, y(left downto left-len(x.wr_en)+1)));
      left := left - len(x.wr_en);
      assign(y(left downto left-len(x.wr_addr)+1), convert(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.en)+1), convert(x.en, y(left downto left-len(x.en)+1)));
      left := left - len(x.en);
      assign(y(left downto left-len(x.wr_data)+1), convert(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_DRP_CTRL_t) return HAL_CORE_MGT_MGT_DRP_CTRL_t is
    variable y: HAL_CORE_MGT_MGT_DRP_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_en := structify(x(left to left+len(y.wr_en)-1), y.wr_en);
      left := left + len(y.wr_en);
      y.wr_addr := structify(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.en := structify(x(left to left+len(y.en)-1), y.en);
      left := left + len(y.en);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.wr_en := structify(x(left downto left-len(y.wr_en)+1), y.wr_en);
      left := left - len(y.wr_en);
      y.wr_addr := structify(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.en := structify(x(left downto left-len(y.en)+1), y.en);
      left := left - len(y.en);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_DRP_CTRL_t) return HAL_CORE_MGT_MGT_DRP_CTRL_t is
    variable y: HAL_CORE_MGT_MGT_DRP_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_en := convert(x(left to left+len(y.wr_en)-1), y.wr_en);
      left := left + len(y.wr_en);
      y.wr_addr := convert(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.en := convert(x(left to left+len(y.en)-1), y.en);
      left := left + len(y.en);
      y.wr_data := convert(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.wr_en := convert(x(left downto left-len(y.wr_en)+1), y.wr_en);
      left := left - len(y.wr_en);
      y.wr_addr := convert(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.en := convert(x(left downto left-len(y.en)+1), y.en);
      left := left - len(y.en);
      y.wr_data := convert(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MGT_MGT_DRP_CTRL_t) return HAL_CORE_MGT_MGT_DRP_CTRL_t is
  variable y: HAL_CORE_MGT_MGT_DRP_CTRL_t;
  begin
    y.wr_en := nullify(t.wr_en);
    y.wr_addr := nullify(t.wr_addr);
    y.en := nullify(t.en);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MGT_MGT_DRP_CTRL_t) return HAL_CORE_MGT_MGT_DRP_CTRL_t is
  variable y: HAL_CORE_MGT_MGT_DRP_CTRL_t;
  begin
    y.wr_en := zeroed(t.wr_en);
    y.wr_addr := zeroed(t.wr_addr);
    y.en := zeroed(t.en);
    y.wr_data := zeroed(t.wr_data);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.reset);
    l := l + len(x.reset_pll_and_datapath);
    l := l + len(x.reset_datapath);
    l := l + len(x.reset_bufbypass);
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.reset);
    l := l + width(x.reset_pll_and_datapath);
    l := l + width(x.reset_datapath);
    l := l + width(x.reset_bufbypass);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.reset)-1), vectorify(x.reset, y(left to left+len(x.reset)-1)));
      left := left + len(x.reset);
      assign(y(left to left+len(x.reset_pll_and_datapath)-1), vectorify(x.reset_pll_and_datapath, y(left to left+len(x.reset_pll_and_datapath)-1)));
      left := left + len(x.reset_pll_and_datapath);
      assign(y(left to left+len(x.reset_datapath)-1), vectorify(x.reset_datapath, y(left to left+len(x.reset_datapath)-1)));
      left := left + len(x.reset_datapath);
      assign(y(left to left+len(x.reset_bufbypass)-1), vectorify(x.reset_bufbypass, y(left to left+len(x.reset_bufbypass)-1)));
    else
      assign(y(left downto left-len(x.reset)+1), vectorify(x.reset, y(left downto left-len(x.reset)+1)));
      left := left - len(x.reset);
      assign(y(left downto left-len(x.reset_pll_and_datapath)+1), vectorify(x.reset_pll_and_datapath, y(left downto left-len(x.reset_pll_and_datapath)+1)));
      left := left - len(x.reset_pll_and_datapath);
      assign(y(left downto left-len(x.reset_datapath)+1), vectorify(x.reset_datapath, y(left downto left-len(x.reset_datapath)+1)));
      left := left - len(x.reset_datapath);
      assign(y(left downto left-len(x.reset_bufbypass)+1), vectorify(x.reset_bufbypass, y(left downto left-len(x.reset_bufbypass)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.reset)-1), convert(x.reset, y(left to left+len(x.reset)-1)));
      left := left + len(x.reset);
      assign(y(left to left+len(x.reset_pll_and_datapath)-1), convert(x.reset_pll_and_datapath, y(left to left+len(x.reset_pll_and_datapath)-1)));
      left := left + len(x.reset_pll_and_datapath);
      assign(y(left to left+len(x.reset_datapath)-1), convert(x.reset_datapath, y(left to left+len(x.reset_datapath)-1)));
      left := left + len(x.reset_datapath);
      assign(y(left to left+len(x.reset_bufbypass)-1), convert(x.reset_bufbypass, y(left to left+len(x.reset_bufbypass)-1)));
    else
      assign(y(left downto left-len(x.reset)+1), convert(x.reset, y(left downto left-len(x.reset)+1)));
      left := left - len(x.reset);
      assign(y(left downto left-len(x.reset_pll_and_datapath)+1), convert(x.reset_pll_and_datapath, y(left downto left-len(x.reset_pll_and_datapath)+1)));
      left := left - len(x.reset_pll_and_datapath);
      assign(y(left downto left-len(x.reset_datapath)+1), convert(x.reset_datapath, y(left downto left-len(x.reset_datapath)+1)));
      left := left - len(x.reset_datapath);
      assign(y(left downto left-len(x.reset_bufbypass)+1), convert(x.reset_bufbypass, y(left downto left-len(x.reset_bufbypass)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t is
    variable y: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.reset := structify(x(left to left+len(y.reset)-1), y.reset);
      left := left + len(y.reset);
      y.reset_pll_and_datapath := structify(x(left to left+len(y.reset_pll_and_datapath)-1), y.reset_pll_and_datapath);
      left := left + len(y.reset_pll_and_datapath);
      y.reset_datapath := structify(x(left to left+len(y.reset_datapath)-1), y.reset_datapath);
      left := left + len(y.reset_datapath);
      y.reset_bufbypass := structify(x(left to left+len(y.reset_bufbypass)-1), y.reset_bufbypass);
    else
      y.reset := structify(x(left downto left-len(y.reset)+1), y.reset);
      left := left - len(y.reset);
      y.reset_pll_and_datapath := structify(x(left downto left-len(y.reset_pll_and_datapath)+1), y.reset_pll_and_datapath);
      left := left - len(y.reset_pll_and_datapath);
      y.reset_datapath := structify(x(left downto left-len(y.reset_datapath)+1), y.reset_datapath);
      left := left - len(y.reset_datapath);
      y.reset_bufbypass := structify(x(left downto left-len(y.reset_bufbypass)+1), y.reset_bufbypass);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t is
    variable y: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.reset := convert(x(left to left+len(y.reset)-1), y.reset);
      left := left + len(y.reset);
      y.reset_pll_and_datapath := convert(x(left to left+len(y.reset_pll_and_datapath)-1), y.reset_pll_and_datapath);
      left := left + len(y.reset_pll_and_datapath);
      y.reset_datapath := convert(x(left to left+len(y.reset_datapath)-1), y.reset_datapath);
      left := left + len(y.reset_datapath);
      y.reset_bufbypass := convert(x(left to left+len(y.reset_bufbypass)-1), y.reset_bufbypass);
    else
      y.reset := convert(x(left downto left-len(y.reset)+1), y.reset);
      left := left - len(y.reset);
      y.reset_pll_and_datapath := convert(x(left downto left-len(y.reset_pll_and_datapath)+1), y.reset_pll_and_datapath);
      left := left - len(y.reset_pll_and_datapath);
      y.reset_datapath := convert(x(left downto left-len(y.reset_datapath)+1), y.reset_datapath);
      left := left - len(y.reset_datapath);
      y.reset_bufbypass := convert(x(left downto left-len(y.reset_bufbypass)+1), y.reset_bufbypass);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t is
  variable y: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;
  begin
    y.reset := nullify(t.reset);
    y.reset_pll_and_datapath := nullify(t.reset_pll_and_datapath);
    y.reset_datapath := nullify(t.reset_datapath);
    y.reset_bufbypass := nullify(t.reset_bufbypass);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t is
  variable y: HAL_CORE_MGT_MGT_TX_RESETS_CTRL_t;
  begin
    y.reset := zeroed(t.reset);
    y.reset_pll_and_datapath := zeroed(t.reset_pll_and_datapath);
    y.reset_datapath := zeroed(t.reset_datapath);
    y.reset_bufbypass := zeroed(t.reset_bufbypass);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.reset);
    l := l + len(x.reset_pll_and_datapath);
    l := l + len(x.reset_datapath);
    l := l + len(x.reset_bufbypass);
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.reset);
    l := l + width(x.reset_pll_and_datapath);
    l := l + width(x.reset_datapath);
    l := l + width(x.reset_bufbypass);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.reset)-1), vectorify(x.reset, y(left to left+len(x.reset)-1)));
      left := left + len(x.reset);
      assign(y(left to left+len(x.reset_pll_and_datapath)-1), vectorify(x.reset_pll_and_datapath, y(left to left+len(x.reset_pll_and_datapath)-1)));
      left := left + len(x.reset_pll_and_datapath);
      assign(y(left to left+len(x.reset_datapath)-1), vectorify(x.reset_datapath, y(left to left+len(x.reset_datapath)-1)));
      left := left + len(x.reset_datapath);
      assign(y(left to left+len(x.reset_bufbypass)-1), vectorify(x.reset_bufbypass, y(left to left+len(x.reset_bufbypass)-1)));
    else
      assign(y(left downto left-len(x.reset)+1), vectorify(x.reset, y(left downto left-len(x.reset)+1)));
      left := left - len(x.reset);
      assign(y(left downto left-len(x.reset_pll_and_datapath)+1), vectorify(x.reset_pll_and_datapath, y(left downto left-len(x.reset_pll_and_datapath)+1)));
      left := left - len(x.reset_pll_and_datapath);
      assign(y(left downto left-len(x.reset_datapath)+1), vectorify(x.reset_datapath, y(left downto left-len(x.reset_datapath)+1)));
      left := left - len(x.reset_datapath);
      assign(y(left downto left-len(x.reset_bufbypass)+1), vectorify(x.reset_bufbypass, y(left downto left-len(x.reset_bufbypass)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.reset)-1), convert(x.reset, y(left to left+len(x.reset)-1)));
      left := left + len(x.reset);
      assign(y(left to left+len(x.reset_pll_and_datapath)-1), convert(x.reset_pll_and_datapath, y(left to left+len(x.reset_pll_and_datapath)-1)));
      left := left + len(x.reset_pll_and_datapath);
      assign(y(left to left+len(x.reset_datapath)-1), convert(x.reset_datapath, y(left to left+len(x.reset_datapath)-1)));
      left := left + len(x.reset_datapath);
      assign(y(left to left+len(x.reset_bufbypass)-1), convert(x.reset_bufbypass, y(left to left+len(x.reset_bufbypass)-1)));
    else
      assign(y(left downto left-len(x.reset)+1), convert(x.reset, y(left downto left-len(x.reset)+1)));
      left := left - len(x.reset);
      assign(y(left downto left-len(x.reset_pll_and_datapath)+1), convert(x.reset_pll_and_datapath, y(left downto left-len(x.reset_pll_and_datapath)+1)));
      left := left - len(x.reset_pll_and_datapath);
      assign(y(left downto left-len(x.reset_datapath)+1), convert(x.reset_datapath, y(left downto left-len(x.reset_datapath)+1)));
      left := left - len(x.reset_datapath);
      assign(y(left downto left-len(x.reset_bufbypass)+1), convert(x.reset_bufbypass, y(left downto left-len(x.reset_bufbypass)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t is
    variable y: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.reset := structify(x(left to left+len(y.reset)-1), y.reset);
      left := left + len(y.reset);
      y.reset_pll_and_datapath := structify(x(left to left+len(y.reset_pll_and_datapath)-1), y.reset_pll_and_datapath);
      left := left + len(y.reset_pll_and_datapath);
      y.reset_datapath := structify(x(left to left+len(y.reset_datapath)-1), y.reset_datapath);
      left := left + len(y.reset_datapath);
      y.reset_bufbypass := structify(x(left to left+len(y.reset_bufbypass)-1), y.reset_bufbypass);
    else
      y.reset := structify(x(left downto left-len(y.reset)+1), y.reset);
      left := left - len(y.reset);
      y.reset_pll_and_datapath := structify(x(left downto left-len(y.reset_pll_and_datapath)+1), y.reset_pll_and_datapath);
      left := left - len(y.reset_pll_and_datapath);
      y.reset_datapath := structify(x(left downto left-len(y.reset_datapath)+1), y.reset_datapath);
      left := left - len(y.reset_datapath);
      y.reset_bufbypass := structify(x(left downto left-len(y.reset_bufbypass)+1), y.reset_bufbypass);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t is
    variable y: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.reset := convert(x(left to left+len(y.reset)-1), y.reset);
      left := left + len(y.reset);
      y.reset_pll_and_datapath := convert(x(left to left+len(y.reset_pll_and_datapath)-1), y.reset_pll_and_datapath);
      left := left + len(y.reset_pll_and_datapath);
      y.reset_datapath := convert(x(left to left+len(y.reset_datapath)-1), y.reset_datapath);
      left := left + len(y.reset_datapath);
      y.reset_bufbypass := convert(x(left to left+len(y.reset_bufbypass)-1), y.reset_bufbypass);
    else
      y.reset := convert(x(left downto left-len(y.reset)+1), y.reset);
      left := left - len(y.reset);
      y.reset_pll_and_datapath := convert(x(left downto left-len(y.reset_pll_and_datapath)+1), y.reset_pll_and_datapath);
      left := left - len(y.reset_pll_and_datapath);
      y.reset_datapath := convert(x(left downto left-len(y.reset_datapath)+1), y.reset_datapath);
      left := left - len(y.reset_datapath);
      y.reset_bufbypass := convert(x(left downto left-len(y.reset_bufbypass)+1), y.reset_bufbypass);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t is
  variable y: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;
  begin
    y.reset := nullify(t.reset);
    y.reset_pll_and_datapath := nullify(t.reset_pll_and_datapath);
    y.reset_datapath := nullify(t.reset_datapath);
    y.reset_bufbypass := nullify(t.reset_bufbypass);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t) return HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t is
  variable y: HAL_CORE_MGT_MGT_RX_RESETS_CTRL_t;
  begin
    y.reset := zeroed(t.reset);
    y.reset_pll_and_datapath := zeroed(t.reset_pll_and_datapath);
    y.reset_datapath := zeroed(t.reset_datapath);
    y.reset_bufbypass := zeroed(t.reset_bufbypass);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MGT_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.STATUS);
    l := l + len(x.DRP);
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MGT_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.STATUS);
    l := l + width(x.DRP);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MGT_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), vectorify(x.STATUS, y(left to left+len(x.STATUS)-1)));
      left := left + len(x.STATUS);
      assign(y(left to left+len(x.DRP)-1), vectorify(x.DRP, y(left to left+len(x.DRP)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), vectorify(x.STATUS, y(left downto left-len(x.STATUS)+1)));
      left := left - len(x.STATUS);
      assign(y(left downto left-len(x.DRP)+1), vectorify(x.DRP, y(left downto left-len(x.DRP)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MGT_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), convert(x.STATUS, y(left to left+len(x.STATUS)-1)));
      left := left + len(x.STATUS);
      assign(y(left to left+len(x.DRP)-1), convert(x.DRP, y(left to left+len(x.DRP)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), convert(x.STATUS, y(left downto left-len(x.STATUS)+1)));
      left := left - len(x.STATUS);
      assign(y(left downto left-len(x.DRP)+1), convert(x.DRP, y(left downto left-len(x.DRP)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_MON_t) return HAL_CORE_MGT_MGT_MON_t is
    variable y: HAL_CORE_MGT_MGT_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := structify(x(left to left+len(y.STATUS)-1), y.STATUS);
      left := left + len(y.STATUS);
      y.DRP := structify(x(left to left+len(y.DRP)-1), y.DRP);
    else
      y.STATUS := structify(x(left downto left-len(y.STATUS)+1), y.STATUS);
      left := left - len(y.STATUS);
      y.DRP := structify(x(left downto left-len(y.DRP)+1), y.DRP);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_MON_t) return HAL_CORE_MGT_MGT_MON_t is
    variable y: HAL_CORE_MGT_MGT_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := convert(x(left to left+len(y.STATUS)-1), y.STATUS);
      left := left + len(y.STATUS);
      y.DRP := convert(x(left to left+len(y.DRP)-1), y.DRP);
    else
      y.STATUS := convert(x(left downto left-len(y.STATUS)+1), y.STATUS);
      left := left - len(y.STATUS);
      y.DRP := convert(x(left downto left-len(y.DRP)+1), y.DRP);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MGT_MGT_MON_t) return HAL_CORE_MGT_MGT_MON_t is
  variable y: HAL_CORE_MGT_MGT_MON_t;
  begin
    y.STATUS := nullify(t.STATUS);
    y.DRP := nullify(t.DRP);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MGT_MGT_MON_t) return HAL_CORE_MGT_MGT_MON_t is
  variable y: HAL_CORE_MGT_MGT_MON_t;
  begin
    y.STATUS := zeroed(t.STATUS);
    y.DRP := zeroed(t.DRP);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MGT_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MGT_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MGT_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MGT_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HAL_CORE_MGT_MGT_MON_t_ARRAY) return HAL_CORE_MGT_MGT_MON_t_ARRAY is
    variable y : HAL_CORE_MGT_MGT_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HAL_CORE_MGT_MGT_MON_t_ARRAY) return HAL_CORE_MGT_MGT_MON_t_ARRAY is
    variable y : HAL_CORE_MGT_MGT_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HAL_CORE_MGT_MGT_MON_t_ARRAY) return HAL_CORE_MGT_MGT_MON_t_ARRAY is
    variable y : HAL_CORE_MGT_MGT_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HAL_CORE_MGT_MGT_MON_t_ARRAY) return HAL_CORE_MGT_MGT_MON_t_ARRAY is
    variable y : HAL_CORE_MGT_MGT_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MGT_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.DRP);
    l := l + len(x.TX_RESETS);
    l := l + len(x.RX_RESETS);
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MGT_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.DRP);
    l := l + width(x.TX_RESETS);
    l := l + width(x.RX_RESETS);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MGT_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.DRP)-1), vectorify(x.DRP, y(left to left+len(x.DRP)-1)));
      left := left + len(x.DRP);
      assign(y(left to left+len(x.TX_RESETS)-1), vectorify(x.TX_RESETS, y(left to left+len(x.TX_RESETS)-1)));
      left := left + len(x.TX_RESETS);
      assign(y(left to left+len(x.RX_RESETS)-1), vectorify(x.RX_RESETS, y(left to left+len(x.RX_RESETS)-1)));
    else
      assign(y(left downto left-len(x.DRP)+1), vectorify(x.DRP, y(left downto left-len(x.DRP)+1)));
      left := left - len(x.DRP);
      assign(y(left downto left-len(x.TX_RESETS)+1), vectorify(x.TX_RESETS, y(left downto left-len(x.TX_RESETS)+1)));
      left := left - len(x.TX_RESETS);
      assign(y(left downto left-len(x.RX_RESETS)+1), vectorify(x.RX_RESETS, y(left downto left-len(x.RX_RESETS)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MGT_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.DRP)-1), convert(x.DRP, y(left to left+len(x.DRP)-1)));
      left := left + len(x.DRP);
      assign(y(left to left+len(x.TX_RESETS)-1), convert(x.TX_RESETS, y(left to left+len(x.TX_RESETS)-1)));
      left := left + len(x.TX_RESETS);
      assign(y(left to left+len(x.RX_RESETS)-1), convert(x.RX_RESETS, y(left to left+len(x.RX_RESETS)-1)));
    else
      assign(y(left downto left-len(x.DRP)+1), convert(x.DRP, y(left downto left-len(x.DRP)+1)));
      left := left - len(x.DRP);
      assign(y(left downto left-len(x.TX_RESETS)+1), convert(x.TX_RESETS, y(left downto left-len(x.TX_RESETS)+1)));
      left := left - len(x.TX_RESETS);
      assign(y(left downto left-len(x.RX_RESETS)+1), convert(x.RX_RESETS, y(left downto left-len(x.RX_RESETS)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_CTRL_t) return HAL_CORE_MGT_MGT_CTRL_t is
    variable y: HAL_CORE_MGT_MGT_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.DRP := structify(x(left to left+len(y.DRP)-1), y.DRP);
      left := left + len(y.DRP);
      y.TX_RESETS := structify(x(left to left+len(y.TX_RESETS)-1), y.TX_RESETS);
      left := left + len(y.TX_RESETS);
      y.RX_RESETS := structify(x(left to left+len(y.RX_RESETS)-1), y.RX_RESETS);
    else
      y.DRP := structify(x(left downto left-len(y.DRP)+1), y.DRP);
      left := left - len(y.DRP);
      y.TX_RESETS := structify(x(left downto left-len(y.TX_RESETS)+1), y.TX_RESETS);
      left := left - len(y.TX_RESETS);
      y.RX_RESETS := structify(x(left downto left-len(y.RX_RESETS)+1), y.RX_RESETS);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MGT_CTRL_t) return HAL_CORE_MGT_MGT_CTRL_t is
    variable y: HAL_CORE_MGT_MGT_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.DRP := convert(x(left to left+len(y.DRP)-1), y.DRP);
      left := left + len(y.DRP);
      y.TX_RESETS := convert(x(left to left+len(y.TX_RESETS)-1), y.TX_RESETS);
      left := left + len(y.TX_RESETS);
      y.RX_RESETS := convert(x(left to left+len(y.RX_RESETS)-1), y.RX_RESETS);
    else
      y.DRP := convert(x(left downto left-len(y.DRP)+1), y.DRP);
      left := left - len(y.DRP);
      y.TX_RESETS := convert(x(left downto left-len(y.TX_RESETS)+1), y.TX_RESETS);
      left := left - len(y.TX_RESETS);
      y.RX_RESETS := convert(x(left downto left-len(y.RX_RESETS)+1), y.RX_RESETS);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MGT_MGT_CTRL_t) return HAL_CORE_MGT_MGT_CTRL_t is
  variable y: HAL_CORE_MGT_MGT_CTRL_t;
  begin
    y.DRP := nullify(t.DRP);
    y.TX_RESETS := nullify(t.TX_RESETS);
    y.RX_RESETS := nullify(t.RX_RESETS);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MGT_MGT_CTRL_t) return HAL_CORE_MGT_MGT_CTRL_t is
  variable y: HAL_CORE_MGT_MGT_CTRL_t;
  begin
    y.DRP := zeroed(t.DRP);
    y.TX_RESETS := zeroed(t.TX_RESETS);
    y.RX_RESETS := zeroed(t.RX_RESETS);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return HAL_CORE_MGT_MGT_CTRL_t_ARRAY is
    variable y : HAL_CORE_MGT_MGT_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return HAL_CORE_MGT_MGT_CTRL_t_ARRAY is
    variable y : HAL_CORE_MGT_MGT_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return HAL_CORE_MGT_MGT_CTRL_t_ARRAY is
    variable y : HAL_CORE_MGT_MGT_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HAL_CORE_MGT_MGT_CTRL_t_ARRAY) return HAL_CORE_MGT_MGT_CTRL_t_ARRAY is
    variable y : HAL_CORE_MGT_MGT_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MGT);
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.MGT);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MGT)-1), vectorify(x.MGT, y(left to left+len(x.MGT)-1)));
    else
      assign(y(left downto left-len(x.MGT)+1), vectorify(x.MGT, y(left downto left-len(x.MGT)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MGT)-1), convert(x.MGT, y(left to left+len(x.MGT)-1)));
    else
      assign(y(left downto left-len(x.MGT)+1), convert(x.MGT, y(left downto left-len(x.MGT)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_MON_t) return HAL_CORE_MGT_MON_t is
    variable y: HAL_CORE_MGT_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MGT := structify(x(left to left+len(y.MGT)-1), y.MGT);
    else
      y.MGT := structify(x(left downto left-len(y.MGT)+1), y.MGT);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_MON_t) return HAL_CORE_MGT_MON_t is
    variable y: HAL_CORE_MGT_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MGT := convert(x(left to left+len(y.MGT)-1), y.MGT);
    else
      y.MGT := convert(x(left downto left-len(y.MGT)+1), y.MGT);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MGT_MON_t) return HAL_CORE_MGT_MON_t is
  variable y: HAL_CORE_MGT_MON_t;
  begin
    y.MGT := nullify(t.MGT);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MGT_MON_t) return HAL_CORE_MGT_MON_t is
  variable y: HAL_CORE_MGT_MON_t;
  begin
    y.MGT := zeroed(t.MGT);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MGT_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MGT);
    return l;
  end function len;
  function width(x: HAL_CORE_MGT_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.MGT);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MGT_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MGT)-1), vectorify(x.MGT, y(left to left+len(x.MGT)-1)));
    else
      assign(y(left downto left-len(x.MGT)+1), vectorify(x.MGT, y(left downto left-len(x.MGT)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MGT_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MGT)-1), convert(x.MGT, y(left to left+len(x.MGT)-1)));
    else
      assign(y(left downto left-len(x.MGT)+1), convert(x.MGT, y(left downto left-len(x.MGT)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MGT_CTRL_t) return HAL_CORE_MGT_CTRL_t is
    variable y: HAL_CORE_MGT_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MGT := structify(x(left to left+len(y.MGT)-1), y.MGT);
    else
      y.MGT := structify(x(left downto left-len(y.MGT)+1), y.MGT);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MGT_CTRL_t) return HAL_CORE_MGT_CTRL_t is
    variable y: HAL_CORE_MGT_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MGT := convert(x(left to left+len(y.MGT)-1), y.MGT);
    else
      y.MGT := convert(x(left downto left-len(y.MGT)+1), y.MGT);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MGT_CTRL_t) return HAL_CORE_MGT_CTRL_t is
  variable y: HAL_CORE_MGT_CTRL_t;
  begin
    y.MGT := nullify(t.MGT);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MGT_CTRL_t) return HAL_CORE_MGT_CTRL_t is
  variable y: HAL_CORE_MGT_CTRL_t;
  begin
    y.MGT := zeroed(t.MGT);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.CLOCKING);
    l := l + len(x.MGT);
    return l;
  end function len;
  function width(x: HAL_CORE_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.CLOCKING);
    l := l + width(x.MGT);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CLOCKING)-1), vectorify(x.CLOCKING, y(left to left+len(x.CLOCKING)-1)));
      left := left + len(x.CLOCKING);
      assign(y(left to left+len(x.MGT)-1), vectorify(x.MGT, y(left to left+len(x.MGT)-1)));
    else
      assign(y(left downto left-len(x.CLOCKING)+1), vectorify(x.CLOCKING, y(left downto left-len(x.CLOCKING)+1)));
      left := left - len(x.CLOCKING);
      assign(y(left downto left-len(x.MGT)+1), vectorify(x.MGT, y(left downto left-len(x.MGT)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CLOCKING)-1), convert(x.CLOCKING, y(left to left+len(x.CLOCKING)-1)));
      left := left + len(x.CLOCKING);
      assign(y(left to left+len(x.MGT)-1), convert(x.MGT, y(left to left+len(x.MGT)-1)));
    else
      assign(y(left downto left-len(x.CLOCKING)+1), convert(x.CLOCKING, y(left downto left-len(x.CLOCKING)+1)));
      left := left - len(x.CLOCKING);
      assign(y(left downto left-len(x.MGT)+1), convert(x.MGT, y(left downto left-len(x.MGT)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_MON_t) return HAL_CORE_MON_t is
    variable y: HAL_CORE_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CLOCKING := structify(x(left to left+len(y.CLOCKING)-1), y.CLOCKING);
      left := left + len(y.CLOCKING);
      y.MGT := structify(x(left to left+len(y.MGT)-1), y.MGT);
    else
      y.CLOCKING := structify(x(left downto left-len(y.CLOCKING)+1), y.CLOCKING);
      left := left - len(y.CLOCKING);
      y.MGT := structify(x(left downto left-len(y.MGT)+1), y.MGT);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_MON_t) return HAL_CORE_MON_t is
    variable y: HAL_CORE_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CLOCKING := convert(x(left to left+len(y.CLOCKING)-1), y.CLOCKING);
      left := left + len(y.CLOCKING);
      y.MGT := convert(x(left to left+len(y.MGT)-1), y.MGT);
    else
      y.CLOCKING := convert(x(left downto left-len(y.CLOCKING)+1), y.CLOCKING);
      left := left - len(y.CLOCKING);
      y.MGT := convert(x(left downto left-len(y.MGT)+1), y.MGT);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_MON_t) return HAL_CORE_MON_t is
  variable y: HAL_CORE_MON_t;
  begin
    y.CLOCKING := nullify(t.CLOCKING);
    y.MGT := nullify(t.MGT);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_MON_t) return HAL_CORE_MON_t is
  variable y: HAL_CORE_MON_t;
  begin
    y.CLOCKING := zeroed(t.CLOCKING);
    y.MGT := zeroed(t.MGT);
    return y;
  end function zeroed;

  function len(x: HAL_CORE_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.CLOCKING);
    l := l + len(x.MGT);
    return l;
  end function len;
  function width(x: HAL_CORE_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.CLOCKING);
    l := l + width(x.MGT);
    return l;
  end function width;
  function vectorify(x: HAL_CORE_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CLOCKING)-1), vectorify(x.CLOCKING, y(left to left+len(x.CLOCKING)-1)));
      left := left + len(x.CLOCKING);
      assign(y(left to left+len(x.MGT)-1), vectorify(x.MGT, y(left to left+len(x.MGT)-1)));
    else
      assign(y(left downto left-len(x.CLOCKING)+1), vectorify(x.CLOCKING, y(left downto left-len(x.CLOCKING)+1)));
      left := left - len(x.CLOCKING);
      assign(y(left downto left-len(x.MGT)+1), vectorify(x.MGT, y(left downto left-len(x.MGT)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HAL_CORE_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CLOCKING)-1), convert(x.CLOCKING, y(left to left+len(x.CLOCKING)-1)));
      left := left + len(x.CLOCKING);
      assign(y(left to left+len(x.MGT)-1), convert(x.MGT, y(left to left+len(x.MGT)-1)));
    else
      assign(y(left downto left-len(x.CLOCKING)+1), convert(x.CLOCKING, y(left downto left-len(x.CLOCKING)+1)));
      left := left - len(x.CLOCKING);
      assign(y(left downto left-len(x.MGT)+1), convert(x.MGT, y(left downto left-len(x.MGT)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HAL_CORE_CTRL_t) return HAL_CORE_CTRL_t is
    variable y: HAL_CORE_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CLOCKING := structify(x(left to left+len(y.CLOCKING)-1), y.CLOCKING);
      left := left + len(y.CLOCKING);
      y.MGT := structify(x(left to left+len(y.MGT)-1), y.MGT);
    else
      y.CLOCKING := structify(x(left downto left-len(y.CLOCKING)+1), y.CLOCKING);
      left := left - len(y.CLOCKING);
      y.MGT := structify(x(left downto left-len(y.MGT)+1), y.MGT);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HAL_CORE_CTRL_t) return HAL_CORE_CTRL_t is
    variable y: HAL_CORE_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CLOCKING := convert(x(left to left+len(y.CLOCKING)-1), y.CLOCKING);
      left := left + len(y.CLOCKING);
      y.MGT := convert(x(left to left+len(y.MGT)-1), y.MGT);
    else
      y.CLOCKING := convert(x(left downto left-len(y.CLOCKING)+1), y.CLOCKING);
      left := left - len(y.CLOCKING);
      y.MGT := convert(x(left downto left-len(y.MGT)+1), y.MGT);
    end if;
    return y;
  end function convert;
  function nullify(t: HAL_CORE_CTRL_t) return HAL_CORE_CTRL_t is
  variable y: HAL_CORE_CTRL_t;
  begin
    y.CLOCKING := nullify(t.CLOCKING);
    y.MGT := nullify(t.MGT);
    return y;
  end function nullify;
  function zeroed(t: HAL_CORE_CTRL_t) return HAL_CORE_CTRL_t is
  variable y: HAL_CORE_CTRL_t;
  begin
    y.CLOCKING := zeroed(t.CLOCKING);
    y.MGT := zeroed(t.MGT);
    return y;
  end function zeroed;

end package body HAL_CORE_CTRL;
