-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package C2C_INTF_CTRL is

   -- Custom types and functions --

   type C2C_INTF_DRP_MOSI_t is record
      clk : std_logic;
      enable : std_logic;
      wr_enable : std_logic;
      address : std_logic_vector(10 -1 downto 0);
      wr_data : std_logic_vector(16 -1 downto 0);
   end record C2C_INTF_DRP_MOSI_t;
   attribute w of C2C_INTF_DRP_MOSI_t : type is 29;
   function width(x: C2C_INTF_DRP_MOSI_t) return natural;
   function convert(x: C2C_INTF_DRP_MOSI_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DRP_MOSI_t) return C2C_INTF_DRP_MOSI_t;
   function zero(tpl: C2C_INTF_DRP_MOSI_t) return C2C_INTF_DRP_MOSI_t;

   type C2C_INTF_DRP_MISO_t is record
      rd_data : std_logic_vector(16 -1 downto 0);
      rd_data_valid : std_logic;
   end record C2C_INTF_DRP_MISO_t;
   attribute w of C2C_INTF_DRP_MISO_t : type is 17;
   function width(x: C2C_INTF_DRP_MISO_t) return natural;
   function convert(x: C2C_INTF_DRP_MISO_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DRP_MISO_t) return C2C_INTF_DRP_MISO_t;
   function zero(tpl: C2C_INTF_DRP_MISO_t) return C2C_INTF_DRP_MISO_t;

   type C2C_INTF_STATUS_MON_t is record
      CONFIG_ERROR : std_logic;
      LINK_ERROR : std_logic;
      LINK_GOOD : std_logic;
      MB_ERROR : std_logic;
      DO_CC : std_logic;
      PHY_RESET : std_logic;
      PHY_GT_PLL_LOCK : std_logic;
      PHY_MMCM_LOL : std_logic;
      PHY_LANE_UP : std_logic;
      PHY_HARD_ERR : std_logic;
      PHY_SOFT_ERR : std_logic;
      CHANNEL_UP : std_logic;
      LINK_IN_FW : std_logic;
   end record C2C_INTF_STATUS_MON_t;
   attribute w of C2C_INTF_STATUS_MON_t : type is 13;
   function width(x: C2C_INTF_STATUS_MON_t) return natural;
   function convert(x: C2C_INTF_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_STATUS_MON_t) return C2C_INTF_STATUS_MON_t;
   function zero(tpl: C2C_INTF_STATUS_MON_t) return C2C_INTF_STATUS_MON_t;

   type C2C_INTF_STATUS_CTRL_t is record
      INITIALIZE : std_logic;
   end record C2C_INTF_STATUS_CTRL_t;
   attribute w of C2C_INTF_STATUS_CTRL_t : type is 1;
   function width(x: C2C_INTF_STATUS_CTRL_t) return natural;
   function convert(x: C2C_INTF_STATUS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_STATUS_CTRL_t) return C2C_INTF_STATUS_CTRL_t;
   function zero(tpl: C2C_INTF_STATUS_CTRL_t) return C2C_INTF_STATUS_CTRL_t;

   type C2C_INTF_DEBUG_RX_MON_t is record
      BUF_STATUS : std_logic_vector(3 - 1 downto 0);
      PMA_RESET_DONE : std_logic;
      PRBS_ERR : std_logic;
      RESET_DONE : std_logic;
   end record C2C_INTF_DEBUG_RX_MON_t;
   attribute w of C2C_INTF_DEBUG_RX_MON_t : type is 6;
   function width(x: C2C_INTF_DEBUG_RX_MON_t) return natural;
   function convert(x: C2C_INTF_DEBUG_RX_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_RX_MON_t) return C2C_INTF_DEBUG_RX_MON_t;
   function zero(tpl: C2C_INTF_DEBUG_RX_MON_t) return C2C_INTF_DEBUG_RX_MON_t;

   type C2C_INTF_DEBUG_RX_CTRL_t is record
      BUF_RESET : std_logic;
      CDR_HOLD : std_logic;
      DFE_LPM_RESET : std_logic;
      LPM_EN : std_logic;
      PCS_RESET : std_logic;
      PMA_RESET : std_logic;
      PRBS_CNT_RST : std_logic;
      PRBS_SEL : std_logic_vector(4 - 1 downto 0);
      RATE : std_logic_vector(3 - 1 downto 0);
   end record C2C_INTF_DEBUG_RX_CTRL_t;
   attribute w of C2C_INTF_DEBUG_RX_CTRL_t : type is 14;
   function width(x: C2C_INTF_DEBUG_RX_CTRL_t) return natural;
   function convert(x: C2C_INTF_DEBUG_RX_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_RX_CTRL_t) return C2C_INTF_DEBUG_RX_CTRL_t;
   function zero(tpl: C2C_INTF_DEBUG_RX_CTRL_t) return C2C_INTF_DEBUG_RX_CTRL_t;

   type C2C_INTF_DEBUG_TX_MON_t is record
      BUF_STATUS : std_logic_vector(2 - 1 downto 0);
      RESET_DONE : std_logic;
   end record C2C_INTF_DEBUG_TX_MON_t;
   attribute w of C2C_INTF_DEBUG_TX_MON_t : type is 3;
   function width(x: C2C_INTF_DEBUG_TX_MON_t) return natural;
   function convert(x: C2C_INTF_DEBUG_TX_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_TX_MON_t) return C2C_INTF_DEBUG_TX_MON_t;
   function zero(tpl: C2C_INTF_DEBUG_TX_MON_t) return C2C_INTF_DEBUG_TX_MON_t;

   type C2C_INTF_DEBUG_TX_CTRL_t is record
      INHIBIT : std_logic;
      PCS_RESET : std_logic;
      PMA_RESET : std_logic;
      POLARITY : std_logic;
      POST_CURSOR : std_logic_vector(5 - 1 downto 0);
      PRBS_FORCE_ERR : std_logic;
      PRE_CURSOR : std_logic_vector(5 - 1 downto 0);
      PRBS_SEL : std_logic_vector(4 - 1 downto 0);
      DIFF_CTRL : std_logic_vector(5 - 1 downto 0);
   end record C2C_INTF_DEBUG_TX_CTRL_t;
   attribute w of C2C_INTF_DEBUG_TX_CTRL_t : type is 24;
   function width(x: C2C_INTF_DEBUG_TX_CTRL_t) return natural;
   function convert(x: C2C_INTF_DEBUG_TX_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_TX_CTRL_t) return C2C_INTF_DEBUG_TX_CTRL_t;
   function zero(tpl: C2C_INTF_DEBUG_TX_CTRL_t) return C2C_INTF_DEBUG_TX_CTRL_t;

   type C2C_INTF_DEBUG_MON_t is record
      DMONITOR : std_logic_vector(16 - 1 downto 0);
      QPLL_LOCK : std_logic;
      CPLL_LOCK : std_logic;
      EYESCAN_DATA_ERROR : std_logic;
      RX : C2C_INTF_DEBUG_RX_MON_t;
      TX : C2C_INTF_DEBUG_TX_MON_t;
   end record C2C_INTF_DEBUG_MON_t;
   attribute w of C2C_INTF_DEBUG_MON_t : type is 28;
   function width(x: C2C_INTF_DEBUG_MON_t) return natural;
   function convert(x: C2C_INTF_DEBUG_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_MON_t) return C2C_INTF_DEBUG_MON_t;
   function zero(tpl: C2C_INTF_DEBUG_MON_t) return C2C_INTF_DEBUG_MON_t;

   type C2C_INTF_DEBUG_CTRL_t is record
      EYESCAN_RESET : std_logic;
      EYESCAN_TRIGGER : std_logic;
      PCS_RSV_DIN : std_logic_vector(16 - 1 downto 0);
      RX : C2C_INTF_DEBUG_RX_CTRL_t;
      TX : C2C_INTF_DEBUG_TX_CTRL_t;
   end record C2C_INTF_DEBUG_CTRL_t;
   attribute w of C2C_INTF_DEBUG_CTRL_t : type is 56;
   function width(x: C2C_INTF_DEBUG_CTRL_t) return natural;
   function convert(x: C2C_INTF_DEBUG_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_CTRL_t) return C2C_INTF_DEBUG_CTRL_t;
   function zero(tpl: C2C_INTF_DEBUG_CTRL_t) return C2C_INTF_DEBUG_CTRL_t;

   type C2C_INTF_COUNTERS_MON_t is record
      ERRORS_ALL_TIME : std_logic_vector(32 - 1 downto 0);
      ERRORS_SINCE_LOCKED : std_logic_vector(32 - 1 downto 0);
      CONFIG_ERROR_COUNT : std_logic_vector(32 - 1 downto 0);
      LINK_ERROR_COUNT : std_logic_vector(32 - 1 downto 0);
      MB_ERROR_COUNT : std_logic_vector(32 - 1 downto 0);
      PHY_HARD_ERROR_COUNT : std_logic_vector(32 - 1 downto 0);
      PHY_SOFT_ERROR_COUNT : std_logic_vector(32 - 1 downto 0);
      PHYLANE_STATE : std_logic_vector(3 - 1 downto 0);
      ERROR_WAITS_SINCE_LOCKED : std_logic_vector(32 - 1 downto 0);
      USER_CLK_FREQ : std_logic_vector(32 - 1 downto 0);
      XCVR_RESETS : std_logic_vector(32 - 1 downto 0);
      WAITING_TIMEOUTS : std_logic_vector(32 - 1 downto 0);
      SB_ERROR_RATE : std_logic_vector(32 - 1 downto 0);
      MB_ERROR_RATE : std_logic_vector(32 - 1 downto 0);
   end record C2C_INTF_COUNTERS_MON_t;
   attribute w of C2C_INTF_COUNTERS_MON_t : type is 419;
   function width(x: C2C_INTF_COUNTERS_MON_t) return natural;
   function convert(x: C2C_INTF_COUNTERS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_COUNTERS_MON_t) return C2C_INTF_COUNTERS_MON_t;
   function zero(tpl: C2C_INTF_COUNTERS_MON_t) return C2C_INTF_COUNTERS_MON_t;

   type C2C_INTF_COUNTERS_CTRL_t is record
      RESET_COUNTERS : std_logic;
   end record C2C_INTF_COUNTERS_CTRL_t;
   attribute w of C2C_INTF_COUNTERS_CTRL_t : type is 1;
   function width(x: C2C_INTF_COUNTERS_CTRL_t) return natural;
   function convert(x: C2C_INTF_COUNTERS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_COUNTERS_CTRL_t) return C2C_INTF_COUNTERS_CTRL_t;
   function zero(tpl: C2C_INTF_COUNTERS_CTRL_t) return C2C_INTF_COUNTERS_CTRL_t;

   type C2C_INTF_MON_t is record
      DRP : C2C_INTF_DRP_MISO_t;
      STATUS : C2C_INTF_STATUS_MON_t;
      DEBUG : C2C_INTF_DEBUG_MON_t;
      COUNTERS : C2C_INTF_COUNTERS_MON_t;
      USER_FREQ : std_logic_vector(32 - 1 downto 0);
   end record C2C_INTF_MON_t;
   attribute w of C2C_INTF_MON_t : type is 509;
   function width(x: C2C_INTF_MON_t) return natural;
   function convert(x: C2C_INTF_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_MON_t) return C2C_INTF_MON_t;
   function zero(tpl: C2C_INTF_MON_t) return C2C_INTF_MON_t;

   type C2C_INTF_CTRL_t is record
      DRP : C2C_INTF_DRP_MOSI_t;
      STATUS : C2C_INTF_STATUS_CTRL_t;
      DEBUG : C2C_INTF_DEBUG_CTRL_t;
      COUNTERS : C2C_INTF_COUNTERS_CTRL_t;
      PHY_READ_TIME : std_logic_vector(24 - 1 downto 0);
      ENABLE_PHY_CTRL : std_logic;
      PHY_LANE_STABLE : std_logic_vector(20 - 1 downto 0);
      PHY_LANE_ERRORS_TO_RESET : std_logic_vector(8 - 1 downto 0);
      PHY_MAX_SINGLE_BIT_ERROR_RATE : std_logic_vector(32 - 1 downto 0);
      PHY_MAX_MULTI_BIT_ERROR_RATE : std_logic_vector(32 - 1 downto 0);
   end record C2C_INTF_CTRL_t;
   attribute w of C2C_INTF_CTRL_t : type is 204;
   function width(x: C2C_INTF_CTRL_t) return natural;
   function convert(x: C2C_INTF_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: C2C_INTF_CTRL_t) return C2C_INTF_CTRL_t;
   function zero(tpl: C2C_INTF_CTRL_t) return C2C_INTF_CTRL_t;

end package C2C_INTF_CTRL;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package body C2C_INTF_CTRL is

   -- Custom types and functions --

   function width(x: C2C_INTF_DRP_MOSI_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.clk);
      w := w + width(x.enable);
      w := w + width(x.wr_enable);
      w := w + width(x.address);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: C2C_INTF_DRP_MOSI_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.clk);
         y(u to u+w-1) := convert(x.clk, y(u to u+w-1));
         u := u + w;
         w := width(x.enable);
         y(u to u+w-1) := convert(x.enable, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_enable);
         y(u to u+w-1) := convert(x.wr_enable, y(u to u+w-1));
         u := u + w;
         w := width(x.address);
         y(u to u+w-1) := convert(x.address, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.clk);
         y(u downto u-w+1) := convert(x.clk, y(u downto u-w+1));
         u := u - w;
         w := width(x.enable);
         y(u downto u-w+1) := convert(x.enable, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_enable);
         y(u downto u-w+1) := convert(x.wr_enable, y(u downto u-w+1));
         u := u - w;
         w := width(x.address);
         y(u downto u-w+1) := convert(x.address, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DRP_MOSI_t) return C2C_INTF_DRP_MOSI_t is
      variable y : C2C_INTF_DRP_MOSI_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.clk);
         y.clk := convert(x(u to u+w-1), tpl.clk);
         u := u + w;
         w := width(tpl.enable);
         y.enable := convert(x(u to u+w-1), tpl.enable);
         u := u + w;
         w := width(tpl.wr_enable);
         y.wr_enable := convert(x(u to u+w-1), tpl.wr_enable);
         u := u + w;
         w := width(tpl.address);
         y.address := convert(x(u to u+w-1), tpl.address);
         u := u + w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u to u+w-1), tpl.wr_data);
      else
         w := width(tpl.clk);
         y.clk := convert(x(u downto u-w+1), tpl.clk);
         u := u - w;
         w := width(tpl.enable);
         y.enable := convert(x(u downto u-w+1), tpl.enable);
         u := u - w;
         w := width(tpl.wr_enable);
         y.wr_enable := convert(x(u downto u-w+1), tpl.wr_enable);
         u := u - w;
         w := width(tpl.address);
         y.address := convert(x(u downto u-w+1), tpl.address);
         u := u - w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u downto u-w+1), tpl.wr_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_DRP_MOSI_t) return C2C_INTF_DRP_MOSI_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_DRP_MISO_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_data);
      w := w + width(x.rd_data_valid);
      return w;
   end function width;
   function convert(x: C2C_INTF_DRP_MISO_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data_valid);
         y(u to u+w-1) := convert(x.rd_data_valid, y(u to u+w-1));
      else
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data_valid);
         y(u downto u-w+1) := convert(x.rd_data_valid, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DRP_MISO_t) return C2C_INTF_DRP_MISO_t is
      variable y : C2C_INTF_DRP_MISO_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u to u+w-1), tpl.rd_data);
         u := u + w;
         w := width(tpl.rd_data_valid);
         y.rd_data_valid := convert(x(u to u+w-1), tpl.rd_data_valid);
      else
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u downto u-w+1), tpl.rd_data);
         u := u - w;
         w := width(tpl.rd_data_valid);
         y.rd_data_valid := convert(x(u downto u-w+1), tpl.rd_data_valid);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_DRP_MISO_t) return C2C_INTF_DRP_MISO_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_STATUS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CONFIG_ERROR);
      w := w + width(x.LINK_ERROR);
      w := w + width(x.LINK_GOOD);
      w := w + width(x.MB_ERROR);
      w := w + width(x.DO_CC);
      w := w + width(x.PHY_RESET);
      w := w + width(x.PHY_GT_PLL_LOCK);
      w := w + width(x.PHY_MMCM_LOL);
      w := w + width(x.PHY_LANE_UP);
      w := w + width(x.PHY_HARD_ERR);
      w := w + width(x.PHY_SOFT_ERR);
      w := w + width(x.CHANNEL_UP);
      w := w + width(x.LINK_IN_FW);
      return w;
   end function width;
   function convert(x: C2C_INTF_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.CONFIG_ERROR);
         y(u to u+w-1) := convert(x.CONFIG_ERROR, y(u to u+w-1));
         u := u + w;
         w := width(x.LINK_ERROR);
         y(u to u+w-1) := convert(x.LINK_ERROR, y(u to u+w-1));
         u := u + w;
         w := width(x.LINK_GOOD);
         y(u to u+w-1) := convert(x.LINK_GOOD, y(u to u+w-1));
         u := u + w;
         w := width(x.MB_ERROR);
         y(u to u+w-1) := convert(x.MB_ERROR, y(u to u+w-1));
         u := u + w;
         w := width(x.DO_CC);
         y(u to u+w-1) := convert(x.DO_CC, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_RESET);
         y(u to u+w-1) := convert(x.PHY_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_GT_PLL_LOCK);
         y(u to u+w-1) := convert(x.PHY_GT_PLL_LOCK, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_MMCM_LOL);
         y(u to u+w-1) := convert(x.PHY_MMCM_LOL, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_LANE_UP);
         y(u to u+w-1) := convert(x.PHY_LANE_UP, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_HARD_ERR);
         y(u to u+w-1) := convert(x.PHY_HARD_ERR, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_SOFT_ERR);
         y(u to u+w-1) := convert(x.PHY_SOFT_ERR, y(u to u+w-1));
         u := u + w;
         w := width(x.CHANNEL_UP);
         y(u to u+w-1) := convert(x.CHANNEL_UP, y(u to u+w-1));
         u := u + w;
         w := width(x.LINK_IN_FW);
         y(u to u+w-1) := convert(x.LINK_IN_FW, y(u to u+w-1));
      else
         w := width(x.CONFIG_ERROR);
         y(u downto u-w+1) := convert(x.CONFIG_ERROR, y(u downto u-w+1));
         u := u - w;
         w := width(x.LINK_ERROR);
         y(u downto u-w+1) := convert(x.LINK_ERROR, y(u downto u-w+1));
         u := u - w;
         w := width(x.LINK_GOOD);
         y(u downto u-w+1) := convert(x.LINK_GOOD, y(u downto u-w+1));
         u := u - w;
         w := width(x.MB_ERROR);
         y(u downto u-w+1) := convert(x.MB_ERROR, y(u downto u-w+1));
         u := u - w;
         w := width(x.DO_CC);
         y(u downto u-w+1) := convert(x.DO_CC, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_RESET);
         y(u downto u-w+1) := convert(x.PHY_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_GT_PLL_LOCK);
         y(u downto u-w+1) := convert(x.PHY_GT_PLL_LOCK, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_MMCM_LOL);
         y(u downto u-w+1) := convert(x.PHY_MMCM_LOL, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_LANE_UP);
         y(u downto u-w+1) := convert(x.PHY_LANE_UP, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_HARD_ERR);
         y(u downto u-w+1) := convert(x.PHY_HARD_ERR, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_SOFT_ERR);
         y(u downto u-w+1) := convert(x.PHY_SOFT_ERR, y(u downto u-w+1));
         u := u - w;
         w := width(x.CHANNEL_UP);
         y(u downto u-w+1) := convert(x.CHANNEL_UP, y(u downto u-w+1));
         u := u - w;
         w := width(x.LINK_IN_FW);
         y(u downto u-w+1) := convert(x.LINK_IN_FW, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_STATUS_MON_t) return C2C_INTF_STATUS_MON_t is
      variable y : C2C_INTF_STATUS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.CONFIG_ERROR);
         y.CONFIG_ERROR := convert(x(u to u+w-1), tpl.CONFIG_ERROR);
         u := u + w;
         w := width(tpl.LINK_ERROR);
         y.LINK_ERROR := convert(x(u to u+w-1), tpl.LINK_ERROR);
         u := u + w;
         w := width(tpl.LINK_GOOD);
         y.LINK_GOOD := convert(x(u to u+w-1), tpl.LINK_GOOD);
         u := u + w;
         w := width(tpl.MB_ERROR);
         y.MB_ERROR := convert(x(u to u+w-1), tpl.MB_ERROR);
         u := u + w;
         w := width(tpl.DO_CC);
         y.DO_CC := convert(x(u to u+w-1), tpl.DO_CC);
         u := u + w;
         w := width(tpl.PHY_RESET);
         y.PHY_RESET := convert(x(u to u+w-1), tpl.PHY_RESET);
         u := u + w;
         w := width(tpl.PHY_GT_PLL_LOCK);
         y.PHY_GT_PLL_LOCK := convert(x(u to u+w-1), tpl.PHY_GT_PLL_LOCK);
         u := u + w;
         w := width(tpl.PHY_MMCM_LOL);
         y.PHY_MMCM_LOL := convert(x(u to u+w-1), tpl.PHY_MMCM_LOL);
         u := u + w;
         w := width(tpl.PHY_LANE_UP);
         y.PHY_LANE_UP := convert(x(u to u+w-1), tpl.PHY_LANE_UP);
         u := u + w;
         w := width(tpl.PHY_HARD_ERR);
         y.PHY_HARD_ERR := convert(x(u to u+w-1), tpl.PHY_HARD_ERR);
         u := u + w;
         w := width(tpl.PHY_SOFT_ERR);
         y.PHY_SOFT_ERR := convert(x(u to u+w-1), tpl.PHY_SOFT_ERR);
         u := u + w;
         w := width(tpl.CHANNEL_UP);
         y.CHANNEL_UP := convert(x(u to u+w-1), tpl.CHANNEL_UP);
         u := u + w;
         w := width(tpl.LINK_IN_FW);
         y.LINK_IN_FW := convert(x(u to u+w-1), tpl.LINK_IN_FW);
      else
         w := width(tpl.CONFIG_ERROR);
         y.CONFIG_ERROR := convert(x(u downto u-w+1), tpl.CONFIG_ERROR);
         u := u - w;
         w := width(tpl.LINK_ERROR);
         y.LINK_ERROR := convert(x(u downto u-w+1), tpl.LINK_ERROR);
         u := u - w;
         w := width(tpl.LINK_GOOD);
         y.LINK_GOOD := convert(x(u downto u-w+1), tpl.LINK_GOOD);
         u := u - w;
         w := width(tpl.MB_ERROR);
         y.MB_ERROR := convert(x(u downto u-w+1), tpl.MB_ERROR);
         u := u - w;
         w := width(tpl.DO_CC);
         y.DO_CC := convert(x(u downto u-w+1), tpl.DO_CC);
         u := u - w;
         w := width(tpl.PHY_RESET);
         y.PHY_RESET := convert(x(u downto u-w+1), tpl.PHY_RESET);
         u := u - w;
         w := width(tpl.PHY_GT_PLL_LOCK);
         y.PHY_GT_PLL_LOCK := convert(x(u downto u-w+1), tpl.PHY_GT_PLL_LOCK);
         u := u - w;
         w := width(tpl.PHY_MMCM_LOL);
         y.PHY_MMCM_LOL := convert(x(u downto u-w+1), tpl.PHY_MMCM_LOL);
         u := u - w;
         w := width(tpl.PHY_LANE_UP);
         y.PHY_LANE_UP := convert(x(u downto u-w+1), tpl.PHY_LANE_UP);
         u := u - w;
         w := width(tpl.PHY_HARD_ERR);
         y.PHY_HARD_ERR := convert(x(u downto u-w+1), tpl.PHY_HARD_ERR);
         u := u - w;
         w := width(tpl.PHY_SOFT_ERR);
         y.PHY_SOFT_ERR := convert(x(u downto u-w+1), tpl.PHY_SOFT_ERR);
         u := u - w;
         w := width(tpl.CHANNEL_UP);
         y.CHANNEL_UP := convert(x(u downto u-w+1), tpl.CHANNEL_UP);
         u := u - w;
         w := width(tpl.LINK_IN_FW);
         y.LINK_IN_FW := convert(x(u downto u-w+1), tpl.LINK_IN_FW);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_STATUS_MON_t) return C2C_INTF_STATUS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_STATUS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.INITIALIZE);
      return w;
   end function width;
   function convert(x: C2C_INTF_STATUS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.INITIALIZE);
         y(u to u+w-1) := convert(x.INITIALIZE, y(u to u+w-1));
      else
         w := width(x.INITIALIZE);
         y(u downto u-w+1) := convert(x.INITIALIZE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_STATUS_CTRL_t) return C2C_INTF_STATUS_CTRL_t is
      variable y : C2C_INTF_STATUS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.INITIALIZE);
         y.INITIALIZE := convert(x(u to u+w-1), tpl.INITIALIZE);
      else
         w := width(tpl.INITIALIZE);
         y.INITIALIZE := convert(x(u downto u-w+1), tpl.INITIALIZE);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_STATUS_CTRL_t) return C2C_INTF_STATUS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_DEBUG_RX_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.BUF_STATUS);
      w := w + width(x.PMA_RESET_DONE);
      w := w + width(x.PRBS_ERR);
      w := w + width(x.RESET_DONE);
      return w;
   end function width;
   function convert(x: C2C_INTF_DEBUG_RX_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.BUF_STATUS);
         y(u to u+w-1) := convert(x.BUF_STATUS, y(u to u+w-1));
         u := u + w;
         w := width(x.PMA_RESET_DONE);
         y(u to u+w-1) := convert(x.PMA_RESET_DONE, y(u to u+w-1));
         u := u + w;
         w := width(x.PRBS_ERR);
         y(u to u+w-1) := convert(x.PRBS_ERR, y(u to u+w-1));
         u := u + w;
         w := width(x.RESET_DONE);
         y(u to u+w-1) := convert(x.RESET_DONE, y(u to u+w-1));
      else
         w := width(x.BUF_STATUS);
         y(u downto u-w+1) := convert(x.BUF_STATUS, y(u downto u-w+1));
         u := u - w;
         w := width(x.PMA_RESET_DONE);
         y(u downto u-w+1) := convert(x.PMA_RESET_DONE, y(u downto u-w+1));
         u := u - w;
         w := width(x.PRBS_ERR);
         y(u downto u-w+1) := convert(x.PRBS_ERR, y(u downto u-w+1));
         u := u - w;
         w := width(x.RESET_DONE);
         y(u downto u-w+1) := convert(x.RESET_DONE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_RX_MON_t) return C2C_INTF_DEBUG_RX_MON_t is
      variable y : C2C_INTF_DEBUG_RX_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.BUF_STATUS);
         y.BUF_STATUS := convert(x(u to u+w-1), tpl.BUF_STATUS);
         u := u + w;
         w := width(tpl.PMA_RESET_DONE);
         y.PMA_RESET_DONE := convert(x(u to u+w-1), tpl.PMA_RESET_DONE);
         u := u + w;
         w := width(tpl.PRBS_ERR);
         y.PRBS_ERR := convert(x(u to u+w-1), tpl.PRBS_ERR);
         u := u + w;
         w := width(tpl.RESET_DONE);
         y.RESET_DONE := convert(x(u to u+w-1), tpl.RESET_DONE);
      else
         w := width(tpl.BUF_STATUS);
         y.BUF_STATUS := convert(x(u downto u-w+1), tpl.BUF_STATUS);
         u := u - w;
         w := width(tpl.PMA_RESET_DONE);
         y.PMA_RESET_DONE := convert(x(u downto u-w+1), tpl.PMA_RESET_DONE);
         u := u - w;
         w := width(tpl.PRBS_ERR);
         y.PRBS_ERR := convert(x(u downto u-w+1), tpl.PRBS_ERR);
         u := u - w;
         w := width(tpl.RESET_DONE);
         y.RESET_DONE := convert(x(u downto u-w+1), tpl.RESET_DONE);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_DEBUG_RX_MON_t) return C2C_INTF_DEBUG_RX_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_DEBUG_RX_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.BUF_RESET);
      w := w + width(x.CDR_HOLD);
      w := w + width(x.DFE_LPM_RESET);
      w := w + width(x.LPM_EN);
      w := w + width(x.PCS_RESET);
      w := w + width(x.PMA_RESET);
      w := w + width(x.PRBS_CNT_RST);
      w := w + width(x.PRBS_SEL);
      w := w + width(x.RATE);
      return w;
   end function width;
   function convert(x: C2C_INTF_DEBUG_RX_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.BUF_RESET);
         y(u to u+w-1) := convert(x.BUF_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.CDR_HOLD);
         y(u to u+w-1) := convert(x.CDR_HOLD, y(u to u+w-1));
         u := u + w;
         w := width(x.DFE_LPM_RESET);
         y(u to u+w-1) := convert(x.DFE_LPM_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.LPM_EN);
         y(u to u+w-1) := convert(x.LPM_EN, y(u to u+w-1));
         u := u + w;
         w := width(x.PCS_RESET);
         y(u to u+w-1) := convert(x.PCS_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.PMA_RESET);
         y(u to u+w-1) := convert(x.PMA_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.PRBS_CNT_RST);
         y(u to u+w-1) := convert(x.PRBS_CNT_RST, y(u to u+w-1));
         u := u + w;
         w := width(x.PRBS_SEL);
         y(u to u+w-1) := convert(x.PRBS_SEL, y(u to u+w-1));
         u := u + w;
         w := width(x.RATE);
         y(u to u+w-1) := convert(x.RATE, y(u to u+w-1));
      else
         w := width(x.BUF_RESET);
         y(u downto u-w+1) := convert(x.BUF_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.CDR_HOLD);
         y(u downto u-w+1) := convert(x.CDR_HOLD, y(u downto u-w+1));
         u := u - w;
         w := width(x.DFE_LPM_RESET);
         y(u downto u-w+1) := convert(x.DFE_LPM_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.LPM_EN);
         y(u downto u-w+1) := convert(x.LPM_EN, y(u downto u-w+1));
         u := u - w;
         w := width(x.PCS_RESET);
         y(u downto u-w+1) := convert(x.PCS_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.PMA_RESET);
         y(u downto u-w+1) := convert(x.PMA_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.PRBS_CNT_RST);
         y(u downto u-w+1) := convert(x.PRBS_CNT_RST, y(u downto u-w+1));
         u := u - w;
         w := width(x.PRBS_SEL);
         y(u downto u-w+1) := convert(x.PRBS_SEL, y(u downto u-w+1));
         u := u - w;
         w := width(x.RATE);
         y(u downto u-w+1) := convert(x.RATE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_RX_CTRL_t) return C2C_INTF_DEBUG_RX_CTRL_t is
      variable y : C2C_INTF_DEBUG_RX_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.BUF_RESET);
         y.BUF_RESET := convert(x(u to u+w-1), tpl.BUF_RESET);
         u := u + w;
         w := width(tpl.CDR_HOLD);
         y.CDR_HOLD := convert(x(u to u+w-1), tpl.CDR_HOLD);
         u := u + w;
         w := width(tpl.DFE_LPM_RESET);
         y.DFE_LPM_RESET := convert(x(u to u+w-1), tpl.DFE_LPM_RESET);
         u := u + w;
         w := width(tpl.LPM_EN);
         y.LPM_EN := convert(x(u to u+w-1), tpl.LPM_EN);
         u := u + w;
         w := width(tpl.PCS_RESET);
         y.PCS_RESET := convert(x(u to u+w-1), tpl.PCS_RESET);
         u := u + w;
         w := width(tpl.PMA_RESET);
         y.PMA_RESET := convert(x(u to u+w-1), tpl.PMA_RESET);
         u := u + w;
         w := width(tpl.PRBS_CNT_RST);
         y.PRBS_CNT_RST := convert(x(u to u+w-1), tpl.PRBS_CNT_RST);
         u := u + w;
         w := width(tpl.PRBS_SEL);
         y.PRBS_SEL := convert(x(u to u+w-1), tpl.PRBS_SEL);
         u := u + w;
         w := width(tpl.RATE);
         y.RATE := convert(x(u to u+w-1), tpl.RATE);
      else
         w := width(tpl.BUF_RESET);
         y.BUF_RESET := convert(x(u downto u-w+1), tpl.BUF_RESET);
         u := u - w;
         w := width(tpl.CDR_HOLD);
         y.CDR_HOLD := convert(x(u downto u-w+1), tpl.CDR_HOLD);
         u := u - w;
         w := width(tpl.DFE_LPM_RESET);
         y.DFE_LPM_RESET := convert(x(u downto u-w+1), tpl.DFE_LPM_RESET);
         u := u - w;
         w := width(tpl.LPM_EN);
         y.LPM_EN := convert(x(u downto u-w+1), tpl.LPM_EN);
         u := u - w;
         w := width(tpl.PCS_RESET);
         y.PCS_RESET := convert(x(u downto u-w+1), tpl.PCS_RESET);
         u := u - w;
         w := width(tpl.PMA_RESET);
         y.PMA_RESET := convert(x(u downto u-w+1), tpl.PMA_RESET);
         u := u - w;
         w := width(tpl.PRBS_CNT_RST);
         y.PRBS_CNT_RST := convert(x(u downto u-w+1), tpl.PRBS_CNT_RST);
         u := u - w;
         w := width(tpl.PRBS_SEL);
         y.PRBS_SEL := convert(x(u downto u-w+1), tpl.PRBS_SEL);
         u := u - w;
         w := width(tpl.RATE);
         y.RATE := convert(x(u downto u-w+1), tpl.RATE);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_DEBUG_RX_CTRL_t) return C2C_INTF_DEBUG_RX_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_DEBUG_TX_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.BUF_STATUS);
      w := w + width(x.RESET_DONE);
      return w;
   end function width;
   function convert(x: C2C_INTF_DEBUG_TX_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.BUF_STATUS);
         y(u to u+w-1) := convert(x.BUF_STATUS, y(u to u+w-1));
         u := u + w;
         w := width(x.RESET_DONE);
         y(u to u+w-1) := convert(x.RESET_DONE, y(u to u+w-1));
      else
         w := width(x.BUF_STATUS);
         y(u downto u-w+1) := convert(x.BUF_STATUS, y(u downto u-w+1));
         u := u - w;
         w := width(x.RESET_DONE);
         y(u downto u-w+1) := convert(x.RESET_DONE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_TX_MON_t) return C2C_INTF_DEBUG_TX_MON_t is
      variable y : C2C_INTF_DEBUG_TX_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.BUF_STATUS);
         y.BUF_STATUS := convert(x(u to u+w-1), tpl.BUF_STATUS);
         u := u + w;
         w := width(tpl.RESET_DONE);
         y.RESET_DONE := convert(x(u to u+w-1), tpl.RESET_DONE);
      else
         w := width(tpl.BUF_STATUS);
         y.BUF_STATUS := convert(x(u downto u-w+1), tpl.BUF_STATUS);
         u := u - w;
         w := width(tpl.RESET_DONE);
         y.RESET_DONE := convert(x(u downto u-w+1), tpl.RESET_DONE);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_DEBUG_TX_MON_t) return C2C_INTF_DEBUG_TX_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_DEBUG_TX_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.INHIBIT);
      w := w + width(x.PCS_RESET);
      w := w + width(x.PMA_RESET);
      w := w + width(x.POLARITY);
      w := w + width(x.POST_CURSOR);
      w := w + width(x.PRBS_FORCE_ERR);
      w := w + width(x.PRE_CURSOR);
      w := w + width(x.PRBS_SEL);
      w := w + width(x.DIFF_CTRL);
      return w;
   end function width;
   function convert(x: C2C_INTF_DEBUG_TX_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.INHIBIT);
         y(u to u+w-1) := convert(x.INHIBIT, y(u to u+w-1));
         u := u + w;
         w := width(x.PCS_RESET);
         y(u to u+w-1) := convert(x.PCS_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.PMA_RESET);
         y(u to u+w-1) := convert(x.PMA_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.POLARITY);
         y(u to u+w-1) := convert(x.POLARITY, y(u to u+w-1));
         u := u + w;
         w := width(x.POST_CURSOR);
         y(u to u+w-1) := convert(x.POST_CURSOR, y(u to u+w-1));
         u := u + w;
         w := width(x.PRBS_FORCE_ERR);
         y(u to u+w-1) := convert(x.PRBS_FORCE_ERR, y(u to u+w-1));
         u := u + w;
         w := width(x.PRE_CURSOR);
         y(u to u+w-1) := convert(x.PRE_CURSOR, y(u to u+w-1));
         u := u + w;
         w := width(x.PRBS_SEL);
         y(u to u+w-1) := convert(x.PRBS_SEL, y(u to u+w-1));
         u := u + w;
         w := width(x.DIFF_CTRL);
         y(u to u+w-1) := convert(x.DIFF_CTRL, y(u to u+w-1));
      else
         w := width(x.INHIBIT);
         y(u downto u-w+1) := convert(x.INHIBIT, y(u downto u-w+1));
         u := u - w;
         w := width(x.PCS_RESET);
         y(u downto u-w+1) := convert(x.PCS_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.PMA_RESET);
         y(u downto u-w+1) := convert(x.PMA_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.POLARITY);
         y(u downto u-w+1) := convert(x.POLARITY, y(u downto u-w+1));
         u := u - w;
         w := width(x.POST_CURSOR);
         y(u downto u-w+1) := convert(x.POST_CURSOR, y(u downto u-w+1));
         u := u - w;
         w := width(x.PRBS_FORCE_ERR);
         y(u downto u-w+1) := convert(x.PRBS_FORCE_ERR, y(u downto u-w+1));
         u := u - w;
         w := width(x.PRE_CURSOR);
         y(u downto u-w+1) := convert(x.PRE_CURSOR, y(u downto u-w+1));
         u := u - w;
         w := width(x.PRBS_SEL);
         y(u downto u-w+1) := convert(x.PRBS_SEL, y(u downto u-w+1));
         u := u - w;
         w := width(x.DIFF_CTRL);
         y(u downto u-w+1) := convert(x.DIFF_CTRL, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_TX_CTRL_t) return C2C_INTF_DEBUG_TX_CTRL_t is
      variable y : C2C_INTF_DEBUG_TX_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.INHIBIT);
         y.INHIBIT := convert(x(u to u+w-1), tpl.INHIBIT);
         u := u + w;
         w := width(tpl.PCS_RESET);
         y.PCS_RESET := convert(x(u to u+w-1), tpl.PCS_RESET);
         u := u + w;
         w := width(tpl.PMA_RESET);
         y.PMA_RESET := convert(x(u to u+w-1), tpl.PMA_RESET);
         u := u + w;
         w := width(tpl.POLARITY);
         y.POLARITY := convert(x(u to u+w-1), tpl.POLARITY);
         u := u + w;
         w := width(tpl.POST_CURSOR);
         y.POST_CURSOR := convert(x(u to u+w-1), tpl.POST_CURSOR);
         u := u + w;
         w := width(tpl.PRBS_FORCE_ERR);
         y.PRBS_FORCE_ERR := convert(x(u to u+w-1), tpl.PRBS_FORCE_ERR);
         u := u + w;
         w := width(tpl.PRE_CURSOR);
         y.PRE_CURSOR := convert(x(u to u+w-1), tpl.PRE_CURSOR);
         u := u + w;
         w := width(tpl.PRBS_SEL);
         y.PRBS_SEL := convert(x(u to u+w-1), tpl.PRBS_SEL);
         u := u + w;
         w := width(tpl.DIFF_CTRL);
         y.DIFF_CTRL := convert(x(u to u+w-1), tpl.DIFF_CTRL);
      else
         w := width(tpl.INHIBIT);
         y.INHIBIT := convert(x(u downto u-w+1), tpl.INHIBIT);
         u := u - w;
         w := width(tpl.PCS_RESET);
         y.PCS_RESET := convert(x(u downto u-w+1), tpl.PCS_RESET);
         u := u - w;
         w := width(tpl.PMA_RESET);
         y.PMA_RESET := convert(x(u downto u-w+1), tpl.PMA_RESET);
         u := u - w;
         w := width(tpl.POLARITY);
         y.POLARITY := convert(x(u downto u-w+1), tpl.POLARITY);
         u := u - w;
         w := width(tpl.POST_CURSOR);
         y.POST_CURSOR := convert(x(u downto u-w+1), tpl.POST_CURSOR);
         u := u - w;
         w := width(tpl.PRBS_FORCE_ERR);
         y.PRBS_FORCE_ERR := convert(x(u downto u-w+1), tpl.PRBS_FORCE_ERR);
         u := u - w;
         w := width(tpl.PRE_CURSOR);
         y.PRE_CURSOR := convert(x(u downto u-w+1), tpl.PRE_CURSOR);
         u := u - w;
         w := width(tpl.PRBS_SEL);
         y.PRBS_SEL := convert(x(u downto u-w+1), tpl.PRBS_SEL);
         u := u - w;
         w := width(tpl.DIFF_CTRL);
         y.DIFF_CTRL := convert(x(u downto u-w+1), tpl.DIFF_CTRL);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_DEBUG_TX_CTRL_t) return C2C_INTF_DEBUG_TX_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_DEBUG_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.DMONITOR);
      w := w + width(x.QPLL_LOCK);
      w := w + width(x.CPLL_LOCK);
      w := w + width(x.EYESCAN_DATA_ERROR);
      w := w + width(x.RX);
      w := w + width(x.TX);
      return w;
   end function width;
   function convert(x: C2C_INTF_DEBUG_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.DMONITOR);
         y(u to u+w-1) := convert(x.DMONITOR, y(u to u+w-1));
         u := u + w;
         w := width(x.QPLL_LOCK);
         y(u to u+w-1) := convert(x.QPLL_LOCK, y(u to u+w-1));
         u := u + w;
         w := width(x.CPLL_LOCK);
         y(u to u+w-1) := convert(x.CPLL_LOCK, y(u to u+w-1));
         u := u + w;
         w := width(x.EYESCAN_DATA_ERROR);
         y(u to u+w-1) := convert(x.EYESCAN_DATA_ERROR, y(u to u+w-1));
         u := u + w;
         w := width(x.RX);
         y(u to u+w-1) := convert(x.RX, y(u to u+w-1));
         u := u + w;
         w := width(x.TX);
         y(u to u+w-1) := convert(x.TX, y(u to u+w-1));
      else
         w := width(x.DMONITOR);
         y(u downto u-w+1) := convert(x.DMONITOR, y(u downto u-w+1));
         u := u - w;
         w := width(x.QPLL_LOCK);
         y(u downto u-w+1) := convert(x.QPLL_LOCK, y(u downto u-w+1));
         u := u - w;
         w := width(x.CPLL_LOCK);
         y(u downto u-w+1) := convert(x.CPLL_LOCK, y(u downto u-w+1));
         u := u - w;
         w := width(x.EYESCAN_DATA_ERROR);
         y(u downto u-w+1) := convert(x.EYESCAN_DATA_ERROR, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX);
         y(u downto u-w+1) := convert(x.RX, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX);
         y(u downto u-w+1) := convert(x.TX, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_MON_t) return C2C_INTF_DEBUG_MON_t is
      variable y : C2C_INTF_DEBUG_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.DMONITOR);
         y.DMONITOR := convert(x(u to u+w-1), tpl.DMONITOR);
         u := u + w;
         w := width(tpl.QPLL_LOCK);
         y.QPLL_LOCK := convert(x(u to u+w-1), tpl.QPLL_LOCK);
         u := u + w;
         w := width(tpl.CPLL_LOCK);
         y.CPLL_LOCK := convert(x(u to u+w-1), tpl.CPLL_LOCK);
         u := u + w;
         w := width(tpl.EYESCAN_DATA_ERROR);
         y.EYESCAN_DATA_ERROR := convert(x(u to u+w-1), tpl.EYESCAN_DATA_ERROR);
         u := u + w;
         w := width(tpl.RX);
         y.RX := convert(x(u to u+w-1), tpl.RX);
         u := u + w;
         w := width(tpl.TX);
         y.TX := convert(x(u to u+w-1), tpl.TX);
      else
         w := width(tpl.DMONITOR);
         y.DMONITOR := convert(x(u downto u-w+1), tpl.DMONITOR);
         u := u - w;
         w := width(tpl.QPLL_LOCK);
         y.QPLL_LOCK := convert(x(u downto u-w+1), tpl.QPLL_LOCK);
         u := u - w;
         w := width(tpl.CPLL_LOCK);
         y.CPLL_LOCK := convert(x(u downto u-w+1), tpl.CPLL_LOCK);
         u := u - w;
         w := width(tpl.EYESCAN_DATA_ERROR);
         y.EYESCAN_DATA_ERROR := convert(x(u downto u-w+1), tpl.EYESCAN_DATA_ERROR);
         u := u - w;
         w := width(tpl.RX);
         y.RX := convert(x(u downto u-w+1), tpl.RX);
         u := u - w;
         w := width(tpl.TX);
         y.TX := convert(x(u downto u-w+1), tpl.TX);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_DEBUG_MON_t) return C2C_INTF_DEBUG_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_DEBUG_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.EYESCAN_RESET);
      w := w + width(x.EYESCAN_TRIGGER);
      w := w + width(x.PCS_RSV_DIN);
      w := w + width(x.RX);
      w := w + width(x.TX);
      return w;
   end function width;
   function convert(x: C2C_INTF_DEBUG_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.EYESCAN_RESET);
         y(u to u+w-1) := convert(x.EYESCAN_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.EYESCAN_TRIGGER);
         y(u to u+w-1) := convert(x.EYESCAN_TRIGGER, y(u to u+w-1));
         u := u + w;
         w := width(x.PCS_RSV_DIN);
         y(u to u+w-1) := convert(x.PCS_RSV_DIN, y(u to u+w-1));
         u := u + w;
         w := width(x.RX);
         y(u to u+w-1) := convert(x.RX, y(u to u+w-1));
         u := u + w;
         w := width(x.TX);
         y(u to u+w-1) := convert(x.TX, y(u to u+w-1));
      else
         w := width(x.EYESCAN_RESET);
         y(u downto u-w+1) := convert(x.EYESCAN_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.EYESCAN_TRIGGER);
         y(u downto u-w+1) := convert(x.EYESCAN_TRIGGER, y(u downto u-w+1));
         u := u - w;
         w := width(x.PCS_RSV_DIN);
         y(u downto u-w+1) := convert(x.PCS_RSV_DIN, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX);
         y(u downto u-w+1) := convert(x.RX, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX);
         y(u downto u-w+1) := convert(x.TX, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_DEBUG_CTRL_t) return C2C_INTF_DEBUG_CTRL_t is
      variable y : C2C_INTF_DEBUG_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.EYESCAN_RESET);
         y.EYESCAN_RESET := convert(x(u to u+w-1), tpl.EYESCAN_RESET);
         u := u + w;
         w := width(tpl.EYESCAN_TRIGGER);
         y.EYESCAN_TRIGGER := convert(x(u to u+w-1), tpl.EYESCAN_TRIGGER);
         u := u + w;
         w := width(tpl.PCS_RSV_DIN);
         y.PCS_RSV_DIN := convert(x(u to u+w-1), tpl.PCS_RSV_DIN);
         u := u + w;
         w := width(tpl.RX);
         y.RX := convert(x(u to u+w-1), tpl.RX);
         u := u + w;
         w := width(tpl.TX);
         y.TX := convert(x(u to u+w-1), tpl.TX);
      else
         w := width(tpl.EYESCAN_RESET);
         y.EYESCAN_RESET := convert(x(u downto u-w+1), tpl.EYESCAN_RESET);
         u := u - w;
         w := width(tpl.EYESCAN_TRIGGER);
         y.EYESCAN_TRIGGER := convert(x(u downto u-w+1), tpl.EYESCAN_TRIGGER);
         u := u - w;
         w := width(tpl.PCS_RSV_DIN);
         y.PCS_RSV_DIN := convert(x(u downto u-w+1), tpl.PCS_RSV_DIN);
         u := u - w;
         w := width(tpl.RX);
         y.RX := convert(x(u downto u-w+1), tpl.RX);
         u := u - w;
         w := width(tpl.TX);
         y.TX := convert(x(u downto u-w+1), tpl.TX);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_DEBUG_CTRL_t) return C2C_INTF_DEBUG_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_COUNTERS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ERRORS_ALL_TIME);
      w := w + width(x.ERRORS_SINCE_LOCKED);
      w := w + width(x.CONFIG_ERROR_COUNT);
      w := w + width(x.LINK_ERROR_COUNT);
      w := w + width(x.MB_ERROR_COUNT);
      w := w + width(x.PHY_HARD_ERROR_COUNT);
      w := w + width(x.PHY_SOFT_ERROR_COUNT);
      w := w + width(x.PHYLANE_STATE);
      w := w + width(x.ERROR_WAITS_SINCE_LOCKED);
      w := w + width(x.USER_CLK_FREQ);
      w := w + width(x.XCVR_RESETS);
      w := w + width(x.WAITING_TIMEOUTS);
      w := w + width(x.SB_ERROR_RATE);
      w := w + width(x.MB_ERROR_RATE);
      return w;
   end function width;
   function convert(x: C2C_INTF_COUNTERS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ERRORS_ALL_TIME);
         y(u to u+w-1) := convert(x.ERRORS_ALL_TIME, y(u to u+w-1));
         u := u + w;
         w := width(x.ERRORS_SINCE_LOCKED);
         y(u to u+w-1) := convert(x.ERRORS_SINCE_LOCKED, y(u to u+w-1));
         u := u + w;
         w := width(x.CONFIG_ERROR_COUNT);
         y(u to u+w-1) := convert(x.CONFIG_ERROR_COUNT, y(u to u+w-1));
         u := u + w;
         w := width(x.LINK_ERROR_COUNT);
         y(u to u+w-1) := convert(x.LINK_ERROR_COUNT, y(u to u+w-1));
         u := u + w;
         w := width(x.MB_ERROR_COUNT);
         y(u to u+w-1) := convert(x.MB_ERROR_COUNT, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_HARD_ERROR_COUNT);
         y(u to u+w-1) := convert(x.PHY_HARD_ERROR_COUNT, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_SOFT_ERROR_COUNT);
         y(u to u+w-1) := convert(x.PHY_SOFT_ERROR_COUNT, y(u to u+w-1));
         u := u + w;
         w := width(x.PHYLANE_STATE);
         y(u to u+w-1) := convert(x.PHYLANE_STATE, y(u to u+w-1));
         u := u + w;
         w := width(x.ERROR_WAITS_SINCE_LOCKED);
         y(u to u+w-1) := convert(x.ERROR_WAITS_SINCE_LOCKED, y(u to u+w-1));
         u := u + w;
         w := width(x.USER_CLK_FREQ);
         y(u to u+w-1) := convert(x.USER_CLK_FREQ, y(u to u+w-1));
         u := u + w;
         w := width(x.XCVR_RESETS);
         y(u to u+w-1) := convert(x.XCVR_RESETS, y(u to u+w-1));
         u := u + w;
         w := width(x.WAITING_TIMEOUTS);
         y(u to u+w-1) := convert(x.WAITING_TIMEOUTS, y(u to u+w-1));
         u := u + w;
         w := width(x.SB_ERROR_RATE);
         y(u to u+w-1) := convert(x.SB_ERROR_RATE, y(u to u+w-1));
         u := u + w;
         w := width(x.MB_ERROR_RATE);
         y(u to u+w-1) := convert(x.MB_ERROR_RATE, y(u to u+w-1));
      else
         w := width(x.ERRORS_ALL_TIME);
         y(u downto u-w+1) := convert(x.ERRORS_ALL_TIME, y(u downto u-w+1));
         u := u - w;
         w := width(x.ERRORS_SINCE_LOCKED);
         y(u downto u-w+1) := convert(x.ERRORS_SINCE_LOCKED, y(u downto u-w+1));
         u := u - w;
         w := width(x.CONFIG_ERROR_COUNT);
         y(u downto u-w+1) := convert(x.CONFIG_ERROR_COUNT, y(u downto u-w+1));
         u := u - w;
         w := width(x.LINK_ERROR_COUNT);
         y(u downto u-w+1) := convert(x.LINK_ERROR_COUNT, y(u downto u-w+1));
         u := u - w;
         w := width(x.MB_ERROR_COUNT);
         y(u downto u-w+1) := convert(x.MB_ERROR_COUNT, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_HARD_ERROR_COUNT);
         y(u downto u-w+1) := convert(x.PHY_HARD_ERROR_COUNT, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_SOFT_ERROR_COUNT);
         y(u downto u-w+1) := convert(x.PHY_SOFT_ERROR_COUNT, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHYLANE_STATE);
         y(u downto u-w+1) := convert(x.PHYLANE_STATE, y(u downto u-w+1));
         u := u - w;
         w := width(x.ERROR_WAITS_SINCE_LOCKED);
         y(u downto u-w+1) := convert(x.ERROR_WAITS_SINCE_LOCKED, y(u downto u-w+1));
         u := u - w;
         w := width(x.USER_CLK_FREQ);
         y(u downto u-w+1) := convert(x.USER_CLK_FREQ, y(u downto u-w+1));
         u := u - w;
         w := width(x.XCVR_RESETS);
         y(u downto u-w+1) := convert(x.XCVR_RESETS, y(u downto u-w+1));
         u := u - w;
         w := width(x.WAITING_TIMEOUTS);
         y(u downto u-w+1) := convert(x.WAITING_TIMEOUTS, y(u downto u-w+1));
         u := u - w;
         w := width(x.SB_ERROR_RATE);
         y(u downto u-w+1) := convert(x.SB_ERROR_RATE, y(u downto u-w+1));
         u := u - w;
         w := width(x.MB_ERROR_RATE);
         y(u downto u-w+1) := convert(x.MB_ERROR_RATE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_COUNTERS_MON_t) return C2C_INTF_COUNTERS_MON_t is
      variable y : C2C_INTF_COUNTERS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ERRORS_ALL_TIME);
         y.ERRORS_ALL_TIME := convert(x(u to u+w-1), tpl.ERRORS_ALL_TIME);
         u := u + w;
         w := width(tpl.ERRORS_SINCE_LOCKED);
         y.ERRORS_SINCE_LOCKED := convert(x(u to u+w-1), tpl.ERRORS_SINCE_LOCKED);
         u := u + w;
         w := width(tpl.CONFIG_ERROR_COUNT);
         y.CONFIG_ERROR_COUNT := convert(x(u to u+w-1), tpl.CONFIG_ERROR_COUNT);
         u := u + w;
         w := width(tpl.LINK_ERROR_COUNT);
         y.LINK_ERROR_COUNT := convert(x(u to u+w-1), tpl.LINK_ERROR_COUNT);
         u := u + w;
         w := width(tpl.MB_ERROR_COUNT);
         y.MB_ERROR_COUNT := convert(x(u to u+w-1), tpl.MB_ERROR_COUNT);
         u := u + w;
         w := width(tpl.PHY_HARD_ERROR_COUNT);
         y.PHY_HARD_ERROR_COUNT := convert(x(u to u+w-1), tpl.PHY_HARD_ERROR_COUNT);
         u := u + w;
         w := width(tpl.PHY_SOFT_ERROR_COUNT);
         y.PHY_SOFT_ERROR_COUNT := convert(x(u to u+w-1), tpl.PHY_SOFT_ERROR_COUNT);
         u := u + w;
         w := width(tpl.PHYLANE_STATE);
         y.PHYLANE_STATE := convert(x(u to u+w-1), tpl.PHYLANE_STATE);
         u := u + w;
         w := width(tpl.ERROR_WAITS_SINCE_LOCKED);
         y.ERROR_WAITS_SINCE_LOCKED := convert(x(u to u+w-1), tpl.ERROR_WAITS_SINCE_LOCKED);
         u := u + w;
         w := width(tpl.USER_CLK_FREQ);
         y.USER_CLK_FREQ := convert(x(u to u+w-1), tpl.USER_CLK_FREQ);
         u := u + w;
         w := width(tpl.XCVR_RESETS);
         y.XCVR_RESETS := convert(x(u to u+w-1), tpl.XCVR_RESETS);
         u := u + w;
         w := width(tpl.WAITING_TIMEOUTS);
         y.WAITING_TIMEOUTS := convert(x(u to u+w-1), tpl.WAITING_TIMEOUTS);
         u := u + w;
         w := width(tpl.SB_ERROR_RATE);
         y.SB_ERROR_RATE := convert(x(u to u+w-1), tpl.SB_ERROR_RATE);
         u := u + w;
         w := width(tpl.MB_ERROR_RATE);
         y.MB_ERROR_RATE := convert(x(u to u+w-1), tpl.MB_ERROR_RATE);
      else
         w := width(tpl.ERRORS_ALL_TIME);
         y.ERRORS_ALL_TIME := convert(x(u downto u-w+1), tpl.ERRORS_ALL_TIME);
         u := u - w;
         w := width(tpl.ERRORS_SINCE_LOCKED);
         y.ERRORS_SINCE_LOCKED := convert(x(u downto u-w+1), tpl.ERRORS_SINCE_LOCKED);
         u := u - w;
         w := width(tpl.CONFIG_ERROR_COUNT);
         y.CONFIG_ERROR_COUNT := convert(x(u downto u-w+1), tpl.CONFIG_ERROR_COUNT);
         u := u - w;
         w := width(tpl.LINK_ERROR_COUNT);
         y.LINK_ERROR_COUNT := convert(x(u downto u-w+1), tpl.LINK_ERROR_COUNT);
         u := u - w;
         w := width(tpl.MB_ERROR_COUNT);
         y.MB_ERROR_COUNT := convert(x(u downto u-w+1), tpl.MB_ERROR_COUNT);
         u := u - w;
         w := width(tpl.PHY_HARD_ERROR_COUNT);
         y.PHY_HARD_ERROR_COUNT := convert(x(u downto u-w+1), tpl.PHY_HARD_ERROR_COUNT);
         u := u - w;
         w := width(tpl.PHY_SOFT_ERROR_COUNT);
         y.PHY_SOFT_ERROR_COUNT := convert(x(u downto u-w+1), tpl.PHY_SOFT_ERROR_COUNT);
         u := u - w;
         w := width(tpl.PHYLANE_STATE);
         y.PHYLANE_STATE := convert(x(u downto u-w+1), tpl.PHYLANE_STATE);
         u := u - w;
         w := width(tpl.ERROR_WAITS_SINCE_LOCKED);
         y.ERROR_WAITS_SINCE_LOCKED := convert(x(u downto u-w+1), tpl.ERROR_WAITS_SINCE_LOCKED);
         u := u - w;
         w := width(tpl.USER_CLK_FREQ);
         y.USER_CLK_FREQ := convert(x(u downto u-w+1), tpl.USER_CLK_FREQ);
         u := u - w;
         w := width(tpl.XCVR_RESETS);
         y.XCVR_RESETS := convert(x(u downto u-w+1), tpl.XCVR_RESETS);
         u := u - w;
         w := width(tpl.WAITING_TIMEOUTS);
         y.WAITING_TIMEOUTS := convert(x(u downto u-w+1), tpl.WAITING_TIMEOUTS);
         u := u - w;
         w := width(tpl.SB_ERROR_RATE);
         y.SB_ERROR_RATE := convert(x(u downto u-w+1), tpl.SB_ERROR_RATE);
         u := u - w;
         w := width(tpl.MB_ERROR_RATE);
         y.MB_ERROR_RATE := convert(x(u downto u-w+1), tpl.MB_ERROR_RATE);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_COUNTERS_MON_t) return C2C_INTF_COUNTERS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_COUNTERS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET_COUNTERS);
      return w;
   end function width;
   function convert(x: C2C_INTF_COUNTERS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET_COUNTERS);
         y(u to u+w-1) := convert(x.RESET_COUNTERS, y(u to u+w-1));
      else
         w := width(x.RESET_COUNTERS);
         y(u downto u-w+1) := convert(x.RESET_COUNTERS, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_COUNTERS_CTRL_t) return C2C_INTF_COUNTERS_CTRL_t is
      variable y : C2C_INTF_COUNTERS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET_COUNTERS);
         y.RESET_COUNTERS := convert(x(u to u+w-1), tpl.RESET_COUNTERS);
      else
         w := width(tpl.RESET_COUNTERS);
         y.RESET_COUNTERS := convert(x(u downto u-w+1), tpl.RESET_COUNTERS);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_COUNTERS_CTRL_t) return C2C_INTF_COUNTERS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.DRP);
      w := w + width(x.STATUS);
      w := w + width(x.DEBUG);
      w := w + width(x.COUNTERS);
      w := w + width(x.USER_FREQ);
      return w;
   end function width;
   function convert(x: C2C_INTF_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.DRP);
         y(u to u+w-1) := convert(x.DRP, y(u to u+w-1));
         u := u + w;
         w := width(x.STATUS);
         y(u to u+w-1) := convert(x.STATUS, y(u to u+w-1));
         u := u + w;
         w := width(x.DEBUG);
         y(u to u+w-1) := convert(x.DEBUG, y(u to u+w-1));
         u := u + w;
         w := width(x.COUNTERS);
         y(u to u+w-1) := convert(x.COUNTERS, y(u to u+w-1));
         u := u + w;
         w := width(x.USER_FREQ);
         y(u to u+w-1) := convert(x.USER_FREQ, y(u to u+w-1));
      else
         w := width(x.DRP);
         y(u downto u-w+1) := convert(x.DRP, y(u downto u-w+1));
         u := u - w;
         w := width(x.STATUS);
         y(u downto u-w+1) := convert(x.STATUS, y(u downto u-w+1));
         u := u - w;
         w := width(x.DEBUG);
         y(u downto u-w+1) := convert(x.DEBUG, y(u downto u-w+1));
         u := u - w;
         w := width(x.COUNTERS);
         y(u downto u-w+1) := convert(x.COUNTERS, y(u downto u-w+1));
         u := u - w;
         w := width(x.USER_FREQ);
         y(u downto u-w+1) := convert(x.USER_FREQ, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_MON_t) return C2C_INTF_MON_t is
      variable y : C2C_INTF_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.DRP);
         y.DRP := convert(x(u to u+w-1), tpl.DRP);
         u := u + w;
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u to u+w-1), tpl.STATUS);
         u := u + w;
         w := width(tpl.DEBUG);
         y.DEBUG := convert(x(u to u+w-1), tpl.DEBUG);
         u := u + w;
         w := width(tpl.COUNTERS);
         y.COUNTERS := convert(x(u to u+w-1), tpl.COUNTERS);
         u := u + w;
         w := width(tpl.USER_FREQ);
         y.USER_FREQ := convert(x(u to u+w-1), tpl.USER_FREQ);
      else
         w := width(tpl.DRP);
         y.DRP := convert(x(u downto u-w+1), tpl.DRP);
         u := u - w;
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u downto u-w+1), tpl.STATUS);
         u := u - w;
         w := width(tpl.DEBUG);
         y.DEBUG := convert(x(u downto u-w+1), tpl.DEBUG);
         u := u - w;
         w := width(tpl.COUNTERS);
         y.COUNTERS := convert(x(u downto u-w+1), tpl.COUNTERS);
         u := u - w;
         w := width(tpl.USER_FREQ);
         y.USER_FREQ := convert(x(u downto u-w+1), tpl.USER_FREQ);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_MON_t) return C2C_INTF_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: C2C_INTF_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.DRP);
      w := w + width(x.STATUS);
      w := w + width(x.DEBUG);
      w := w + width(x.COUNTERS);
      w := w + width(x.PHY_READ_TIME);
      w := w + width(x.ENABLE_PHY_CTRL);
      w := w + width(x.PHY_LANE_STABLE);
      w := w + width(x.PHY_LANE_ERRORS_TO_RESET);
      w := w + width(x.PHY_MAX_SINGLE_BIT_ERROR_RATE);
      w := w + width(x.PHY_MAX_MULTI_BIT_ERROR_RATE);
      return w;
   end function width;
   function convert(x: C2C_INTF_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.DRP);
         y(u to u+w-1) := convert(x.DRP, y(u to u+w-1));
         u := u + w;
         w := width(x.STATUS);
         y(u to u+w-1) := convert(x.STATUS, y(u to u+w-1));
         u := u + w;
         w := width(x.DEBUG);
         y(u to u+w-1) := convert(x.DEBUG, y(u to u+w-1));
         u := u + w;
         w := width(x.COUNTERS);
         y(u to u+w-1) := convert(x.COUNTERS, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_READ_TIME);
         y(u to u+w-1) := convert(x.PHY_READ_TIME, y(u to u+w-1));
         u := u + w;
         w := width(x.ENABLE_PHY_CTRL);
         y(u to u+w-1) := convert(x.ENABLE_PHY_CTRL, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_LANE_STABLE);
         y(u to u+w-1) := convert(x.PHY_LANE_STABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_LANE_ERRORS_TO_RESET);
         y(u to u+w-1) := convert(x.PHY_LANE_ERRORS_TO_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_MAX_SINGLE_BIT_ERROR_RATE);
         y(u to u+w-1) := convert(x.PHY_MAX_SINGLE_BIT_ERROR_RATE, y(u to u+w-1));
         u := u + w;
         w := width(x.PHY_MAX_MULTI_BIT_ERROR_RATE);
         y(u to u+w-1) := convert(x.PHY_MAX_MULTI_BIT_ERROR_RATE, y(u to u+w-1));
      else
         w := width(x.DRP);
         y(u downto u-w+1) := convert(x.DRP, y(u downto u-w+1));
         u := u - w;
         w := width(x.STATUS);
         y(u downto u-w+1) := convert(x.STATUS, y(u downto u-w+1));
         u := u - w;
         w := width(x.DEBUG);
         y(u downto u-w+1) := convert(x.DEBUG, y(u downto u-w+1));
         u := u - w;
         w := width(x.COUNTERS);
         y(u downto u-w+1) := convert(x.COUNTERS, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_READ_TIME);
         y(u downto u-w+1) := convert(x.PHY_READ_TIME, y(u downto u-w+1));
         u := u - w;
         w := width(x.ENABLE_PHY_CTRL);
         y(u downto u-w+1) := convert(x.ENABLE_PHY_CTRL, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_LANE_STABLE);
         y(u downto u-w+1) := convert(x.PHY_LANE_STABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_LANE_ERRORS_TO_RESET);
         y(u downto u-w+1) := convert(x.PHY_LANE_ERRORS_TO_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_MAX_SINGLE_BIT_ERROR_RATE);
         y(u downto u-w+1) := convert(x.PHY_MAX_SINGLE_BIT_ERROR_RATE, y(u downto u-w+1));
         u := u - w;
         w := width(x.PHY_MAX_MULTI_BIT_ERROR_RATE);
         y(u downto u-w+1) := convert(x.PHY_MAX_MULTI_BIT_ERROR_RATE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: C2C_INTF_CTRL_t) return C2C_INTF_CTRL_t is
      variable y : C2C_INTF_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.DRP);
         y.DRP := convert(x(u to u+w-1), tpl.DRP);
         u := u + w;
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u to u+w-1), tpl.STATUS);
         u := u + w;
         w := width(tpl.DEBUG);
         y.DEBUG := convert(x(u to u+w-1), tpl.DEBUG);
         u := u + w;
         w := width(tpl.COUNTERS);
         y.COUNTERS := convert(x(u to u+w-1), tpl.COUNTERS);
         u := u + w;
         w := width(tpl.PHY_READ_TIME);
         y.PHY_READ_TIME := convert(x(u to u+w-1), tpl.PHY_READ_TIME);
         u := u + w;
         w := width(tpl.ENABLE_PHY_CTRL);
         y.ENABLE_PHY_CTRL := convert(x(u to u+w-1), tpl.ENABLE_PHY_CTRL);
         u := u + w;
         w := width(tpl.PHY_LANE_STABLE);
         y.PHY_LANE_STABLE := convert(x(u to u+w-1), tpl.PHY_LANE_STABLE);
         u := u + w;
         w := width(tpl.PHY_LANE_ERRORS_TO_RESET);
         y.PHY_LANE_ERRORS_TO_RESET := convert(x(u to u+w-1), tpl.PHY_LANE_ERRORS_TO_RESET);
         u := u + w;
         w := width(tpl.PHY_MAX_SINGLE_BIT_ERROR_RATE);
         y.PHY_MAX_SINGLE_BIT_ERROR_RATE := convert(x(u to u+w-1), tpl.PHY_MAX_SINGLE_BIT_ERROR_RATE);
         u := u + w;
         w := width(tpl.PHY_MAX_MULTI_BIT_ERROR_RATE);
         y.PHY_MAX_MULTI_BIT_ERROR_RATE := convert(x(u to u+w-1), tpl.PHY_MAX_MULTI_BIT_ERROR_RATE);
      else
         w := width(tpl.DRP);
         y.DRP := convert(x(u downto u-w+1), tpl.DRP);
         u := u - w;
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u downto u-w+1), tpl.STATUS);
         u := u - w;
         w := width(tpl.DEBUG);
         y.DEBUG := convert(x(u downto u-w+1), tpl.DEBUG);
         u := u - w;
         w := width(tpl.COUNTERS);
         y.COUNTERS := convert(x(u downto u-w+1), tpl.COUNTERS);
         u := u - w;
         w := width(tpl.PHY_READ_TIME);
         y.PHY_READ_TIME := convert(x(u downto u-w+1), tpl.PHY_READ_TIME);
         u := u - w;
         w := width(tpl.ENABLE_PHY_CTRL);
         y.ENABLE_PHY_CTRL := convert(x(u downto u-w+1), tpl.ENABLE_PHY_CTRL);
         u := u - w;
         w := width(tpl.PHY_LANE_STABLE);
         y.PHY_LANE_STABLE := convert(x(u downto u-w+1), tpl.PHY_LANE_STABLE);
         u := u - w;
         w := width(tpl.PHY_LANE_ERRORS_TO_RESET);
         y.PHY_LANE_ERRORS_TO_RESET := convert(x(u downto u-w+1), tpl.PHY_LANE_ERRORS_TO_RESET);
         u := u - w;
         w := width(tpl.PHY_MAX_SINGLE_BIT_ERROR_RATE);
         y.PHY_MAX_SINGLE_BIT_ERROR_RATE := convert(x(u downto u-w+1), tpl.PHY_MAX_SINGLE_BIT_ERROR_RATE);
         u := u - w;
         w := width(tpl.PHY_MAX_MULTI_BIT_ERROR_RATE);
         y.PHY_MAX_MULTI_BIT_ERROR_RATE := convert(x(u downto u-w+1), tpl.PHY_MAX_MULTI_BIT_ERROR_RATE);
      end if;
      return y;
   end function convert;
   function zero(tpl: C2C_INTF_CTRL_t) return C2C_INTF_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

end package body C2C_INTF_CTRL;
