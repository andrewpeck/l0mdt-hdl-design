-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package HAL_CTRL is

   -- Custom types and functions --

   type HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t is record
      READY : std_logic;
      FEC_ERR_CNT : std_logic_vector(16 - 1 downto 0);
   end record HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t;
   attribute w of HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t : type is 17;
   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t;

   type HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY is array(2 -1 downto 0) of HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t;
   attribute w of HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY : type is 34;
   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY) return integer;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY;

   type HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t is record
      RESET : std_logic;
   end record HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t;
   attribute w of HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t : type is 1;
   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t;

   type HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY is array(2 -1 downto 0) of HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t;
   attribute w of HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY : type is 2;
   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY) return integer;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY;

   type HAL_CSM_CSM_LPGBT_UPLINK_MON_t is record
      UPLINK : HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY;
   end record HAL_CSM_CSM_LPGBT_UPLINK_MON_t;
   attribute w of HAL_CSM_CSM_LPGBT_UPLINK_MON_t : type is 34;
   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_MON_t) return HAL_CSM_CSM_LPGBT_UPLINK_MON_t;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_MON_t) return HAL_CSM_CSM_LPGBT_UPLINK_MON_t;

   type HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t is record
      UPLINK : HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY;
   end record HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t;
   attribute w of HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t : type is 2;
   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t;

   type HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t is record
      READY : std_logic;
   end record HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t;
   attribute w of HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t : type is 1;
   function width(x: HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t) return HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t;
   function zero(tpl: HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t) return HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t;

   type HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t is record
      RESET : std_logic;
   end record HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t;
   attribute w of HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t : type is 1;
   function width(x: HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t;

   type HAL_CSM_CSM_LPGBT_MON_t is record
      UPLINK : HAL_CSM_CSM_LPGBT_UPLINK_MON_t;
      DOWNLINK : HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t;
   end record HAL_CSM_CSM_LPGBT_MON_t;
   attribute w of HAL_CSM_CSM_LPGBT_MON_t : type is 35;
   function width(x: HAL_CSM_CSM_LPGBT_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_LPGBT_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_MON_t) return HAL_CSM_CSM_LPGBT_MON_t;
   function zero(tpl: HAL_CSM_CSM_LPGBT_MON_t) return HAL_CSM_CSM_LPGBT_MON_t;

   type HAL_CSM_CSM_LPGBT_CTRL_t is record
      UPLINK : HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t;
      DOWNLINK : HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t;
   end record HAL_CSM_CSM_LPGBT_CTRL_t;
   attribute w of HAL_CSM_CSM_LPGBT_CTRL_t : type is 3;
   function width(x: HAL_CSM_CSM_LPGBT_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_LPGBT_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_CTRL_t) return HAL_CSM_CSM_LPGBT_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_LPGBT_CTRL_t) return HAL_CSM_CSM_LPGBT_CTRL_t;

   type HAL_CSM_CSM_SC_MASTER_IC_MON_t is record
      RX_DATA_FROM_GBTX : std_logic_vector(8 - 1 downto 0);
      TX_READY : std_logic;
      RX_DATA : std_logic_vector(32 - 1 downto 0);
      RX_CHIP_ADR : std_logic_vector(7 - 1 downto 0);
      RX_UP_PARITY_OK : std_logic;
      RX_DOWN_PARITY_OK : std_logic;
      RX_ERR : std_logic;
      RX_VALID : std_logic;
      RX_REG_ADR : std_logic_vector(16 - 1 downto 0);
      RX_LENGTH : std_logic_vector(16 - 1 downto 0);
   end record HAL_CSM_CSM_SC_MASTER_IC_MON_t;
   attribute w of HAL_CSM_CSM_SC_MASTER_IC_MON_t : type is 84;
   function width(x: HAL_CSM_CSM_SC_MASTER_IC_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_MASTER_IC_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_IC_MON_t) return HAL_CSM_CSM_SC_MASTER_IC_MON_t;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_IC_MON_t) return HAL_CSM_CSM_SC_MASTER_IC_MON_t;

   type HAL_CSM_CSM_SC_MASTER_IC_CTRL_t is record
      TX_START_WRITE : std_logic;
      TX_START_READ : std_logic;
      TX_REGISTER_ADDR : std_logic_vector(16 - 1 downto 0);
      TX_NUM_BYTES_TO_READ : std_logic_vector(16 - 1 downto 0);
      TX_DATA_TO_GBTX : std_logic_vector(8 - 1 downto 0);
      TX_GBTX_ADDR : std_logic_vector(8 - 1 downto 0);
      TX_WR : std_logic;
   end record HAL_CSM_CSM_SC_MASTER_IC_CTRL_t;
   attribute w of HAL_CSM_CSM_SC_MASTER_IC_CTRL_t : type is 51;
   function width(x: HAL_CSM_CSM_SC_MASTER_IC_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_MASTER_IC_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_IC_CTRL_t) return HAL_CSM_CSM_SC_MASTER_IC_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_IC_CTRL_t) return HAL_CSM_CSM_SC_MASTER_IC_CTRL_t;

   type HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t is record
      RX_LEN : std_logic_vector(8 - 1 downto 0);
      RX_ADDRESS : std_logic_vector(8 - 1 downto 0);
      RX_CONTROL : std_logic_vector(8 - 1 downto 0);
      RX_TRANSID : std_logic_vector(8 - 1 downto 0);
      RX_ERR : std_logic_vector(8 - 1 downto 0);
      RX_RECEIVED : std_logic;
      RX_CHANNEL : std_logic_vector(8 - 1 downto 0);
      RX_DATA : std_logic_vector(32 - 1 downto 0);
   end record HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t;
   attribute w of HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t : type is 81;
   function width(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t;

   type HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY is array(4 -1 downto 0) of HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t;
   attribute w of HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY : type is 324;
   function width(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY) return integer;
   function convert(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY;
   function convert(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY;

   type HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t is record
      RX : HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY;
   end record HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t;
   attribute w of HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t : type is 324;
   function width(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t) return HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t) return HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t;

   type HAL_CSM_CSM_SC_MASTER_MON_t is record
      IC : HAL_CSM_CSM_SC_MASTER_IC_MON_t;
      SCA_RX : HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t;
   end record HAL_CSM_CSM_SC_MASTER_MON_t;
   attribute w of HAL_CSM_CSM_SC_MASTER_MON_t : type is 408;
   function width(x: HAL_CSM_CSM_SC_MASTER_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_MASTER_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_MON_t) return HAL_CSM_CSM_SC_MASTER_MON_t;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_MON_t) return HAL_CSM_CSM_SC_MASTER_MON_t;

   type HAL_CSM_CSM_SC_MASTER_CTRL_t is record
      TX_RESET : std_logic;
      RX_RESET : std_logic;
      IC : HAL_CSM_CSM_SC_MASTER_IC_CTRL_t;
      TX_CMD : std_logic_vector(8 - 1 downto 0);
      TX_ADDRESS : std_logic_vector(8 - 1 downto 0);
      TX_TRANSID : std_logic_vector(8 - 1 downto 0);
      TX_CHANNEL : std_logic_vector(8 - 1 downto 0);
      TX_DATA : std_logic_vector(32 - 1 downto 0);
      SCA_ENABLE : std_logic_vector(4 - 1 downto 0);
      START_RESET : std_logic;
      START_CONNECT : std_logic;
      START_COMMAND : std_logic;
      INJ_CRC_ERR : std_logic;
   end record HAL_CSM_CSM_SC_MASTER_CTRL_t;
   attribute w of HAL_CSM_CSM_SC_MASTER_CTRL_t : type is 125;
   function width(x: HAL_CSM_CSM_SC_MASTER_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_MASTER_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_CTRL_t) return HAL_CSM_CSM_SC_MASTER_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_CTRL_t) return HAL_CSM_CSM_SC_MASTER_CTRL_t;

   type HAL_CSM_CSM_SC_SLAVE_IC_MON_t is record
      RX_DATA_FROM_GBTX : std_logic_vector(8 - 1 downto 0);
      TX_READY : std_logic;
      RX_DATA : std_logic_vector(32 - 1 downto 0);
      RX_CHIP_ADR : std_logic_vector(7 - 1 downto 0);
      RX_UP_PARITY_OK : std_logic;
      RX_DOWN_PARITY_OK : std_logic;
      RX_ERR : std_logic;
      RX_VALID : std_logic;
      RX_REG_ADR : std_logic_vector(16 - 1 downto 0);
      RX_LENGTH : std_logic_vector(16 - 1 downto 0);
   end record HAL_CSM_CSM_SC_SLAVE_IC_MON_t;
   attribute w of HAL_CSM_CSM_SC_SLAVE_IC_MON_t : type is 84;
   function width(x: HAL_CSM_CSM_SC_SLAVE_IC_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_SLAVE_IC_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_SLAVE_IC_MON_t) return HAL_CSM_CSM_SC_SLAVE_IC_MON_t;
   function zero(tpl: HAL_CSM_CSM_SC_SLAVE_IC_MON_t) return HAL_CSM_CSM_SC_SLAVE_IC_MON_t;

   type HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t is record
      TX_START_WRITE : std_logic;
      TX_START_READ : std_logic;
      TX_REGISTER_ADDR : std_logic_vector(16 - 1 downto 0);
      TX_NUM_BYTES_TO_READ : std_logic_vector(16 - 1 downto 0);
      TX_DATA_TO_GBTX : std_logic_vector(8 - 1 downto 0);
      TX_GBTX_ADDR : std_logic_vector(8 - 1 downto 0);
      TX_WR : std_logic;
   end record HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t;
   attribute w of HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t : type is 51;
   function width(x: HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t) return HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t) return HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t;

   type HAL_CSM_CSM_SC_SLAVE_MON_t is record
      IC : HAL_CSM_CSM_SC_SLAVE_IC_MON_t;
   end record HAL_CSM_CSM_SC_SLAVE_MON_t;
   attribute w of HAL_CSM_CSM_SC_SLAVE_MON_t : type is 84;
   function width(x: HAL_CSM_CSM_SC_SLAVE_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_SLAVE_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_SLAVE_MON_t) return HAL_CSM_CSM_SC_SLAVE_MON_t;
   function zero(tpl: HAL_CSM_CSM_SC_SLAVE_MON_t) return HAL_CSM_CSM_SC_SLAVE_MON_t;

   type HAL_CSM_CSM_SC_SLAVE_CTRL_t is record
      TX_RESET : std_logic;
      RX_RESET : std_logic;
      IC : HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t;
   end record HAL_CSM_CSM_SC_SLAVE_CTRL_t;
   attribute w of HAL_CSM_CSM_SC_SLAVE_CTRL_t : type is 53;
   function width(x: HAL_CSM_CSM_SC_SLAVE_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_SLAVE_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_SLAVE_CTRL_t) return HAL_CSM_CSM_SC_SLAVE_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_SC_SLAVE_CTRL_t) return HAL_CSM_CSM_SC_SLAVE_CTRL_t;

   type HAL_CSM_CSM_SC_MON_t is record
      MASTER : HAL_CSM_CSM_SC_MASTER_MON_t;
      SLAVE : HAL_CSM_CSM_SC_SLAVE_MON_t;
   end record HAL_CSM_CSM_SC_MON_t;
   attribute w of HAL_CSM_CSM_SC_MON_t : type is 492;
   function width(x: HAL_CSM_CSM_SC_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MON_t) return HAL_CSM_CSM_SC_MON_t;
   function zero(tpl: HAL_CSM_CSM_SC_MON_t) return HAL_CSM_CSM_SC_MON_t;

   type HAL_CSM_CSM_SC_CTRL_t is record
      MASTER : HAL_CSM_CSM_SC_MASTER_CTRL_t;
      FRAME_FORMAT : std_logic;
      SLAVE : HAL_CSM_CSM_SC_SLAVE_CTRL_t;
   end record HAL_CSM_CSM_SC_CTRL_t;
   attribute w of HAL_CSM_CSM_SC_CTRL_t : type is 179;
   function width(x: HAL_CSM_CSM_SC_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_SC_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_CTRL_t) return HAL_CSM_CSM_SC_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_SC_CTRL_t) return HAL_CSM_CSM_SC_CTRL_t;

   type HAL_CSM_CSM_CONFIG_MON_t is record
      master_link_id : std_logic_vector(6 - 1 downto 0);
      servant_link_id : std_logic_vector(6 - 1 downto 0);
      station : std_logic_vector(3 - 1 downto 0);
      polmux : std_logic_vector(6 - 1 downto 0);
      en : std_logic_vector(20 - 1 downto 0);
      legacy : std_logic_vector(20 - 1 downto 0);
   end record HAL_CSM_CSM_CONFIG_MON_t;
   attribute w of HAL_CSM_CSM_CONFIG_MON_t : type is 61;
   function width(x: HAL_CSM_CSM_CONFIG_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_CONFIG_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_CONFIG_MON_t) return HAL_CSM_CSM_CONFIG_MON_t;
   function zero(tpl: HAL_CSM_CSM_CONFIG_MON_t) return HAL_CSM_CSM_CONFIG_MON_t;

   type HAL_CSM_CSM_MON_t is record
      LPGBT : HAL_CSM_CSM_LPGBT_MON_t;
      SC : HAL_CSM_CSM_SC_MON_t;
      CONFIG : HAL_CSM_CSM_CONFIG_MON_t;
   end record HAL_CSM_CSM_MON_t;
   attribute w of HAL_CSM_CSM_MON_t : type is 588;
   function width(x: HAL_CSM_CSM_MON_t) return natural;
   function convert(x: HAL_CSM_CSM_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_MON_t) return HAL_CSM_CSM_MON_t;
   function zero(tpl: HAL_CSM_CSM_MON_t) return HAL_CSM_CSM_MON_t;

   type HAL_CSM_CSM_MON_t_ARRAY is array(36 -1 downto 0) of HAL_CSM_CSM_MON_t;
   attribute w of HAL_CSM_CSM_MON_t_ARRAY : type is 21168;
   function width(x: HAL_CSM_CSM_MON_t_ARRAY) return integer;
   function convert(x: HAL_CSM_CSM_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_MON_t_ARRAY) return HAL_CSM_CSM_MON_t_ARRAY;
   function zero(tpl: HAL_CSM_CSM_MON_t_ARRAY) return HAL_CSM_CSM_MON_t_ARRAY;
   function convert(x: HAL_CSM_CSM_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_MON_t_ARRAY) return HAL_CSM_CSM_MON_t_ARRAY;

   type HAL_CSM_CSM_CTRL_t is record
      LPGBT : HAL_CSM_CSM_LPGBT_CTRL_t;
      SC : HAL_CSM_CSM_SC_CTRL_t;
   end record HAL_CSM_CSM_CTRL_t;
   attribute w of HAL_CSM_CSM_CTRL_t : type is 182;
   function width(x: HAL_CSM_CSM_CTRL_t) return natural;
   function convert(x: HAL_CSM_CSM_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_CTRL_t) return HAL_CSM_CSM_CTRL_t;
   function zero(tpl: HAL_CSM_CSM_CTRL_t) return HAL_CSM_CSM_CTRL_t;

   type HAL_CSM_CSM_CTRL_t_ARRAY is array(36 -1 downto 0) of HAL_CSM_CSM_CTRL_t;
   attribute w of HAL_CSM_CSM_CTRL_t_ARRAY : type is 6552;
   function width(x: HAL_CSM_CSM_CTRL_t_ARRAY) return integer;
   function convert(x: HAL_CSM_CSM_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_CTRL_t_ARRAY) return HAL_CSM_CSM_CTRL_t_ARRAY;
   function zero(tpl: HAL_CSM_CSM_CTRL_t_ARRAY) return HAL_CSM_CSM_CTRL_t_ARRAY;
   function convert(x: HAL_CSM_CSM_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_CTRL_t_ARRAY) return HAL_CSM_CSM_CTRL_t_ARRAY;

   type HAL_CSM_MON_t is record
      CSM : HAL_CSM_CSM_MON_t_ARRAY;
   end record HAL_CSM_MON_t;
   attribute w of HAL_CSM_MON_t : type is 21168;
   function width(x: HAL_CSM_MON_t) return natural;
   function convert(x: HAL_CSM_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_MON_t) return HAL_CSM_MON_t;
   function zero(tpl: HAL_CSM_MON_t) return HAL_CSM_MON_t;

   type HAL_CSM_CTRL_t is record
      CSM : HAL_CSM_CSM_CTRL_t_ARRAY;
   end record HAL_CSM_CTRL_t;
   attribute w of HAL_CSM_CTRL_t : type is 6552;
   function width(x: HAL_CSM_CTRL_t) return natural;
   function convert(x: HAL_CSM_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CTRL_t) return HAL_CSM_CTRL_t;
   function zero(tpl: HAL_CSM_CTRL_t) return HAL_CSM_CTRL_t;

   type HAL_SL_RESET_CTRL_t is record
      rx_comma : std_logic;
      rx_packet_former : std_logic;
      rx_counter : std_logic;
   end record HAL_SL_RESET_CTRL_t;
   attribute w of HAL_SL_RESET_CTRL_t : type is 3;
   function width(x: HAL_SL_RESET_CTRL_t) return natural;
   function convert(x: HAL_SL_RESET_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_SL_RESET_CTRL_t) return HAL_SL_RESET_CTRL_t;
   function zero(tpl: HAL_SL_RESET_CTRL_t) return HAL_SL_RESET_CTRL_t;

   type HAL_SL_SL_TEST_MON_t is record
      ERROR_COUNTER : std_logic_vector(32 - 1 downto 0);
      WORD_COUNTER_0 : std_logic_vector(32 - 1 downto 0);
      WORD_COUNTER_1 : std_logic_vector(32 - 1 downto 0);
   end record HAL_SL_SL_TEST_MON_t;
   attribute w of HAL_SL_SL_TEST_MON_t : type is 96;
   function width(x: HAL_SL_SL_TEST_MON_t) return natural;
   function convert(x: HAL_SL_SL_TEST_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_SL_SL_TEST_MON_t) return HAL_SL_SL_TEST_MON_t;
   function zero(tpl: HAL_SL_SL_TEST_MON_t) return HAL_SL_SL_TEST_MON_t;

   type HAL_SL_SL_TEST_MON_t_ARRAY is array(12 -1 downto 0) of HAL_SL_SL_TEST_MON_t;
   attribute w of HAL_SL_SL_TEST_MON_t_ARRAY : type is 1152;
   function width(x: HAL_SL_SL_TEST_MON_t_ARRAY) return integer;
   function convert(x: HAL_SL_SL_TEST_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_SL_SL_TEST_MON_t_ARRAY) return HAL_SL_SL_TEST_MON_t_ARRAY;
   function zero(tpl: HAL_SL_SL_TEST_MON_t_ARRAY) return HAL_SL_SL_TEST_MON_t_ARRAY;
   function convert(x: HAL_SL_SL_TEST_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HAL_SL_SL_TEST_MON_t_ARRAY) return HAL_SL_SL_TEST_MON_t_ARRAY;

   type HAL_SL_MON_t is record
      RX_COMMA_LOCK : std_logic_vector(12 - 1 downto 0);
      RX_PACKET_LOCKED : std_logic_vector(12 - 1 downto 0);
      SL_TEST : HAL_SL_SL_TEST_MON_t_ARRAY;
   end record HAL_SL_MON_t;
   attribute w of HAL_SL_MON_t : type is 1176;
   function width(x: HAL_SL_MON_t) return natural;
   function convert(x: HAL_SL_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_SL_MON_t) return HAL_SL_MON_t;
   function zero(tpl: HAL_SL_MON_t) return HAL_SL_MON_t;

   type HAL_SL_CTRL_t is record
      TX_ENA_TEST_PATTERN : std_logic_vector(12 - 1 downto 0);
      COMMA_EVEN_SLIDES : std_logic_vector(12 - 1 downto 0);
      RESET : HAL_SL_RESET_CTRL_t;
   end record HAL_SL_CTRL_t;
   attribute w of HAL_SL_CTRL_t : type is 27;
   function width(x: HAL_SL_CTRL_t) return natural;
   function convert(x: HAL_SL_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_SL_CTRL_t) return HAL_SL_CTRL_t;
   function zero(tpl: HAL_SL_CTRL_t) return HAL_SL_CTRL_t;

   type HAL_MON_t is record
      CSM : HAL_CSM_MON_t;
      SL : HAL_SL_MON_t;
   end record HAL_MON_t;
   attribute w of HAL_MON_t : type is 22344;
   function width(x: HAL_MON_t) return natural;
   function convert(x: HAL_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_MON_t) return HAL_MON_t;
   function zero(tpl: HAL_MON_t) return HAL_MON_t;

   type HAL_CTRL_t is record
      RESET_DOWNLINKS : std_logic;
      RESET_UPLINKS : std_logic;
      RESET_COUNTERS : std_logic;
      CSM : HAL_CSM_CTRL_t;
      SL : HAL_SL_CTRL_t;
   end record HAL_CTRL_t;
   attribute w of HAL_CTRL_t : type is 6582;
   function width(x: HAL_CTRL_t) return natural;
   function convert(x: HAL_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HAL_CTRL_t) return HAL_CTRL_t;
   function zero(tpl: HAL_CTRL_t) return HAL_CTRL_t;

end package HAL_CTRL;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package body HAL_CTRL is

   -- Custom types and functions --

   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.READY);
      w := w + width(x.FEC_ERR_CNT);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.READY);
         y(u to u+w-1) := convert(x.READY, y(u to u+w-1));
         u := u + w;
         w := width(x.FEC_ERR_CNT);
         y(u to u+w-1) := convert(x.FEC_ERR_CNT, y(u to u+w-1));
      else
         w := width(x.READY);
         y(u downto u-w+1) := convert(x.READY, y(u downto u-w+1));
         u := u - w;
         w := width(x.FEC_ERR_CNT);
         y(u downto u-w+1) := convert(x.FEC_ERR_CNT, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t is
      variable y : HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.READY);
         y.READY := convert(x(u to u+w-1), tpl.READY);
         u := u + w;
         w := width(tpl.FEC_ERR_CNT);
         y.FEC_ERR_CNT := convert(x(u to u+w-1), tpl.FEC_ERR_CNT);
      else
         w := width(tpl.READY);
         y.READY := convert(x(u downto u-w+1), tpl.READY);
         u := u - w;
         w := width(tpl.FEC_ERR_CNT);
         y.FEC_ERR_CNT := convert(x(u downto u-w+1), tpl.FEC_ERR_CNT);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY is
      variable y : HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY is
      variable y : HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET);
         y(u to u+w-1) := convert(x.RESET, y(u to u+w-1));
      else
         w := width(x.RESET);
         y(u downto u-w+1) := convert(x.RESET, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t is
      variable y : HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET);
         y.RESET := convert(x(u to u+w-1), tpl.RESET);
      else
         w := width(tpl.RESET);
         y.RESET := convert(x(u downto u-w+1), tpl.RESET);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY is
      variable y : HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY) return HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY is
      variable y : HAL_CSM_CSM_LPGBT_UPLINK_UPLINK_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.UPLINK);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.UPLINK);
         y(u to u+w-1) := convert(x.UPLINK, y(u to u+w-1));
      else
         w := width(x.UPLINK);
         y(u downto u-w+1) := convert(x.UPLINK, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_MON_t) return HAL_CSM_CSM_LPGBT_UPLINK_MON_t is
      variable y : HAL_CSM_CSM_LPGBT_UPLINK_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.UPLINK);
         y.UPLINK := convert(x(u to u+w-1), tpl.UPLINK);
      else
         w := width(tpl.UPLINK);
         y.UPLINK := convert(x(u downto u-w+1), tpl.UPLINK);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_MON_t) return HAL_CSM_CSM_LPGBT_UPLINK_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.UPLINK);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.UPLINK);
         y(u to u+w-1) := convert(x.UPLINK, y(u to u+w-1));
      else
         w := width(x.UPLINK);
         y(u downto u-w+1) := convert(x.UPLINK, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t is
      variable y : HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.UPLINK);
         y.UPLINK := convert(x(u to u+w-1), tpl.UPLINK);
      else
         w := width(tpl.UPLINK);
         y.UPLINK := convert(x(u downto u-w+1), tpl.UPLINK);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_UPLINK_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.READY);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.READY);
         y(u to u+w-1) := convert(x.READY, y(u to u+w-1));
      else
         w := width(x.READY);
         y(u downto u-w+1) := convert(x.READY, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t) return HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t is
      variable y : HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.READY);
         y.READY := convert(x(u to u+w-1), tpl.READY);
      else
         w := width(tpl.READY);
         y.READY := convert(x(u downto u-w+1), tpl.READY);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t) return HAL_CSM_CSM_LPGBT_DOWNLINK_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET);
         y(u to u+w-1) := convert(x.RESET, y(u to u+w-1));
      else
         w := width(x.RESET);
         y(u downto u-w+1) := convert(x.RESET, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t is
      variable y : HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET);
         y.RESET := convert(x(u to u+w-1), tpl.RESET);
      else
         w := width(tpl.RESET);
         y.RESET := convert(x(u downto u-w+1), tpl.RESET);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t) return HAL_CSM_CSM_LPGBT_DOWNLINK_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_LPGBT_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.UPLINK);
      w := w + width(x.DOWNLINK);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.UPLINK);
         y(u to u+w-1) := convert(x.UPLINK, y(u to u+w-1));
         u := u + w;
         w := width(x.DOWNLINK);
         y(u to u+w-1) := convert(x.DOWNLINK, y(u to u+w-1));
      else
         w := width(x.UPLINK);
         y(u downto u-w+1) := convert(x.UPLINK, y(u downto u-w+1));
         u := u - w;
         w := width(x.DOWNLINK);
         y(u downto u-w+1) := convert(x.DOWNLINK, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_MON_t) return HAL_CSM_CSM_LPGBT_MON_t is
      variable y : HAL_CSM_CSM_LPGBT_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.UPLINK);
         y.UPLINK := convert(x(u to u+w-1), tpl.UPLINK);
         u := u + w;
         w := width(tpl.DOWNLINK);
         y.DOWNLINK := convert(x(u to u+w-1), tpl.DOWNLINK);
      else
         w := width(tpl.UPLINK);
         y.UPLINK := convert(x(u downto u-w+1), tpl.UPLINK);
         u := u - w;
         w := width(tpl.DOWNLINK);
         y.DOWNLINK := convert(x(u downto u-w+1), tpl.DOWNLINK);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_MON_t) return HAL_CSM_CSM_LPGBT_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_LPGBT_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.UPLINK);
      w := w + width(x.DOWNLINK);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_LPGBT_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.UPLINK);
         y(u to u+w-1) := convert(x.UPLINK, y(u to u+w-1));
         u := u + w;
         w := width(x.DOWNLINK);
         y(u to u+w-1) := convert(x.DOWNLINK, y(u to u+w-1));
      else
         w := width(x.UPLINK);
         y(u downto u-w+1) := convert(x.UPLINK, y(u downto u-w+1));
         u := u - w;
         w := width(x.DOWNLINK);
         y(u downto u-w+1) := convert(x.DOWNLINK, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_LPGBT_CTRL_t) return HAL_CSM_CSM_LPGBT_CTRL_t is
      variable y : HAL_CSM_CSM_LPGBT_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.UPLINK);
         y.UPLINK := convert(x(u to u+w-1), tpl.UPLINK);
         u := u + w;
         w := width(tpl.DOWNLINK);
         y.DOWNLINK := convert(x(u to u+w-1), tpl.DOWNLINK);
      else
         w := width(tpl.UPLINK);
         y.UPLINK := convert(x(u downto u-w+1), tpl.UPLINK);
         u := u - w;
         w := width(tpl.DOWNLINK);
         y.DOWNLINK := convert(x(u downto u-w+1), tpl.DOWNLINK);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_LPGBT_CTRL_t) return HAL_CSM_CSM_LPGBT_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_MASTER_IC_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RX_DATA_FROM_GBTX);
      w := w + width(x.TX_READY);
      w := w + width(x.RX_DATA);
      w := w + width(x.RX_CHIP_ADR);
      w := w + width(x.RX_UP_PARITY_OK);
      w := w + width(x.RX_DOWN_PARITY_OK);
      w := w + width(x.RX_ERR);
      w := w + width(x.RX_VALID);
      w := w + width(x.RX_REG_ADR);
      w := w + width(x.RX_LENGTH);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_MASTER_IC_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RX_DATA_FROM_GBTX);
         y(u to u+w-1) := convert(x.RX_DATA_FROM_GBTX, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_READY);
         y(u to u+w-1) := convert(x.TX_READY, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_DATA);
         y(u to u+w-1) := convert(x.RX_DATA, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_CHIP_ADR);
         y(u to u+w-1) := convert(x.RX_CHIP_ADR, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_UP_PARITY_OK);
         y(u to u+w-1) := convert(x.RX_UP_PARITY_OK, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_DOWN_PARITY_OK);
         y(u to u+w-1) := convert(x.RX_DOWN_PARITY_OK, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_ERR);
         y(u to u+w-1) := convert(x.RX_ERR, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_VALID);
         y(u to u+w-1) := convert(x.RX_VALID, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_REG_ADR);
         y(u to u+w-1) := convert(x.RX_REG_ADR, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_LENGTH);
         y(u to u+w-1) := convert(x.RX_LENGTH, y(u to u+w-1));
      else
         w := width(x.RX_DATA_FROM_GBTX);
         y(u downto u-w+1) := convert(x.RX_DATA_FROM_GBTX, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_READY);
         y(u downto u-w+1) := convert(x.TX_READY, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_DATA);
         y(u downto u-w+1) := convert(x.RX_DATA, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_CHIP_ADR);
         y(u downto u-w+1) := convert(x.RX_CHIP_ADR, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_UP_PARITY_OK);
         y(u downto u-w+1) := convert(x.RX_UP_PARITY_OK, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_DOWN_PARITY_OK);
         y(u downto u-w+1) := convert(x.RX_DOWN_PARITY_OK, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_ERR);
         y(u downto u-w+1) := convert(x.RX_ERR, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_VALID);
         y(u downto u-w+1) := convert(x.RX_VALID, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_REG_ADR);
         y(u downto u-w+1) := convert(x.RX_REG_ADR, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_LENGTH);
         y(u downto u-w+1) := convert(x.RX_LENGTH, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_IC_MON_t) return HAL_CSM_CSM_SC_MASTER_IC_MON_t is
      variable y : HAL_CSM_CSM_SC_MASTER_IC_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RX_DATA_FROM_GBTX);
         y.RX_DATA_FROM_GBTX := convert(x(u to u+w-1), tpl.RX_DATA_FROM_GBTX);
         u := u + w;
         w := width(tpl.TX_READY);
         y.TX_READY := convert(x(u to u+w-1), tpl.TX_READY);
         u := u + w;
         w := width(tpl.RX_DATA);
         y.RX_DATA := convert(x(u to u+w-1), tpl.RX_DATA);
         u := u + w;
         w := width(tpl.RX_CHIP_ADR);
         y.RX_CHIP_ADR := convert(x(u to u+w-1), tpl.RX_CHIP_ADR);
         u := u + w;
         w := width(tpl.RX_UP_PARITY_OK);
         y.RX_UP_PARITY_OK := convert(x(u to u+w-1), tpl.RX_UP_PARITY_OK);
         u := u + w;
         w := width(tpl.RX_DOWN_PARITY_OK);
         y.RX_DOWN_PARITY_OK := convert(x(u to u+w-1), tpl.RX_DOWN_PARITY_OK);
         u := u + w;
         w := width(tpl.RX_ERR);
         y.RX_ERR := convert(x(u to u+w-1), tpl.RX_ERR);
         u := u + w;
         w := width(tpl.RX_VALID);
         y.RX_VALID := convert(x(u to u+w-1), tpl.RX_VALID);
         u := u + w;
         w := width(tpl.RX_REG_ADR);
         y.RX_REG_ADR := convert(x(u to u+w-1), tpl.RX_REG_ADR);
         u := u + w;
         w := width(tpl.RX_LENGTH);
         y.RX_LENGTH := convert(x(u to u+w-1), tpl.RX_LENGTH);
      else
         w := width(tpl.RX_DATA_FROM_GBTX);
         y.RX_DATA_FROM_GBTX := convert(x(u downto u-w+1), tpl.RX_DATA_FROM_GBTX);
         u := u - w;
         w := width(tpl.TX_READY);
         y.TX_READY := convert(x(u downto u-w+1), tpl.TX_READY);
         u := u - w;
         w := width(tpl.RX_DATA);
         y.RX_DATA := convert(x(u downto u-w+1), tpl.RX_DATA);
         u := u - w;
         w := width(tpl.RX_CHIP_ADR);
         y.RX_CHIP_ADR := convert(x(u downto u-w+1), tpl.RX_CHIP_ADR);
         u := u - w;
         w := width(tpl.RX_UP_PARITY_OK);
         y.RX_UP_PARITY_OK := convert(x(u downto u-w+1), tpl.RX_UP_PARITY_OK);
         u := u - w;
         w := width(tpl.RX_DOWN_PARITY_OK);
         y.RX_DOWN_PARITY_OK := convert(x(u downto u-w+1), tpl.RX_DOWN_PARITY_OK);
         u := u - w;
         w := width(tpl.RX_ERR);
         y.RX_ERR := convert(x(u downto u-w+1), tpl.RX_ERR);
         u := u - w;
         w := width(tpl.RX_VALID);
         y.RX_VALID := convert(x(u downto u-w+1), tpl.RX_VALID);
         u := u - w;
         w := width(tpl.RX_REG_ADR);
         y.RX_REG_ADR := convert(x(u downto u-w+1), tpl.RX_REG_ADR);
         u := u - w;
         w := width(tpl.RX_LENGTH);
         y.RX_LENGTH := convert(x(u downto u-w+1), tpl.RX_LENGTH);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_IC_MON_t) return HAL_CSM_CSM_SC_MASTER_IC_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_MASTER_IC_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.TX_START_WRITE);
      w := w + width(x.TX_START_READ);
      w := w + width(x.TX_REGISTER_ADDR);
      w := w + width(x.TX_NUM_BYTES_TO_READ);
      w := w + width(x.TX_DATA_TO_GBTX);
      w := w + width(x.TX_GBTX_ADDR);
      w := w + width(x.TX_WR);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_MASTER_IC_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.TX_START_WRITE);
         y(u to u+w-1) := convert(x.TX_START_WRITE, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_START_READ);
         y(u to u+w-1) := convert(x.TX_START_READ, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_REGISTER_ADDR);
         y(u to u+w-1) := convert(x.TX_REGISTER_ADDR, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_NUM_BYTES_TO_READ);
         y(u to u+w-1) := convert(x.TX_NUM_BYTES_TO_READ, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_DATA_TO_GBTX);
         y(u to u+w-1) := convert(x.TX_DATA_TO_GBTX, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_GBTX_ADDR);
         y(u to u+w-1) := convert(x.TX_GBTX_ADDR, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_WR);
         y(u to u+w-1) := convert(x.TX_WR, y(u to u+w-1));
      else
         w := width(x.TX_START_WRITE);
         y(u downto u-w+1) := convert(x.TX_START_WRITE, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_START_READ);
         y(u downto u-w+1) := convert(x.TX_START_READ, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_REGISTER_ADDR);
         y(u downto u-w+1) := convert(x.TX_REGISTER_ADDR, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_NUM_BYTES_TO_READ);
         y(u downto u-w+1) := convert(x.TX_NUM_BYTES_TO_READ, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_DATA_TO_GBTX);
         y(u downto u-w+1) := convert(x.TX_DATA_TO_GBTX, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_GBTX_ADDR);
         y(u downto u-w+1) := convert(x.TX_GBTX_ADDR, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_WR);
         y(u downto u-w+1) := convert(x.TX_WR, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_IC_CTRL_t) return HAL_CSM_CSM_SC_MASTER_IC_CTRL_t is
      variable y : HAL_CSM_CSM_SC_MASTER_IC_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.TX_START_WRITE);
         y.TX_START_WRITE := convert(x(u to u+w-1), tpl.TX_START_WRITE);
         u := u + w;
         w := width(tpl.TX_START_READ);
         y.TX_START_READ := convert(x(u to u+w-1), tpl.TX_START_READ);
         u := u + w;
         w := width(tpl.TX_REGISTER_ADDR);
         y.TX_REGISTER_ADDR := convert(x(u to u+w-1), tpl.TX_REGISTER_ADDR);
         u := u + w;
         w := width(tpl.TX_NUM_BYTES_TO_READ);
         y.TX_NUM_BYTES_TO_READ := convert(x(u to u+w-1), tpl.TX_NUM_BYTES_TO_READ);
         u := u + w;
         w := width(tpl.TX_DATA_TO_GBTX);
         y.TX_DATA_TO_GBTX := convert(x(u to u+w-1), tpl.TX_DATA_TO_GBTX);
         u := u + w;
         w := width(tpl.TX_GBTX_ADDR);
         y.TX_GBTX_ADDR := convert(x(u to u+w-1), tpl.TX_GBTX_ADDR);
         u := u + w;
         w := width(tpl.TX_WR);
         y.TX_WR := convert(x(u to u+w-1), tpl.TX_WR);
      else
         w := width(tpl.TX_START_WRITE);
         y.TX_START_WRITE := convert(x(u downto u-w+1), tpl.TX_START_WRITE);
         u := u - w;
         w := width(tpl.TX_START_READ);
         y.TX_START_READ := convert(x(u downto u-w+1), tpl.TX_START_READ);
         u := u - w;
         w := width(tpl.TX_REGISTER_ADDR);
         y.TX_REGISTER_ADDR := convert(x(u downto u-w+1), tpl.TX_REGISTER_ADDR);
         u := u - w;
         w := width(tpl.TX_NUM_BYTES_TO_READ);
         y.TX_NUM_BYTES_TO_READ := convert(x(u downto u-w+1), tpl.TX_NUM_BYTES_TO_READ);
         u := u - w;
         w := width(tpl.TX_DATA_TO_GBTX);
         y.TX_DATA_TO_GBTX := convert(x(u downto u-w+1), tpl.TX_DATA_TO_GBTX);
         u := u - w;
         w := width(tpl.TX_GBTX_ADDR);
         y.TX_GBTX_ADDR := convert(x(u downto u-w+1), tpl.TX_GBTX_ADDR);
         u := u - w;
         w := width(tpl.TX_WR);
         y.TX_WR := convert(x(u downto u-w+1), tpl.TX_WR);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_IC_CTRL_t) return HAL_CSM_CSM_SC_MASTER_IC_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RX_LEN);
      w := w + width(x.RX_ADDRESS);
      w := w + width(x.RX_CONTROL);
      w := w + width(x.RX_TRANSID);
      w := w + width(x.RX_ERR);
      w := w + width(x.RX_RECEIVED);
      w := w + width(x.RX_CHANNEL);
      w := w + width(x.RX_DATA);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RX_LEN);
         y(u to u+w-1) := convert(x.RX_LEN, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_ADDRESS);
         y(u to u+w-1) := convert(x.RX_ADDRESS, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_CONTROL);
         y(u to u+w-1) := convert(x.RX_CONTROL, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_TRANSID);
         y(u to u+w-1) := convert(x.RX_TRANSID, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_ERR);
         y(u to u+w-1) := convert(x.RX_ERR, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_RECEIVED);
         y(u to u+w-1) := convert(x.RX_RECEIVED, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_CHANNEL);
         y(u to u+w-1) := convert(x.RX_CHANNEL, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_DATA);
         y(u to u+w-1) := convert(x.RX_DATA, y(u to u+w-1));
      else
         w := width(x.RX_LEN);
         y(u downto u-w+1) := convert(x.RX_LEN, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_ADDRESS);
         y(u downto u-w+1) := convert(x.RX_ADDRESS, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_CONTROL);
         y(u downto u-w+1) := convert(x.RX_CONTROL, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_TRANSID);
         y(u downto u-w+1) := convert(x.RX_TRANSID, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_ERR);
         y(u downto u-w+1) := convert(x.RX_ERR, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_RECEIVED);
         y(u downto u-w+1) := convert(x.RX_RECEIVED, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_CHANNEL);
         y(u downto u-w+1) := convert(x.RX_CHANNEL, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_DATA);
         y(u downto u-w+1) := convert(x.RX_DATA, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t is
      variable y : HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RX_LEN);
         y.RX_LEN := convert(x(u to u+w-1), tpl.RX_LEN);
         u := u + w;
         w := width(tpl.RX_ADDRESS);
         y.RX_ADDRESS := convert(x(u to u+w-1), tpl.RX_ADDRESS);
         u := u + w;
         w := width(tpl.RX_CONTROL);
         y.RX_CONTROL := convert(x(u to u+w-1), tpl.RX_CONTROL);
         u := u + w;
         w := width(tpl.RX_TRANSID);
         y.RX_TRANSID := convert(x(u to u+w-1), tpl.RX_TRANSID);
         u := u + w;
         w := width(tpl.RX_ERR);
         y.RX_ERR := convert(x(u to u+w-1), tpl.RX_ERR);
         u := u + w;
         w := width(tpl.RX_RECEIVED);
         y.RX_RECEIVED := convert(x(u to u+w-1), tpl.RX_RECEIVED);
         u := u + w;
         w := width(tpl.RX_CHANNEL);
         y.RX_CHANNEL := convert(x(u to u+w-1), tpl.RX_CHANNEL);
         u := u + w;
         w := width(tpl.RX_DATA);
         y.RX_DATA := convert(x(u to u+w-1), tpl.RX_DATA);
      else
         w := width(tpl.RX_LEN);
         y.RX_LEN := convert(x(u downto u-w+1), tpl.RX_LEN);
         u := u - w;
         w := width(tpl.RX_ADDRESS);
         y.RX_ADDRESS := convert(x(u downto u-w+1), tpl.RX_ADDRESS);
         u := u - w;
         w := width(tpl.RX_CONTROL);
         y.RX_CONTROL := convert(x(u downto u-w+1), tpl.RX_CONTROL);
         u := u - w;
         w := width(tpl.RX_TRANSID);
         y.RX_TRANSID := convert(x(u downto u-w+1), tpl.RX_TRANSID);
         u := u - w;
         w := width(tpl.RX_ERR);
         y.RX_ERR := convert(x(u downto u-w+1), tpl.RX_ERR);
         u := u - w;
         w := width(tpl.RX_RECEIVED);
         y.RX_RECEIVED := convert(x(u downto u-w+1), tpl.RX_RECEIVED);
         u := u - w;
         w := width(tpl.RX_CHANNEL);
         y.RX_CHANNEL := convert(x(u downto u-w+1), tpl.RX_CHANNEL);
         u := u - w;
         w := width(tpl.RX_DATA);
         y.RX_DATA := convert(x(u downto u-w+1), tpl.RX_DATA);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY is
      variable y : HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY) return HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY is
      variable y : HAL_CSM_CSM_SC_MASTER_SCA_RX_RX_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RX);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RX);
         y(u to u+w-1) := convert(x.RX, y(u to u+w-1));
      else
         w := width(x.RX);
         y(u downto u-w+1) := convert(x.RX, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t) return HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t is
      variable y : HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RX);
         y.RX := convert(x(u to u+w-1), tpl.RX);
      else
         w := width(tpl.RX);
         y.RX := convert(x(u downto u-w+1), tpl.RX);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t) return HAL_CSM_CSM_SC_MASTER_SCA_RX_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_MASTER_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.IC);
      w := w + width(x.SCA_RX);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_MASTER_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.IC);
         y(u to u+w-1) := convert(x.IC, y(u to u+w-1));
         u := u + w;
         w := width(x.SCA_RX);
         y(u to u+w-1) := convert(x.SCA_RX, y(u to u+w-1));
      else
         w := width(x.IC);
         y(u downto u-w+1) := convert(x.IC, y(u downto u-w+1));
         u := u - w;
         w := width(x.SCA_RX);
         y(u downto u-w+1) := convert(x.SCA_RX, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_MON_t) return HAL_CSM_CSM_SC_MASTER_MON_t is
      variable y : HAL_CSM_CSM_SC_MASTER_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.IC);
         y.IC := convert(x(u to u+w-1), tpl.IC);
         u := u + w;
         w := width(tpl.SCA_RX);
         y.SCA_RX := convert(x(u to u+w-1), tpl.SCA_RX);
      else
         w := width(tpl.IC);
         y.IC := convert(x(u downto u-w+1), tpl.IC);
         u := u - w;
         w := width(tpl.SCA_RX);
         y.SCA_RX := convert(x(u downto u-w+1), tpl.SCA_RX);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_MON_t) return HAL_CSM_CSM_SC_MASTER_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_MASTER_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.TX_RESET);
      w := w + width(x.RX_RESET);
      w := w + width(x.IC);
      w := w + width(x.TX_CMD);
      w := w + width(x.TX_ADDRESS);
      w := w + width(x.TX_TRANSID);
      w := w + width(x.TX_CHANNEL);
      w := w + width(x.TX_DATA);
      w := w + width(x.SCA_ENABLE);
      w := w + width(x.START_RESET);
      w := w + width(x.START_CONNECT);
      w := w + width(x.START_COMMAND);
      w := w + width(x.INJ_CRC_ERR);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_MASTER_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.TX_RESET);
         y(u to u+w-1) := convert(x.TX_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_RESET);
         y(u to u+w-1) := convert(x.RX_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.IC);
         y(u to u+w-1) := convert(x.IC, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_CMD);
         y(u to u+w-1) := convert(x.TX_CMD, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_ADDRESS);
         y(u to u+w-1) := convert(x.TX_ADDRESS, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_TRANSID);
         y(u to u+w-1) := convert(x.TX_TRANSID, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_CHANNEL);
         y(u to u+w-1) := convert(x.TX_CHANNEL, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_DATA);
         y(u to u+w-1) := convert(x.TX_DATA, y(u to u+w-1));
         u := u + w;
         w := width(x.SCA_ENABLE);
         y(u to u+w-1) := convert(x.SCA_ENABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.START_RESET);
         y(u to u+w-1) := convert(x.START_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.START_CONNECT);
         y(u to u+w-1) := convert(x.START_CONNECT, y(u to u+w-1));
         u := u + w;
         w := width(x.START_COMMAND);
         y(u to u+w-1) := convert(x.START_COMMAND, y(u to u+w-1));
         u := u + w;
         w := width(x.INJ_CRC_ERR);
         y(u to u+w-1) := convert(x.INJ_CRC_ERR, y(u to u+w-1));
      else
         w := width(x.TX_RESET);
         y(u downto u-w+1) := convert(x.TX_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_RESET);
         y(u downto u-w+1) := convert(x.RX_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.IC);
         y(u downto u-w+1) := convert(x.IC, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_CMD);
         y(u downto u-w+1) := convert(x.TX_CMD, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_ADDRESS);
         y(u downto u-w+1) := convert(x.TX_ADDRESS, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_TRANSID);
         y(u downto u-w+1) := convert(x.TX_TRANSID, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_CHANNEL);
         y(u downto u-w+1) := convert(x.TX_CHANNEL, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_DATA);
         y(u downto u-w+1) := convert(x.TX_DATA, y(u downto u-w+1));
         u := u - w;
         w := width(x.SCA_ENABLE);
         y(u downto u-w+1) := convert(x.SCA_ENABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.START_RESET);
         y(u downto u-w+1) := convert(x.START_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.START_CONNECT);
         y(u downto u-w+1) := convert(x.START_CONNECT, y(u downto u-w+1));
         u := u - w;
         w := width(x.START_COMMAND);
         y(u downto u-w+1) := convert(x.START_COMMAND, y(u downto u-w+1));
         u := u - w;
         w := width(x.INJ_CRC_ERR);
         y(u downto u-w+1) := convert(x.INJ_CRC_ERR, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MASTER_CTRL_t) return HAL_CSM_CSM_SC_MASTER_CTRL_t is
      variable y : HAL_CSM_CSM_SC_MASTER_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.TX_RESET);
         y.TX_RESET := convert(x(u to u+w-1), tpl.TX_RESET);
         u := u + w;
         w := width(tpl.RX_RESET);
         y.RX_RESET := convert(x(u to u+w-1), tpl.RX_RESET);
         u := u + w;
         w := width(tpl.IC);
         y.IC := convert(x(u to u+w-1), tpl.IC);
         u := u + w;
         w := width(tpl.TX_CMD);
         y.TX_CMD := convert(x(u to u+w-1), tpl.TX_CMD);
         u := u + w;
         w := width(tpl.TX_ADDRESS);
         y.TX_ADDRESS := convert(x(u to u+w-1), tpl.TX_ADDRESS);
         u := u + w;
         w := width(tpl.TX_TRANSID);
         y.TX_TRANSID := convert(x(u to u+w-1), tpl.TX_TRANSID);
         u := u + w;
         w := width(tpl.TX_CHANNEL);
         y.TX_CHANNEL := convert(x(u to u+w-1), tpl.TX_CHANNEL);
         u := u + w;
         w := width(tpl.TX_DATA);
         y.TX_DATA := convert(x(u to u+w-1), tpl.TX_DATA);
         u := u + w;
         w := width(tpl.SCA_ENABLE);
         y.SCA_ENABLE := convert(x(u to u+w-1), tpl.SCA_ENABLE);
         u := u + w;
         w := width(tpl.START_RESET);
         y.START_RESET := convert(x(u to u+w-1), tpl.START_RESET);
         u := u + w;
         w := width(tpl.START_CONNECT);
         y.START_CONNECT := convert(x(u to u+w-1), tpl.START_CONNECT);
         u := u + w;
         w := width(tpl.START_COMMAND);
         y.START_COMMAND := convert(x(u to u+w-1), tpl.START_COMMAND);
         u := u + w;
         w := width(tpl.INJ_CRC_ERR);
         y.INJ_CRC_ERR := convert(x(u to u+w-1), tpl.INJ_CRC_ERR);
      else
         w := width(tpl.TX_RESET);
         y.TX_RESET := convert(x(u downto u-w+1), tpl.TX_RESET);
         u := u - w;
         w := width(tpl.RX_RESET);
         y.RX_RESET := convert(x(u downto u-w+1), tpl.RX_RESET);
         u := u - w;
         w := width(tpl.IC);
         y.IC := convert(x(u downto u-w+1), tpl.IC);
         u := u - w;
         w := width(tpl.TX_CMD);
         y.TX_CMD := convert(x(u downto u-w+1), tpl.TX_CMD);
         u := u - w;
         w := width(tpl.TX_ADDRESS);
         y.TX_ADDRESS := convert(x(u downto u-w+1), tpl.TX_ADDRESS);
         u := u - w;
         w := width(tpl.TX_TRANSID);
         y.TX_TRANSID := convert(x(u downto u-w+1), tpl.TX_TRANSID);
         u := u - w;
         w := width(tpl.TX_CHANNEL);
         y.TX_CHANNEL := convert(x(u downto u-w+1), tpl.TX_CHANNEL);
         u := u - w;
         w := width(tpl.TX_DATA);
         y.TX_DATA := convert(x(u downto u-w+1), tpl.TX_DATA);
         u := u - w;
         w := width(tpl.SCA_ENABLE);
         y.SCA_ENABLE := convert(x(u downto u-w+1), tpl.SCA_ENABLE);
         u := u - w;
         w := width(tpl.START_RESET);
         y.START_RESET := convert(x(u downto u-w+1), tpl.START_RESET);
         u := u - w;
         w := width(tpl.START_CONNECT);
         y.START_CONNECT := convert(x(u downto u-w+1), tpl.START_CONNECT);
         u := u - w;
         w := width(tpl.START_COMMAND);
         y.START_COMMAND := convert(x(u downto u-w+1), tpl.START_COMMAND);
         u := u - w;
         w := width(tpl.INJ_CRC_ERR);
         y.INJ_CRC_ERR := convert(x(u downto u-w+1), tpl.INJ_CRC_ERR);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_MASTER_CTRL_t) return HAL_CSM_CSM_SC_MASTER_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_SLAVE_IC_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RX_DATA_FROM_GBTX);
      w := w + width(x.TX_READY);
      w := w + width(x.RX_DATA);
      w := w + width(x.RX_CHIP_ADR);
      w := w + width(x.RX_UP_PARITY_OK);
      w := w + width(x.RX_DOWN_PARITY_OK);
      w := w + width(x.RX_ERR);
      w := w + width(x.RX_VALID);
      w := w + width(x.RX_REG_ADR);
      w := w + width(x.RX_LENGTH);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_SLAVE_IC_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RX_DATA_FROM_GBTX);
         y(u to u+w-1) := convert(x.RX_DATA_FROM_GBTX, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_READY);
         y(u to u+w-1) := convert(x.TX_READY, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_DATA);
         y(u to u+w-1) := convert(x.RX_DATA, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_CHIP_ADR);
         y(u to u+w-1) := convert(x.RX_CHIP_ADR, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_UP_PARITY_OK);
         y(u to u+w-1) := convert(x.RX_UP_PARITY_OK, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_DOWN_PARITY_OK);
         y(u to u+w-1) := convert(x.RX_DOWN_PARITY_OK, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_ERR);
         y(u to u+w-1) := convert(x.RX_ERR, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_VALID);
         y(u to u+w-1) := convert(x.RX_VALID, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_REG_ADR);
         y(u to u+w-1) := convert(x.RX_REG_ADR, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_LENGTH);
         y(u to u+w-1) := convert(x.RX_LENGTH, y(u to u+w-1));
      else
         w := width(x.RX_DATA_FROM_GBTX);
         y(u downto u-w+1) := convert(x.RX_DATA_FROM_GBTX, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_READY);
         y(u downto u-w+1) := convert(x.TX_READY, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_DATA);
         y(u downto u-w+1) := convert(x.RX_DATA, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_CHIP_ADR);
         y(u downto u-w+1) := convert(x.RX_CHIP_ADR, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_UP_PARITY_OK);
         y(u downto u-w+1) := convert(x.RX_UP_PARITY_OK, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_DOWN_PARITY_OK);
         y(u downto u-w+1) := convert(x.RX_DOWN_PARITY_OK, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_ERR);
         y(u downto u-w+1) := convert(x.RX_ERR, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_VALID);
         y(u downto u-w+1) := convert(x.RX_VALID, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_REG_ADR);
         y(u downto u-w+1) := convert(x.RX_REG_ADR, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_LENGTH);
         y(u downto u-w+1) := convert(x.RX_LENGTH, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_SLAVE_IC_MON_t) return HAL_CSM_CSM_SC_SLAVE_IC_MON_t is
      variable y : HAL_CSM_CSM_SC_SLAVE_IC_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RX_DATA_FROM_GBTX);
         y.RX_DATA_FROM_GBTX := convert(x(u to u+w-1), tpl.RX_DATA_FROM_GBTX);
         u := u + w;
         w := width(tpl.TX_READY);
         y.TX_READY := convert(x(u to u+w-1), tpl.TX_READY);
         u := u + w;
         w := width(tpl.RX_DATA);
         y.RX_DATA := convert(x(u to u+w-1), tpl.RX_DATA);
         u := u + w;
         w := width(tpl.RX_CHIP_ADR);
         y.RX_CHIP_ADR := convert(x(u to u+w-1), tpl.RX_CHIP_ADR);
         u := u + w;
         w := width(tpl.RX_UP_PARITY_OK);
         y.RX_UP_PARITY_OK := convert(x(u to u+w-1), tpl.RX_UP_PARITY_OK);
         u := u + w;
         w := width(tpl.RX_DOWN_PARITY_OK);
         y.RX_DOWN_PARITY_OK := convert(x(u to u+w-1), tpl.RX_DOWN_PARITY_OK);
         u := u + w;
         w := width(tpl.RX_ERR);
         y.RX_ERR := convert(x(u to u+w-1), tpl.RX_ERR);
         u := u + w;
         w := width(tpl.RX_VALID);
         y.RX_VALID := convert(x(u to u+w-1), tpl.RX_VALID);
         u := u + w;
         w := width(tpl.RX_REG_ADR);
         y.RX_REG_ADR := convert(x(u to u+w-1), tpl.RX_REG_ADR);
         u := u + w;
         w := width(tpl.RX_LENGTH);
         y.RX_LENGTH := convert(x(u to u+w-1), tpl.RX_LENGTH);
      else
         w := width(tpl.RX_DATA_FROM_GBTX);
         y.RX_DATA_FROM_GBTX := convert(x(u downto u-w+1), tpl.RX_DATA_FROM_GBTX);
         u := u - w;
         w := width(tpl.TX_READY);
         y.TX_READY := convert(x(u downto u-w+1), tpl.TX_READY);
         u := u - w;
         w := width(tpl.RX_DATA);
         y.RX_DATA := convert(x(u downto u-w+1), tpl.RX_DATA);
         u := u - w;
         w := width(tpl.RX_CHIP_ADR);
         y.RX_CHIP_ADR := convert(x(u downto u-w+1), tpl.RX_CHIP_ADR);
         u := u - w;
         w := width(tpl.RX_UP_PARITY_OK);
         y.RX_UP_PARITY_OK := convert(x(u downto u-w+1), tpl.RX_UP_PARITY_OK);
         u := u - w;
         w := width(tpl.RX_DOWN_PARITY_OK);
         y.RX_DOWN_PARITY_OK := convert(x(u downto u-w+1), tpl.RX_DOWN_PARITY_OK);
         u := u - w;
         w := width(tpl.RX_ERR);
         y.RX_ERR := convert(x(u downto u-w+1), tpl.RX_ERR);
         u := u - w;
         w := width(tpl.RX_VALID);
         y.RX_VALID := convert(x(u downto u-w+1), tpl.RX_VALID);
         u := u - w;
         w := width(tpl.RX_REG_ADR);
         y.RX_REG_ADR := convert(x(u downto u-w+1), tpl.RX_REG_ADR);
         u := u - w;
         w := width(tpl.RX_LENGTH);
         y.RX_LENGTH := convert(x(u downto u-w+1), tpl.RX_LENGTH);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_SLAVE_IC_MON_t) return HAL_CSM_CSM_SC_SLAVE_IC_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.TX_START_WRITE);
      w := w + width(x.TX_START_READ);
      w := w + width(x.TX_REGISTER_ADDR);
      w := w + width(x.TX_NUM_BYTES_TO_READ);
      w := w + width(x.TX_DATA_TO_GBTX);
      w := w + width(x.TX_GBTX_ADDR);
      w := w + width(x.TX_WR);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.TX_START_WRITE);
         y(u to u+w-1) := convert(x.TX_START_WRITE, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_START_READ);
         y(u to u+w-1) := convert(x.TX_START_READ, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_REGISTER_ADDR);
         y(u to u+w-1) := convert(x.TX_REGISTER_ADDR, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_NUM_BYTES_TO_READ);
         y(u to u+w-1) := convert(x.TX_NUM_BYTES_TO_READ, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_DATA_TO_GBTX);
         y(u to u+w-1) := convert(x.TX_DATA_TO_GBTX, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_GBTX_ADDR);
         y(u to u+w-1) := convert(x.TX_GBTX_ADDR, y(u to u+w-1));
         u := u + w;
         w := width(x.TX_WR);
         y(u to u+w-1) := convert(x.TX_WR, y(u to u+w-1));
      else
         w := width(x.TX_START_WRITE);
         y(u downto u-w+1) := convert(x.TX_START_WRITE, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_START_READ);
         y(u downto u-w+1) := convert(x.TX_START_READ, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_REGISTER_ADDR);
         y(u downto u-w+1) := convert(x.TX_REGISTER_ADDR, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_NUM_BYTES_TO_READ);
         y(u downto u-w+1) := convert(x.TX_NUM_BYTES_TO_READ, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_DATA_TO_GBTX);
         y(u downto u-w+1) := convert(x.TX_DATA_TO_GBTX, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_GBTX_ADDR);
         y(u downto u-w+1) := convert(x.TX_GBTX_ADDR, y(u downto u-w+1));
         u := u - w;
         w := width(x.TX_WR);
         y(u downto u-w+1) := convert(x.TX_WR, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t) return HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t is
      variable y : HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.TX_START_WRITE);
         y.TX_START_WRITE := convert(x(u to u+w-1), tpl.TX_START_WRITE);
         u := u + w;
         w := width(tpl.TX_START_READ);
         y.TX_START_READ := convert(x(u to u+w-1), tpl.TX_START_READ);
         u := u + w;
         w := width(tpl.TX_REGISTER_ADDR);
         y.TX_REGISTER_ADDR := convert(x(u to u+w-1), tpl.TX_REGISTER_ADDR);
         u := u + w;
         w := width(tpl.TX_NUM_BYTES_TO_READ);
         y.TX_NUM_BYTES_TO_READ := convert(x(u to u+w-1), tpl.TX_NUM_BYTES_TO_READ);
         u := u + w;
         w := width(tpl.TX_DATA_TO_GBTX);
         y.TX_DATA_TO_GBTX := convert(x(u to u+w-1), tpl.TX_DATA_TO_GBTX);
         u := u + w;
         w := width(tpl.TX_GBTX_ADDR);
         y.TX_GBTX_ADDR := convert(x(u to u+w-1), tpl.TX_GBTX_ADDR);
         u := u + w;
         w := width(tpl.TX_WR);
         y.TX_WR := convert(x(u to u+w-1), tpl.TX_WR);
      else
         w := width(tpl.TX_START_WRITE);
         y.TX_START_WRITE := convert(x(u downto u-w+1), tpl.TX_START_WRITE);
         u := u - w;
         w := width(tpl.TX_START_READ);
         y.TX_START_READ := convert(x(u downto u-w+1), tpl.TX_START_READ);
         u := u - w;
         w := width(tpl.TX_REGISTER_ADDR);
         y.TX_REGISTER_ADDR := convert(x(u downto u-w+1), tpl.TX_REGISTER_ADDR);
         u := u - w;
         w := width(tpl.TX_NUM_BYTES_TO_READ);
         y.TX_NUM_BYTES_TO_READ := convert(x(u downto u-w+1), tpl.TX_NUM_BYTES_TO_READ);
         u := u - w;
         w := width(tpl.TX_DATA_TO_GBTX);
         y.TX_DATA_TO_GBTX := convert(x(u downto u-w+1), tpl.TX_DATA_TO_GBTX);
         u := u - w;
         w := width(tpl.TX_GBTX_ADDR);
         y.TX_GBTX_ADDR := convert(x(u downto u-w+1), tpl.TX_GBTX_ADDR);
         u := u - w;
         w := width(tpl.TX_WR);
         y.TX_WR := convert(x(u downto u-w+1), tpl.TX_WR);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t) return HAL_CSM_CSM_SC_SLAVE_IC_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_SLAVE_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.IC);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_SLAVE_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.IC);
         y(u to u+w-1) := convert(x.IC, y(u to u+w-1));
      else
         w := width(x.IC);
         y(u downto u-w+1) := convert(x.IC, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_SLAVE_MON_t) return HAL_CSM_CSM_SC_SLAVE_MON_t is
      variable y : HAL_CSM_CSM_SC_SLAVE_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.IC);
         y.IC := convert(x(u to u+w-1), tpl.IC);
      else
         w := width(tpl.IC);
         y.IC := convert(x(u downto u-w+1), tpl.IC);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_SLAVE_MON_t) return HAL_CSM_CSM_SC_SLAVE_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_SLAVE_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.TX_RESET);
      w := w + width(x.RX_RESET);
      w := w + width(x.IC);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_SLAVE_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.TX_RESET);
         y(u to u+w-1) := convert(x.TX_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_RESET);
         y(u to u+w-1) := convert(x.RX_RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.IC);
         y(u to u+w-1) := convert(x.IC, y(u to u+w-1));
      else
         w := width(x.TX_RESET);
         y(u downto u-w+1) := convert(x.TX_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_RESET);
         y(u downto u-w+1) := convert(x.RX_RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.IC);
         y(u downto u-w+1) := convert(x.IC, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_SLAVE_CTRL_t) return HAL_CSM_CSM_SC_SLAVE_CTRL_t is
      variable y : HAL_CSM_CSM_SC_SLAVE_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.TX_RESET);
         y.TX_RESET := convert(x(u to u+w-1), tpl.TX_RESET);
         u := u + w;
         w := width(tpl.RX_RESET);
         y.RX_RESET := convert(x(u to u+w-1), tpl.RX_RESET);
         u := u + w;
         w := width(tpl.IC);
         y.IC := convert(x(u to u+w-1), tpl.IC);
      else
         w := width(tpl.TX_RESET);
         y.TX_RESET := convert(x(u downto u-w+1), tpl.TX_RESET);
         u := u - w;
         w := width(tpl.RX_RESET);
         y.RX_RESET := convert(x(u downto u-w+1), tpl.RX_RESET);
         u := u - w;
         w := width(tpl.IC);
         y.IC := convert(x(u downto u-w+1), tpl.IC);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_SLAVE_CTRL_t) return HAL_CSM_CSM_SC_SLAVE_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MASTER);
      w := w + width(x.SLAVE);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MASTER);
         y(u to u+w-1) := convert(x.MASTER, y(u to u+w-1));
         u := u + w;
         w := width(x.SLAVE);
         y(u to u+w-1) := convert(x.SLAVE, y(u to u+w-1));
      else
         w := width(x.MASTER);
         y(u downto u-w+1) := convert(x.MASTER, y(u downto u-w+1));
         u := u - w;
         w := width(x.SLAVE);
         y(u downto u-w+1) := convert(x.SLAVE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_MON_t) return HAL_CSM_CSM_SC_MON_t is
      variable y : HAL_CSM_CSM_SC_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MASTER);
         y.MASTER := convert(x(u to u+w-1), tpl.MASTER);
         u := u + w;
         w := width(tpl.SLAVE);
         y.SLAVE := convert(x(u to u+w-1), tpl.SLAVE);
      else
         w := width(tpl.MASTER);
         y.MASTER := convert(x(u downto u-w+1), tpl.MASTER);
         u := u - w;
         w := width(tpl.SLAVE);
         y.SLAVE := convert(x(u downto u-w+1), tpl.SLAVE);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_MON_t) return HAL_CSM_CSM_SC_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_SC_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MASTER);
      w := w + width(x.FRAME_FORMAT);
      w := w + width(x.SLAVE);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_SC_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MASTER);
         y(u to u+w-1) := convert(x.MASTER, y(u to u+w-1));
         u := u + w;
         w := width(x.FRAME_FORMAT);
         y(u to u+w-1) := convert(x.FRAME_FORMAT, y(u to u+w-1));
         u := u + w;
         w := width(x.SLAVE);
         y(u to u+w-1) := convert(x.SLAVE, y(u to u+w-1));
      else
         w := width(x.MASTER);
         y(u downto u-w+1) := convert(x.MASTER, y(u downto u-w+1));
         u := u - w;
         w := width(x.FRAME_FORMAT);
         y(u downto u-w+1) := convert(x.FRAME_FORMAT, y(u downto u-w+1));
         u := u - w;
         w := width(x.SLAVE);
         y(u downto u-w+1) := convert(x.SLAVE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_SC_CTRL_t) return HAL_CSM_CSM_SC_CTRL_t is
      variable y : HAL_CSM_CSM_SC_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MASTER);
         y.MASTER := convert(x(u to u+w-1), tpl.MASTER);
         u := u + w;
         w := width(tpl.FRAME_FORMAT);
         y.FRAME_FORMAT := convert(x(u to u+w-1), tpl.FRAME_FORMAT);
         u := u + w;
         w := width(tpl.SLAVE);
         y.SLAVE := convert(x(u to u+w-1), tpl.SLAVE);
      else
         w := width(tpl.MASTER);
         y.MASTER := convert(x(u downto u-w+1), tpl.MASTER);
         u := u - w;
         w := width(tpl.FRAME_FORMAT);
         y.FRAME_FORMAT := convert(x(u downto u-w+1), tpl.FRAME_FORMAT);
         u := u - w;
         w := width(tpl.SLAVE);
         y.SLAVE := convert(x(u downto u-w+1), tpl.SLAVE);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_SC_CTRL_t) return HAL_CSM_CSM_SC_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_CONFIG_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.master_link_id);
      w := w + width(x.servant_link_id);
      w := w + width(x.station);
      w := w + width(x.polmux);
      w := w + width(x.en);
      w := w + width(x.legacy);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_CONFIG_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.master_link_id);
         y(u to u+w-1) := convert(x.master_link_id, y(u to u+w-1));
         u := u + w;
         w := width(x.servant_link_id);
         y(u to u+w-1) := convert(x.servant_link_id, y(u to u+w-1));
         u := u + w;
         w := width(x.station);
         y(u to u+w-1) := convert(x.station, y(u to u+w-1));
         u := u + w;
         w := width(x.polmux);
         y(u to u+w-1) := convert(x.polmux, y(u to u+w-1));
         u := u + w;
         w := width(x.en);
         y(u to u+w-1) := convert(x.en, y(u to u+w-1));
         u := u + w;
         w := width(x.legacy);
         y(u to u+w-1) := convert(x.legacy, y(u to u+w-1));
      else
         w := width(x.master_link_id);
         y(u downto u-w+1) := convert(x.master_link_id, y(u downto u-w+1));
         u := u - w;
         w := width(x.servant_link_id);
         y(u downto u-w+1) := convert(x.servant_link_id, y(u downto u-w+1));
         u := u - w;
         w := width(x.station);
         y(u downto u-w+1) := convert(x.station, y(u downto u-w+1));
         u := u - w;
         w := width(x.polmux);
         y(u downto u-w+1) := convert(x.polmux, y(u downto u-w+1));
         u := u - w;
         w := width(x.en);
         y(u downto u-w+1) := convert(x.en, y(u downto u-w+1));
         u := u - w;
         w := width(x.legacy);
         y(u downto u-w+1) := convert(x.legacy, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_CONFIG_MON_t) return HAL_CSM_CSM_CONFIG_MON_t is
      variable y : HAL_CSM_CSM_CONFIG_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.master_link_id);
         y.master_link_id := convert(x(u to u+w-1), tpl.master_link_id);
         u := u + w;
         w := width(tpl.servant_link_id);
         y.servant_link_id := convert(x(u to u+w-1), tpl.servant_link_id);
         u := u + w;
         w := width(tpl.station);
         y.station := convert(x(u to u+w-1), tpl.station);
         u := u + w;
         w := width(tpl.polmux);
         y.polmux := convert(x(u to u+w-1), tpl.polmux);
         u := u + w;
         w := width(tpl.en);
         y.en := convert(x(u to u+w-1), tpl.en);
         u := u + w;
         w := width(tpl.legacy);
         y.legacy := convert(x(u to u+w-1), tpl.legacy);
      else
         w := width(tpl.master_link_id);
         y.master_link_id := convert(x(u downto u-w+1), tpl.master_link_id);
         u := u - w;
         w := width(tpl.servant_link_id);
         y.servant_link_id := convert(x(u downto u-w+1), tpl.servant_link_id);
         u := u - w;
         w := width(tpl.station);
         y.station := convert(x(u downto u-w+1), tpl.station);
         u := u - w;
         w := width(tpl.polmux);
         y.polmux := convert(x(u downto u-w+1), tpl.polmux);
         u := u - w;
         w := width(tpl.en);
         y.en := convert(x(u downto u-w+1), tpl.en);
         u := u - w;
         w := width(tpl.legacy);
         y.legacy := convert(x(u downto u-w+1), tpl.legacy);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_CONFIG_MON_t) return HAL_CSM_CSM_CONFIG_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.LPGBT);
      w := w + width(x.SC);
      w := w + width(x.CONFIG);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.LPGBT);
         y(u to u+w-1) := convert(x.LPGBT, y(u to u+w-1));
         u := u + w;
         w := width(x.SC);
         y(u to u+w-1) := convert(x.SC, y(u to u+w-1));
         u := u + w;
         w := width(x.CONFIG);
         y(u to u+w-1) := convert(x.CONFIG, y(u to u+w-1));
      else
         w := width(x.LPGBT);
         y(u downto u-w+1) := convert(x.LPGBT, y(u downto u-w+1));
         u := u - w;
         w := width(x.SC);
         y(u downto u-w+1) := convert(x.SC, y(u downto u-w+1));
         u := u - w;
         w := width(x.CONFIG);
         y(u downto u-w+1) := convert(x.CONFIG, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_MON_t) return HAL_CSM_CSM_MON_t is
      variable y : HAL_CSM_CSM_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.LPGBT);
         y.LPGBT := convert(x(u to u+w-1), tpl.LPGBT);
         u := u + w;
         w := width(tpl.SC);
         y.SC := convert(x(u to u+w-1), tpl.SC);
         u := u + w;
         w := width(tpl.CONFIG);
         y.CONFIG := convert(x(u to u+w-1), tpl.CONFIG);
      else
         w := width(tpl.LPGBT);
         y.LPGBT := convert(x(u downto u-w+1), tpl.LPGBT);
         u := u - w;
         w := width(tpl.SC);
         y.SC := convert(x(u downto u-w+1), tpl.SC);
         u := u - w;
         w := width(tpl.CONFIG);
         y.CONFIG := convert(x(u downto u-w+1), tpl.CONFIG);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_MON_t) return HAL_CSM_CSM_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_MON_t_ARRAY) return HAL_CSM_CSM_MON_t_ARRAY is
      variable y : HAL_CSM_CSM_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_MON_t_ARRAY) return HAL_CSM_CSM_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HAL_CSM_CSM_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_MON_t_ARRAY) return HAL_CSM_CSM_MON_t_ARRAY is
      variable y : HAL_CSM_CSM_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HAL_CSM_CSM_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.LPGBT);
      w := w + width(x.SC);
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.LPGBT);
         y(u to u+w-1) := convert(x.LPGBT, y(u to u+w-1));
         u := u + w;
         w := width(x.SC);
         y(u to u+w-1) := convert(x.SC, y(u to u+w-1));
      else
         w := width(x.LPGBT);
         y(u downto u-w+1) := convert(x.LPGBT, y(u downto u-w+1));
         u := u - w;
         w := width(x.SC);
         y(u downto u-w+1) := convert(x.SC, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_CTRL_t) return HAL_CSM_CSM_CTRL_t is
      variable y : HAL_CSM_CSM_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.LPGBT);
         y.LPGBT := convert(x(u to u+w-1), tpl.LPGBT);
         u := u + w;
         w := width(tpl.SC);
         y.SC := convert(x(u to u+w-1), tpl.SC);
      else
         w := width(tpl.LPGBT);
         y.LPGBT := convert(x(u downto u-w+1), tpl.LPGBT);
         u := u - w;
         w := width(tpl.SC);
         y.SC := convert(x(u downto u-w+1), tpl.SC);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_CTRL_t) return HAL_CSM_CSM_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CSM_CTRL_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HAL_CSM_CSM_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CSM_CTRL_t_ARRAY) return HAL_CSM_CSM_CTRL_t_ARRAY is
      variable y : HAL_CSM_CSM_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CSM_CTRL_t_ARRAY) return HAL_CSM_CSM_CTRL_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HAL_CSM_CSM_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HAL_CSM_CSM_CTRL_t_ARRAY) return HAL_CSM_CSM_CTRL_t_ARRAY is
      variable y : HAL_CSM_CSM_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HAL_CSM_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CSM);
      return w;
   end function width;
   function convert(x: HAL_CSM_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.CSM);
         y(u to u+w-1) := convert(x.CSM, y(u to u+w-1));
      else
         w := width(x.CSM);
         y(u downto u-w+1) := convert(x.CSM, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_MON_t) return HAL_CSM_MON_t is
      variable y : HAL_CSM_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.CSM);
         y.CSM := convert(x(u to u+w-1), tpl.CSM);
      else
         w := width(tpl.CSM);
         y.CSM := convert(x(u downto u-w+1), tpl.CSM);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_MON_t) return HAL_CSM_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CSM_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CSM);
      return w;
   end function width;
   function convert(x: HAL_CSM_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.CSM);
         y(u to u+w-1) := convert(x.CSM, y(u to u+w-1));
      else
         w := width(x.CSM);
         y(u downto u-w+1) := convert(x.CSM, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CSM_CTRL_t) return HAL_CSM_CTRL_t is
      variable y : HAL_CSM_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.CSM);
         y.CSM := convert(x(u to u+w-1), tpl.CSM);
      else
         w := width(tpl.CSM);
         y.CSM := convert(x(u downto u-w+1), tpl.CSM);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CSM_CTRL_t) return HAL_CSM_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_SL_RESET_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rx_comma);
      w := w + width(x.rx_packet_former);
      w := w + width(x.rx_counter);
      return w;
   end function width;
   function convert(x: HAL_SL_RESET_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rx_comma);
         y(u to u+w-1) := convert(x.rx_comma, y(u to u+w-1));
         u := u + w;
         w := width(x.rx_packet_former);
         y(u to u+w-1) := convert(x.rx_packet_former, y(u to u+w-1));
         u := u + w;
         w := width(x.rx_counter);
         y(u to u+w-1) := convert(x.rx_counter, y(u to u+w-1));
      else
         w := width(x.rx_comma);
         y(u downto u-w+1) := convert(x.rx_comma, y(u downto u-w+1));
         u := u - w;
         w := width(x.rx_packet_former);
         y(u downto u-w+1) := convert(x.rx_packet_former, y(u downto u-w+1));
         u := u - w;
         w := width(x.rx_counter);
         y(u downto u-w+1) := convert(x.rx_counter, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_SL_RESET_CTRL_t) return HAL_SL_RESET_CTRL_t is
      variable y : HAL_SL_RESET_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rx_comma);
         y.rx_comma := convert(x(u to u+w-1), tpl.rx_comma);
         u := u + w;
         w := width(tpl.rx_packet_former);
         y.rx_packet_former := convert(x(u to u+w-1), tpl.rx_packet_former);
         u := u + w;
         w := width(tpl.rx_counter);
         y.rx_counter := convert(x(u to u+w-1), tpl.rx_counter);
      else
         w := width(tpl.rx_comma);
         y.rx_comma := convert(x(u downto u-w+1), tpl.rx_comma);
         u := u - w;
         w := width(tpl.rx_packet_former);
         y.rx_packet_former := convert(x(u downto u-w+1), tpl.rx_packet_former);
         u := u - w;
         w := width(tpl.rx_counter);
         y.rx_counter := convert(x(u downto u-w+1), tpl.rx_counter);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_SL_RESET_CTRL_t) return HAL_SL_RESET_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_SL_SL_TEST_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ERROR_COUNTER);
      w := w + width(x.WORD_COUNTER_0);
      w := w + width(x.WORD_COUNTER_1);
      return w;
   end function width;
   function convert(x: HAL_SL_SL_TEST_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ERROR_COUNTER);
         y(u to u+w-1) := convert(x.ERROR_COUNTER, y(u to u+w-1));
         u := u + w;
         w := width(x.WORD_COUNTER_0);
         y(u to u+w-1) := convert(x.WORD_COUNTER_0, y(u to u+w-1));
         u := u + w;
         w := width(x.WORD_COUNTER_1);
         y(u to u+w-1) := convert(x.WORD_COUNTER_1, y(u to u+w-1));
      else
         w := width(x.ERROR_COUNTER);
         y(u downto u-w+1) := convert(x.ERROR_COUNTER, y(u downto u-w+1));
         u := u - w;
         w := width(x.WORD_COUNTER_0);
         y(u downto u-w+1) := convert(x.WORD_COUNTER_0, y(u downto u-w+1));
         u := u - w;
         w := width(x.WORD_COUNTER_1);
         y(u downto u-w+1) := convert(x.WORD_COUNTER_1, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_SL_SL_TEST_MON_t) return HAL_SL_SL_TEST_MON_t is
      variable y : HAL_SL_SL_TEST_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ERROR_COUNTER);
         y.ERROR_COUNTER := convert(x(u to u+w-1), tpl.ERROR_COUNTER);
         u := u + w;
         w := width(tpl.WORD_COUNTER_0);
         y.WORD_COUNTER_0 := convert(x(u to u+w-1), tpl.WORD_COUNTER_0);
         u := u + w;
         w := width(tpl.WORD_COUNTER_1);
         y.WORD_COUNTER_1 := convert(x(u to u+w-1), tpl.WORD_COUNTER_1);
      else
         w := width(tpl.ERROR_COUNTER);
         y.ERROR_COUNTER := convert(x(u downto u-w+1), tpl.ERROR_COUNTER);
         u := u - w;
         w := width(tpl.WORD_COUNTER_0);
         y.WORD_COUNTER_0 := convert(x(u downto u-w+1), tpl.WORD_COUNTER_0);
         u := u - w;
         w := width(tpl.WORD_COUNTER_1);
         y.WORD_COUNTER_1 := convert(x(u downto u-w+1), tpl.WORD_COUNTER_1);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_SL_SL_TEST_MON_t) return HAL_SL_SL_TEST_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_SL_SL_TEST_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HAL_SL_SL_TEST_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_SL_SL_TEST_MON_t_ARRAY) return HAL_SL_SL_TEST_MON_t_ARRAY is
      variable y : HAL_SL_SL_TEST_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_SL_SL_TEST_MON_t_ARRAY) return HAL_SL_SL_TEST_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HAL_SL_SL_TEST_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HAL_SL_SL_TEST_MON_t_ARRAY) return HAL_SL_SL_TEST_MON_t_ARRAY is
      variable y : HAL_SL_SL_TEST_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HAL_SL_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RX_COMMA_LOCK);
      w := w + width(x.RX_PACKET_LOCKED);
      w := w + width(x.SL_TEST);
      return w;
   end function width;
   function convert(x: HAL_SL_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RX_COMMA_LOCK);
         y(u to u+w-1) := convert(x.RX_COMMA_LOCK, y(u to u+w-1));
         u := u + w;
         w := width(x.RX_PACKET_LOCKED);
         y(u to u+w-1) := convert(x.RX_PACKET_LOCKED, y(u to u+w-1));
         u := u + w;
         w := width(x.SL_TEST);
         y(u to u+w-1) := convert(x.SL_TEST, y(u to u+w-1));
      else
         w := width(x.RX_COMMA_LOCK);
         y(u downto u-w+1) := convert(x.RX_COMMA_LOCK, y(u downto u-w+1));
         u := u - w;
         w := width(x.RX_PACKET_LOCKED);
         y(u downto u-w+1) := convert(x.RX_PACKET_LOCKED, y(u downto u-w+1));
         u := u - w;
         w := width(x.SL_TEST);
         y(u downto u-w+1) := convert(x.SL_TEST, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_SL_MON_t) return HAL_SL_MON_t is
      variable y : HAL_SL_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RX_COMMA_LOCK);
         y.RX_COMMA_LOCK := convert(x(u to u+w-1), tpl.RX_COMMA_LOCK);
         u := u + w;
         w := width(tpl.RX_PACKET_LOCKED);
         y.RX_PACKET_LOCKED := convert(x(u to u+w-1), tpl.RX_PACKET_LOCKED);
         u := u + w;
         w := width(tpl.SL_TEST);
         y.SL_TEST := convert(x(u to u+w-1), tpl.SL_TEST);
      else
         w := width(tpl.RX_COMMA_LOCK);
         y.RX_COMMA_LOCK := convert(x(u downto u-w+1), tpl.RX_COMMA_LOCK);
         u := u - w;
         w := width(tpl.RX_PACKET_LOCKED);
         y.RX_PACKET_LOCKED := convert(x(u downto u-w+1), tpl.RX_PACKET_LOCKED);
         u := u - w;
         w := width(tpl.SL_TEST);
         y.SL_TEST := convert(x(u downto u-w+1), tpl.SL_TEST);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_SL_MON_t) return HAL_SL_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_SL_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.TX_ENA_TEST_PATTERN);
      w := w + width(x.COMMA_EVEN_SLIDES);
      w := w + width(x.RESET);
      return w;
   end function width;
   function convert(x: HAL_SL_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.TX_ENA_TEST_PATTERN);
         y(u to u+w-1) := convert(x.TX_ENA_TEST_PATTERN, y(u to u+w-1));
         u := u + w;
         w := width(x.COMMA_EVEN_SLIDES);
         y(u to u+w-1) := convert(x.COMMA_EVEN_SLIDES, y(u to u+w-1));
         u := u + w;
         w := width(x.RESET);
         y(u to u+w-1) := convert(x.RESET, y(u to u+w-1));
      else
         w := width(x.TX_ENA_TEST_PATTERN);
         y(u downto u-w+1) := convert(x.TX_ENA_TEST_PATTERN, y(u downto u-w+1));
         u := u - w;
         w := width(x.COMMA_EVEN_SLIDES);
         y(u downto u-w+1) := convert(x.COMMA_EVEN_SLIDES, y(u downto u-w+1));
         u := u - w;
         w := width(x.RESET);
         y(u downto u-w+1) := convert(x.RESET, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_SL_CTRL_t) return HAL_SL_CTRL_t is
      variable y : HAL_SL_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.TX_ENA_TEST_PATTERN);
         y.TX_ENA_TEST_PATTERN := convert(x(u to u+w-1), tpl.TX_ENA_TEST_PATTERN);
         u := u + w;
         w := width(tpl.COMMA_EVEN_SLIDES);
         y.COMMA_EVEN_SLIDES := convert(x(u to u+w-1), tpl.COMMA_EVEN_SLIDES);
         u := u + w;
         w := width(tpl.RESET);
         y.RESET := convert(x(u to u+w-1), tpl.RESET);
      else
         w := width(tpl.TX_ENA_TEST_PATTERN);
         y.TX_ENA_TEST_PATTERN := convert(x(u downto u-w+1), tpl.TX_ENA_TEST_PATTERN);
         u := u - w;
         w := width(tpl.COMMA_EVEN_SLIDES);
         y.COMMA_EVEN_SLIDES := convert(x(u downto u-w+1), tpl.COMMA_EVEN_SLIDES);
         u := u - w;
         w := width(tpl.RESET);
         y.RESET := convert(x(u downto u-w+1), tpl.RESET);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_SL_CTRL_t) return HAL_SL_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CSM);
      w := w + width(x.SL);
      return w;
   end function width;
   function convert(x: HAL_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.CSM);
         y(u to u+w-1) := convert(x.CSM, y(u to u+w-1));
         u := u + w;
         w := width(x.SL);
         y(u to u+w-1) := convert(x.SL, y(u to u+w-1));
      else
         w := width(x.CSM);
         y(u downto u-w+1) := convert(x.CSM, y(u downto u-w+1));
         u := u - w;
         w := width(x.SL);
         y(u downto u-w+1) := convert(x.SL, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_MON_t) return HAL_MON_t is
      variable y : HAL_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.CSM);
         y.CSM := convert(x(u to u+w-1), tpl.CSM);
         u := u + w;
         w := width(tpl.SL);
         y.SL := convert(x(u to u+w-1), tpl.SL);
      else
         w := width(tpl.CSM);
         y.CSM := convert(x(u downto u-w+1), tpl.CSM);
         u := u - w;
         w := width(tpl.SL);
         y.SL := convert(x(u downto u-w+1), tpl.SL);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_MON_t) return HAL_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HAL_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET_DOWNLINKS);
      w := w + width(x.RESET_UPLINKS);
      w := w + width(x.RESET_COUNTERS);
      w := w + width(x.CSM);
      w := w + width(x.SL);
      return w;
   end function width;
   function convert(x: HAL_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET_DOWNLINKS);
         y(u to u+w-1) := convert(x.RESET_DOWNLINKS, y(u to u+w-1));
         u := u + w;
         w := width(x.RESET_UPLINKS);
         y(u to u+w-1) := convert(x.RESET_UPLINKS, y(u to u+w-1));
         u := u + w;
         w := width(x.RESET_COUNTERS);
         y(u to u+w-1) := convert(x.RESET_COUNTERS, y(u to u+w-1));
         u := u + w;
         w := width(x.CSM);
         y(u to u+w-1) := convert(x.CSM, y(u to u+w-1));
         u := u + w;
         w := width(x.SL);
         y(u to u+w-1) := convert(x.SL, y(u to u+w-1));
      else
         w := width(x.RESET_DOWNLINKS);
         y(u downto u-w+1) := convert(x.RESET_DOWNLINKS, y(u downto u-w+1));
         u := u - w;
         w := width(x.RESET_UPLINKS);
         y(u downto u-w+1) := convert(x.RESET_UPLINKS, y(u downto u-w+1));
         u := u - w;
         w := width(x.RESET_COUNTERS);
         y(u downto u-w+1) := convert(x.RESET_COUNTERS, y(u downto u-w+1));
         u := u - w;
         w := width(x.CSM);
         y(u downto u-w+1) := convert(x.CSM, y(u downto u-w+1));
         u := u - w;
         w := width(x.SL);
         y(u downto u-w+1) := convert(x.SL, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HAL_CTRL_t) return HAL_CTRL_t is
      variable y : HAL_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET_DOWNLINKS);
         y.RESET_DOWNLINKS := convert(x(u to u+w-1), tpl.RESET_DOWNLINKS);
         u := u + w;
         w := width(tpl.RESET_UPLINKS);
         y.RESET_UPLINKS := convert(x(u to u+w-1), tpl.RESET_UPLINKS);
         u := u + w;
         w := width(tpl.RESET_COUNTERS);
         y.RESET_COUNTERS := convert(x(u to u+w-1), tpl.RESET_COUNTERS);
         u := u + w;
         w := width(tpl.CSM);
         y.CSM := convert(x(u to u+w-1), tpl.CSM);
         u := u + w;
         w := width(tpl.SL);
         y.SL := convert(x(u to u+w-1), tpl.SL);
      else
         w := width(tpl.RESET_DOWNLINKS);
         y.RESET_DOWNLINKS := convert(x(u downto u-w+1), tpl.RESET_DOWNLINKS);
         u := u - w;
         w := width(tpl.RESET_UPLINKS);
         y.RESET_UPLINKS := convert(x(u downto u-w+1), tpl.RESET_UPLINKS);
         u := u - w;
         w := width(tpl.RESET_COUNTERS);
         y.RESET_COUNTERS := convert(x(u downto u-w+1), tpl.RESET_COUNTERS);
         u := u - w;
         w := width(tpl.CSM);
         y.CSM := convert(x(u downto u-w+1), tpl.CSM);
         u := u - w;
         w := width(tpl.SL);
         y.SL := convert(x(u downto u-w+1), tpl.SL);
      end if;
      return y;
   end function convert;
   function zero(tpl: HAL_CTRL_t) return HAL_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

end package body HAL_CTRL;
