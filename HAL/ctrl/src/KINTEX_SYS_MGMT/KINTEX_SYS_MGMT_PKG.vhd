-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;

use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;

use shared_lib.common_ieee.all;

package KINTEX_SYS_MGMT_CTRL is

  type KINTEX_SYS_MGMT_MON_t is record
    TEMP : std_logic_vector(10-1 downto 0);
    VCCINT : std_logic_vector(10-1 downto 0);
    VCCAUX : std_logic_vector(10-1 downto 0);
    VCCBRAM : std_logic_vector(10-1 downto 0);
    TEMP_MAX : std_logic_vector(10-1 downto 0);
    VCCINT_MAX : std_logic_vector(10-1 downto 0);
    VCCAUX_MAX : std_logic_vector(10-1 downto 0);
    VCCBRAM_MAX : std_logic_vector(10-1 downto 0);
    TEMP_MIN : std_logic_vector(10-1 downto 0);
    VCCINT_MIN : std_logic_vector(10-1 downto 0);
    VCCAUX_MIN : std_logic_vector(10-1 downto 0);
    VCCBRAM_MIN : std_logic_vector(10-1 downto 0);
  end record KINTEX_SYS_MGMT_MON_t;
  function len(x: KINTEX_SYS_MGMT_MON_t) return natural;
  function width(x: KINTEX_SYS_MGMT_MON_t) return natural;
  function vectorify(x: KINTEX_SYS_MGMT_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: KINTEX_SYS_MGMT_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: KINTEX_SYS_MGMT_MON_t) return KINTEX_SYS_MGMT_MON_t;
  function convert(x: in std_logic_vector; t: KINTEX_SYS_MGMT_MON_t) return KINTEX_SYS_MGMT_MON_t;
  function nullify(t: KINTEX_SYS_MGMT_MON_t) return KINTEX_SYS_MGMT_MON_t;
  function zeroed(t: KINTEX_SYS_MGMT_MON_t) return KINTEX_SYS_MGMT_MON_t;

end package KINTEX_SYS_MGMT_CTRL;

------------------------------------------------------------

package body KINTEX_SYS_MGMT_CTRL is

  function len(x: KINTEX_SYS_MGMT_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.TEMP);
    l := l + len(x.VCCINT);
    l := l + len(x.VCCAUX);
    l := l + len(x.VCCBRAM);
    l := l + len(x.TEMP_MAX);
    l := l + len(x.VCCINT_MAX);
    l := l + len(x.VCCAUX_MAX);
    l := l + len(x.VCCBRAM_MAX);
    l := l + len(x.TEMP_MIN);
    l := l + len(x.VCCINT_MIN);
    l := l + len(x.VCCAUX_MIN);
    l := l + len(x.VCCBRAM_MIN);
    return l;
  end function len;
  function width(x: KINTEX_SYS_MGMT_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.TEMP);
    l := l + width(x.VCCINT);
    l := l + width(x.VCCAUX);
    l := l + width(x.VCCBRAM);
    l := l + width(x.TEMP_MAX);
    l := l + width(x.VCCINT_MAX);
    l := l + width(x.VCCAUX_MAX);
    l := l + width(x.VCCBRAM_MAX);
    l := l + width(x.TEMP_MIN);
    l := l + width(x.VCCINT_MIN);
    l := l + width(x.VCCAUX_MIN);
    l := l + width(x.VCCBRAM_MIN);
    return l;
  end function width;
  function vectorify(x: KINTEX_SYS_MGMT_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.TEMP)-1), vectorify(x.TEMP, y(left to left+len(x.TEMP)-1)));
      left := left + len(x.TEMP);
      assign(y(left to left+len(x.VCCINT)-1), vectorify(x.VCCINT, y(left to left+len(x.VCCINT)-1)));
      left := left + len(x.VCCINT);
      assign(y(left to left+len(x.VCCAUX)-1), vectorify(x.VCCAUX, y(left to left+len(x.VCCAUX)-1)));
      left := left + len(x.VCCAUX);
      assign(y(left to left+len(x.VCCBRAM)-1), vectorify(x.VCCBRAM, y(left to left+len(x.VCCBRAM)-1)));
      left := left + len(x.VCCBRAM);
      assign(y(left to left+len(x.TEMP_MAX)-1), vectorify(x.TEMP_MAX, y(left to left+len(x.TEMP_MAX)-1)));
      left := left + len(x.TEMP_MAX);
      assign(y(left to left+len(x.VCCINT_MAX)-1), vectorify(x.VCCINT_MAX, y(left to left+len(x.VCCINT_MAX)-1)));
      left := left + len(x.VCCINT_MAX);
      assign(y(left to left+len(x.VCCAUX_MAX)-1), vectorify(x.VCCAUX_MAX, y(left to left+len(x.VCCAUX_MAX)-1)));
      left := left + len(x.VCCAUX_MAX);
      assign(y(left to left+len(x.VCCBRAM_MAX)-1), vectorify(x.VCCBRAM_MAX, y(left to left+len(x.VCCBRAM_MAX)-1)));
      left := left + len(x.VCCBRAM_MAX);
      assign(y(left to left+len(x.TEMP_MIN)-1), vectorify(x.TEMP_MIN, y(left to left+len(x.TEMP_MIN)-1)));
      left := left + len(x.TEMP_MIN);
      assign(y(left to left+len(x.VCCINT_MIN)-1), vectorify(x.VCCINT_MIN, y(left to left+len(x.VCCINT_MIN)-1)));
      left := left + len(x.VCCINT_MIN);
      assign(y(left to left+len(x.VCCAUX_MIN)-1), vectorify(x.VCCAUX_MIN, y(left to left+len(x.VCCAUX_MIN)-1)));
      left := left + len(x.VCCAUX_MIN);
      assign(y(left to left+len(x.VCCBRAM_MIN)-1), vectorify(x.VCCBRAM_MIN, y(left to left+len(x.VCCBRAM_MIN)-1)));
    else
      assign(y(left downto left-len(x.TEMP)+1), vectorify(x.TEMP, y(left downto left-len(x.TEMP)+1)));
      left := left - len(x.TEMP);
      assign(y(left downto left-len(x.VCCINT)+1), vectorify(x.VCCINT, y(left downto left-len(x.VCCINT)+1)));
      left := left - len(x.VCCINT);
      assign(y(left downto left-len(x.VCCAUX)+1), vectorify(x.VCCAUX, y(left downto left-len(x.VCCAUX)+1)));
      left := left - len(x.VCCAUX);
      assign(y(left downto left-len(x.VCCBRAM)+1), vectorify(x.VCCBRAM, y(left downto left-len(x.VCCBRAM)+1)));
      left := left - len(x.VCCBRAM);
      assign(y(left downto left-len(x.TEMP_MAX)+1), vectorify(x.TEMP_MAX, y(left downto left-len(x.TEMP_MAX)+1)));
      left := left - len(x.TEMP_MAX);
      assign(y(left downto left-len(x.VCCINT_MAX)+1), vectorify(x.VCCINT_MAX, y(left downto left-len(x.VCCINT_MAX)+1)));
      left := left - len(x.VCCINT_MAX);
      assign(y(left downto left-len(x.VCCAUX_MAX)+1), vectorify(x.VCCAUX_MAX, y(left downto left-len(x.VCCAUX_MAX)+1)));
      left := left - len(x.VCCAUX_MAX);
      assign(y(left downto left-len(x.VCCBRAM_MAX)+1), vectorify(x.VCCBRAM_MAX, y(left downto left-len(x.VCCBRAM_MAX)+1)));
      left := left - len(x.VCCBRAM_MAX);
      assign(y(left downto left-len(x.TEMP_MIN)+1), vectorify(x.TEMP_MIN, y(left downto left-len(x.TEMP_MIN)+1)));
      left := left - len(x.TEMP_MIN);
      assign(y(left downto left-len(x.VCCINT_MIN)+1), vectorify(x.VCCINT_MIN, y(left downto left-len(x.VCCINT_MIN)+1)));
      left := left - len(x.VCCINT_MIN);
      assign(y(left downto left-len(x.VCCAUX_MIN)+1), vectorify(x.VCCAUX_MIN, y(left downto left-len(x.VCCAUX_MIN)+1)));
      left := left - len(x.VCCAUX_MIN);
      assign(y(left downto left-len(x.VCCBRAM_MIN)+1), vectorify(x.VCCBRAM_MIN, y(left downto left-len(x.VCCBRAM_MIN)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: KINTEX_SYS_MGMT_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.TEMP)-1), convert(x.TEMP, y(left to left+len(x.TEMP)-1)));
      left := left + len(x.TEMP);
      assign(y(left to left+len(x.VCCINT)-1), convert(x.VCCINT, y(left to left+len(x.VCCINT)-1)));
      left := left + len(x.VCCINT);
      assign(y(left to left+len(x.VCCAUX)-1), convert(x.VCCAUX, y(left to left+len(x.VCCAUX)-1)));
      left := left + len(x.VCCAUX);
      assign(y(left to left+len(x.VCCBRAM)-1), convert(x.VCCBRAM, y(left to left+len(x.VCCBRAM)-1)));
      left := left + len(x.VCCBRAM);
      assign(y(left to left+len(x.TEMP_MAX)-1), convert(x.TEMP_MAX, y(left to left+len(x.TEMP_MAX)-1)));
      left := left + len(x.TEMP_MAX);
      assign(y(left to left+len(x.VCCINT_MAX)-1), convert(x.VCCINT_MAX, y(left to left+len(x.VCCINT_MAX)-1)));
      left := left + len(x.VCCINT_MAX);
      assign(y(left to left+len(x.VCCAUX_MAX)-1), convert(x.VCCAUX_MAX, y(left to left+len(x.VCCAUX_MAX)-1)));
      left := left + len(x.VCCAUX_MAX);
      assign(y(left to left+len(x.VCCBRAM_MAX)-1), convert(x.VCCBRAM_MAX, y(left to left+len(x.VCCBRAM_MAX)-1)));
      left := left + len(x.VCCBRAM_MAX);
      assign(y(left to left+len(x.TEMP_MIN)-1), convert(x.TEMP_MIN, y(left to left+len(x.TEMP_MIN)-1)));
      left := left + len(x.TEMP_MIN);
      assign(y(left to left+len(x.VCCINT_MIN)-1), convert(x.VCCINT_MIN, y(left to left+len(x.VCCINT_MIN)-1)));
      left := left + len(x.VCCINT_MIN);
      assign(y(left to left+len(x.VCCAUX_MIN)-1), convert(x.VCCAUX_MIN, y(left to left+len(x.VCCAUX_MIN)-1)));
      left := left + len(x.VCCAUX_MIN);
      assign(y(left to left+len(x.VCCBRAM_MIN)-1), convert(x.VCCBRAM_MIN, y(left to left+len(x.VCCBRAM_MIN)-1)));
    else
      assign(y(left downto left-len(x.TEMP)+1), convert(x.TEMP, y(left downto left-len(x.TEMP)+1)));
      left := left - len(x.TEMP);
      assign(y(left downto left-len(x.VCCINT)+1), convert(x.VCCINT, y(left downto left-len(x.VCCINT)+1)));
      left := left - len(x.VCCINT);
      assign(y(left downto left-len(x.VCCAUX)+1), convert(x.VCCAUX, y(left downto left-len(x.VCCAUX)+1)));
      left := left - len(x.VCCAUX);
      assign(y(left downto left-len(x.VCCBRAM)+1), convert(x.VCCBRAM, y(left downto left-len(x.VCCBRAM)+1)));
      left := left - len(x.VCCBRAM);
      assign(y(left downto left-len(x.TEMP_MAX)+1), convert(x.TEMP_MAX, y(left downto left-len(x.TEMP_MAX)+1)));
      left := left - len(x.TEMP_MAX);
      assign(y(left downto left-len(x.VCCINT_MAX)+1), convert(x.VCCINT_MAX, y(left downto left-len(x.VCCINT_MAX)+1)));
      left := left - len(x.VCCINT_MAX);
      assign(y(left downto left-len(x.VCCAUX_MAX)+1), convert(x.VCCAUX_MAX, y(left downto left-len(x.VCCAUX_MAX)+1)));
      left := left - len(x.VCCAUX_MAX);
      assign(y(left downto left-len(x.VCCBRAM_MAX)+1), convert(x.VCCBRAM_MAX, y(left downto left-len(x.VCCBRAM_MAX)+1)));
      left := left - len(x.VCCBRAM_MAX);
      assign(y(left downto left-len(x.TEMP_MIN)+1), convert(x.TEMP_MIN, y(left downto left-len(x.TEMP_MIN)+1)));
      left := left - len(x.TEMP_MIN);
      assign(y(left downto left-len(x.VCCINT_MIN)+1), convert(x.VCCINT_MIN, y(left downto left-len(x.VCCINT_MIN)+1)));
      left := left - len(x.VCCINT_MIN);
      assign(y(left downto left-len(x.VCCAUX_MIN)+1), convert(x.VCCAUX_MIN, y(left downto left-len(x.VCCAUX_MIN)+1)));
      left := left - len(x.VCCAUX_MIN);
      assign(y(left downto left-len(x.VCCBRAM_MIN)+1), convert(x.VCCBRAM_MIN, y(left downto left-len(x.VCCBRAM_MIN)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: KINTEX_SYS_MGMT_MON_t) return KINTEX_SYS_MGMT_MON_t is
    variable y: KINTEX_SYS_MGMT_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.TEMP := structify(x(left to left+len(y.TEMP)-1), y.TEMP);
      left := left + len(y.TEMP);
      y.VCCINT := structify(x(left to left+len(y.VCCINT)-1), y.VCCINT);
      left := left + len(y.VCCINT);
      y.VCCAUX := structify(x(left to left+len(y.VCCAUX)-1), y.VCCAUX);
      left := left + len(y.VCCAUX);
      y.VCCBRAM := structify(x(left to left+len(y.VCCBRAM)-1), y.VCCBRAM);
      left := left + len(y.VCCBRAM);
      y.TEMP_MAX := structify(x(left to left+len(y.TEMP_MAX)-1), y.TEMP_MAX);
      left := left + len(y.TEMP_MAX);
      y.VCCINT_MAX := structify(x(left to left+len(y.VCCINT_MAX)-1), y.VCCINT_MAX);
      left := left + len(y.VCCINT_MAX);
      y.VCCAUX_MAX := structify(x(left to left+len(y.VCCAUX_MAX)-1), y.VCCAUX_MAX);
      left := left + len(y.VCCAUX_MAX);
      y.VCCBRAM_MAX := structify(x(left to left+len(y.VCCBRAM_MAX)-1), y.VCCBRAM_MAX);
      left := left + len(y.VCCBRAM_MAX);
      y.TEMP_MIN := structify(x(left to left+len(y.TEMP_MIN)-1), y.TEMP_MIN);
      left := left + len(y.TEMP_MIN);
      y.VCCINT_MIN := structify(x(left to left+len(y.VCCINT_MIN)-1), y.VCCINT_MIN);
      left := left + len(y.VCCINT_MIN);
      y.VCCAUX_MIN := structify(x(left to left+len(y.VCCAUX_MIN)-1), y.VCCAUX_MIN);
      left := left + len(y.VCCAUX_MIN);
      y.VCCBRAM_MIN := structify(x(left to left+len(y.VCCBRAM_MIN)-1), y.VCCBRAM_MIN);
    else
      y.TEMP := structify(x(left downto left-len(y.TEMP)+1), y.TEMP);
      left := left - len(y.TEMP);
      y.VCCINT := structify(x(left downto left-len(y.VCCINT)+1), y.VCCINT);
      left := left - len(y.VCCINT);
      y.VCCAUX := structify(x(left downto left-len(y.VCCAUX)+1), y.VCCAUX);
      left := left - len(y.VCCAUX);
      y.VCCBRAM := structify(x(left downto left-len(y.VCCBRAM)+1), y.VCCBRAM);
      left := left - len(y.VCCBRAM);
      y.TEMP_MAX := structify(x(left downto left-len(y.TEMP_MAX)+1), y.TEMP_MAX);
      left := left - len(y.TEMP_MAX);
      y.VCCINT_MAX := structify(x(left downto left-len(y.VCCINT_MAX)+1), y.VCCINT_MAX);
      left := left - len(y.VCCINT_MAX);
      y.VCCAUX_MAX := structify(x(left downto left-len(y.VCCAUX_MAX)+1), y.VCCAUX_MAX);
      left := left - len(y.VCCAUX_MAX);
      y.VCCBRAM_MAX := structify(x(left downto left-len(y.VCCBRAM_MAX)+1), y.VCCBRAM_MAX);
      left := left - len(y.VCCBRAM_MAX);
      y.TEMP_MIN := structify(x(left downto left-len(y.TEMP_MIN)+1), y.TEMP_MIN);
      left := left - len(y.TEMP_MIN);
      y.VCCINT_MIN := structify(x(left downto left-len(y.VCCINT_MIN)+1), y.VCCINT_MIN);
      left := left - len(y.VCCINT_MIN);
      y.VCCAUX_MIN := structify(x(left downto left-len(y.VCCAUX_MIN)+1), y.VCCAUX_MIN);
      left := left - len(y.VCCAUX_MIN);
      y.VCCBRAM_MIN := structify(x(left downto left-len(y.VCCBRAM_MIN)+1), y.VCCBRAM_MIN);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: KINTEX_SYS_MGMT_MON_t) return KINTEX_SYS_MGMT_MON_t is
    variable y: KINTEX_SYS_MGMT_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.TEMP := convert(x(left to left+len(y.TEMP)-1), y.TEMP);
      left := left + len(y.TEMP);
      y.VCCINT := convert(x(left to left+len(y.VCCINT)-1), y.VCCINT);
      left := left + len(y.VCCINT);
      y.VCCAUX := convert(x(left to left+len(y.VCCAUX)-1), y.VCCAUX);
      left := left + len(y.VCCAUX);
      y.VCCBRAM := convert(x(left to left+len(y.VCCBRAM)-1), y.VCCBRAM);
      left := left + len(y.VCCBRAM);
      y.TEMP_MAX := convert(x(left to left+len(y.TEMP_MAX)-1), y.TEMP_MAX);
      left := left + len(y.TEMP_MAX);
      y.VCCINT_MAX := convert(x(left to left+len(y.VCCINT_MAX)-1), y.VCCINT_MAX);
      left := left + len(y.VCCINT_MAX);
      y.VCCAUX_MAX := convert(x(left to left+len(y.VCCAUX_MAX)-1), y.VCCAUX_MAX);
      left := left + len(y.VCCAUX_MAX);
      y.VCCBRAM_MAX := convert(x(left to left+len(y.VCCBRAM_MAX)-1), y.VCCBRAM_MAX);
      left := left + len(y.VCCBRAM_MAX);
      y.TEMP_MIN := convert(x(left to left+len(y.TEMP_MIN)-1), y.TEMP_MIN);
      left := left + len(y.TEMP_MIN);
      y.VCCINT_MIN := convert(x(left to left+len(y.VCCINT_MIN)-1), y.VCCINT_MIN);
      left := left + len(y.VCCINT_MIN);
      y.VCCAUX_MIN := convert(x(left to left+len(y.VCCAUX_MIN)-1), y.VCCAUX_MIN);
      left := left + len(y.VCCAUX_MIN);
      y.VCCBRAM_MIN := convert(x(left to left+len(y.VCCBRAM_MIN)-1), y.VCCBRAM_MIN);
    else
      y.TEMP := convert(x(left downto left-len(y.TEMP)+1), y.TEMP);
      left := left - len(y.TEMP);
      y.VCCINT := convert(x(left downto left-len(y.VCCINT)+1), y.VCCINT);
      left := left - len(y.VCCINT);
      y.VCCAUX := convert(x(left downto left-len(y.VCCAUX)+1), y.VCCAUX);
      left := left - len(y.VCCAUX);
      y.VCCBRAM := convert(x(left downto left-len(y.VCCBRAM)+1), y.VCCBRAM);
      left := left - len(y.VCCBRAM);
      y.TEMP_MAX := convert(x(left downto left-len(y.TEMP_MAX)+1), y.TEMP_MAX);
      left := left - len(y.TEMP_MAX);
      y.VCCINT_MAX := convert(x(left downto left-len(y.VCCINT_MAX)+1), y.VCCINT_MAX);
      left := left - len(y.VCCINT_MAX);
      y.VCCAUX_MAX := convert(x(left downto left-len(y.VCCAUX_MAX)+1), y.VCCAUX_MAX);
      left := left - len(y.VCCAUX_MAX);
      y.VCCBRAM_MAX := convert(x(left downto left-len(y.VCCBRAM_MAX)+1), y.VCCBRAM_MAX);
      left := left - len(y.VCCBRAM_MAX);
      y.TEMP_MIN := convert(x(left downto left-len(y.TEMP_MIN)+1), y.TEMP_MIN);
      left := left - len(y.TEMP_MIN);
      y.VCCINT_MIN := convert(x(left downto left-len(y.VCCINT_MIN)+1), y.VCCINT_MIN);
      left := left - len(y.VCCINT_MIN);
      y.VCCAUX_MIN := convert(x(left downto left-len(y.VCCAUX_MIN)+1), y.VCCAUX_MIN);
      left := left - len(y.VCCAUX_MIN);
      y.VCCBRAM_MIN := convert(x(left downto left-len(y.VCCBRAM_MIN)+1), y.VCCBRAM_MIN);
    end if;
    return y;
  end function convert;
  function nullify(t: KINTEX_SYS_MGMT_MON_t) return KINTEX_SYS_MGMT_MON_t is
  variable y: KINTEX_SYS_MGMT_MON_t;
  begin
    y.TEMP := nullify(t.TEMP);
    y.VCCINT := nullify(t.VCCINT);
    y.VCCAUX := nullify(t.VCCAUX);
    y.VCCBRAM := nullify(t.VCCBRAM);
    y.TEMP_MAX := nullify(t.TEMP_MAX);
    y.VCCINT_MAX := nullify(t.VCCINT_MAX);
    y.VCCAUX_MAX := nullify(t.VCCAUX_MAX);
    y.VCCBRAM_MAX := nullify(t.VCCBRAM_MAX);
    y.TEMP_MIN := nullify(t.TEMP_MIN);
    y.VCCINT_MIN := nullify(t.VCCINT_MIN);
    y.VCCAUX_MIN := nullify(t.VCCAUX_MIN);
    y.VCCBRAM_MIN := nullify(t.VCCBRAM_MIN);
    return y;
  end function nullify;
  function zeroed(t: KINTEX_SYS_MGMT_MON_t) return KINTEX_SYS_MGMT_MON_t is
  variable y: KINTEX_SYS_MGMT_MON_t;
  begin
    y.TEMP := zeroed(t.TEMP);
    y.VCCINT := zeroed(t.VCCINT);
    y.VCCAUX := zeroed(t.VCCAUX);
    y.VCCBRAM := zeroed(t.VCCBRAM);
    y.TEMP_MAX := zeroed(t.TEMP_MAX);
    y.VCCINT_MAX := zeroed(t.VCCINT_MAX);
    y.VCCAUX_MAX := zeroed(t.VCCAUX_MAX);
    y.VCCBRAM_MAX := zeroed(t.VCCBRAM_MAX);
    y.TEMP_MIN := zeroed(t.TEMP_MIN);
    y.VCCINT_MIN := zeroed(t.VCCINT_MIN);
    y.VCCAUX_MIN := zeroed(t.VCCAUX_MIN);
    y.VCCBRAM_MIN := zeroed(t.VCCBRAM_MIN);
    return y;
  end function zeroed;

end package body KINTEX_SYS_MGMT_CTRL;
