-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl
-- 2022-03-14 23:33:50

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package UCM_PKG is

   -- Custom types and functions --

   type UCM_SUPER_ACTIONS_CTRL_t is record
      RESET : std_logic;
      ENABLE : std_logic;
      DISABLE : std_logic;
      FREEZE : std_logic;
   end record UCM_SUPER_ACTIONS_CTRL_t;
   function width(x: UCM_SUPER_ACTIONS_CTRL_t) return natural;
   function convert(x: UCM_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_ACTIONS_CTRL_t) return UCM_SUPER_ACTIONS_CTRL_t;

   type UCM_SUPER_CONFIGS_CTRL_t is record
      THREADS : std_logic_vector(4-1 downto 0);
      INPUT_EN : std_logic;
      OUTPUT_EN : std_logic;
   end record UCM_SUPER_CONFIGS_CTRL_t;
   function width(x: UCM_SUPER_CONFIGS_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CONFIGS_CTRL_t) return UCM_SUPER_CONFIGS_CTRL_t;

   type UCM_SUPER_STATUS_MON_t is record
      ENABLED : std_logic;
      READY : std_logic;
      ERROR : std_logic_vector(8-1 downto 0);
   end record UCM_SUPER_STATUS_MON_t;
   function width(x: UCM_SUPER_STATUS_MON_t) return natural;
   function convert(x: UCM_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_STATUS_MON_t) return UCM_SUPER_STATUS_MON_t;

   type UCM_SUPER_SECTOR_PHI_MON_t is record
      rd_data : std_logic_vector(10-1 downto 0);
   end record UCM_SUPER_SECTOR_PHI_MON_t;
   function width(x: UCM_SUPER_SECTOR_PHI_MON_t) return natural;
   function convert(x: UCM_SUPER_SECTOR_PHI_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_SECTOR_PHI_MON_t) return UCM_SUPER_SECTOR_PHI_MON_t;

   type UCM_SUPER_SECTOR_PHI_CTRL_t is record
      wr_req : std_logic;
      rd_req : std_logic;
      wr_data : std_logic_vector(10-1 downto 0);
   end record UCM_SUPER_SECTOR_PHI_CTRL_t;
   function width(x: UCM_SUPER_SECTOR_PHI_CTRL_t) return natural;
   function convert(x: UCM_SUPER_SECTOR_PHI_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_SECTOR_PHI_CTRL_t) return UCM_SUPER_SECTOR_PHI_CTRL_t;

   type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t is record
      rd_rdy : std_logic;
      freeze_ena : std_logic;
   end record UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t) return natural;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t;

   type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t is record
      wr_req : std_logic;
      wr_ack : std_logic;
      rd_req : std_logic;
      rd_ack : std_logic;
      flush_req : std_logic;
      freeze_req : std_logic;
      mem_sel : std_logic_vector(3-1 downto 0);
   end record UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t;

   type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t is record
      wr_data_0 : std_logic_vector(16-1 downto 0);
   end record UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t;

   type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t is record
      rd_data_0 : std_logic_vector(16-1 downto 0);
   end record UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t) return natural;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t;

   type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t is record
      SIGNALS : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t;
      rd_data : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t;
   end record UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return natural;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t;

   type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY is array(4-1 downto 0) of UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return integer;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;

   type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t is record
      SIGNALS : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t;
      wr_addr : std_logic_vector(8-1 downto 0);
      rd_addr : std_logic_vector(8-1 downto 0);
      wr_data : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t;
   end record UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t;

   type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY is array(4-1 downto 0) of UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return integer;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;

   type UCM_SUPER_CDE_CHAMB_Z0_MON_t is record
      CDE_CHAMB_Z0 : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;
   end record UCM_SUPER_CDE_CHAMB_Z0_MON_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return natural;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_MON_t;

   type UCM_SUPER_CDE_CHAMB_Z0_CTRL_t is record
      CDE_CHAMB_Z0 : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;
   end record UCM_SUPER_CDE_CHAMB_Z0_CTRL_t;
   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CTRL_t;

   type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t is record
      rd_rdy : std_logic;
      freeze_ena : std_logic;
   end record UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t) return natural;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t;

   type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t is record
      wr_req : std_logic;
      wr_ack : std_logic;
      rd_req : std_logic;
      rd_ack : std_logic;
      flush_req : std_logic;
      freeze_req : std_logic;
      mem_sel : std_logic_vector(3-1 downto 0);
   end record UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t;

   type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t is record
      wr_data_0 : std_logic_vector(16-1 downto 0);
   end record UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t;

   type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t is record
      rd_data_0 : std_logic_vector(16-1 downto 0);
   end record UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t) return natural;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t;

   type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t is record
      SIGNALS : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t;
      rd_data : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t;
   end record UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return natural;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t;

   type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY is array(4-1 downto 0) of UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return integer;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;

   type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t is record
      SIGNALS : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t;
      wr_addr : std_logic_vector(8-1 downto 0);
      rd_addr : std_logic_vector(8-1 downto 0);
      wr_data : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t;
   end record UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t;

   type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY is array(4-1 downto 0) of UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return integer;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;

   type UCM_SUPER_CVP_CHAMB_Z0_MON_t is record
      CVP_CHAMB_Z0 : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;
   end record UCM_SUPER_CVP_CHAMB_Z0_MON_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return natural;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_MON_t;

   type UCM_SUPER_CVP_CHAMB_Z0_CTRL_t is record
      CVP_CHAMB_Z0 : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;
   end record UCM_SUPER_CVP_CHAMB_Z0_CTRL_t;
   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CTRL_t;

   type UCM_SUPER_MON_t is record
      STATUS : UCM_SUPER_STATUS_MON_t;
      SECTOR_PHI : UCM_SUPER_SECTOR_PHI_MON_t;
      CDE_CHAMB_Z0 : UCM_SUPER_CDE_CHAMB_Z0_MON_t;
      CVP_CHAMB_Z0 : UCM_SUPER_CVP_CHAMB_Z0_MON_t;
   end record UCM_SUPER_MON_t;
   function width(x: UCM_SUPER_MON_t) return natural;
   function convert(x: UCM_SUPER_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_MON_t) return UCM_SUPER_MON_t;

   type UCM_SUPER_CTRL_t is record
      ACTIONS : UCM_SUPER_ACTIONS_CTRL_t;
      CONFIGS : UCM_SUPER_CONFIGS_CTRL_t;
      SECTOR_PHI : UCM_SUPER_SECTOR_PHI_CTRL_t;
      CDE_CHAMB_Z0 : UCM_SUPER_CDE_CHAMB_Z0_CTRL_t;
      CVP_CHAMB_Z0 : UCM_SUPER_CVP_CHAMB_Z0_CTRL_t;
   end record UCM_SUPER_CTRL_t;
   function width(x: UCM_SUPER_CTRL_t) return natural;
   function convert(x: UCM_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_SUPER_CTRL_t) return UCM_SUPER_CTRL_t;

   type UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t is record
      rd_rdy : std_logic;
      rd_data : std_logic_vector(12-1 downto 0);
   end record UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t;
   function width(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return natural;
   function convert(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t;

   type UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t is record
      wr_req : std_logic;
      rd_req : std_logic;
      wr_addr : std_logic_vector(5-1 downto 0);
      rd_addr : std_logic_vector(5-1 downto 0);
      wr_data : std_logic_vector(12-1 downto 0);
   end record UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t;
   function width(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return natural;
   function convert(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t;

   type UCM_R_PHI_COMP_RPC_MON_t is record
      MEM_INTERFACE : UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t;
   end record UCM_R_PHI_COMP_RPC_MON_t;
   function width(x: UCM_R_PHI_COMP_RPC_MON_t) return natural;
   function convert(x: UCM_R_PHI_COMP_RPC_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_RPC_MON_t) return UCM_R_PHI_COMP_RPC_MON_t;

   type UCM_R_PHI_COMP_RPC_CTRL_t is record
      sel_thread : std_logic_vector(4-1 downto 0);
      sel_station : std_logic_vector(4-1 downto 0);
      sel_layer : std_logic_vector(4-1 downto 0);
      ext_ctrl : std_logic;
      MEM_INTERFACE : UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t;
   end record UCM_R_PHI_COMP_RPC_CTRL_t;
   function width(x: UCM_R_PHI_COMP_RPC_CTRL_t) return natural;
   function convert(x: UCM_R_PHI_COMP_RPC_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_RPC_CTRL_t) return UCM_R_PHI_COMP_RPC_CTRL_t;

   type UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t is record
      rd_rdy : std_logic;
      rd_data : std_logic_vector(14-1 downto 0);
   end record UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t;
   function width(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return natural;
   function convert(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t;

   type UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t is record
      wr_req : std_logic;
      rd_req : std_logic;
      wr_addr : std_logic_vector(5-1 downto 0);
      rd_addr : std_logic_vector(5-1 downto 0);
      wr_data : std_logic_vector(14-1 downto 0);
   end record UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t;
   function width(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return natural;
   function convert(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t;

   type UCM_R_PHI_COMP_MDT_MON_t is record
      MEM_INTERFACE : UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t;
   end record UCM_R_PHI_COMP_MDT_MON_t;
   function width(x: UCM_R_PHI_COMP_MDT_MON_t) return natural;
   function convert(x: UCM_R_PHI_COMP_MDT_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MDT_MON_t) return UCM_R_PHI_COMP_MDT_MON_t;

   type UCM_R_PHI_COMP_MDT_CTRL_t is record
      sel_thread : std_logic_vector(4-1 downto 0);
      sel_station : std_logic_vector(4-1 downto 0);
      sel_layer : std_logic_vector(4-1 downto 0);
      ext_ctrl : std_logic;
      MEM_INTERFACE : UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t;
   end record UCM_R_PHI_COMP_MDT_CTRL_t;
   function width(x: UCM_R_PHI_COMP_MDT_CTRL_t) return natural;
   function convert(x: UCM_R_PHI_COMP_MDT_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MDT_CTRL_t) return UCM_R_PHI_COMP_MDT_CTRL_t;

   type UCM_R_PHI_COMP_MON_t is record
      RPC : UCM_R_PHI_COMP_RPC_MON_t;
      MDT : UCM_R_PHI_COMP_MDT_MON_t;
   end record UCM_R_PHI_COMP_MON_t;
   function width(x: UCM_R_PHI_COMP_MON_t) return natural;
   function convert(x: UCM_R_PHI_COMP_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MON_t) return UCM_R_PHI_COMP_MON_t;

   type UCM_R_PHI_COMP_CTRL_t is record
      RPC : UCM_R_PHI_COMP_RPC_CTRL_t;
      MDT : UCM_R_PHI_COMP_MDT_CTRL_t;
   end record UCM_R_PHI_COMP_CTRL_t;
   function width(x: UCM_R_PHI_COMP_CTRL_t) return natural;
   function convert(x: UCM_R_PHI_COMP_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_CTRL_t) return UCM_R_PHI_COMP_CTRL_t;

   type UCM_MON_t is record
      SUPER : UCM_SUPER_MON_t;
      R_PHI_COMP : UCM_R_PHI_COMP_MON_t;
   end record UCM_MON_t;
   function width(x: UCM_MON_t) return natural;
   function convert(x: UCM_MON_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_MON_t) return UCM_MON_t;

   type UCM_CTRL_t is record
      SUPER : UCM_SUPER_CTRL_t;
      R_PHI_COMP : UCM_R_PHI_COMP_CTRL_t;
   end record UCM_CTRL_t;
   function width(x: UCM_CTRL_t) return natural;
   function convert(x: UCM_CTRL_t; t: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; t: UCM_CTRL_t) return UCM_CTRL_t;

end package UCM_PKG;

------------------------------------------------------------

package body UCM_PKG is

   -- Custom types and functions --

   function width(x: UCM_SUPER_ACTIONS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET);
      w := w + width(x.ENABLE);
      w := w + width(x.DISABLE);
      w := w + width(x.FREEZE);
      return w;
   end function width;
   function convert(x: UCM_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.RESET);
         y(u to u+w-1) := convert(x.RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.ENABLE);
         y(u to u+w-1) := convert(x.ENABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.DISABLE);
         y(u to u+w-1) := convert(x.DISABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.FREEZE);
         y(u to u+w-1) := convert(x.FREEZE, y(u to u+w-1));
      else
         w := width(x.RESET);
         y(u downto u-w+1) := convert(x.RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.ENABLE);
         y(u downto u-w+1) := convert(x.ENABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.DISABLE);
         y(u downto u-w+1) := convert(x.DISABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.FREEZE);
         y(u downto u-w+1) := convert(x.FREEZE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_ACTIONS_CTRL_t) return UCM_SUPER_ACTIONS_CTRL_t is
      variable y : UCM_SUPER_ACTIONS_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.RESET);
         y.RESET := convert(x(u to u+w-1), t.RESET);
         u := u + w;
         w := width(t.ENABLE);
         y.ENABLE := convert(x(u to u+w-1), t.ENABLE);
         u := u + w;
         w := width(t.DISABLE);
         y.DISABLE := convert(x(u to u+w-1), t.DISABLE);
         u := u + w;
         w := width(t.FREEZE);
         y.FREEZE := convert(x(u to u+w-1), t.FREEZE);
      else
         w := width(t.RESET);
         y.RESET := convert(x(u downto u-w+1), t.RESET);
         u := u - w;
         w := width(t.ENABLE);
         y.ENABLE := convert(x(u downto u-w+1), t.ENABLE);
         u := u - w;
         w := width(t.DISABLE);
         y.DISABLE := convert(x(u downto u-w+1), t.DISABLE);
         u := u - w;
         w := width(t.FREEZE);
         y.FREEZE := convert(x(u downto u-w+1), t.FREEZE);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CONFIGS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.THREADS);
      w := w + width(x.INPUT_EN);
      w := w + width(x.OUTPUT_EN);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.THREADS);
         y(u to u+w-1) := convert(x.THREADS, y(u to u+w-1));
         u := u + w;
         w := width(x.INPUT_EN);
         y(u to u+w-1) := convert(x.INPUT_EN, y(u to u+w-1));
         u := u + w;
         w := width(x.OUTPUT_EN);
         y(u to u+w-1) := convert(x.OUTPUT_EN, y(u to u+w-1));
      else
         w := width(x.THREADS);
         y(u downto u-w+1) := convert(x.THREADS, y(u downto u-w+1));
         u := u - w;
         w := width(x.INPUT_EN);
         y(u downto u-w+1) := convert(x.INPUT_EN, y(u downto u-w+1));
         u := u - w;
         w := width(x.OUTPUT_EN);
         y(u downto u-w+1) := convert(x.OUTPUT_EN, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CONFIGS_CTRL_t) return UCM_SUPER_CONFIGS_CTRL_t is
      variable y : UCM_SUPER_CONFIGS_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.THREADS);
         y.THREADS := convert(x(u to u+w-1), t.THREADS);
         u := u + w;
         w := width(t.INPUT_EN);
         y.INPUT_EN := convert(x(u to u+w-1), t.INPUT_EN);
         u := u + w;
         w := width(t.OUTPUT_EN);
         y.OUTPUT_EN := convert(x(u to u+w-1), t.OUTPUT_EN);
      else
         w := width(t.THREADS);
         y.THREADS := convert(x(u downto u-w+1), t.THREADS);
         u := u - w;
         w := width(t.INPUT_EN);
         y.INPUT_EN := convert(x(u downto u-w+1), t.INPUT_EN);
         u := u - w;
         w := width(t.OUTPUT_EN);
         y.OUTPUT_EN := convert(x(u downto u-w+1), t.OUTPUT_EN);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_STATUS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ENABLED);
      w := w + width(x.READY);
      w := w + width(x.ERROR);
      return w;
   end function width;
   function convert(x: UCM_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.ENABLED);
         y(u to u+w-1) := convert(x.ENABLED, y(u to u+w-1));
         u := u + w;
         w := width(x.READY);
         y(u to u+w-1) := convert(x.READY, y(u to u+w-1));
         u := u + w;
         w := width(x.ERROR);
         y(u to u+w-1) := convert(x.ERROR, y(u to u+w-1));
      else
         w := width(x.ENABLED);
         y(u downto u-w+1) := convert(x.ENABLED, y(u downto u-w+1));
         u := u - w;
         w := width(x.READY);
         y(u downto u-w+1) := convert(x.READY, y(u downto u-w+1));
         u := u - w;
         w := width(x.ERROR);
         y(u downto u-w+1) := convert(x.ERROR, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_STATUS_MON_t) return UCM_SUPER_STATUS_MON_t is
      variable y : UCM_SUPER_STATUS_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.ENABLED);
         y.ENABLED := convert(x(u to u+w-1), t.ENABLED);
         u := u + w;
         w := width(t.READY);
         y.READY := convert(x(u to u+w-1), t.READY);
         u := u + w;
         w := width(t.ERROR);
         y.ERROR := convert(x(u to u+w-1), t.ERROR);
      else
         w := width(t.ENABLED);
         y.ENABLED := convert(x(u downto u-w+1), t.ENABLED);
         u := u - w;
         w := width(t.READY);
         y.READY := convert(x(u downto u-w+1), t.READY);
         u := u - w;
         w := width(t.ERROR);
         y.ERROR := convert(x(u downto u-w+1), t.ERROR);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_SECTOR_PHI_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: UCM_SUPER_SECTOR_PHI_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_SECTOR_PHI_MON_t) return UCM_SUPER_SECTOR_PHI_MON_t is
      variable y : UCM_SUPER_SECTOR_PHI_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.rd_data);
         y.rd_data := convert(x(u to u+w-1), t.rd_data);
      else
         w := width(t.rd_data);
         y.rd_data := convert(x(u downto u-w+1), t.rd_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_SECTOR_PHI_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_req);
      w := w + width(x.rd_req);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: UCM_SUPER_SECTOR_PHI_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.wr_req);
         y(u to u+w-1) := convert(x.wr_req, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_req);
         y(u to u+w-1) := convert(x.rd_req, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.wr_req);
         y(u downto u-w+1) := convert(x.wr_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_req);
         y(u downto u-w+1) := convert(x.rd_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_SECTOR_PHI_CTRL_t) return UCM_SUPER_SECTOR_PHI_CTRL_t is
      variable y : UCM_SUPER_SECTOR_PHI_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.wr_req);
         y.wr_req := convert(x(u to u+w-1), t.wr_req);
         u := u + w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u to u+w-1), t.rd_req);
         u := u + w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u to u+w-1), t.wr_data);
      else
         w := width(t.wr_req);
         y.wr_req := convert(x(u downto u-w+1), t.wr_req);
         u := u - w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u downto u-w+1), t.rd_req);
         u := u - w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u downto u-w+1), t.wr_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_rdy);
      w := w + width(x.freeze_ena);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.rd_rdy);
         y(u to u+w-1) := convert(x.rd_rdy, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_ena);
         y(u to u+w-1) := convert(x.freeze_ena, y(u to u+w-1));
      else
         w := width(x.rd_rdy);
         y(u downto u-w+1) := convert(x.rd_rdy, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_ena);
         y(u downto u-w+1) := convert(x.freeze_ena, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.rd_rdy);
         y.rd_rdy := convert(x(u to u+w-1), t.rd_rdy);
         u := u + w;
         w := width(t.freeze_ena);
         y.freeze_ena := convert(x(u to u+w-1), t.freeze_ena);
      else
         w := width(t.rd_rdy);
         y.rd_rdy := convert(x(u downto u-w+1), t.rd_rdy);
         u := u - w;
         w := width(t.freeze_ena);
         y.freeze_ena := convert(x(u downto u-w+1), t.freeze_ena);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_req);
      w := w + width(x.wr_ack);
      w := w + width(x.rd_req);
      w := w + width(x.rd_ack);
      w := w + width(x.flush_req);
      w := w + width(x.freeze_req);
      w := w + width(x.mem_sel);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.wr_req);
         y(u to u+w-1) := convert(x.wr_req, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_ack);
         y(u to u+w-1) := convert(x.wr_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_req);
         y(u to u+w-1) := convert(x.rd_req, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_ack);
         y(u to u+w-1) := convert(x.rd_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.flush_req);
         y(u to u+w-1) := convert(x.flush_req, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_req);
         y(u to u+w-1) := convert(x.freeze_req, y(u to u+w-1));
         u := u + w;
         w := width(x.mem_sel);
         y(u to u+w-1) := convert(x.mem_sel, y(u to u+w-1));
      else
         w := width(x.wr_req);
         y(u downto u-w+1) := convert(x.wr_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_ack);
         y(u downto u-w+1) := convert(x.wr_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_req);
         y(u downto u-w+1) := convert(x.rd_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_ack);
         y(u downto u-w+1) := convert(x.rd_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.flush_req);
         y(u downto u-w+1) := convert(x.flush_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_req);
         y(u downto u-w+1) := convert(x.freeze_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.mem_sel);
         y(u downto u-w+1) := convert(x.mem_sel, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_SIGNALS_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.wr_req);
         y.wr_req := convert(x(u to u+w-1), t.wr_req);
         u := u + w;
         w := width(t.wr_ack);
         y.wr_ack := convert(x(u to u+w-1), t.wr_ack);
         u := u + w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u to u+w-1), t.rd_req);
         u := u + w;
         w := width(t.rd_ack);
         y.rd_ack := convert(x(u to u+w-1), t.rd_ack);
         u := u + w;
         w := width(t.flush_req);
         y.flush_req := convert(x(u to u+w-1), t.flush_req);
         u := u + w;
         w := width(t.freeze_req);
         y.freeze_req := convert(x(u to u+w-1), t.freeze_req);
         u := u + w;
         w := width(t.mem_sel);
         y.mem_sel := convert(x(u to u+w-1), t.mem_sel);
      else
         w := width(t.wr_req);
         y.wr_req := convert(x(u downto u-w+1), t.wr_req);
         u := u - w;
         w := width(t.wr_ack);
         y.wr_ack := convert(x(u downto u-w+1), t.wr_ack);
         u := u - w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u downto u-w+1), t.rd_req);
         u := u - w;
         w := width(t.rd_ack);
         y.rd_ack := convert(x(u downto u-w+1), t.rd_ack);
         u := u - w;
         w := width(t.flush_req);
         y.flush_req := convert(x(u downto u-w+1), t.flush_req);
         u := u - w;
         w := width(t.freeze_req);
         y.freeze_req := convert(x(u downto u-w+1), t.freeze_req);
         u := u - w;
         w := width(t.mem_sel);
         y.mem_sel := convert(x(u downto u-w+1), t.mem_sel);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_data_0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.wr_data_0);
         y(u to u+w-1) := convert(x.wr_data_0, y(u to u+w-1));
      else
         w := width(x.wr_data_0);
         y(u downto u-w+1) := convert(x.wr_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_wr_data_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.wr_data_0);
         y.wr_data_0 := convert(x(u to u+w-1), t.wr_data_0);
      else
         w := width(t.wr_data_0);
         y.wr_data_0 := convert(x(u downto u-w+1), t.wr_data_0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_data_0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.rd_data_0);
         y(u to u+w-1) := convert(x.rd_data_0, y(u to u+w-1));
      else
         w := width(x.rd_data_0);
         y(u downto u-w+1) := convert(x.rd_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_rd_data_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.rd_data_0);
         y.rd_data_0 := convert(x(u to u+w-1), t.rd_data_0);
      else
         w := width(t.rd_data_0);
         y.rd_data_0 := convert(x(u downto u-w+1), t.rd_data_0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), t.SIGNALS);
         u := u + w;
         w := width(t.rd_data);
         y.rd_data := convert(x(u to u+w-1), t.rd_data);
      else
         w := width(t.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), t.SIGNALS);
         u := u - w;
         w := width(t.rd_data);
         y.rd_data := convert(x(u downto u-w+1), t.rd_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(t'range)(t(t'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.wr_addr);
      w := w + width(x.rd_addr);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_addr);
         y(u to u+w-1) := convert(x.wr_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_addr);
         y(u to u+w-1) := convert(x.rd_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_addr);
         y(u downto u-w+1) := convert(x.wr_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_addr);
         y(u downto u-w+1) := convert(x.rd_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), t.SIGNALS);
         u := u + w;
         w := width(t.wr_addr);
         y.wr_addr := convert(x(u to u+w-1), t.wr_addr);
         u := u + w;
         w := width(t.rd_addr);
         y.rd_addr := convert(x(u to u+w-1), t.rd_addr);
         u := u + w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u to u+w-1), t.wr_data);
      else
         w := width(t.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), t.SIGNALS);
         u := u - w;
         w := width(t.wr_addr);
         y.wr_addr := convert(x(u downto u-w+1), t.wr_addr);
         u := u - w;
         w := width(t.rd_addr);
         y.rd_addr := convert(x(u downto u-w+1), t.rd_addr);
         u := u - w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u downto u-w+1), t.wr_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(t'range)(t(t'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CDE_CHAMB_Z0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.CDE_CHAMB_Z0);
         y(u to u+w-1) := convert(x.CDE_CHAMB_Z0, y(u to u+w-1));
      else
         w := width(x.CDE_CHAMB_Z0);
         y(u downto u-w+1) := convert(x.CDE_CHAMB_Z0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_MON_t is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.CDE_CHAMB_Z0);
         y.CDE_CHAMB_Z0 := convert(x(u to u+w-1), t.CDE_CHAMB_Z0);
      else
         w := width(t.CDE_CHAMB_Z0);
         y.CDE_CHAMB_Z0 := convert(x(u downto u-w+1), t.CDE_CHAMB_Z0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CDE_CHAMB_Z0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.CDE_CHAMB_Z0);
         y(u to u+w-1) := convert(x.CDE_CHAMB_Z0, y(u to u+w-1));
      else
         w := width(x.CDE_CHAMB_Z0);
         y(u downto u-w+1) := convert(x.CDE_CHAMB_Z0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CTRL_t is
      variable y : UCM_SUPER_CDE_CHAMB_Z0_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.CDE_CHAMB_Z0);
         y.CDE_CHAMB_Z0 := convert(x(u to u+w-1), t.CDE_CHAMB_Z0);
      else
         w := width(t.CDE_CHAMB_Z0);
         y.CDE_CHAMB_Z0 := convert(x(u downto u-w+1), t.CDE_CHAMB_Z0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_rdy);
      w := w + width(x.freeze_ena);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.rd_rdy);
         y(u to u+w-1) := convert(x.rd_rdy, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_ena);
         y(u to u+w-1) := convert(x.freeze_ena, y(u to u+w-1));
      else
         w := width(x.rd_rdy);
         y(u downto u-w+1) := convert(x.rd_rdy, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_ena);
         y(u downto u-w+1) := convert(x.freeze_ena, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.rd_rdy);
         y.rd_rdy := convert(x(u to u+w-1), t.rd_rdy);
         u := u + w;
         w := width(t.freeze_ena);
         y.freeze_ena := convert(x(u to u+w-1), t.freeze_ena);
      else
         w := width(t.rd_rdy);
         y.rd_rdy := convert(x(u downto u-w+1), t.rd_rdy);
         u := u - w;
         w := width(t.freeze_ena);
         y.freeze_ena := convert(x(u downto u-w+1), t.freeze_ena);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_req);
      w := w + width(x.wr_ack);
      w := w + width(x.rd_req);
      w := w + width(x.rd_ack);
      w := w + width(x.flush_req);
      w := w + width(x.freeze_req);
      w := w + width(x.mem_sel);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.wr_req);
         y(u to u+w-1) := convert(x.wr_req, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_ack);
         y(u to u+w-1) := convert(x.wr_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_req);
         y(u to u+w-1) := convert(x.rd_req, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_ack);
         y(u to u+w-1) := convert(x.rd_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.flush_req);
         y(u to u+w-1) := convert(x.flush_req, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_req);
         y(u to u+w-1) := convert(x.freeze_req, y(u to u+w-1));
         u := u + w;
         w := width(x.mem_sel);
         y(u to u+w-1) := convert(x.mem_sel, y(u to u+w-1));
      else
         w := width(x.wr_req);
         y(u downto u-w+1) := convert(x.wr_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_ack);
         y(u downto u-w+1) := convert(x.wr_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_req);
         y(u downto u-w+1) := convert(x.rd_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_ack);
         y(u downto u-w+1) := convert(x.rd_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.flush_req);
         y(u downto u-w+1) := convert(x.flush_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_req);
         y(u downto u-w+1) := convert(x.freeze_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.mem_sel);
         y(u downto u-w+1) := convert(x.mem_sel, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_SIGNALS_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.wr_req);
         y.wr_req := convert(x(u to u+w-1), t.wr_req);
         u := u + w;
         w := width(t.wr_ack);
         y.wr_ack := convert(x(u to u+w-1), t.wr_ack);
         u := u + w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u to u+w-1), t.rd_req);
         u := u + w;
         w := width(t.rd_ack);
         y.rd_ack := convert(x(u to u+w-1), t.rd_ack);
         u := u + w;
         w := width(t.flush_req);
         y.flush_req := convert(x(u to u+w-1), t.flush_req);
         u := u + w;
         w := width(t.freeze_req);
         y.freeze_req := convert(x(u to u+w-1), t.freeze_req);
         u := u + w;
         w := width(t.mem_sel);
         y.mem_sel := convert(x(u to u+w-1), t.mem_sel);
      else
         w := width(t.wr_req);
         y.wr_req := convert(x(u downto u-w+1), t.wr_req);
         u := u - w;
         w := width(t.wr_ack);
         y.wr_ack := convert(x(u downto u-w+1), t.wr_ack);
         u := u - w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u downto u-w+1), t.rd_req);
         u := u - w;
         w := width(t.rd_ack);
         y.rd_ack := convert(x(u downto u-w+1), t.rd_ack);
         u := u - w;
         w := width(t.flush_req);
         y.flush_req := convert(x(u downto u-w+1), t.flush_req);
         u := u - w;
         w := width(t.freeze_req);
         y.freeze_req := convert(x(u downto u-w+1), t.freeze_req);
         u := u - w;
         w := width(t.mem_sel);
         y.mem_sel := convert(x(u downto u-w+1), t.mem_sel);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_data_0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.wr_data_0);
         y(u to u+w-1) := convert(x.wr_data_0, y(u to u+w-1));
      else
         w := width(x.wr_data_0);
         y(u downto u-w+1) := convert(x.wr_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_wr_data_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.wr_data_0);
         y.wr_data_0 := convert(x(u to u+w-1), t.wr_data_0);
      else
         w := width(t.wr_data_0);
         y.wr_data_0 := convert(x(u downto u-w+1), t.wr_data_0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_data_0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.rd_data_0);
         y(u to u+w-1) := convert(x.rd_data_0, y(u to u+w-1));
      else
         w := width(x.rd_data_0);
         y(u downto u-w+1) := convert(x.rd_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_rd_data_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.rd_data_0);
         y.rd_data_0 := convert(x(u to u+w-1), t.rd_data_0);
      else
         w := width(t.rd_data_0);
         y.rd_data_0 := convert(x(u downto u-w+1), t.rd_data_0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), t.SIGNALS);
         u := u + w;
         w := width(t.rd_data);
         y.rd_data := convert(x(u to u+w-1), t.rd_data);
      else
         w := width(t.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), t.SIGNALS);
         u := u - w;
         w := width(t.rd_data);
         y.rd_data := convert(x(u downto u-w+1), t.rd_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(t'range)(t(t'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.wr_addr);
      w := w + width(x.rd_addr);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_addr);
         y(u to u+w-1) := convert(x.wr_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_addr);
         y(u to u+w-1) := convert(x.rd_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_addr);
         y(u downto u-w+1) := convert(x.wr_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_addr);
         y(u downto u-w+1) := convert(x.rd_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), t.SIGNALS);
         u := u + w;
         w := width(t.wr_addr);
         y.wr_addr := convert(x(u to u+w-1), t.wr_addr);
         u := u + w;
         w := width(t.rd_addr);
         y.rd_addr := convert(x(u to u+w-1), t.rd_addr);
         u := u + w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u to u+w-1), t.wr_data);
      else
         w := width(t.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), t.SIGNALS);
         u := u - w;
         w := width(t.wr_addr);
         y.wr_addr := convert(x(u downto u-w+1), t.wr_addr);
         u := u - w;
         w := width(t.rd_addr);
         y.rd_addr := convert(x(u downto u-w+1), t.rd_addr);
         u := u - w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u downto u-w+1), t.wr_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return integer is
      variable w : integer := x'length * width(x(x'low));
   begin
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(t'range)(t(t'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CVP_CHAMB_Z0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.CVP_CHAMB_Z0);
         y(u to u+w-1) := convert(x.CVP_CHAMB_Z0, y(u to u+w-1));
      else
         w := width(x.CVP_CHAMB_Z0);
         y(u downto u-w+1) := convert(x.CVP_CHAMB_Z0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_MON_t is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.CVP_CHAMB_Z0);
         y.CVP_CHAMB_Z0 := convert(x(u to u+w-1), t.CVP_CHAMB_Z0);
      else
         w := width(t.CVP_CHAMB_Z0);
         y.CVP_CHAMB_Z0 := convert(x(u downto u-w+1), t.CVP_CHAMB_Z0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CVP_CHAMB_Z0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.CVP_CHAMB_Z0);
         y(u to u+w-1) := convert(x.CVP_CHAMB_Z0, y(u to u+w-1));
      else
         w := width(x.CVP_CHAMB_Z0);
         y(u downto u-w+1) := convert(x.CVP_CHAMB_Z0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CTRL_t is
      variable y : UCM_SUPER_CVP_CHAMB_Z0_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.CVP_CHAMB_Z0);
         y.CVP_CHAMB_Z0 := convert(x(u to u+w-1), t.CVP_CHAMB_Z0);
      else
         w := width(t.CVP_CHAMB_Z0);
         y.CVP_CHAMB_Z0 := convert(x(u downto u-w+1), t.CVP_CHAMB_Z0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.STATUS);
      w := w + width(x.SECTOR_PHI);
      w := w + width(x.CDE_CHAMB_Z0);
      w := w + width(x.CVP_CHAMB_Z0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.STATUS);
         y(u to u+w-1) := convert(x.STATUS, y(u to u+w-1));
         u := u + w;
         w := width(x.SECTOR_PHI);
         y(u to u+w-1) := convert(x.SECTOR_PHI, y(u to u+w-1));
         u := u + w;
         w := width(x.CDE_CHAMB_Z0);
         y(u to u+w-1) := convert(x.CDE_CHAMB_Z0, y(u to u+w-1));
         u := u + w;
         w := width(x.CVP_CHAMB_Z0);
         y(u to u+w-1) := convert(x.CVP_CHAMB_Z0, y(u to u+w-1));
      else
         w := width(x.STATUS);
         y(u downto u-w+1) := convert(x.STATUS, y(u downto u-w+1));
         u := u - w;
         w := width(x.SECTOR_PHI);
         y(u downto u-w+1) := convert(x.SECTOR_PHI, y(u downto u-w+1));
         u := u - w;
         w := width(x.CDE_CHAMB_Z0);
         y(u downto u-w+1) := convert(x.CDE_CHAMB_Z0, y(u downto u-w+1));
         u := u - w;
         w := width(x.CVP_CHAMB_Z0);
         y(u downto u-w+1) := convert(x.CVP_CHAMB_Z0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_MON_t) return UCM_SUPER_MON_t is
      variable y : UCM_SUPER_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.STATUS);
         y.STATUS := convert(x(u to u+w-1), t.STATUS);
         u := u + w;
         w := width(t.SECTOR_PHI);
         y.SECTOR_PHI := convert(x(u to u+w-1), t.SECTOR_PHI);
         u := u + w;
         w := width(t.CDE_CHAMB_Z0);
         y.CDE_CHAMB_Z0 := convert(x(u to u+w-1), t.CDE_CHAMB_Z0);
         u := u + w;
         w := width(t.CVP_CHAMB_Z0);
         y.CVP_CHAMB_Z0 := convert(x(u to u+w-1), t.CVP_CHAMB_Z0);
      else
         w := width(t.STATUS);
         y.STATUS := convert(x(u downto u-w+1), t.STATUS);
         u := u - w;
         w := width(t.SECTOR_PHI);
         y.SECTOR_PHI := convert(x(u downto u-w+1), t.SECTOR_PHI);
         u := u - w;
         w := width(t.CDE_CHAMB_Z0);
         y.CDE_CHAMB_Z0 := convert(x(u downto u-w+1), t.CDE_CHAMB_Z0);
         u := u - w;
         w := width(t.CVP_CHAMB_Z0);
         y.CVP_CHAMB_Z0 := convert(x(u downto u-w+1), t.CVP_CHAMB_Z0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_SUPER_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ACTIONS);
      w := w + width(x.CONFIGS);
      w := w + width(x.SECTOR_PHI);
      w := w + width(x.CDE_CHAMB_Z0);
      w := w + width(x.CVP_CHAMB_Z0);
      return w;
   end function width;
   function convert(x: UCM_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.ACTIONS);
         y(u to u+w-1) := convert(x.ACTIONS, y(u to u+w-1));
         u := u + w;
         w := width(x.CONFIGS);
         y(u to u+w-1) := convert(x.CONFIGS, y(u to u+w-1));
         u := u + w;
         w := width(x.SECTOR_PHI);
         y(u to u+w-1) := convert(x.SECTOR_PHI, y(u to u+w-1));
         u := u + w;
         w := width(x.CDE_CHAMB_Z0);
         y(u to u+w-1) := convert(x.CDE_CHAMB_Z0, y(u to u+w-1));
         u := u + w;
         w := width(x.CVP_CHAMB_Z0);
         y(u to u+w-1) := convert(x.CVP_CHAMB_Z0, y(u to u+w-1));
      else
         w := width(x.ACTIONS);
         y(u downto u-w+1) := convert(x.ACTIONS, y(u downto u-w+1));
         u := u - w;
         w := width(x.CONFIGS);
         y(u downto u-w+1) := convert(x.CONFIGS, y(u downto u-w+1));
         u := u - w;
         w := width(x.SECTOR_PHI);
         y(u downto u-w+1) := convert(x.SECTOR_PHI, y(u downto u-w+1));
         u := u - w;
         w := width(x.CDE_CHAMB_Z0);
         y(u downto u-w+1) := convert(x.CDE_CHAMB_Z0, y(u downto u-w+1));
         u := u - w;
         w := width(x.CVP_CHAMB_Z0);
         y(u downto u-w+1) := convert(x.CVP_CHAMB_Z0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_SUPER_CTRL_t) return UCM_SUPER_CTRL_t is
      variable y : UCM_SUPER_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.ACTIONS);
         y.ACTIONS := convert(x(u to u+w-1), t.ACTIONS);
         u := u + w;
         w := width(t.CONFIGS);
         y.CONFIGS := convert(x(u to u+w-1), t.CONFIGS);
         u := u + w;
         w := width(t.SECTOR_PHI);
         y.SECTOR_PHI := convert(x(u to u+w-1), t.SECTOR_PHI);
         u := u + w;
         w := width(t.CDE_CHAMB_Z0);
         y.CDE_CHAMB_Z0 := convert(x(u to u+w-1), t.CDE_CHAMB_Z0);
         u := u + w;
         w := width(t.CVP_CHAMB_Z0);
         y.CVP_CHAMB_Z0 := convert(x(u to u+w-1), t.CVP_CHAMB_Z0);
      else
         w := width(t.ACTIONS);
         y.ACTIONS := convert(x(u downto u-w+1), t.ACTIONS);
         u := u - w;
         w := width(t.CONFIGS);
         y.CONFIGS := convert(x(u downto u-w+1), t.CONFIGS);
         u := u - w;
         w := width(t.SECTOR_PHI);
         y.SECTOR_PHI := convert(x(u downto u-w+1), t.SECTOR_PHI);
         u := u - w;
         w := width(t.CDE_CHAMB_Z0);
         y.CDE_CHAMB_Z0 := convert(x(u downto u-w+1), t.CDE_CHAMB_Z0);
         u := u - w;
         w := width(t.CVP_CHAMB_Z0);
         y.CVP_CHAMB_Z0 := convert(x(u downto u-w+1), t.CVP_CHAMB_Z0);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_rdy);
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.rd_rdy);
         y(u to u+w-1) := convert(x.rd_rdy, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.rd_rdy);
         y(u downto u-w+1) := convert(x.rd_rdy, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t is
      variable y : UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.rd_rdy);
         y.rd_rdy := convert(x(u to u+w-1), t.rd_rdy);
         u := u + w;
         w := width(t.rd_data);
         y.rd_data := convert(x(u to u+w-1), t.rd_data);
      else
         w := width(t.rd_rdy);
         y.rd_rdy := convert(x(u downto u-w+1), t.rd_rdy);
         u := u - w;
         w := width(t.rd_data);
         y.rd_data := convert(x(u downto u-w+1), t.rd_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_req);
      w := w + width(x.rd_req);
      w := w + width(x.wr_addr);
      w := w + width(x.rd_addr);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.wr_req);
         y(u to u+w-1) := convert(x.wr_req, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_req);
         y(u to u+w-1) := convert(x.rd_req, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_addr);
         y(u to u+w-1) := convert(x.wr_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_addr);
         y(u to u+w-1) := convert(x.rd_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.wr_req);
         y(u downto u-w+1) := convert(x.wr_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_req);
         y(u downto u-w+1) := convert(x.rd_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_addr);
         y(u downto u-w+1) := convert(x.wr_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_addr);
         y(u downto u-w+1) := convert(x.rd_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t is
      variable y : UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.wr_req);
         y.wr_req := convert(x(u to u+w-1), t.wr_req);
         u := u + w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u to u+w-1), t.rd_req);
         u := u + w;
         w := width(t.wr_addr);
         y.wr_addr := convert(x(u to u+w-1), t.wr_addr);
         u := u + w;
         w := width(t.rd_addr);
         y.rd_addr := convert(x(u to u+w-1), t.rd_addr);
         u := u + w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u to u+w-1), t.wr_data);
      else
         w := width(t.wr_req);
         y.wr_req := convert(x(u downto u-w+1), t.wr_req);
         u := u - w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u downto u-w+1), t.rd_req);
         u := u - w;
         w := width(t.wr_addr);
         y.wr_addr := convert(x(u downto u-w+1), t.wr_addr);
         u := u - w;
         w := width(t.rd_addr);
         y.rd_addr := convert(x(u downto u-w+1), t.rd_addr);
         u := u - w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u downto u-w+1), t.wr_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_RPC_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MEM_INTERFACE);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_RPC_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.MEM_INTERFACE);
         y(u to u+w-1) := convert(x.MEM_INTERFACE, y(u to u+w-1));
      else
         w := width(x.MEM_INTERFACE);
         y(u downto u-w+1) := convert(x.MEM_INTERFACE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_RPC_MON_t) return UCM_R_PHI_COMP_RPC_MON_t is
      variable y : UCM_R_PHI_COMP_RPC_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.MEM_INTERFACE);
         y.MEM_INTERFACE := convert(x(u to u+w-1), t.MEM_INTERFACE);
      else
         w := width(t.MEM_INTERFACE);
         y.MEM_INTERFACE := convert(x(u downto u-w+1), t.MEM_INTERFACE);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_RPC_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.sel_thread);
      w := w + width(x.sel_station);
      w := w + width(x.sel_layer);
      w := w + width(x.ext_ctrl);
      w := w + width(x.MEM_INTERFACE);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_RPC_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.sel_thread);
         y(u to u+w-1) := convert(x.sel_thread, y(u to u+w-1));
         u := u + w;
         w := width(x.sel_station);
         y(u to u+w-1) := convert(x.sel_station, y(u to u+w-1));
         u := u + w;
         w := width(x.sel_layer);
         y(u to u+w-1) := convert(x.sel_layer, y(u to u+w-1));
         u := u + w;
         w := width(x.ext_ctrl);
         y(u to u+w-1) := convert(x.ext_ctrl, y(u to u+w-1));
         u := u + w;
         w := width(x.MEM_INTERFACE);
         y(u to u+w-1) := convert(x.MEM_INTERFACE, y(u to u+w-1));
      else
         w := width(x.sel_thread);
         y(u downto u-w+1) := convert(x.sel_thread, y(u downto u-w+1));
         u := u - w;
         w := width(x.sel_station);
         y(u downto u-w+1) := convert(x.sel_station, y(u downto u-w+1));
         u := u - w;
         w := width(x.sel_layer);
         y(u downto u-w+1) := convert(x.sel_layer, y(u downto u-w+1));
         u := u - w;
         w := width(x.ext_ctrl);
         y(u downto u-w+1) := convert(x.ext_ctrl, y(u downto u-w+1));
         u := u - w;
         w := width(x.MEM_INTERFACE);
         y(u downto u-w+1) := convert(x.MEM_INTERFACE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_RPC_CTRL_t) return UCM_R_PHI_COMP_RPC_CTRL_t is
      variable y : UCM_R_PHI_COMP_RPC_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.sel_thread);
         y.sel_thread := convert(x(u to u+w-1), t.sel_thread);
         u := u + w;
         w := width(t.sel_station);
         y.sel_station := convert(x(u to u+w-1), t.sel_station);
         u := u + w;
         w := width(t.sel_layer);
         y.sel_layer := convert(x(u to u+w-1), t.sel_layer);
         u := u + w;
         w := width(t.ext_ctrl);
         y.ext_ctrl := convert(x(u to u+w-1), t.ext_ctrl);
         u := u + w;
         w := width(t.MEM_INTERFACE);
         y.MEM_INTERFACE := convert(x(u to u+w-1), t.MEM_INTERFACE);
      else
         w := width(t.sel_thread);
         y.sel_thread := convert(x(u downto u-w+1), t.sel_thread);
         u := u - w;
         w := width(t.sel_station);
         y.sel_station := convert(x(u downto u-w+1), t.sel_station);
         u := u - w;
         w := width(t.sel_layer);
         y.sel_layer := convert(x(u downto u-w+1), t.sel_layer);
         u := u - w;
         w := width(t.ext_ctrl);
         y.ext_ctrl := convert(x(u downto u-w+1), t.ext_ctrl);
         u := u - w;
         w := width(t.MEM_INTERFACE);
         y.MEM_INTERFACE := convert(x(u downto u-w+1), t.MEM_INTERFACE);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_rdy);
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.rd_rdy);
         y(u to u+w-1) := convert(x.rd_rdy, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.rd_rdy);
         y(u downto u-w+1) := convert(x.rd_rdy, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t is
      variable y : UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.rd_rdy);
         y.rd_rdy := convert(x(u to u+w-1), t.rd_rdy);
         u := u + w;
         w := width(t.rd_data);
         y.rd_data := convert(x(u to u+w-1), t.rd_data);
      else
         w := width(t.rd_rdy);
         y.rd_rdy := convert(x(u downto u-w+1), t.rd_rdy);
         u := u - w;
         w := width(t.rd_data);
         y.rd_data := convert(x(u downto u-w+1), t.rd_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_req);
      w := w + width(x.rd_req);
      w := w + width(x.wr_addr);
      w := w + width(x.rd_addr);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.wr_req);
         y(u to u+w-1) := convert(x.wr_req, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_req);
         y(u to u+w-1) := convert(x.rd_req, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_addr);
         y(u to u+w-1) := convert(x.wr_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_addr);
         y(u to u+w-1) := convert(x.rd_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.wr_req);
         y(u downto u-w+1) := convert(x.wr_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_req);
         y(u downto u-w+1) := convert(x.rd_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_addr);
         y(u downto u-w+1) := convert(x.wr_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_addr);
         y(u downto u-w+1) := convert(x.rd_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t is
      variable y : UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.wr_req);
         y.wr_req := convert(x(u to u+w-1), t.wr_req);
         u := u + w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u to u+w-1), t.rd_req);
         u := u + w;
         w := width(t.wr_addr);
         y.wr_addr := convert(x(u to u+w-1), t.wr_addr);
         u := u + w;
         w := width(t.rd_addr);
         y.rd_addr := convert(x(u to u+w-1), t.rd_addr);
         u := u + w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u to u+w-1), t.wr_data);
      else
         w := width(t.wr_req);
         y.wr_req := convert(x(u downto u-w+1), t.wr_req);
         u := u - w;
         w := width(t.rd_req);
         y.rd_req := convert(x(u downto u-w+1), t.rd_req);
         u := u - w;
         w := width(t.wr_addr);
         y.wr_addr := convert(x(u downto u-w+1), t.wr_addr);
         u := u - w;
         w := width(t.rd_addr);
         y.rd_addr := convert(x(u downto u-w+1), t.rd_addr);
         u := u - w;
         w := width(t.wr_data);
         y.wr_data := convert(x(u downto u-w+1), t.wr_data);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_MDT_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MEM_INTERFACE);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_MDT_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.MEM_INTERFACE);
         y(u to u+w-1) := convert(x.MEM_INTERFACE, y(u to u+w-1));
      else
         w := width(x.MEM_INTERFACE);
         y(u downto u-w+1) := convert(x.MEM_INTERFACE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MDT_MON_t) return UCM_R_PHI_COMP_MDT_MON_t is
      variable y : UCM_R_PHI_COMP_MDT_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.MEM_INTERFACE);
         y.MEM_INTERFACE := convert(x(u to u+w-1), t.MEM_INTERFACE);
      else
         w := width(t.MEM_INTERFACE);
         y.MEM_INTERFACE := convert(x(u downto u-w+1), t.MEM_INTERFACE);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_MDT_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.sel_thread);
      w := w + width(x.sel_station);
      w := w + width(x.sel_layer);
      w := w + width(x.ext_ctrl);
      w := w + width(x.MEM_INTERFACE);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_MDT_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.sel_thread);
         y(u to u+w-1) := convert(x.sel_thread, y(u to u+w-1));
         u := u + w;
         w := width(x.sel_station);
         y(u to u+w-1) := convert(x.sel_station, y(u to u+w-1));
         u := u + w;
         w := width(x.sel_layer);
         y(u to u+w-1) := convert(x.sel_layer, y(u to u+w-1));
         u := u + w;
         w := width(x.ext_ctrl);
         y(u to u+w-1) := convert(x.ext_ctrl, y(u to u+w-1));
         u := u + w;
         w := width(x.MEM_INTERFACE);
         y(u to u+w-1) := convert(x.MEM_INTERFACE, y(u to u+w-1));
      else
         w := width(x.sel_thread);
         y(u downto u-w+1) := convert(x.sel_thread, y(u downto u-w+1));
         u := u - w;
         w := width(x.sel_station);
         y(u downto u-w+1) := convert(x.sel_station, y(u downto u-w+1));
         u := u - w;
         w := width(x.sel_layer);
         y(u downto u-w+1) := convert(x.sel_layer, y(u downto u-w+1));
         u := u - w;
         w := width(x.ext_ctrl);
         y(u downto u-w+1) := convert(x.ext_ctrl, y(u downto u-w+1));
         u := u - w;
         w := width(x.MEM_INTERFACE);
         y(u downto u-w+1) := convert(x.MEM_INTERFACE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MDT_CTRL_t) return UCM_R_PHI_COMP_MDT_CTRL_t is
      variable y : UCM_R_PHI_COMP_MDT_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.sel_thread);
         y.sel_thread := convert(x(u to u+w-1), t.sel_thread);
         u := u + w;
         w := width(t.sel_station);
         y.sel_station := convert(x(u to u+w-1), t.sel_station);
         u := u + w;
         w := width(t.sel_layer);
         y.sel_layer := convert(x(u to u+w-1), t.sel_layer);
         u := u + w;
         w := width(t.ext_ctrl);
         y.ext_ctrl := convert(x(u to u+w-1), t.ext_ctrl);
         u := u + w;
         w := width(t.MEM_INTERFACE);
         y.MEM_INTERFACE := convert(x(u to u+w-1), t.MEM_INTERFACE);
      else
         w := width(t.sel_thread);
         y.sel_thread := convert(x(u downto u-w+1), t.sel_thread);
         u := u - w;
         w := width(t.sel_station);
         y.sel_station := convert(x(u downto u-w+1), t.sel_station);
         u := u - w;
         w := width(t.sel_layer);
         y.sel_layer := convert(x(u downto u-w+1), t.sel_layer);
         u := u - w;
         w := width(t.ext_ctrl);
         y.ext_ctrl := convert(x(u downto u-w+1), t.ext_ctrl);
         u := u - w;
         w := width(t.MEM_INTERFACE);
         y.MEM_INTERFACE := convert(x(u downto u-w+1), t.MEM_INTERFACE);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RPC);
      w := w + width(x.MDT);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.RPC);
         y(u to u+w-1) := convert(x.RPC, y(u to u+w-1));
         u := u + w;
         w := width(x.MDT);
         y(u to u+w-1) := convert(x.MDT, y(u to u+w-1));
      else
         w := width(x.RPC);
         y(u downto u-w+1) := convert(x.RPC, y(u downto u-w+1));
         u := u - w;
         w := width(x.MDT);
         y(u downto u-w+1) := convert(x.MDT, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_MON_t) return UCM_R_PHI_COMP_MON_t is
      variable y : UCM_R_PHI_COMP_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.RPC);
         y.RPC := convert(x(u to u+w-1), t.RPC);
         u := u + w;
         w := width(t.MDT);
         y.MDT := convert(x(u to u+w-1), t.MDT);
      else
         w := width(t.RPC);
         y.RPC := convert(x(u downto u-w+1), t.RPC);
         u := u - w;
         w := width(t.MDT);
         y.MDT := convert(x(u downto u-w+1), t.MDT);
      end if;
      return y;
   end function convert;

   function width(x: UCM_R_PHI_COMP_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RPC);
      w := w + width(x.MDT);
      return w;
   end function width;
   function convert(x: UCM_R_PHI_COMP_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.RPC);
         y(u to u+w-1) := convert(x.RPC, y(u to u+w-1));
         u := u + w;
         w := width(x.MDT);
         y(u to u+w-1) := convert(x.MDT, y(u to u+w-1));
      else
         w := width(x.RPC);
         y(u downto u-w+1) := convert(x.RPC, y(u downto u-w+1));
         u := u - w;
         w := width(x.MDT);
         y(u downto u-w+1) := convert(x.MDT, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_R_PHI_COMP_CTRL_t) return UCM_R_PHI_COMP_CTRL_t is
      variable y : UCM_R_PHI_COMP_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.RPC);
         y.RPC := convert(x(u to u+w-1), t.RPC);
         u := u + w;
         w := width(t.MDT);
         y.MDT := convert(x(u to u+w-1), t.MDT);
      else
         w := width(t.RPC);
         y.RPC := convert(x(u downto u-w+1), t.RPC);
         u := u - w;
         w := width(t.MDT);
         y.MDT := convert(x(u downto u-w+1), t.MDT);
      end if;
      return y;
   end function convert;

   function width(x: UCM_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SUPER);
      w := w + width(x.R_PHI_COMP);
      return w;
   end function width;
   function convert(x: UCM_MON_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.SUPER);
         y(u to u+w-1) := convert(x.SUPER, y(u to u+w-1));
         u := u + w;
         w := width(x.R_PHI_COMP);
         y(u to u+w-1) := convert(x.R_PHI_COMP, y(u to u+w-1));
      else
         w := width(x.SUPER);
         y(u downto u-w+1) := convert(x.SUPER, y(u downto u-w+1));
         u := u - w;
         w := width(x.R_PHI_COMP);
         y(u downto u-w+1) := convert(x.R_PHI_COMP, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_MON_t) return UCM_MON_t is
      variable y : UCM_MON_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.SUPER);
         y.SUPER := convert(x(u to u+w-1), t.SUPER);
         u := u + w;
         w := width(t.R_PHI_COMP);
         y.R_PHI_COMP := convert(x(u to u+w-1), t.R_PHI_COMP);
      else
         w := width(t.SUPER);
         y.SUPER := convert(x(u downto u-w+1), t.SUPER);
         u := u - w;
         w := width(t.R_PHI_COMP);
         y.R_PHI_COMP := convert(x(u downto u-w+1), t.R_PHI_COMP);
      end if;
      return y;
   end function convert;

   function width(x: UCM_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SUPER);
      w := w + width(x.R_PHI_COMP);
      return w;
   end function width;
   function convert(x: UCM_CTRL_t; t: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(t'range);
      variable w : integer;
      variable u : integer := t'left;
   begin
      if t'ascending then
         w := width(x.SUPER);
         y(u to u+w-1) := convert(x.SUPER, y(u to u+w-1));
         u := u + w;
         w := width(x.R_PHI_COMP);
         y(u to u+w-1) := convert(x.R_PHI_COMP, y(u to u+w-1));
      else
         w := width(x.SUPER);
         y(u downto u-w+1) := convert(x.SUPER, y(u downto u-w+1));
         u := u - w;
         w := width(x.R_PHI_COMP);
         y(u downto u-w+1) := convert(x.R_PHI_COMP, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; t: UCM_CTRL_t) return UCM_CTRL_t is
      variable y : UCM_CTRL_t := t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(t.SUPER);
         y.SUPER := convert(x(u to u+w-1), t.SUPER);
         u := u + w;
         w := width(t.R_PHI_COMP);
         y.R_PHI_COMP := convert(x(u to u+w-1), t.R_PHI_COMP);
      else
         w := width(t.SUPER);
         y.SUPER := convert(x(u downto u-w+1), t.SUPER);
         u := u - w;
         w := width(t.R_PHI_COMP);
         y.R_PHI_COMP := convert(x(u downto u-w+1), t.R_PHI_COMP);
      end if;
      return y;
   end function convert;

end package body UCM_PKG;
