-- This file was auto-generated by YML2HDL toll.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;

use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;

use shared_lib.common_ieee.all;

package UCM_CTRL is

  type UCM_SUPER_ACTIONS_CTRL_t is record
    RESET : std_logic;
    ENABLE : std_logic;
    DISABLE : std_logic;
    FREEZE : std_logic;
  end record UCM_SUPER_ACTIONS_CTRL_t;
  function len(x: UCM_SUPER_ACTIONS_CTRL_t) return natural;
  function vectorify(x: UCM_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_ACTIONS_CTRL_t) return UCM_SUPER_ACTIONS_CTRL_t;
  function nullify(t: UCM_SUPER_ACTIONS_CTRL_t) return UCM_SUPER_ACTIONS_CTRL_t;

  type UCM_SUPER_CONFIGS_CTRL_t is record
    THREADS : std_logic_vector(4-1 downto 0);
    INPUT_EN : std_logic;
    OUTPUT_EN : std_logic;
  end record UCM_SUPER_CONFIGS_CTRL_t;
  function len(x: UCM_SUPER_CONFIGS_CTRL_t) return natural;
  function vectorify(x: UCM_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CONFIGS_CTRL_t) return UCM_SUPER_CONFIGS_CTRL_t;
  function nullify(t: UCM_SUPER_CONFIGS_CTRL_t) return UCM_SUPER_CONFIGS_CTRL_t;

  type UCM_SUPER_STATUS_MON_t is record
    ENABLED : std_logic_vector(8-1 downto 0);
    READY : std_logic_vector(8-1 downto 0);
    ERROR : std_logic_vector(8-1 downto 0);
  end record UCM_SUPER_STATUS_MON_t;
  function len(x: UCM_SUPER_STATUS_MON_t) return natural;
  function vectorify(x: UCM_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_STATUS_MON_t) return UCM_SUPER_STATUS_MON_t;
  function nullify(t: UCM_SUPER_STATUS_MON_t) return UCM_SUPER_STATUS_MON_t;

  type UCM_SUPER_SECTOR_PHI_MON_t is record
    rd_data : std_logic_vector(10-1 downto 0);
  end record UCM_SUPER_SECTOR_PHI_MON_t;
  function len(x: UCM_SUPER_SECTOR_PHI_MON_t) return natural;
  function vectorify(x: UCM_SUPER_SECTOR_PHI_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_SECTOR_PHI_MON_t) return UCM_SUPER_SECTOR_PHI_MON_t;
  function nullify(t: UCM_SUPER_SECTOR_PHI_MON_t) return UCM_SUPER_SECTOR_PHI_MON_t;

  type UCM_SUPER_SECTOR_PHI_CTRL_t is record
    wr_req : std_logic;
    rd_req : std_logic;
    wr_data : std_logic_vector(10-1 downto 0);
  end record UCM_SUPER_SECTOR_PHI_CTRL_t;
  function len(x: UCM_SUPER_SECTOR_PHI_CTRL_t) return natural;
  function vectorify(x: UCM_SUPER_SECTOR_PHI_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_SECTOR_PHI_CTRL_t) return UCM_SUPER_SECTOR_PHI_CTRL_t;
  function nullify(t: UCM_SUPER_SECTOR_PHI_CTRL_t) return UCM_SUPER_SECTOR_PHI_CTRL_t;

  type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t is record
    rd_rdy : std_logic;
    rd_data : std_logic_vector(16-1 downto 0);
  end record UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t;
  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return natural;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t;
  function nullify(t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t;

  type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY is array(4-1 downto 0) of UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t;
  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return natural;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;
  function nullify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;

  type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t is record
    wr_req : std_logic;
    rd_req : std_logic;
    wr_addr : std_logic_vector(8-1 downto 0);
    rd_addr : std_logic_vector(8-1 downto 0);
    wr_data : std_logic_vector(16-1 downto 0);
  end record UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t;
  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return natural;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t;
  function nullify(t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t;

  type UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY is array(4-1 downto 0) of UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t;
  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return natural;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;
  function nullify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;

  type UCM_SUPER_CDE_CHAMB_Z0_MON_t is record
    CDE_CHAMB_Z0 : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;
  end record UCM_SUPER_CDE_CHAMB_Z0_MON_t;
  function len(x: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return natural;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_MON_t;
  function nullify(t: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_MON_t;

  type UCM_SUPER_CDE_CHAMB_Z0_CTRL_t is record
    CDE_CHAMB_Z0 : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;
  end record UCM_SUPER_CDE_CHAMB_Z0_CTRL_t;
  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return natural;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CTRL_t;
  function nullify(t: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CTRL_t;

  type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t is record
    rd_rdy : std_logic;
    rd_data : std_logic_vector(16-1 downto 0);
  end record UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t;
  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return natural;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t;
  function nullify(t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t;

  type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY is array(4-1 downto 0) of UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t;
  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return natural;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;
  function nullify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;

  type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t is record
    wr_req : std_logic;
    rd_req : std_logic;
    wr_addr : std_logic_vector(8-1 downto 0);
    rd_addr : std_logic_vector(8-1 downto 0);
    wr_data : std_logic_vector(16-1 downto 0);
  end record UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t;
  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return natural;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t;
  function nullify(t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t;

  type UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY is array(4-1 downto 0) of UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t;
  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return natural;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;
  function nullify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;

  type UCM_SUPER_CVP_CHAMB_Z0_MON_t is record
    CVP_CHAMB_Z0 : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;
  end record UCM_SUPER_CVP_CHAMB_Z0_MON_t;
  function len(x: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return natural;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_MON_t;
  function nullify(t: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_MON_t;

  type UCM_SUPER_CVP_CHAMB_Z0_CTRL_t is record
    CVP_CHAMB_Z0 : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;
  end record UCM_SUPER_CVP_CHAMB_Z0_CTRL_t;
  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return natural;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CTRL_t;
  function nullify(t: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CTRL_t;

  type UCM_SUPER_MON_t is record
    STATUS : UCM_SUPER_STATUS_MON_t;
    SECTOR_PHI : UCM_SUPER_SECTOR_PHI_MON_t;
    CDE_CHAMB_Z0 : UCM_SUPER_CDE_CHAMB_Z0_MON_t;
    CVP_CHAMB_Z0 : UCM_SUPER_CVP_CHAMB_Z0_MON_t;
  end record UCM_SUPER_MON_t;
  function len(x: UCM_SUPER_MON_t) return natural;
  function vectorify(x: UCM_SUPER_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_MON_t) return UCM_SUPER_MON_t;
  function nullify(t: UCM_SUPER_MON_t) return UCM_SUPER_MON_t;

  type UCM_SUPER_CTRL_t is record
    ACTIONS : UCM_SUPER_ACTIONS_CTRL_t;
    CONFIGS : UCM_SUPER_CONFIGS_CTRL_t;
    SECTOR_PHI : UCM_SUPER_SECTOR_PHI_CTRL_t;
    CDE_CHAMB_Z0 : UCM_SUPER_CDE_CHAMB_Z0_CTRL_t;
    CVP_CHAMB_Z0 : UCM_SUPER_CVP_CHAMB_Z0_CTRL_t;
  end record UCM_SUPER_CTRL_t;
  function len(x: UCM_SUPER_CTRL_t) return natural;
  function vectorify(x: UCM_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CTRL_t) return UCM_SUPER_CTRL_t;
  function nullify(t: UCM_SUPER_CTRL_t) return UCM_SUPER_CTRL_t;

  type UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t is record
    rd_rdy : std_logic;
    rd_data : std_logic_vector(12-1 downto 0);
  end record UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t;
  function len(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t;
  function nullify(t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t;

  type UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t is record
    wr_req : std_logic;
    rd_req : std_logic;
    wr_addr : std_logic_vector(5-1 downto 0);
    rd_addr : std_logic_vector(5-1 downto 0);
    wr_data : std_logic_vector(12-1 downto 0);
  end record UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t;
  function len(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t;
  function nullify(t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t;

  type UCM_R_PHI_COMP_RPC_MON_t is record
    MEM_INTERFACE : UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t;
  end record UCM_R_PHI_COMP_RPC_MON_t;
  function len(x: UCM_R_PHI_COMP_RPC_MON_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_RPC_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_RPC_MON_t) return UCM_R_PHI_COMP_RPC_MON_t;
  function nullify(t: UCM_R_PHI_COMP_RPC_MON_t) return UCM_R_PHI_COMP_RPC_MON_t;

  type UCM_R_PHI_COMP_RPC_CTRL_t is record
    sel_thread : std_logic_vector(4-1 downto 0);
    sel_station : std_logic_vector(4-1 downto 0);
    sel_layer : std_logic_vector(4-1 downto 0);
    ext_ctrl : std_logic;
    MEM_INTERFACE : UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t;
  end record UCM_R_PHI_COMP_RPC_CTRL_t;
  function len(x: UCM_R_PHI_COMP_RPC_CTRL_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_RPC_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_RPC_CTRL_t) return UCM_R_PHI_COMP_RPC_CTRL_t;
  function nullify(t: UCM_R_PHI_COMP_RPC_CTRL_t) return UCM_R_PHI_COMP_RPC_CTRL_t;

  type UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t is record
    rd_rdy : std_logic;
    rd_data : std_logic_vector(14-1 downto 0);
  end record UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t;
  function len(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t;
  function nullify(t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t;

  type UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t is record
    wr_req : std_logic;
    rd_req : std_logic;
    wr_addr : std_logic_vector(5-1 downto 0);
    rd_addr : std_logic_vector(5-1 downto 0);
    wr_data : std_logic_vector(14-1 downto 0);
  end record UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t;
  function len(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t;
  function nullify(t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t;

  type UCM_R_PHI_COMP_MDT_MON_t is record
    MEM_INTERFACE : UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t;
  end record UCM_R_PHI_COMP_MDT_MON_t;
  function len(x: UCM_R_PHI_COMP_MDT_MON_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_MDT_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MDT_MON_t) return UCM_R_PHI_COMP_MDT_MON_t;
  function nullify(t: UCM_R_PHI_COMP_MDT_MON_t) return UCM_R_PHI_COMP_MDT_MON_t;

  type UCM_R_PHI_COMP_MDT_CTRL_t is record
    sel_thread : std_logic_vector(4-1 downto 0);
    sel_station : std_logic_vector(4-1 downto 0);
    sel_layer : std_logic_vector(4-1 downto 0);
    ext_ctrl : std_logic;
    MEM_INTERFACE : UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t;
  end record UCM_R_PHI_COMP_MDT_CTRL_t;
  function len(x: UCM_R_PHI_COMP_MDT_CTRL_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_MDT_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MDT_CTRL_t) return UCM_R_PHI_COMP_MDT_CTRL_t;
  function nullify(t: UCM_R_PHI_COMP_MDT_CTRL_t) return UCM_R_PHI_COMP_MDT_CTRL_t;

  type UCM_R_PHI_COMP_MON_t is record
    RPC : UCM_R_PHI_COMP_RPC_MON_t;
    MDT : UCM_R_PHI_COMP_MDT_MON_t;
  end record UCM_R_PHI_COMP_MON_t;
  function len(x: UCM_R_PHI_COMP_MON_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MON_t) return UCM_R_PHI_COMP_MON_t;
  function nullify(t: UCM_R_PHI_COMP_MON_t) return UCM_R_PHI_COMP_MON_t;

  type UCM_R_PHI_COMP_CTRL_t is record
    RPC : UCM_R_PHI_COMP_RPC_CTRL_t;
    MDT : UCM_R_PHI_COMP_MDT_CTRL_t;
  end record UCM_R_PHI_COMP_CTRL_t;
  function len(x: UCM_R_PHI_COMP_CTRL_t) return natural;
  function vectorify(x: UCM_R_PHI_COMP_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_CTRL_t) return UCM_R_PHI_COMP_CTRL_t;
  function nullify(t: UCM_R_PHI_COMP_CTRL_t) return UCM_R_PHI_COMP_CTRL_t;

  type UCM_MON_t is record
    SUPER : UCM_SUPER_MON_t;
    R_PHI_COMP : UCM_R_PHI_COMP_MON_t;
  end record UCM_MON_t;
  function len(x: UCM_MON_t) return natural;
  function vectorify(x: UCM_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_MON_t) return UCM_MON_t;
  function nullify(t: UCM_MON_t) return UCM_MON_t;

  type UCM_CTRL_t is record
    SUPER : UCM_SUPER_CTRL_t;
    R_PHI_COMP : UCM_R_PHI_COMP_CTRL_t;
  end record UCM_CTRL_t;
  function len(x: UCM_CTRL_t) return natural;
  function vectorify(x: UCM_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: UCM_CTRL_t) return UCM_CTRL_t;
  function nullify(t: UCM_CTRL_t) return UCM_CTRL_t;

end package UCM_CTRL;

------------------------------------------------------------

package body UCM_CTRL is

  function len(x: UCM_SUPER_ACTIONS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.RESET);
    l := l + len(x.ENABLE);
    l := l + len(x.DISABLE);
    l := l + len(x.FREEZE);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), vectorify(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.ENABLE)-1), vectorify(x.ENABLE, y(left to left+len(x.ENABLE)-1)));
      left := left + len(x.ENABLE);
      assign(y(left to left+len(x.DISABLE)-1), vectorify(x.DISABLE, y(left to left+len(x.DISABLE)-1)));
      left := left + len(x.DISABLE);
      assign(y(left to left+len(x.FREEZE)-1), vectorify(x.FREEZE, y(left to left+len(x.FREEZE)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), vectorify(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.ENABLE)+1), vectorify(x.ENABLE, y(left downto left-len(x.ENABLE)+1)));
      left := left - len(x.ENABLE);
      assign(y(left downto left-len(x.DISABLE)+1), vectorify(x.DISABLE, y(left downto left-len(x.DISABLE)+1)));
      left := left - len(x.DISABLE);
      assign(y(left downto left-len(x.FREEZE)+1), vectorify(x.FREEZE, y(left downto left-len(x.FREEZE)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_ACTIONS_CTRL_t) return UCM_SUPER_ACTIONS_CTRL_t is
    variable y: UCM_SUPER_ACTIONS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := structify(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.ENABLE := structify(x(left to left+len(y.ENABLE)-1), y.ENABLE);
      left := left + len(y.ENABLE);
      y.DISABLE := structify(x(left to left+len(y.DISABLE)-1), y.DISABLE);
      left := left + len(y.DISABLE);
      y.FREEZE := structify(x(left to left+len(y.FREEZE)-1), y.FREEZE);
    else
      y.RESET := structify(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.ENABLE := structify(x(left downto left-len(y.ENABLE)+1), y.ENABLE);
      left := left - len(y.ENABLE);
      y.DISABLE := structify(x(left downto left-len(y.DISABLE)+1), y.DISABLE);
      left := left - len(y.DISABLE);
      y.FREEZE := structify(x(left downto left-len(y.FREEZE)+1), y.FREEZE);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_ACTIONS_CTRL_t) return UCM_SUPER_ACTIONS_CTRL_t is
  variable y: UCM_SUPER_ACTIONS_CTRL_t;
  begin
    y.RESET := nullify(t.RESET);
    y.ENABLE := nullify(t.ENABLE);
    y.DISABLE := nullify(t.DISABLE);
    y.FREEZE := nullify(t.FREEZE);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CONFIGS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.THREADS);
    l := l + len(x.INPUT_EN);
    l := l + len(x.OUTPUT_EN);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.THREADS)-1), vectorify(x.THREADS, y(left to left+len(x.THREADS)-1)));
      left := left + len(x.THREADS);
      assign(y(left to left+len(x.INPUT_EN)-1), vectorify(x.INPUT_EN, y(left to left+len(x.INPUT_EN)-1)));
      left := left + len(x.INPUT_EN);
      assign(y(left to left+len(x.OUTPUT_EN)-1), vectorify(x.OUTPUT_EN, y(left to left+len(x.OUTPUT_EN)-1)));
    else
      assign(y(left downto left-len(x.THREADS)+1), vectorify(x.THREADS, y(left downto left-len(x.THREADS)+1)));
      left := left - len(x.THREADS);
      assign(y(left downto left-len(x.INPUT_EN)+1), vectorify(x.INPUT_EN, y(left downto left-len(x.INPUT_EN)+1)));
      left := left - len(x.INPUT_EN);
      assign(y(left downto left-len(x.OUTPUT_EN)+1), vectorify(x.OUTPUT_EN, y(left downto left-len(x.OUTPUT_EN)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CONFIGS_CTRL_t) return UCM_SUPER_CONFIGS_CTRL_t is
    variable y: UCM_SUPER_CONFIGS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.THREADS := structify(x(left to left+len(y.THREADS)-1), y.THREADS);
      left := left + len(y.THREADS);
      y.INPUT_EN := structify(x(left to left+len(y.INPUT_EN)-1), y.INPUT_EN);
      left := left + len(y.INPUT_EN);
      y.OUTPUT_EN := structify(x(left to left+len(y.OUTPUT_EN)-1), y.OUTPUT_EN);
    else
      y.THREADS := structify(x(left downto left-len(y.THREADS)+1), y.THREADS);
      left := left - len(y.THREADS);
      y.INPUT_EN := structify(x(left downto left-len(y.INPUT_EN)+1), y.INPUT_EN);
      left := left - len(y.INPUT_EN);
      y.OUTPUT_EN := structify(x(left downto left-len(y.OUTPUT_EN)+1), y.OUTPUT_EN);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CONFIGS_CTRL_t) return UCM_SUPER_CONFIGS_CTRL_t is
  variable y: UCM_SUPER_CONFIGS_CTRL_t;
  begin
    y.THREADS := nullify(t.THREADS);
    y.INPUT_EN := nullify(t.INPUT_EN);
    y.OUTPUT_EN := nullify(t.OUTPUT_EN);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_STATUS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ENABLED);
    l := l + len(x.READY);
    l := l + len(x.ERROR);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ENABLED)-1), vectorify(x.ENABLED, y(left to left+len(x.ENABLED)-1)));
      left := left + len(x.ENABLED);
      assign(y(left to left+len(x.READY)-1), vectorify(x.READY, y(left to left+len(x.READY)-1)));
      left := left + len(x.READY);
      assign(y(left to left+len(x.ERROR)-1), vectorify(x.ERROR, y(left to left+len(x.ERROR)-1)));
    else
      assign(y(left downto left-len(x.ENABLED)+1), vectorify(x.ENABLED, y(left downto left-len(x.ENABLED)+1)));
      left := left - len(x.ENABLED);
      assign(y(left downto left-len(x.READY)+1), vectorify(x.READY, y(left downto left-len(x.READY)+1)));
      left := left - len(x.READY);
      assign(y(left downto left-len(x.ERROR)+1), vectorify(x.ERROR, y(left downto left-len(x.ERROR)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_STATUS_MON_t) return UCM_SUPER_STATUS_MON_t is
    variable y: UCM_SUPER_STATUS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ENABLED := structify(x(left to left+len(y.ENABLED)-1), y.ENABLED);
      left := left + len(y.ENABLED);
      y.READY := structify(x(left to left+len(y.READY)-1), y.READY);
      left := left + len(y.READY);
      y.ERROR := structify(x(left to left+len(y.ERROR)-1), y.ERROR);
    else
      y.ENABLED := structify(x(left downto left-len(y.ENABLED)+1), y.ENABLED);
      left := left - len(y.ENABLED);
      y.READY := structify(x(left downto left-len(y.READY)+1), y.READY);
      left := left - len(y.READY);
      y.ERROR := structify(x(left downto left-len(y.ERROR)+1), y.ERROR);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_STATUS_MON_t) return UCM_SUPER_STATUS_MON_t is
  variable y: UCM_SUPER_STATUS_MON_t;
  begin
    y.ENABLED := nullify(t.ENABLED);
    y.READY := nullify(t.READY);
    y.ERROR := nullify(t.ERROR);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_SECTOR_PHI_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_data);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_SECTOR_PHI_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_SECTOR_PHI_MON_t) return UCM_SUPER_SECTOR_PHI_MON_t is
    variable y: UCM_SUPER_SECTOR_PHI_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_SECTOR_PHI_MON_t) return UCM_SUPER_SECTOR_PHI_MON_t is
  variable y: UCM_SUPER_SECTOR_PHI_MON_t;
  begin
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_SECTOR_PHI_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_req);
    l := l + len(x.rd_req);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_SECTOR_PHI_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), vectorify(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.rd_req)-1), vectorify(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), vectorify(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.rd_req)+1), vectorify(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_SECTOR_PHI_CTRL_t) return UCM_SUPER_SECTOR_PHI_CTRL_t is
    variable y: UCM_SUPER_SECTOR_PHI_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := structify(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.rd_req := structify(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.wr_req := structify(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.rd_req := structify(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_SECTOR_PHI_CTRL_t) return UCM_SUPER_SECTOR_PHI_CTRL_t is
  variable y: UCM_SUPER_SECTOR_PHI_CTRL_t;
  begin
    y.wr_req := nullify(t.wr_req);
    y.rd_req := nullify(t.rd_req);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_rdy);
    l := l + len(x.rd_data);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), vectorify(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), vectorify(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t is
    variable y: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := structify(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.rd_rdy := structify(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t is
  variable y: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t;
  begin
    y.rd_rdy := nullify(t.rd_rdy);
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function structify(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY is
    variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function nullify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY is
    variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_req);
    l := l + len(x.rd_req);
    l := l + len(x.wr_addr);
    l := l + len(x.rd_addr);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), vectorify(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.rd_req)-1), vectorify(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.wr_addr)-1), vectorify(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), vectorify(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), vectorify(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.rd_req)+1), vectorify(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.wr_addr)+1), vectorify(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), vectorify(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t is
    variable y: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := structify(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.rd_req := structify(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.wr_addr := structify(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := structify(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.wr_req := structify(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.rd_req := structify(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.wr_addr := structify(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := structify(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t is
  variable y: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t;
  begin
    y.wr_req := nullify(t.wr_req);
    y.rd_req := nullify(t.rd_req);
    y.wr_addr := nullify(t.wr_addr);
    y.rd_addr := nullify(t.rd_addr);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function structify(x: std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY is
    variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function nullify(x: UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY is
    variable y : UCM_SUPER_CDE_CHAMB_Z0_CDE_CHAMB_Z0_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.CDE_CHAMB_Z0);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CDE_CHAMB_Z0)-1), vectorify(x.CDE_CHAMB_Z0, y(left to left+len(x.CDE_CHAMB_Z0)-1)));
    else
      assign(y(left downto left-len(x.CDE_CHAMB_Z0)+1), vectorify(x.CDE_CHAMB_Z0, y(left downto left-len(x.CDE_CHAMB_Z0)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_MON_t is
    variable y: UCM_SUPER_CDE_CHAMB_Z0_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CDE_CHAMB_Z0 := structify(x(left to left+len(y.CDE_CHAMB_Z0)-1), y.CDE_CHAMB_Z0);
    else
      y.CDE_CHAMB_Z0 := structify(x(left downto left-len(y.CDE_CHAMB_Z0)+1), y.CDE_CHAMB_Z0);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CDE_CHAMB_Z0_MON_t) return UCM_SUPER_CDE_CHAMB_Z0_MON_t is
  variable y: UCM_SUPER_CDE_CHAMB_Z0_MON_t;
  begin
    y.CDE_CHAMB_Z0 := nullify(t.CDE_CHAMB_Z0);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.CDE_CHAMB_Z0);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CDE_CHAMB_Z0)-1), vectorify(x.CDE_CHAMB_Z0, y(left to left+len(x.CDE_CHAMB_Z0)-1)));
    else
      assign(y(left downto left-len(x.CDE_CHAMB_Z0)+1), vectorify(x.CDE_CHAMB_Z0, y(left downto left-len(x.CDE_CHAMB_Z0)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CTRL_t is
    variable y: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CDE_CHAMB_Z0 := structify(x(left to left+len(y.CDE_CHAMB_Z0)-1), y.CDE_CHAMB_Z0);
    else
      y.CDE_CHAMB_Z0 := structify(x(left downto left-len(y.CDE_CHAMB_Z0)+1), y.CDE_CHAMB_Z0);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t) return UCM_SUPER_CDE_CHAMB_Z0_CTRL_t is
  variable y: UCM_SUPER_CDE_CHAMB_Z0_CTRL_t;
  begin
    y.CDE_CHAMB_Z0 := nullify(t.CDE_CHAMB_Z0);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_rdy);
    l := l + len(x.rd_data);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), vectorify(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), vectorify(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t is
    variable y: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := structify(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.rd_rdy := structify(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t is
  variable y: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t;
  begin
    y.rd_rdy := nullify(t.rd_rdy);
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function structify(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY is
    variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function nullify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY is
    variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_req);
    l := l + len(x.rd_req);
    l := l + len(x.wr_addr);
    l := l + len(x.rd_addr);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), vectorify(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.rd_req)-1), vectorify(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.wr_addr)-1), vectorify(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), vectorify(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), vectorify(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.rd_req)+1), vectorify(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.wr_addr)+1), vectorify(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), vectorify(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t is
    variable y: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := structify(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.rd_req := structify(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.wr_addr := structify(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := structify(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.wr_req := structify(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.rd_req := structify(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.wr_addr := structify(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := structify(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t is
  variable y: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t;
  begin
    y.wr_req := nullify(t.wr_req);
    y.rd_req := nullify(t.rd_req);
    y.wr_addr := nullify(t.wr_addr);
    y.rd_addr := nullify(t.rd_addr);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function structify(x: std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY is
    variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function nullify(x: UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY) return UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY is
    variable y : UCM_SUPER_CVP_CHAMB_Z0_CVP_CHAMB_Z0_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.CVP_CHAMB_Z0);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CVP_CHAMB_Z0)-1), vectorify(x.CVP_CHAMB_Z0, y(left to left+len(x.CVP_CHAMB_Z0)-1)));
    else
      assign(y(left downto left-len(x.CVP_CHAMB_Z0)+1), vectorify(x.CVP_CHAMB_Z0, y(left downto left-len(x.CVP_CHAMB_Z0)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_MON_t is
    variable y: UCM_SUPER_CVP_CHAMB_Z0_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CVP_CHAMB_Z0 := structify(x(left to left+len(y.CVP_CHAMB_Z0)-1), y.CVP_CHAMB_Z0);
    else
      y.CVP_CHAMB_Z0 := structify(x(left downto left-len(y.CVP_CHAMB_Z0)+1), y.CVP_CHAMB_Z0);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CVP_CHAMB_Z0_MON_t) return UCM_SUPER_CVP_CHAMB_Z0_MON_t is
  variable y: UCM_SUPER_CVP_CHAMB_Z0_MON_t;
  begin
    y.CVP_CHAMB_Z0 := nullify(t.CVP_CHAMB_Z0);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.CVP_CHAMB_Z0);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CVP_CHAMB_Z0)-1), vectorify(x.CVP_CHAMB_Z0, y(left to left+len(x.CVP_CHAMB_Z0)-1)));
    else
      assign(y(left downto left-len(x.CVP_CHAMB_Z0)+1), vectorify(x.CVP_CHAMB_Z0, y(left downto left-len(x.CVP_CHAMB_Z0)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CTRL_t is
    variable y: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CVP_CHAMB_Z0 := structify(x(left to left+len(y.CVP_CHAMB_Z0)-1), y.CVP_CHAMB_Z0);
    else
      y.CVP_CHAMB_Z0 := structify(x(left downto left-len(y.CVP_CHAMB_Z0)+1), y.CVP_CHAMB_Z0);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t) return UCM_SUPER_CVP_CHAMB_Z0_CTRL_t is
  variable y: UCM_SUPER_CVP_CHAMB_Z0_CTRL_t;
  begin
    y.CVP_CHAMB_Z0 := nullify(t.CVP_CHAMB_Z0);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.STATUS);
    l := l + len(x.SECTOR_PHI);
    l := l + len(x.CDE_CHAMB_Z0);
    l := l + len(x.CVP_CHAMB_Z0);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), vectorify(x.STATUS, y(left to left+len(x.STATUS)-1)));
      left := left + len(x.STATUS);
      assign(y(left to left+len(x.SECTOR_PHI)-1), vectorify(x.SECTOR_PHI, y(left to left+len(x.SECTOR_PHI)-1)));
      left := left + len(x.SECTOR_PHI);
      assign(y(left to left+len(x.CDE_CHAMB_Z0)-1), vectorify(x.CDE_CHAMB_Z0, y(left to left+len(x.CDE_CHAMB_Z0)-1)));
      left := left + len(x.CDE_CHAMB_Z0);
      assign(y(left to left+len(x.CVP_CHAMB_Z0)-1), vectorify(x.CVP_CHAMB_Z0, y(left to left+len(x.CVP_CHAMB_Z0)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), vectorify(x.STATUS, y(left downto left-len(x.STATUS)+1)));
      left := left - len(x.STATUS);
      assign(y(left downto left-len(x.SECTOR_PHI)+1), vectorify(x.SECTOR_PHI, y(left downto left-len(x.SECTOR_PHI)+1)));
      left := left - len(x.SECTOR_PHI);
      assign(y(left downto left-len(x.CDE_CHAMB_Z0)+1), vectorify(x.CDE_CHAMB_Z0, y(left downto left-len(x.CDE_CHAMB_Z0)+1)));
      left := left - len(x.CDE_CHAMB_Z0);
      assign(y(left downto left-len(x.CVP_CHAMB_Z0)+1), vectorify(x.CVP_CHAMB_Z0, y(left downto left-len(x.CVP_CHAMB_Z0)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_MON_t) return UCM_SUPER_MON_t is
    variable y: UCM_SUPER_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := structify(x(left to left+len(y.STATUS)-1), y.STATUS);
      left := left + len(y.STATUS);
      y.SECTOR_PHI := structify(x(left to left+len(y.SECTOR_PHI)-1), y.SECTOR_PHI);
      left := left + len(y.SECTOR_PHI);
      y.CDE_CHAMB_Z0 := structify(x(left to left+len(y.CDE_CHAMB_Z0)-1), y.CDE_CHAMB_Z0);
      left := left + len(y.CDE_CHAMB_Z0);
      y.CVP_CHAMB_Z0 := structify(x(left to left+len(y.CVP_CHAMB_Z0)-1), y.CVP_CHAMB_Z0);
    else
      y.STATUS := structify(x(left downto left-len(y.STATUS)+1), y.STATUS);
      left := left - len(y.STATUS);
      y.SECTOR_PHI := structify(x(left downto left-len(y.SECTOR_PHI)+1), y.SECTOR_PHI);
      left := left - len(y.SECTOR_PHI);
      y.CDE_CHAMB_Z0 := structify(x(left downto left-len(y.CDE_CHAMB_Z0)+1), y.CDE_CHAMB_Z0);
      left := left - len(y.CDE_CHAMB_Z0);
      y.CVP_CHAMB_Z0 := structify(x(left downto left-len(y.CVP_CHAMB_Z0)+1), y.CVP_CHAMB_Z0);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_MON_t) return UCM_SUPER_MON_t is
  variable y: UCM_SUPER_MON_t;
  begin
    y.STATUS := nullify(t.STATUS);
    y.SECTOR_PHI := nullify(t.SECTOR_PHI);
    y.CDE_CHAMB_Z0 := nullify(t.CDE_CHAMB_Z0);
    y.CVP_CHAMB_Z0 := nullify(t.CVP_CHAMB_Z0);
    return y;
  end function nullify;

  function len(x: UCM_SUPER_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ACTIONS);
    l := l + len(x.CONFIGS);
    l := l + len(x.SECTOR_PHI);
    l := l + len(x.CDE_CHAMB_Z0);
    l := l + len(x.CVP_CHAMB_Z0);
    return l;
  end function len;
  function vectorify(x: UCM_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ACTIONS)-1), vectorify(x.ACTIONS, y(left to left+len(x.ACTIONS)-1)));
      left := left + len(x.ACTIONS);
      assign(y(left to left+len(x.CONFIGS)-1), vectorify(x.CONFIGS, y(left to left+len(x.CONFIGS)-1)));
      left := left + len(x.CONFIGS);
      assign(y(left to left+len(x.SECTOR_PHI)-1), vectorify(x.SECTOR_PHI, y(left to left+len(x.SECTOR_PHI)-1)));
      left := left + len(x.SECTOR_PHI);
      assign(y(left to left+len(x.CDE_CHAMB_Z0)-1), vectorify(x.CDE_CHAMB_Z0, y(left to left+len(x.CDE_CHAMB_Z0)-1)));
      left := left + len(x.CDE_CHAMB_Z0);
      assign(y(left to left+len(x.CVP_CHAMB_Z0)-1), vectorify(x.CVP_CHAMB_Z0, y(left to left+len(x.CVP_CHAMB_Z0)-1)));
    else
      assign(y(left downto left-len(x.ACTIONS)+1), vectorify(x.ACTIONS, y(left downto left-len(x.ACTIONS)+1)));
      left := left - len(x.ACTIONS);
      assign(y(left downto left-len(x.CONFIGS)+1), vectorify(x.CONFIGS, y(left downto left-len(x.CONFIGS)+1)));
      left := left - len(x.CONFIGS);
      assign(y(left downto left-len(x.SECTOR_PHI)+1), vectorify(x.SECTOR_PHI, y(left downto left-len(x.SECTOR_PHI)+1)));
      left := left - len(x.SECTOR_PHI);
      assign(y(left downto left-len(x.CDE_CHAMB_Z0)+1), vectorify(x.CDE_CHAMB_Z0, y(left downto left-len(x.CDE_CHAMB_Z0)+1)));
      left := left - len(x.CDE_CHAMB_Z0);
      assign(y(left downto left-len(x.CVP_CHAMB_Z0)+1), vectorify(x.CVP_CHAMB_Z0, y(left downto left-len(x.CVP_CHAMB_Z0)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_SUPER_CTRL_t) return UCM_SUPER_CTRL_t is
    variable y: UCM_SUPER_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ACTIONS := structify(x(left to left+len(y.ACTIONS)-1), y.ACTIONS);
      left := left + len(y.ACTIONS);
      y.CONFIGS := structify(x(left to left+len(y.CONFIGS)-1), y.CONFIGS);
      left := left + len(y.CONFIGS);
      y.SECTOR_PHI := structify(x(left to left+len(y.SECTOR_PHI)-1), y.SECTOR_PHI);
      left := left + len(y.SECTOR_PHI);
      y.CDE_CHAMB_Z0 := structify(x(left to left+len(y.CDE_CHAMB_Z0)-1), y.CDE_CHAMB_Z0);
      left := left + len(y.CDE_CHAMB_Z0);
      y.CVP_CHAMB_Z0 := structify(x(left to left+len(y.CVP_CHAMB_Z0)-1), y.CVP_CHAMB_Z0);
    else
      y.ACTIONS := structify(x(left downto left-len(y.ACTIONS)+1), y.ACTIONS);
      left := left - len(y.ACTIONS);
      y.CONFIGS := structify(x(left downto left-len(y.CONFIGS)+1), y.CONFIGS);
      left := left - len(y.CONFIGS);
      y.SECTOR_PHI := structify(x(left downto left-len(y.SECTOR_PHI)+1), y.SECTOR_PHI);
      left := left - len(y.SECTOR_PHI);
      y.CDE_CHAMB_Z0 := structify(x(left downto left-len(y.CDE_CHAMB_Z0)+1), y.CDE_CHAMB_Z0);
      left := left - len(y.CDE_CHAMB_Z0);
      y.CVP_CHAMB_Z0 := structify(x(left downto left-len(y.CVP_CHAMB_Z0)+1), y.CVP_CHAMB_Z0);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_SUPER_CTRL_t) return UCM_SUPER_CTRL_t is
  variable y: UCM_SUPER_CTRL_t;
  begin
    y.ACTIONS := nullify(t.ACTIONS);
    y.CONFIGS := nullify(t.CONFIGS);
    y.SECTOR_PHI := nullify(t.SECTOR_PHI);
    y.CDE_CHAMB_Z0 := nullify(t.CDE_CHAMB_Z0);
    y.CVP_CHAMB_Z0 := nullify(t.CVP_CHAMB_Z0);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_rdy);
    l := l + len(x.rd_data);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), vectorify(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), vectorify(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t is
    variable y: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := structify(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.rd_rdy := structify(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t is
  variable y: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_MON_t;
  begin
    y.rd_rdy := nullify(t.rd_rdy);
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_req);
    l := l + len(x.rd_req);
    l := l + len(x.wr_addr);
    l := l + len(x.rd_addr);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), vectorify(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.rd_req)-1), vectorify(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.wr_addr)-1), vectorify(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), vectorify(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), vectorify(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.rd_req)+1), vectorify(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.wr_addr)+1), vectorify(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), vectorify(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t is
    variable y: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := structify(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.rd_req := structify(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.wr_addr := structify(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := structify(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.wr_req := structify(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.rd_req := structify(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.wr_addr := structify(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := structify(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t is
  variable y: UCM_R_PHI_COMP_RPC_MEM_INTERFACE_CTRL_t;
  begin
    y.wr_req := nullify(t.wr_req);
    y.rd_req := nullify(t.rd_req);
    y.wr_addr := nullify(t.wr_addr);
    y.rd_addr := nullify(t.rd_addr);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_RPC_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MEM_INTERFACE);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_RPC_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MEM_INTERFACE)-1), vectorify(x.MEM_INTERFACE, y(left to left+len(x.MEM_INTERFACE)-1)));
    else
      assign(y(left downto left-len(x.MEM_INTERFACE)+1), vectorify(x.MEM_INTERFACE, y(left downto left-len(x.MEM_INTERFACE)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_RPC_MON_t) return UCM_R_PHI_COMP_RPC_MON_t is
    variable y: UCM_R_PHI_COMP_RPC_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MEM_INTERFACE := structify(x(left to left+len(y.MEM_INTERFACE)-1), y.MEM_INTERFACE);
    else
      y.MEM_INTERFACE := structify(x(left downto left-len(y.MEM_INTERFACE)+1), y.MEM_INTERFACE);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_RPC_MON_t) return UCM_R_PHI_COMP_RPC_MON_t is
  variable y: UCM_R_PHI_COMP_RPC_MON_t;
  begin
    y.MEM_INTERFACE := nullify(t.MEM_INTERFACE);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_RPC_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sel_thread);
    l := l + len(x.sel_station);
    l := l + len(x.sel_layer);
    l := l + len(x.ext_ctrl);
    l := l + len(x.MEM_INTERFACE);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_RPC_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sel_thread)-1), vectorify(x.sel_thread, y(left to left+len(x.sel_thread)-1)));
      left := left + len(x.sel_thread);
      assign(y(left to left+len(x.sel_station)-1), vectorify(x.sel_station, y(left to left+len(x.sel_station)-1)));
      left := left + len(x.sel_station);
      assign(y(left to left+len(x.sel_layer)-1), vectorify(x.sel_layer, y(left to left+len(x.sel_layer)-1)));
      left := left + len(x.sel_layer);
      assign(y(left to left+len(x.ext_ctrl)-1), vectorify(x.ext_ctrl, y(left to left+len(x.ext_ctrl)-1)));
      left := left + len(x.ext_ctrl);
      assign(y(left to left+len(x.MEM_INTERFACE)-1), vectorify(x.MEM_INTERFACE, y(left to left+len(x.MEM_INTERFACE)-1)));
    else
      assign(y(left downto left-len(x.sel_thread)+1), vectorify(x.sel_thread, y(left downto left-len(x.sel_thread)+1)));
      left := left - len(x.sel_thread);
      assign(y(left downto left-len(x.sel_station)+1), vectorify(x.sel_station, y(left downto left-len(x.sel_station)+1)));
      left := left - len(x.sel_station);
      assign(y(left downto left-len(x.sel_layer)+1), vectorify(x.sel_layer, y(left downto left-len(x.sel_layer)+1)));
      left := left - len(x.sel_layer);
      assign(y(left downto left-len(x.ext_ctrl)+1), vectorify(x.ext_ctrl, y(left downto left-len(x.ext_ctrl)+1)));
      left := left - len(x.ext_ctrl);
      assign(y(left downto left-len(x.MEM_INTERFACE)+1), vectorify(x.MEM_INTERFACE, y(left downto left-len(x.MEM_INTERFACE)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_RPC_CTRL_t) return UCM_R_PHI_COMP_RPC_CTRL_t is
    variable y: UCM_R_PHI_COMP_RPC_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sel_thread := structify(x(left to left+len(y.sel_thread)-1), y.sel_thread);
      left := left + len(y.sel_thread);
      y.sel_station := structify(x(left to left+len(y.sel_station)-1), y.sel_station);
      left := left + len(y.sel_station);
      y.sel_layer := structify(x(left to left+len(y.sel_layer)-1), y.sel_layer);
      left := left + len(y.sel_layer);
      y.ext_ctrl := structify(x(left to left+len(y.ext_ctrl)-1), y.ext_ctrl);
      left := left + len(y.ext_ctrl);
      y.MEM_INTERFACE := structify(x(left to left+len(y.MEM_INTERFACE)-1), y.MEM_INTERFACE);
    else
      y.sel_thread := structify(x(left downto left-len(y.sel_thread)+1), y.sel_thread);
      left := left - len(y.sel_thread);
      y.sel_station := structify(x(left downto left-len(y.sel_station)+1), y.sel_station);
      left := left - len(y.sel_station);
      y.sel_layer := structify(x(left downto left-len(y.sel_layer)+1), y.sel_layer);
      left := left - len(y.sel_layer);
      y.ext_ctrl := structify(x(left downto left-len(y.ext_ctrl)+1), y.ext_ctrl);
      left := left - len(y.ext_ctrl);
      y.MEM_INTERFACE := structify(x(left downto left-len(y.MEM_INTERFACE)+1), y.MEM_INTERFACE);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_RPC_CTRL_t) return UCM_R_PHI_COMP_RPC_CTRL_t is
  variable y: UCM_R_PHI_COMP_RPC_CTRL_t;
  begin
    y.sel_thread := nullify(t.sel_thread);
    y.sel_station := nullify(t.sel_station);
    y.sel_layer := nullify(t.sel_layer);
    y.ext_ctrl := nullify(t.ext_ctrl);
    y.MEM_INTERFACE := nullify(t.MEM_INTERFACE);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_rdy);
    l := l + len(x.rd_data);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), vectorify(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), vectorify(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t is
    variable y: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := structify(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.rd_rdy := structify(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t is
  variable y: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_MON_t;
  begin
    y.rd_rdy := nullify(t.rd_rdy);
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_req);
    l := l + len(x.rd_req);
    l := l + len(x.wr_addr);
    l := l + len(x.rd_addr);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), vectorify(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.rd_req)-1), vectorify(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.wr_addr)-1), vectorify(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), vectorify(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), vectorify(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.rd_req)+1), vectorify(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.wr_addr)+1), vectorify(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), vectorify(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t is
    variable y: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := structify(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.rd_req := structify(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.wr_addr := structify(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := structify(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.wr_req := structify(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.rd_req := structify(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.wr_addr := structify(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := structify(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t) return UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t is
  variable y: UCM_R_PHI_COMP_MDT_MEM_INTERFACE_CTRL_t;
  begin
    y.wr_req := nullify(t.wr_req);
    y.rd_req := nullify(t.rd_req);
    y.wr_addr := nullify(t.wr_addr);
    y.rd_addr := nullify(t.rd_addr);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_MDT_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MEM_INTERFACE);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_MDT_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MEM_INTERFACE)-1), vectorify(x.MEM_INTERFACE, y(left to left+len(x.MEM_INTERFACE)-1)));
    else
      assign(y(left downto left-len(x.MEM_INTERFACE)+1), vectorify(x.MEM_INTERFACE, y(left downto left-len(x.MEM_INTERFACE)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MDT_MON_t) return UCM_R_PHI_COMP_MDT_MON_t is
    variable y: UCM_R_PHI_COMP_MDT_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MEM_INTERFACE := structify(x(left to left+len(y.MEM_INTERFACE)-1), y.MEM_INTERFACE);
    else
      y.MEM_INTERFACE := structify(x(left downto left-len(y.MEM_INTERFACE)+1), y.MEM_INTERFACE);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_MDT_MON_t) return UCM_R_PHI_COMP_MDT_MON_t is
  variable y: UCM_R_PHI_COMP_MDT_MON_t;
  begin
    y.MEM_INTERFACE := nullify(t.MEM_INTERFACE);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_MDT_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sel_thread);
    l := l + len(x.sel_station);
    l := l + len(x.sel_layer);
    l := l + len(x.ext_ctrl);
    l := l + len(x.MEM_INTERFACE);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_MDT_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sel_thread)-1), vectorify(x.sel_thread, y(left to left+len(x.sel_thread)-1)));
      left := left + len(x.sel_thread);
      assign(y(left to left+len(x.sel_station)-1), vectorify(x.sel_station, y(left to left+len(x.sel_station)-1)));
      left := left + len(x.sel_station);
      assign(y(left to left+len(x.sel_layer)-1), vectorify(x.sel_layer, y(left to left+len(x.sel_layer)-1)));
      left := left + len(x.sel_layer);
      assign(y(left to left+len(x.ext_ctrl)-1), vectorify(x.ext_ctrl, y(left to left+len(x.ext_ctrl)-1)));
      left := left + len(x.ext_ctrl);
      assign(y(left to left+len(x.MEM_INTERFACE)-1), vectorify(x.MEM_INTERFACE, y(left to left+len(x.MEM_INTERFACE)-1)));
    else
      assign(y(left downto left-len(x.sel_thread)+1), vectorify(x.sel_thread, y(left downto left-len(x.sel_thread)+1)));
      left := left - len(x.sel_thread);
      assign(y(left downto left-len(x.sel_station)+1), vectorify(x.sel_station, y(left downto left-len(x.sel_station)+1)));
      left := left - len(x.sel_station);
      assign(y(left downto left-len(x.sel_layer)+1), vectorify(x.sel_layer, y(left downto left-len(x.sel_layer)+1)));
      left := left - len(x.sel_layer);
      assign(y(left downto left-len(x.ext_ctrl)+1), vectorify(x.ext_ctrl, y(left downto left-len(x.ext_ctrl)+1)));
      left := left - len(x.ext_ctrl);
      assign(y(left downto left-len(x.MEM_INTERFACE)+1), vectorify(x.MEM_INTERFACE, y(left downto left-len(x.MEM_INTERFACE)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MDT_CTRL_t) return UCM_R_PHI_COMP_MDT_CTRL_t is
    variable y: UCM_R_PHI_COMP_MDT_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sel_thread := structify(x(left to left+len(y.sel_thread)-1), y.sel_thread);
      left := left + len(y.sel_thread);
      y.sel_station := structify(x(left to left+len(y.sel_station)-1), y.sel_station);
      left := left + len(y.sel_station);
      y.sel_layer := structify(x(left to left+len(y.sel_layer)-1), y.sel_layer);
      left := left + len(y.sel_layer);
      y.ext_ctrl := structify(x(left to left+len(y.ext_ctrl)-1), y.ext_ctrl);
      left := left + len(y.ext_ctrl);
      y.MEM_INTERFACE := structify(x(left to left+len(y.MEM_INTERFACE)-1), y.MEM_INTERFACE);
    else
      y.sel_thread := structify(x(left downto left-len(y.sel_thread)+1), y.sel_thread);
      left := left - len(y.sel_thread);
      y.sel_station := structify(x(left downto left-len(y.sel_station)+1), y.sel_station);
      left := left - len(y.sel_station);
      y.sel_layer := structify(x(left downto left-len(y.sel_layer)+1), y.sel_layer);
      left := left - len(y.sel_layer);
      y.ext_ctrl := structify(x(left downto left-len(y.ext_ctrl)+1), y.ext_ctrl);
      left := left - len(y.ext_ctrl);
      y.MEM_INTERFACE := structify(x(left downto left-len(y.MEM_INTERFACE)+1), y.MEM_INTERFACE);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_MDT_CTRL_t) return UCM_R_PHI_COMP_MDT_CTRL_t is
  variable y: UCM_R_PHI_COMP_MDT_CTRL_t;
  begin
    y.sel_thread := nullify(t.sel_thread);
    y.sel_station := nullify(t.sel_station);
    y.sel_layer := nullify(t.sel_layer);
    y.ext_ctrl := nullify(t.ext_ctrl);
    y.MEM_INTERFACE := nullify(t.MEM_INTERFACE);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.RPC);
    l := l + len(x.MDT);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RPC)-1), vectorify(x.RPC, y(left to left+len(x.RPC)-1)));
      left := left + len(x.RPC);
      assign(y(left to left+len(x.MDT)-1), vectorify(x.MDT, y(left to left+len(x.MDT)-1)));
    else
      assign(y(left downto left-len(x.RPC)+1), vectorify(x.RPC, y(left downto left-len(x.RPC)+1)));
      left := left - len(x.RPC);
      assign(y(left downto left-len(x.MDT)+1), vectorify(x.MDT, y(left downto left-len(x.MDT)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_MON_t) return UCM_R_PHI_COMP_MON_t is
    variable y: UCM_R_PHI_COMP_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RPC := structify(x(left to left+len(y.RPC)-1), y.RPC);
      left := left + len(y.RPC);
      y.MDT := structify(x(left to left+len(y.MDT)-1), y.MDT);
    else
      y.RPC := structify(x(left downto left-len(y.RPC)+1), y.RPC);
      left := left - len(y.RPC);
      y.MDT := structify(x(left downto left-len(y.MDT)+1), y.MDT);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_MON_t) return UCM_R_PHI_COMP_MON_t is
  variable y: UCM_R_PHI_COMP_MON_t;
  begin
    y.RPC := nullify(t.RPC);
    y.MDT := nullify(t.MDT);
    return y;
  end function nullify;

  function len(x: UCM_R_PHI_COMP_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.RPC);
    l := l + len(x.MDT);
    return l;
  end function len;
  function vectorify(x: UCM_R_PHI_COMP_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RPC)-1), vectorify(x.RPC, y(left to left+len(x.RPC)-1)));
      left := left + len(x.RPC);
      assign(y(left to left+len(x.MDT)-1), vectorify(x.MDT, y(left to left+len(x.MDT)-1)));
    else
      assign(y(left downto left-len(x.RPC)+1), vectorify(x.RPC, y(left downto left-len(x.RPC)+1)));
      left := left - len(x.RPC);
      assign(y(left downto left-len(x.MDT)+1), vectorify(x.MDT, y(left downto left-len(x.MDT)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_R_PHI_COMP_CTRL_t) return UCM_R_PHI_COMP_CTRL_t is
    variable y: UCM_R_PHI_COMP_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RPC := structify(x(left to left+len(y.RPC)-1), y.RPC);
      left := left + len(y.RPC);
      y.MDT := structify(x(left to left+len(y.MDT)-1), y.MDT);
    else
      y.RPC := structify(x(left downto left-len(y.RPC)+1), y.RPC);
      left := left - len(y.RPC);
      y.MDT := structify(x(left downto left-len(y.MDT)+1), y.MDT);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_R_PHI_COMP_CTRL_t) return UCM_R_PHI_COMP_CTRL_t is
  variable y: UCM_R_PHI_COMP_CTRL_t;
  begin
    y.RPC := nullify(t.RPC);
    y.MDT := nullify(t.MDT);
    return y;
  end function nullify;

  function len(x: UCM_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SUPER);
    l := l + len(x.R_PHI_COMP);
    return l;
  end function len;
  function vectorify(x: UCM_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), vectorify(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.R_PHI_COMP)-1), vectorify(x.R_PHI_COMP, y(left to left+len(x.R_PHI_COMP)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), vectorify(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.R_PHI_COMP)+1), vectorify(x.R_PHI_COMP, y(left downto left-len(x.R_PHI_COMP)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_MON_t) return UCM_MON_t is
    variable y: UCM_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := structify(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.R_PHI_COMP := structify(x(left to left+len(y.R_PHI_COMP)-1), y.R_PHI_COMP);
    else
      y.SUPER := structify(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.R_PHI_COMP := structify(x(left downto left-len(y.R_PHI_COMP)+1), y.R_PHI_COMP);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_MON_t) return UCM_MON_t is
  variable y: UCM_MON_t;
  begin
    y.SUPER := nullify(t.SUPER);
    y.R_PHI_COMP := nullify(t.R_PHI_COMP);
    return y;
  end function nullify;

  function len(x: UCM_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SUPER);
    l := l + len(x.R_PHI_COMP);
    return l;
  end function len;
  function vectorify(x: UCM_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), vectorify(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.R_PHI_COMP)-1), vectorify(x.R_PHI_COMP, y(left to left+len(x.R_PHI_COMP)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), vectorify(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.R_PHI_COMP)+1), vectorify(x.R_PHI_COMP, y(left downto left-len(x.R_PHI_COMP)+1)));
    end if;
    return y;
  end function vectorify;
  function structify(x: in std_logic_vector; t: UCM_CTRL_t) return UCM_CTRL_t is
    variable y: UCM_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := structify(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.R_PHI_COMP := structify(x(left to left+len(y.R_PHI_COMP)-1), y.R_PHI_COMP);
    else
      y.SUPER := structify(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.R_PHI_COMP := structify(x(left downto left-len(y.R_PHI_COMP)+1), y.R_PHI_COMP);
    end if;
    return y;
  end function structify;
  function nullify(t: UCM_CTRL_t) return UCM_CTRL_t is
  variable y: UCM_CTRL_t;
  begin
    y.SUPER := nullify(t.SUPER);
    y.R_PHI_COMP := nullify(t.R_PHI_COMP);
    return y;
  end function nullify;

end package body UCM_CTRL;
