-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package HPS_CTRL is

  type HPS_SUPER_ACTIONS_CTRL_t is record
    RESET : std_logic;
    ENABLE : std_logic;
    DISABLE : std_logic;
    FREEZE : std_logic;
  end record HPS_SUPER_ACTIONS_CTRL_t;
  function len(x: HPS_SUPER_ACTIONS_CTRL_t) return natural;
  function width(x: HPS_SUPER_ACTIONS_CTRL_t) return natural;
  function vectorify(x: HPS_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t;
  function nullify(t: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t;
  function zeroed(t: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t;

  type HPS_SUPER_CONFIGS_CTRL_t is record
    THREADS : std_logic_vector(4-1 downto 0);
    INPUT_EN : std_logic;
    OUTPUT_EN : std_logic;
    FLUSH_MEM_RESET : std_logic;
  end record HPS_SUPER_CONFIGS_CTRL_t;
  function len(x: HPS_SUPER_CONFIGS_CTRL_t) return natural;
  function width(x: HPS_SUPER_CONFIGS_CTRL_t) return natural;
  function vectorify(x: HPS_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t;
  function nullify(t: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t;
  function zeroed(t: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t;

  type HPS_SUPER_STATUS_MON_t is record
    ENABLED : std_logic;
    READY : std_logic;
    ERROR : std_logic_vector(8-1 downto 0);
  end record HPS_SUPER_STATUS_MON_t;
  function len(x: HPS_SUPER_STATUS_MON_t) return natural;
  function width(x: HPS_SUPER_STATUS_MON_t) return natural;
  function vectorify(x: HPS_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t;
  function convert(x: in std_logic_vector; t: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t;
  function nullify(t: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t;
  function zeroed(t: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t;

  type HPS_SUPER_MON_t is record
    STATUS : HPS_SUPER_STATUS_MON_t;
  end record HPS_SUPER_MON_t;
  function len(x: HPS_SUPER_MON_t) return natural;
  function width(x: HPS_SUPER_MON_t) return natural;
  function vectorify(x: HPS_SUPER_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_SUPER_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_SUPER_MON_t) return HPS_SUPER_MON_t;
  function convert(x: in std_logic_vector; t: HPS_SUPER_MON_t) return HPS_SUPER_MON_t;
  function nullify(t: HPS_SUPER_MON_t) return HPS_SUPER_MON_t;
  function zeroed(t: HPS_SUPER_MON_t) return HPS_SUPER_MON_t;

  type HPS_SUPER_CTRL_t is record
    ACTIONS : HPS_SUPER_ACTIONS_CTRL_t;
    CONFIGS : HPS_SUPER_CONFIGS_CTRL_t;
  end record HPS_SUPER_CTRL_t;
  function len(x: HPS_SUPER_CTRL_t) return natural;
  function width(x: HPS_SUPER_CTRL_t) return natural;
  function vectorify(x: HPS_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t;
  function nullify(t: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t;
  function zeroed(t: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t;

  type HPS_MDT_TC_MDT_TC_SIGNALS_MON_t is record
    rd_rdy : std_logic;
    freeze_ena : std_logic;
  end record HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
  function len(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return natural;
  function width(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return natural;
  function vectorify(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
  function nullify(t: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
  function zeroed(t: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;

  type HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t is record
    wr_req : std_logic;
    wr_ack : std_logic;
    rd_req : std_logic;
    rd_ack : std_logic;
    flush_req : std_logic;
    freeze_req : std_logic;
    mem_sel : std_logic_vector(3-1 downto 0);
  end record HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
  function len(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return natural;
  function width(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return natural;
  function vectorify(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
  function nullify(t: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
  function zeroed(t: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;

  type HPS_MDT_TC_MDT_TC_wr_data_CTRL_t is record
    wr_data_0 : std_logic_vector(32-1 downto 0);
    wr_data_1 : std_logic_vector(6-1 downto 0);
  end record HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
  function len(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return natural;
  function width(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return natural;
  function vectorify(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
  function nullify(t: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
  function zeroed(t: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;

  type HPS_MDT_TC_MDT_TC_rd_data_MON_t is record
    rd_data_1 : std_logic_vector(6-1 downto 0);
    rd_data_0 : std_logic_vector(32-1 downto 0);
  end record HPS_MDT_TC_MDT_TC_rd_data_MON_t;
  function len(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return natural;
  function width(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return natural;
  function vectorify(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t;
  function nullify(t: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t;
  function zeroed(t: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t;

  type HPS_MDT_TC_MDT_TC_MON_t is record
    SIGNALS : HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
    rd_data : HPS_MDT_TC_MDT_TC_rd_data_MON_t;
  end record HPS_MDT_TC_MDT_TC_MON_t;
  function len(x: HPS_MDT_TC_MDT_TC_MON_t) return natural;
  function width(x: HPS_MDT_TC_MDT_TC_MON_t) return natural;
  function vectorify(x: HPS_MDT_TC_MDT_TC_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_MDT_TC_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t;
  function nullify(t: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t;
  function zeroed(t: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t;

  type HPS_MDT_TC_MDT_TC_MON_t_ARRAY is array(6-1 downto 0) of HPS_MDT_TC_MDT_TC_MON_t;
  function len(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return natural;
  function width(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return natural;
  function vectorify(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
  function nullify(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
  function zeroed(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY;

  type HPS_MDT_TC_MDT_TC_CTRL_t is record
    SIGNALS : HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
    wr_addr : std_logic_vector(10-1 downto 0);
    rd_addr : std_logic_vector(10-1 downto 0);
    wr_data : HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
  end record HPS_MDT_TC_MDT_TC_CTRL_t;
  function len(x: HPS_MDT_TC_MDT_TC_CTRL_t) return natural;
  function width(x: HPS_MDT_TC_MDT_TC_CTRL_t) return natural;
  function vectorify(x: HPS_MDT_TC_MDT_TC_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t;
  function nullify(t: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t;
  function zeroed(t: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t;

  type HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY is array(6-1 downto 0) of HPS_MDT_TC_MDT_TC_CTRL_t;
  function len(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return natural;
  function width(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return natural;
  function vectorify(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
  function nullify(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
  function zeroed(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;

  type HPS_MDT_TC_MON_t is record
    MDT_TC : HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
  end record HPS_MDT_TC_MON_t;
  function len(x: HPS_MDT_TC_MON_t) return natural;
  function width(x: HPS_MDT_TC_MON_t) return natural;
  function vectorify(x: HPS_MDT_TC_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t;
  function nullify(t: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t;
  function zeroed(t: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t;

  type HPS_MDT_TC_CTRL_t is record
    MDT_TC : HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
  end record HPS_MDT_TC_CTRL_t;
  function len(x: HPS_MDT_TC_CTRL_t) return natural;
  function width(x: HPS_MDT_TC_CTRL_t) return natural;
  function vectorify(x: HPS_MDT_TC_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_TC_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t;
  function nullify(t: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t;
  function zeroed(t: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t;

  type HPS_MDT_T0_MDT_T0_SIGNALS_MON_t is record
    rd_rdy : std_logic;
    freeze_ena : std_logic;
  end record HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
  function len(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return natural;
  function width(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return natural;
  function vectorify(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
  function nullify(t: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
  function zeroed(t: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;

  type HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t is record
    wr_req : std_logic;
    wr_ack : std_logic;
    rd_req : std_logic;
    rd_ack : std_logic;
    flush_req : std_logic;
    freeze_req : std_logic;
    mem_sel : std_logic_vector(3-1 downto 0);
  end record HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
  function len(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return natural;
  function width(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return natural;
  function vectorify(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
  function nullify(t: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
  function zeroed(t: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;

  type HPS_MDT_T0_MDT_T0_wr_data_CTRL_t is record
    wr_data_0 : std_logic_vector(17-1 downto 0);
  end record HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
  function len(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return natural;
  function width(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return natural;
  function vectorify(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
  function nullify(t: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
  function zeroed(t: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;

  type HPS_MDT_T0_MDT_T0_rd_data_MON_t is record
    rd_data_0 : std_logic_vector(17-1 downto 0);
  end record HPS_MDT_T0_MDT_T0_rd_data_MON_t;
  function len(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return natural;
  function width(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return natural;
  function vectorify(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t;
  function nullify(t: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t;
  function zeroed(t: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t;

  type HPS_MDT_T0_MDT_T0_MON_t is record
    SIGNALS : HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
    rd_data : HPS_MDT_T0_MDT_T0_rd_data_MON_t;
  end record HPS_MDT_T0_MDT_T0_MON_t;
  function len(x: HPS_MDT_T0_MDT_T0_MON_t) return natural;
  function width(x: HPS_MDT_T0_MDT_T0_MON_t) return natural;
  function vectorify(x: HPS_MDT_T0_MDT_T0_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_MDT_T0_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t;
  function nullify(t: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t;
  function zeroed(t: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t;

  type HPS_MDT_T0_MDT_T0_MON_t_ARRAY is array(6-1 downto 0) of HPS_MDT_T0_MDT_T0_MON_t;
  function len(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return natural;
  function width(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return natural;
  function vectorify(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
  function nullify(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
  function zeroed(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY;

  type HPS_MDT_T0_MDT_T0_CTRL_t is record
    SIGNALS : HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
    wr_addr : std_logic_vector(4-1 downto 0);
    rd_addr : std_logic_vector(4-1 downto 0);
    wr_data : HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
  end record HPS_MDT_T0_MDT_T0_CTRL_t;
  function len(x: HPS_MDT_T0_MDT_T0_CTRL_t) return natural;
  function width(x: HPS_MDT_T0_MDT_T0_CTRL_t) return natural;
  function vectorify(x: HPS_MDT_T0_MDT_T0_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t;
  function nullify(t: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t;
  function zeroed(t: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t;

  type HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY is array(6-1 downto 0) of HPS_MDT_T0_MDT_T0_CTRL_t;
  function len(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return natural;
  function width(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return natural;
  function vectorify(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
  function nullify(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
  function zeroed(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;

  type HPS_MDT_T0_MON_t is record
    MDT_T0 : HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
  end record HPS_MDT_T0_MON_t;
  function len(x: HPS_MDT_T0_MON_t) return natural;
  function width(x: HPS_MDT_T0_MON_t) return natural;
  function vectorify(x: HPS_MDT_T0_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t;
  function nullify(t: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t;
  function zeroed(t: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t;

  type HPS_MDT_T0_CTRL_t is record
    MDT_T0 : HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
  end record HPS_MDT_T0_CTRL_t;
  function len(x: HPS_MDT_T0_CTRL_t) return natural;
  function width(x: HPS_MDT_T0_CTRL_t) return natural;
  function vectorify(x: HPS_MDT_T0_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MDT_T0_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t;
  function nullify(t: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t;
  function zeroed(t: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t;

  type HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t is record
    RESET : std_logic;
    ENABLE : std_logic;
    DISABLE : std_logic;
    FREEZE : std_logic;
  end record HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
  function len(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
  function nullify(t: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;

  type HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t is record
    INPUT_EN : std_logic;
    OUTPUT_EN : std_logic;
    FLUSH_MEM_RESET : std_logic;
  end record HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
  function len(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
  function nullify(t: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;

  type HPS_HEG_HEG_SUPER_STATUS_MON_t is record
    ENABLED : std_logic;
    READY : std_logic;
    ERROR : std_logic;
  end record HPS_HEG_HEG_SUPER_STATUS_MON_t;
  function len(x: HPS_HEG_HEG_SUPER_STATUS_MON_t) return natural;
  function width(x: HPS_HEG_HEG_SUPER_STATUS_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t;
  function nullify(t: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t;
  function zeroed(t: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t;

  type HPS_HEG_HEG_SUPER_COUNTERS_MON_t is record
    SLC_PROC : std_logic_vector(32-1 downto 0);
    HIT_PROC : std_logic_vector(32-1 downto 0);
    HIT_OK : std_logic_vector(32-1 downto 0);
    ERROR : std_logic_vector(32-1 downto 0);
  end record HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
  function len(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return natural;
  function width(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
  function nullify(t: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
  function zeroed(t: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t;

  type HPS_HEG_HEG_SUPER_MON_t is record
    STATUS : HPS_HEG_HEG_SUPER_STATUS_MON_t;
    COUNTERS : HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
  end record HPS_HEG_HEG_SUPER_MON_t;
  function len(x: HPS_HEG_HEG_SUPER_MON_t) return natural;
  function width(x: HPS_HEG_HEG_SUPER_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_SUPER_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_SUPER_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t;
  function nullify(t: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t;
  function zeroed(t: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t;

  type HPS_HEG_HEG_SUPER_CTRL_t is record
    ACTIONS : HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
    CONFIGS : HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
  end record HPS_HEG_HEG_SUPER_CTRL_t;
  function len(x: HPS_HEG_HEG_SUPER_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_SUPER_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t;
  function nullify(t: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t;

  type HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t is record
    rd_rdy : std_logic;
    freeze_ena : std_logic;
  end record HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return natural;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;

  type HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t is record
    wr_req : std_logic;
    wr_ack : std_logic;
    rd_req : std_logic;
    rd_ack : std_logic;
    flush_req : std_logic;
    freeze_req : std_logic;
    mem_sel : std_logic_vector(3-1 downto 0);
  end record HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;

  type HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t is record
    wr_data_0 : std_logic_vector(32-1 downto 0);
    wr_data_1 : std_logic_vector(6-1 downto 0);
  end record HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;

  type HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t is record
    rd_data_1 : std_logic_vector(6-1 downto 0);
    rd_data_0 : std_logic_vector(32-1 downto 0);
  end record HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return natural;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;

  type HPS_HEG_HEG_CTRL_ROI_TC_MON_t is record
    SIGNALS : HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
    rd_data : HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
  end record HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return natural;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t;

  type HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t is record
    SIGNALS : HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
    wr_addr : std_logic_vector(10-1 downto 0);
    rd_addr : std_logic_vector(10-1 downto 0);
    wr_data : HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
  end record HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;

  type HPS_HEG_HEG_CTRL_MON_t is record
    ROI_TC : HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
  end record HPS_HEG_HEG_CTRL_MON_t;
  function len(x: HPS_HEG_HEG_CTRL_MON_t) return natural;
  function width(x: HPS_HEG_HEG_CTRL_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t;
  function nullify(t: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t;
  function zeroed(t: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t;

  type HPS_HEG_HEG_CTRL_CTRL_t is record
    ROI_TC : HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
  end record HPS_HEG_HEG_CTRL_CTRL_t;
  function len(x: HPS_HEG_HEG_CTRL_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_CTRL_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t;
  function nullify(t: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t;

  type HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t is record
    RESET : std_logic;
    ENABLE : std_logic;
    DISABLE : std_logic;
    FREEZE : std_logic;
  end record HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
  function len(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;

  type HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t is record
    INPUT_EN : std_logic;
    OUTPUT_EN : std_logic;
    FLUSH_MEM_RESET : std_logic;
  end record HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
  function len(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;

  type HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t is record
    rd_rdy : std_logic;
    freeze_ena : std_logic;
  end record HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;

  type HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t is record
    wr_req : std_logic;
    wr_ack : std_logic;
    rd_req : std_logic;
    rd_ack : std_logic;
    flush_req : std_logic;
    freeze_req : std_logic;
    mem_sel : std_logic_vector(3-1 downto 0);
  end record HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;

  type HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t is record
    wr_data_0 : std_logic_vector(9-1 downto 0);
  end record HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;

  type HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t is record
    rd_data_0 : std_logic_vector(9-1 downto 0);
  end record HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;

  type HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t is record
    SIGNALS : HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
    rd_data : HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
  end record HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;

  type HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t is record
    SIGNALS : HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
    wr_addr : std_logic_vector(10-1 downto 0);
    rd_addr : std_logic_vector(10-1 downto 0);
    wr_data : HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
  end record HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;

  type HPS_HEG_HEG_HP_HP_MON_t is record
    MDT_DT2R : HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
  end record HPS_HEG_HEG_HP_HP_MON_t;
  function len(x: HPS_HEG_HEG_HP_HP_MON_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t;

  type HPS_HEG_HEG_HP_HP_MON_t_ARRAY is array(6-1 downto 0) of HPS_HEG_HEG_HP_HP_MON_t;
  function len(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
  function nullify(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
  function zeroed(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY;

  type HPS_HEG_HEG_HP_HP_CTRL_t is record
    ACTIONS : HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
    CONFIGS : HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
    MDT_DT2R : HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
  end record HPS_HEG_HEG_HP_HP_CTRL_t;
  function len(x: HPS_HEG_HEG_HP_HP_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t;
  function nullify(t: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t;

  type HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY is array(6-1 downto 0) of HPS_HEG_HEG_HP_HP_CTRL_t;
  function len(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return natural;
  function width(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
  function nullify(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
  function zeroed(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;

  type HPS_HEG_HEG_HP_MON_t is record
    HP : HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
  end record HPS_HEG_HEG_HP_MON_t;
  function len(x: HPS_HEG_HEG_HP_MON_t) return natural;
  function width(x: HPS_HEG_HEG_HP_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t;
  function nullify(t: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t;
  function zeroed(t: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t;

  type HPS_HEG_HEG_HP_CTRL_t is record
    HP : HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
  end record HPS_HEG_HEG_HP_CTRL_t;
  function len(x: HPS_HEG_HEG_HP_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_HP_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_HP_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_HP_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t;
  function nullify(t: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t;

  type HPS_HEG_HEG_MON_t is record
    SUPER : HPS_HEG_HEG_SUPER_MON_t;
    CTRL : HPS_HEG_HEG_CTRL_MON_t;
    HP : HPS_HEG_HEG_HP_MON_t;
  end record HPS_HEG_HEG_MON_t;
  function len(x: HPS_HEG_HEG_MON_t) return natural;
  function width(x: HPS_HEG_HEG_MON_t) return natural;
  function vectorify(x: HPS_HEG_HEG_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t;
  function nullify(t: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t;
  function zeroed(t: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t;

  type HPS_HEG_HEG_MON_t_ARRAY is array(3-1 downto 0) of HPS_HEG_HEG_MON_t;
  function len(x: HPS_HEG_HEG_MON_t_ARRAY) return natural;
  function width(x: HPS_HEG_HEG_MON_t_ARRAY) return natural;
  function vectorify(x: HPS_HEG_HEG_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY;
  function nullify(x: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY;
  function zeroed(x: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY;

  type HPS_HEG_HEG_CTRL_t is record
    SUPER : HPS_HEG_HEG_SUPER_CTRL_t;
    CTRL : HPS_HEG_HEG_CTRL_CTRL_t;
    HP : HPS_HEG_HEG_HP_CTRL_t;
  end record HPS_HEG_HEG_CTRL_t;
  function len(x: HPS_HEG_HEG_CTRL_t) return natural;
  function width(x: HPS_HEG_HEG_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t;
  function nullify(t: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t;
  function zeroed(t: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t;

  type HPS_HEG_HEG_CTRL_t_ARRAY is array(3-1 downto 0) of HPS_HEG_HEG_CTRL_t;
  function len(x: HPS_HEG_HEG_CTRL_t_ARRAY) return natural;
  function width(x: HPS_HEG_HEG_CTRL_t_ARRAY) return natural;
  function vectorify(x: HPS_HEG_HEG_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_HEG_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY;
  function nullify(x: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY;
  function zeroed(x: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY;

  type HPS_HEG_MON_t is record
    HEG : HPS_HEG_HEG_MON_t_ARRAY;
  end record HPS_HEG_MON_t;
  function len(x: HPS_HEG_MON_t) return natural;
  function width(x: HPS_HEG_MON_t) return natural;
  function vectorify(x: HPS_HEG_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_MON_t) return HPS_HEG_MON_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_MON_t) return HPS_HEG_MON_t;
  function nullify(t: HPS_HEG_MON_t) return HPS_HEG_MON_t;
  function zeroed(t: HPS_HEG_MON_t) return HPS_HEG_MON_t;

  type HPS_HEG_CTRL_t is record
    HEG : HPS_HEG_HEG_CTRL_t_ARRAY;
  end record HPS_HEG_CTRL_t;
  function len(x: HPS_HEG_CTRL_t) return natural;
  function width(x: HPS_HEG_CTRL_t) return natural;
  function vectorify(x: HPS_HEG_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_HEG_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t;
  function nullify(t: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t;
  function zeroed(t: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t;

  type HPS_LSF_LSF_MON_t is record
    STATUS : std_logic;
    sb_lsf_mdt_hits_rdata_31_0 : std_logic_vector(32-1 downto 0);
    sb_lsf_mdt_hits_rdata_40_32 : std_logic_vector(9-1 downto 0);
  end record HPS_LSF_LSF_MON_t;
  function len(x: HPS_LSF_LSF_MON_t) return natural;
  function width(x: HPS_LSF_LSF_MON_t) return natural;
  function vectorify(x: HPS_LSF_LSF_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_LSF_LSF_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t;
  function convert(x: in std_logic_vector; t: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t;
  function nullify(t: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t;
  function zeroed(t: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t;

  type HPS_LSF_LSF_MON_t_ARRAY is array(3-1 downto 0) of HPS_LSF_LSF_MON_t;
  function len(x: HPS_LSF_LSF_MON_t_ARRAY) return natural;
  function width(x: HPS_LSF_LSF_MON_t_ARRAY) return natural;
  function vectorify(x: HPS_LSF_LSF_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_LSF_LSF_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY;
  function nullify(x: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY;
  function zeroed(x: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY;

  type HPS_LSF_LSF_CTRL_t is record
    RESET : std_logic;
    HBA_MAX_CLOCKS : std_logic_vector(10-1 downto 0);
    sb_lsf_mdt_hits_freeze : std_logic;
    sb_lsf_mdt_hits_raddr : std_logic_vector(8-1 downto 0);
    sb_lsf_mdt_hits_re : std_logic;
  end record HPS_LSF_LSF_CTRL_t;
  function len(x: HPS_LSF_LSF_CTRL_t) return natural;
  function width(x: HPS_LSF_LSF_CTRL_t) return natural;
  function vectorify(x: HPS_LSF_LSF_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_LSF_LSF_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t;
  function nullify(t: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t;
  function zeroed(t: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t;

  type HPS_LSF_LSF_CTRL_t_ARRAY is array(3-1 downto 0) of HPS_LSF_LSF_CTRL_t;
  function len(x: HPS_LSF_LSF_CTRL_t_ARRAY) return natural;
  function width(x: HPS_LSF_LSF_CTRL_t_ARRAY) return natural;
  function vectorify(x: HPS_LSF_LSF_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_LSF_LSF_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY;
  function nullify(x: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY;
  function zeroed(x: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY;

  type HPS_LSF_MON_t is record
    LSF : HPS_LSF_LSF_MON_t_ARRAY;
  end record HPS_LSF_MON_t;
  function len(x: HPS_LSF_MON_t) return natural;
  function width(x: HPS_LSF_MON_t) return natural;
  function vectorify(x: HPS_LSF_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_LSF_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_LSF_MON_t) return HPS_LSF_MON_t;
  function convert(x: in std_logic_vector; t: HPS_LSF_MON_t) return HPS_LSF_MON_t;
  function nullify(t: HPS_LSF_MON_t) return HPS_LSF_MON_t;
  function zeroed(t: HPS_LSF_MON_t) return HPS_LSF_MON_t;

  type HPS_LSF_CTRL_t is record
    LSF : HPS_LSF_LSF_CTRL_t_ARRAY;
  end record HPS_LSF_CTRL_t;
  function len(x: HPS_LSF_CTRL_t) return natural;
  function width(x: HPS_LSF_CTRL_t) return natural;
  function vectorify(x: HPS_LSF_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_LSF_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t;
  function nullify(t: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t;
  function zeroed(t: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t;

  type HPS_CSF_CSF_ACTIONS_CTRL_t is record
    RESET : std_logic;
    ENABLE : std_logic;
    DISABLE : std_logic;
    FREEZE : std_logic;
  end record HPS_CSF_CSF_ACTIONS_CTRL_t;
  function len(x: HPS_CSF_CSF_ACTIONS_CTRL_t) return natural;
  function width(x: HPS_CSF_CSF_ACTIONS_CTRL_t) return natural;
  function vectorify(x: HPS_CSF_CSF_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_CSF_CSF_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t;
  function nullify(t: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t;
  function zeroed(t: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t;

  type HPS_CSF_CSF_STATUS_MON_t is record
    ENABLED : std_logic;
    READY : std_logic;
    ERROR : std_logic;
  end record HPS_CSF_CSF_STATUS_MON_t;
  function len(x: HPS_CSF_CSF_STATUS_MON_t) return natural;
  function width(x: HPS_CSF_CSF_STATUS_MON_t) return natural;
  function vectorify(x: HPS_CSF_CSF_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_CSF_CSF_STATUS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t;
  function convert(x: in std_logic_vector; t: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t;
  function nullify(t: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t;
  function zeroed(t: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t;

  type HPS_CSF_CSF_MON_t is record
    STATUS : HPS_CSF_CSF_STATUS_MON_t;
  end record HPS_CSF_CSF_MON_t;
  function len(x: HPS_CSF_CSF_MON_t) return natural;
  function width(x: HPS_CSF_CSF_MON_t) return natural;
  function vectorify(x: HPS_CSF_CSF_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_CSF_CSF_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t;
  function convert(x: in std_logic_vector; t: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t;
  function nullify(t: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t;
  function zeroed(t: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t;

  type HPS_CSF_CSF_MON_t_ARRAY is array(3-1 downto 0) of HPS_CSF_CSF_MON_t;
  function len(x: HPS_CSF_CSF_MON_t_ARRAY) return natural;
  function width(x: HPS_CSF_CSF_MON_t_ARRAY) return natural;
  function vectorify(x: HPS_CSF_CSF_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_CSF_CSF_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY;
  function nullify(x: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY;
  function zeroed(x: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY;

  type HPS_CSF_CSF_CTRL_t is record
    ACTIONS : HPS_CSF_CSF_ACTIONS_CTRL_t;
  end record HPS_CSF_CSF_CTRL_t;
  function len(x: HPS_CSF_CSF_CTRL_t) return natural;
  function width(x: HPS_CSF_CSF_CTRL_t) return natural;
  function vectorify(x: HPS_CSF_CSF_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_CSF_CSF_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t;
  function nullify(t: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t;
  function zeroed(t: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t;

  type HPS_CSF_CSF_CTRL_t_ARRAY is array(3-1 downto 0) of HPS_CSF_CSF_CTRL_t;
  function len(x: HPS_CSF_CSF_CTRL_t_ARRAY) return natural;
  function width(x: HPS_CSF_CSF_CTRL_t_ARRAY) return natural;
  function vectorify(x: HPS_CSF_CSF_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_CSF_CSF_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY;
  function convert(x: std_logic_vector; t: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY;
  function nullify(x: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY;
  function zeroed(x: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY;

  type HPS_CSF_MON_t is record
    CSF : HPS_CSF_CSF_MON_t_ARRAY;
  end record HPS_CSF_MON_t;
  function len(x: HPS_CSF_MON_t) return natural;
  function width(x: HPS_CSF_MON_t) return natural;
  function vectorify(x: HPS_CSF_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_CSF_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_CSF_MON_t) return HPS_CSF_MON_t;
  function convert(x: in std_logic_vector; t: HPS_CSF_MON_t) return HPS_CSF_MON_t;
  function nullify(t: HPS_CSF_MON_t) return HPS_CSF_MON_t;
  function zeroed(t: HPS_CSF_MON_t) return HPS_CSF_MON_t;

  type HPS_CSF_CTRL_t is record
    CSF : HPS_CSF_CSF_CTRL_t_ARRAY;
  end record HPS_CSF_CTRL_t;
  function len(x: HPS_CSF_CTRL_t) return natural;
  function width(x: HPS_CSF_CTRL_t) return natural;
  function vectorify(x: HPS_CSF_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_CSF_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t;
  function nullify(t: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t;
  function zeroed(t: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t;

  type HPS_MON_t is record
    SUPER : HPS_SUPER_MON_t;
    MDT_TC : HPS_MDT_TC_MON_t;
    MDT_T0 : HPS_MDT_T0_MON_t;
    HEG : HPS_HEG_MON_t;
    LSF : HPS_LSF_MON_t;
    CSF : HPS_CSF_MON_t;
  end record HPS_MON_t;
  function len(x: HPS_MON_t) return natural;
  function width(x: HPS_MON_t) return natural;
  function vectorify(x: HPS_MON_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_MON_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_MON_t) return HPS_MON_t;
  function convert(x: in std_logic_vector; t: HPS_MON_t) return HPS_MON_t;
  function nullify(t: HPS_MON_t) return HPS_MON_t;
  function zeroed(t: HPS_MON_t) return HPS_MON_t;

  type HPS_CTRL_t is record
    SUPER : HPS_SUPER_CTRL_t;
    MDT_TC : HPS_MDT_TC_CTRL_t;
    MDT_T0 : HPS_MDT_T0_CTRL_t;
    HEG : HPS_HEG_CTRL_t;
    LSF : HPS_LSF_CTRL_t;
    CSF : HPS_CSF_CTRL_t;
  end record HPS_CTRL_t;
  function len(x: HPS_CTRL_t) return natural;
  function width(x: HPS_CTRL_t) return natural;
  function vectorify(x: HPS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function convert(x: HPS_CTRL_t; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: HPS_CTRL_t) return HPS_CTRL_t;
  function convert(x: in std_logic_vector; t: HPS_CTRL_t) return HPS_CTRL_t;
  function nullify(t: HPS_CTRL_t) return HPS_CTRL_t;
  function zeroed(t: HPS_CTRL_t) return HPS_CTRL_t;

end package HPS_CTRL;

------------------------------------------------------------

package body HPS_CTRL is

  function len(x: HPS_SUPER_ACTIONS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.RESET);
    l := l + len(x.ENABLE);
    l := l + len(x.DISABLE);
    l := l + len(x.FREEZE);
    return l;
  end function len;
  function width(x: HPS_SUPER_ACTIONS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.RESET);
    l := l + width(x.ENABLE);
    l := l + width(x.DISABLE);
    l := l + width(x.FREEZE);
    return l;
  end function width;
  function vectorify(x: HPS_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), vectorify(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.ENABLE)-1), vectorify(x.ENABLE, y(left to left+len(x.ENABLE)-1)));
      left := left + len(x.ENABLE);
      assign(y(left to left+len(x.DISABLE)-1), vectorify(x.DISABLE, y(left to left+len(x.DISABLE)-1)));
      left := left + len(x.DISABLE);
      assign(y(left to left+len(x.FREEZE)-1), vectorify(x.FREEZE, y(left to left+len(x.FREEZE)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), vectorify(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.ENABLE)+1), vectorify(x.ENABLE, y(left downto left-len(x.ENABLE)+1)));
      left := left - len(x.ENABLE);
      assign(y(left downto left-len(x.DISABLE)+1), vectorify(x.DISABLE, y(left downto left-len(x.DISABLE)+1)));
      left := left - len(x.DISABLE);
      assign(y(left downto left-len(x.FREEZE)+1), vectorify(x.FREEZE, y(left downto left-len(x.FREEZE)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), convert(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.ENABLE)-1), convert(x.ENABLE, y(left to left+len(x.ENABLE)-1)));
      left := left + len(x.ENABLE);
      assign(y(left to left+len(x.DISABLE)-1), convert(x.DISABLE, y(left to left+len(x.DISABLE)-1)));
      left := left + len(x.DISABLE);
      assign(y(left to left+len(x.FREEZE)-1), convert(x.FREEZE, y(left to left+len(x.FREEZE)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), convert(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.ENABLE)+1), convert(x.ENABLE, y(left downto left-len(x.ENABLE)+1)));
      left := left - len(x.ENABLE);
      assign(y(left downto left-len(x.DISABLE)+1), convert(x.DISABLE, y(left downto left-len(x.DISABLE)+1)));
      left := left - len(x.DISABLE);
      assign(y(left downto left-len(x.FREEZE)+1), convert(x.FREEZE, y(left downto left-len(x.FREEZE)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t is
    variable y: HPS_SUPER_ACTIONS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := structify(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.ENABLE := structify(x(left to left+len(y.ENABLE)-1), y.ENABLE);
      left := left + len(y.ENABLE);
      y.DISABLE := structify(x(left to left+len(y.DISABLE)-1), y.DISABLE);
      left := left + len(y.DISABLE);
      y.FREEZE := structify(x(left to left+len(y.FREEZE)-1), y.FREEZE);
    else
      y.RESET := structify(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.ENABLE := structify(x(left downto left-len(y.ENABLE)+1), y.ENABLE);
      left := left - len(y.ENABLE);
      y.DISABLE := structify(x(left downto left-len(y.DISABLE)+1), y.DISABLE);
      left := left - len(y.DISABLE);
      y.FREEZE := structify(x(left downto left-len(y.FREEZE)+1), y.FREEZE);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t is
    variable y: HPS_SUPER_ACTIONS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := convert(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.ENABLE := convert(x(left to left+len(y.ENABLE)-1), y.ENABLE);
      left := left + len(y.ENABLE);
      y.DISABLE := convert(x(left to left+len(y.DISABLE)-1), y.DISABLE);
      left := left + len(y.DISABLE);
      y.FREEZE := convert(x(left to left+len(y.FREEZE)-1), y.FREEZE);
    else
      y.RESET := convert(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.ENABLE := convert(x(left downto left-len(y.ENABLE)+1), y.ENABLE);
      left := left - len(y.ENABLE);
      y.DISABLE := convert(x(left downto left-len(y.DISABLE)+1), y.DISABLE);
      left := left - len(y.DISABLE);
      y.FREEZE := convert(x(left downto left-len(y.FREEZE)+1), y.FREEZE);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t is
  variable y: HPS_SUPER_ACTIONS_CTRL_t;
  begin
    y.RESET := nullify(t.RESET);
    y.ENABLE := nullify(t.ENABLE);
    y.DISABLE := nullify(t.DISABLE);
    y.FREEZE := nullify(t.FREEZE);
    return y;
  end function nullify;
  function zeroed(t: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t is
  variable y: HPS_SUPER_ACTIONS_CTRL_t;
  begin
    y.RESET := zeroed(t.RESET);
    y.ENABLE := zeroed(t.ENABLE);
    y.DISABLE := zeroed(t.DISABLE);
    y.FREEZE := zeroed(t.FREEZE);
    return y;
  end function zeroed;

  function len(x: HPS_SUPER_CONFIGS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.THREADS);
    l := l + len(x.INPUT_EN);
    l := l + len(x.OUTPUT_EN);
    l := l + len(x.FLUSH_MEM_RESET);
    return l;
  end function len;
  function width(x: HPS_SUPER_CONFIGS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.THREADS);
    l := l + width(x.INPUT_EN);
    l := l + width(x.OUTPUT_EN);
    l := l + width(x.FLUSH_MEM_RESET);
    return l;
  end function width;
  function vectorify(x: HPS_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.THREADS)-1), vectorify(x.THREADS, y(left to left+len(x.THREADS)-1)));
      left := left + len(x.THREADS);
      assign(y(left to left+len(x.INPUT_EN)-1), vectorify(x.INPUT_EN, y(left to left+len(x.INPUT_EN)-1)));
      left := left + len(x.INPUT_EN);
      assign(y(left to left+len(x.OUTPUT_EN)-1), vectorify(x.OUTPUT_EN, y(left to left+len(x.OUTPUT_EN)-1)));
      left := left + len(x.OUTPUT_EN);
      assign(y(left to left+len(x.FLUSH_MEM_RESET)-1), vectorify(x.FLUSH_MEM_RESET, y(left to left+len(x.FLUSH_MEM_RESET)-1)));
    else
      assign(y(left downto left-len(x.THREADS)+1), vectorify(x.THREADS, y(left downto left-len(x.THREADS)+1)));
      left := left - len(x.THREADS);
      assign(y(left downto left-len(x.INPUT_EN)+1), vectorify(x.INPUT_EN, y(left downto left-len(x.INPUT_EN)+1)));
      left := left - len(x.INPUT_EN);
      assign(y(left downto left-len(x.OUTPUT_EN)+1), vectorify(x.OUTPUT_EN, y(left downto left-len(x.OUTPUT_EN)+1)));
      left := left - len(x.OUTPUT_EN);
      assign(y(left downto left-len(x.FLUSH_MEM_RESET)+1), vectorify(x.FLUSH_MEM_RESET, y(left downto left-len(x.FLUSH_MEM_RESET)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.THREADS)-1), convert(x.THREADS, y(left to left+len(x.THREADS)-1)));
      left := left + len(x.THREADS);
      assign(y(left to left+len(x.INPUT_EN)-1), convert(x.INPUT_EN, y(left to left+len(x.INPUT_EN)-1)));
      left := left + len(x.INPUT_EN);
      assign(y(left to left+len(x.OUTPUT_EN)-1), convert(x.OUTPUT_EN, y(left to left+len(x.OUTPUT_EN)-1)));
      left := left + len(x.OUTPUT_EN);
      assign(y(left to left+len(x.FLUSH_MEM_RESET)-1), convert(x.FLUSH_MEM_RESET, y(left to left+len(x.FLUSH_MEM_RESET)-1)));
    else
      assign(y(left downto left-len(x.THREADS)+1), convert(x.THREADS, y(left downto left-len(x.THREADS)+1)));
      left := left - len(x.THREADS);
      assign(y(left downto left-len(x.INPUT_EN)+1), convert(x.INPUT_EN, y(left downto left-len(x.INPUT_EN)+1)));
      left := left - len(x.INPUT_EN);
      assign(y(left downto left-len(x.OUTPUT_EN)+1), convert(x.OUTPUT_EN, y(left downto left-len(x.OUTPUT_EN)+1)));
      left := left - len(x.OUTPUT_EN);
      assign(y(left downto left-len(x.FLUSH_MEM_RESET)+1), convert(x.FLUSH_MEM_RESET, y(left downto left-len(x.FLUSH_MEM_RESET)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t is
    variable y: HPS_SUPER_CONFIGS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.THREADS := structify(x(left to left+len(y.THREADS)-1), y.THREADS);
      left := left + len(y.THREADS);
      y.INPUT_EN := structify(x(left to left+len(y.INPUT_EN)-1), y.INPUT_EN);
      left := left + len(y.INPUT_EN);
      y.OUTPUT_EN := structify(x(left to left+len(y.OUTPUT_EN)-1), y.OUTPUT_EN);
      left := left + len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := structify(x(left to left+len(y.FLUSH_MEM_RESET)-1), y.FLUSH_MEM_RESET);
    else
      y.THREADS := structify(x(left downto left-len(y.THREADS)+1), y.THREADS);
      left := left - len(y.THREADS);
      y.INPUT_EN := structify(x(left downto left-len(y.INPUT_EN)+1), y.INPUT_EN);
      left := left - len(y.INPUT_EN);
      y.OUTPUT_EN := structify(x(left downto left-len(y.OUTPUT_EN)+1), y.OUTPUT_EN);
      left := left - len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := structify(x(left downto left-len(y.FLUSH_MEM_RESET)+1), y.FLUSH_MEM_RESET);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t is
    variable y: HPS_SUPER_CONFIGS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.THREADS := convert(x(left to left+len(y.THREADS)-1), y.THREADS);
      left := left + len(y.THREADS);
      y.INPUT_EN := convert(x(left to left+len(y.INPUT_EN)-1), y.INPUT_EN);
      left := left + len(y.INPUT_EN);
      y.OUTPUT_EN := convert(x(left to left+len(y.OUTPUT_EN)-1), y.OUTPUT_EN);
      left := left + len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := convert(x(left to left+len(y.FLUSH_MEM_RESET)-1), y.FLUSH_MEM_RESET);
    else
      y.THREADS := convert(x(left downto left-len(y.THREADS)+1), y.THREADS);
      left := left - len(y.THREADS);
      y.INPUT_EN := convert(x(left downto left-len(y.INPUT_EN)+1), y.INPUT_EN);
      left := left - len(y.INPUT_EN);
      y.OUTPUT_EN := convert(x(left downto left-len(y.OUTPUT_EN)+1), y.OUTPUT_EN);
      left := left - len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := convert(x(left downto left-len(y.FLUSH_MEM_RESET)+1), y.FLUSH_MEM_RESET);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t is
  variable y: HPS_SUPER_CONFIGS_CTRL_t;
  begin
    y.THREADS := nullify(t.THREADS);
    y.INPUT_EN := nullify(t.INPUT_EN);
    y.OUTPUT_EN := nullify(t.OUTPUT_EN);
    y.FLUSH_MEM_RESET := nullify(t.FLUSH_MEM_RESET);
    return y;
  end function nullify;
  function zeroed(t: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t is
  variable y: HPS_SUPER_CONFIGS_CTRL_t;
  begin
    y.THREADS := zeroed(t.THREADS);
    y.INPUT_EN := zeroed(t.INPUT_EN);
    y.OUTPUT_EN := zeroed(t.OUTPUT_EN);
    y.FLUSH_MEM_RESET := zeroed(t.FLUSH_MEM_RESET);
    return y;
  end function zeroed;

  function len(x: HPS_SUPER_STATUS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ENABLED);
    l := l + len(x.READY);
    l := l + len(x.ERROR);
    return l;
  end function len;
  function width(x: HPS_SUPER_STATUS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ENABLED);
    l := l + width(x.READY);
    l := l + width(x.ERROR);
    return l;
  end function width;
  function vectorify(x: HPS_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ENABLED)-1), vectorify(x.ENABLED, y(left to left+len(x.ENABLED)-1)));
      left := left + len(x.ENABLED);
      assign(y(left to left+len(x.READY)-1), vectorify(x.READY, y(left to left+len(x.READY)-1)));
      left := left + len(x.READY);
      assign(y(left to left+len(x.ERROR)-1), vectorify(x.ERROR, y(left to left+len(x.ERROR)-1)));
    else
      assign(y(left downto left-len(x.ENABLED)+1), vectorify(x.ENABLED, y(left downto left-len(x.ENABLED)+1)));
      left := left - len(x.ENABLED);
      assign(y(left downto left-len(x.READY)+1), vectorify(x.READY, y(left downto left-len(x.READY)+1)));
      left := left - len(x.READY);
      assign(y(left downto left-len(x.ERROR)+1), vectorify(x.ERROR, y(left downto left-len(x.ERROR)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ENABLED)-1), convert(x.ENABLED, y(left to left+len(x.ENABLED)-1)));
      left := left + len(x.ENABLED);
      assign(y(left to left+len(x.READY)-1), convert(x.READY, y(left to left+len(x.READY)-1)));
      left := left + len(x.READY);
      assign(y(left to left+len(x.ERROR)-1), convert(x.ERROR, y(left to left+len(x.ERROR)-1)));
    else
      assign(y(left downto left-len(x.ENABLED)+1), convert(x.ENABLED, y(left downto left-len(x.ENABLED)+1)));
      left := left - len(x.ENABLED);
      assign(y(left downto left-len(x.READY)+1), convert(x.READY, y(left downto left-len(x.READY)+1)));
      left := left - len(x.READY);
      assign(y(left downto left-len(x.ERROR)+1), convert(x.ERROR, y(left downto left-len(x.ERROR)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t is
    variable y: HPS_SUPER_STATUS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ENABLED := structify(x(left to left+len(y.ENABLED)-1), y.ENABLED);
      left := left + len(y.ENABLED);
      y.READY := structify(x(left to left+len(y.READY)-1), y.READY);
      left := left + len(y.READY);
      y.ERROR := structify(x(left to left+len(y.ERROR)-1), y.ERROR);
    else
      y.ENABLED := structify(x(left downto left-len(y.ENABLED)+1), y.ENABLED);
      left := left - len(y.ENABLED);
      y.READY := structify(x(left downto left-len(y.READY)+1), y.READY);
      left := left - len(y.READY);
      y.ERROR := structify(x(left downto left-len(y.ERROR)+1), y.ERROR);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t is
    variable y: HPS_SUPER_STATUS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ENABLED := convert(x(left to left+len(y.ENABLED)-1), y.ENABLED);
      left := left + len(y.ENABLED);
      y.READY := convert(x(left to left+len(y.READY)-1), y.READY);
      left := left + len(y.READY);
      y.ERROR := convert(x(left to left+len(y.ERROR)-1), y.ERROR);
    else
      y.ENABLED := convert(x(left downto left-len(y.ENABLED)+1), y.ENABLED);
      left := left - len(y.ENABLED);
      y.READY := convert(x(left downto left-len(y.READY)+1), y.READY);
      left := left - len(y.READY);
      y.ERROR := convert(x(left downto left-len(y.ERROR)+1), y.ERROR);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t is
  variable y: HPS_SUPER_STATUS_MON_t;
  begin
    y.ENABLED := nullify(t.ENABLED);
    y.READY := nullify(t.READY);
    y.ERROR := nullify(t.ERROR);
    return y;
  end function nullify;
  function zeroed(t: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t is
  variable y: HPS_SUPER_STATUS_MON_t;
  begin
    y.ENABLED := zeroed(t.ENABLED);
    y.READY := zeroed(t.READY);
    y.ERROR := zeroed(t.ERROR);
    return y;
  end function zeroed;

  function len(x: HPS_SUPER_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.STATUS);
    return l;
  end function len;
  function width(x: HPS_SUPER_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.STATUS);
    return l;
  end function width;
  function vectorify(x: HPS_SUPER_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), vectorify(x.STATUS, y(left to left+len(x.STATUS)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), vectorify(x.STATUS, y(left downto left-len(x.STATUS)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_SUPER_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), convert(x.STATUS, y(left to left+len(x.STATUS)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), convert(x.STATUS, y(left downto left-len(x.STATUS)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_SUPER_MON_t) return HPS_SUPER_MON_t is
    variable y: HPS_SUPER_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := structify(x(left to left+len(y.STATUS)-1), y.STATUS);
    else
      y.STATUS := structify(x(left downto left-len(y.STATUS)+1), y.STATUS);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_SUPER_MON_t) return HPS_SUPER_MON_t is
    variable y: HPS_SUPER_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := convert(x(left to left+len(y.STATUS)-1), y.STATUS);
    else
      y.STATUS := convert(x(left downto left-len(y.STATUS)+1), y.STATUS);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_SUPER_MON_t) return HPS_SUPER_MON_t is
  variable y: HPS_SUPER_MON_t;
  begin
    y.STATUS := nullify(t.STATUS);
    return y;
  end function nullify;
  function zeroed(t: HPS_SUPER_MON_t) return HPS_SUPER_MON_t is
  variable y: HPS_SUPER_MON_t;
  begin
    y.STATUS := zeroed(t.STATUS);
    return y;
  end function zeroed;

  function len(x: HPS_SUPER_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ACTIONS);
    l := l + len(x.CONFIGS);
    return l;
  end function len;
  function width(x: HPS_SUPER_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ACTIONS);
    l := l + width(x.CONFIGS);
    return l;
  end function width;
  function vectorify(x: HPS_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ACTIONS)-1), vectorify(x.ACTIONS, y(left to left+len(x.ACTIONS)-1)));
      left := left + len(x.ACTIONS);
      assign(y(left to left+len(x.CONFIGS)-1), vectorify(x.CONFIGS, y(left to left+len(x.CONFIGS)-1)));
    else
      assign(y(left downto left-len(x.ACTIONS)+1), vectorify(x.ACTIONS, y(left downto left-len(x.ACTIONS)+1)));
      left := left - len(x.ACTIONS);
      assign(y(left downto left-len(x.CONFIGS)+1), vectorify(x.CONFIGS, y(left downto left-len(x.CONFIGS)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ACTIONS)-1), convert(x.ACTIONS, y(left to left+len(x.ACTIONS)-1)));
      left := left + len(x.ACTIONS);
      assign(y(left to left+len(x.CONFIGS)-1), convert(x.CONFIGS, y(left to left+len(x.CONFIGS)-1)));
    else
      assign(y(left downto left-len(x.ACTIONS)+1), convert(x.ACTIONS, y(left downto left-len(x.ACTIONS)+1)));
      left := left - len(x.ACTIONS);
      assign(y(left downto left-len(x.CONFIGS)+1), convert(x.CONFIGS, y(left downto left-len(x.CONFIGS)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t is
    variable y: HPS_SUPER_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ACTIONS := structify(x(left to left+len(y.ACTIONS)-1), y.ACTIONS);
      left := left + len(y.ACTIONS);
      y.CONFIGS := structify(x(left to left+len(y.CONFIGS)-1), y.CONFIGS);
    else
      y.ACTIONS := structify(x(left downto left-len(y.ACTIONS)+1), y.ACTIONS);
      left := left - len(y.ACTIONS);
      y.CONFIGS := structify(x(left downto left-len(y.CONFIGS)+1), y.CONFIGS);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t is
    variable y: HPS_SUPER_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ACTIONS := convert(x(left to left+len(y.ACTIONS)-1), y.ACTIONS);
      left := left + len(y.ACTIONS);
      y.CONFIGS := convert(x(left to left+len(y.CONFIGS)-1), y.CONFIGS);
    else
      y.ACTIONS := convert(x(left downto left-len(y.ACTIONS)+1), y.ACTIONS);
      left := left - len(y.ACTIONS);
      y.CONFIGS := convert(x(left downto left-len(y.CONFIGS)+1), y.CONFIGS);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t is
  variable y: HPS_SUPER_CTRL_t;
  begin
    y.ACTIONS := nullify(t.ACTIONS);
    y.CONFIGS := nullify(t.CONFIGS);
    return y;
  end function nullify;
  function zeroed(t: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t is
  variable y: HPS_SUPER_CTRL_t;
  begin
    y.ACTIONS := zeroed(t.ACTIONS);
    y.CONFIGS := zeroed(t.CONFIGS);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_rdy);
    l := l + len(x.freeze_ena);
    return l;
  end function len;
  function width(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_rdy);
    l := l + width(x.freeze_ena);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), vectorify(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.freeze_ena)-1), vectorify(x.freeze_ena, y(left to left+len(x.freeze_ena)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), vectorify(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.freeze_ena)+1), vectorify(x.freeze_ena, y(left downto left-len(x.freeze_ena)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), convert(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.freeze_ena)-1), convert(x.freeze_ena, y(left to left+len(x.freeze_ena)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), convert(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.freeze_ena)+1), convert(x.freeze_ena, y(left downto left-len(x.freeze_ena)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t is
    variable y: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := structify(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.freeze_ena := structify(x(left to left+len(y.freeze_ena)-1), y.freeze_ena);
    else
      y.rd_rdy := structify(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.freeze_ena := structify(x(left downto left-len(y.freeze_ena)+1), y.freeze_ena);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t is
    variable y: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := convert(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.freeze_ena := convert(x(left to left+len(y.freeze_ena)-1), y.freeze_ena);
    else
      y.rd_rdy := convert(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.freeze_ena := convert(x(left downto left-len(y.freeze_ena)+1), y.freeze_ena);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t is
  variable y: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
  begin
    y.rd_rdy := nullify(t.rd_rdy);
    y.freeze_ena := nullify(t.freeze_ena);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t is
  variable y: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
  begin
    y.rd_rdy := zeroed(t.rd_rdy);
    y.freeze_ena := zeroed(t.freeze_ena);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_req);
    l := l + len(x.wr_ack);
    l := l + len(x.rd_req);
    l := l + len(x.rd_ack);
    l := l + len(x.flush_req);
    l := l + len(x.freeze_req);
    l := l + len(x.mem_sel);
    return l;
  end function len;
  function width(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_req);
    l := l + width(x.wr_ack);
    l := l + width(x.rd_req);
    l := l + width(x.rd_ack);
    l := l + width(x.flush_req);
    l := l + width(x.freeze_req);
    l := l + width(x.mem_sel);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), vectorify(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.wr_ack)-1), vectorify(x.wr_ack, y(left to left+len(x.wr_ack)-1)));
      left := left + len(x.wr_ack);
      assign(y(left to left+len(x.rd_req)-1), vectorify(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.rd_ack)-1), vectorify(x.rd_ack, y(left to left+len(x.rd_ack)-1)));
      left := left + len(x.rd_ack);
      assign(y(left to left+len(x.flush_req)-1), vectorify(x.flush_req, y(left to left+len(x.flush_req)-1)));
      left := left + len(x.flush_req);
      assign(y(left to left+len(x.freeze_req)-1), vectorify(x.freeze_req, y(left to left+len(x.freeze_req)-1)));
      left := left + len(x.freeze_req);
      assign(y(left to left+len(x.mem_sel)-1), vectorify(x.mem_sel, y(left to left+len(x.mem_sel)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), vectorify(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.wr_ack)+1), vectorify(x.wr_ack, y(left downto left-len(x.wr_ack)+1)));
      left := left - len(x.wr_ack);
      assign(y(left downto left-len(x.rd_req)+1), vectorify(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.rd_ack)+1), vectorify(x.rd_ack, y(left downto left-len(x.rd_ack)+1)));
      left := left - len(x.rd_ack);
      assign(y(left downto left-len(x.flush_req)+1), vectorify(x.flush_req, y(left downto left-len(x.flush_req)+1)));
      left := left - len(x.flush_req);
      assign(y(left downto left-len(x.freeze_req)+1), vectorify(x.freeze_req, y(left downto left-len(x.freeze_req)+1)));
      left := left - len(x.freeze_req);
      assign(y(left downto left-len(x.mem_sel)+1), vectorify(x.mem_sel, y(left downto left-len(x.mem_sel)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), convert(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.wr_ack)-1), convert(x.wr_ack, y(left to left+len(x.wr_ack)-1)));
      left := left + len(x.wr_ack);
      assign(y(left to left+len(x.rd_req)-1), convert(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.rd_ack)-1), convert(x.rd_ack, y(left to left+len(x.rd_ack)-1)));
      left := left + len(x.rd_ack);
      assign(y(left to left+len(x.flush_req)-1), convert(x.flush_req, y(left to left+len(x.flush_req)-1)));
      left := left + len(x.flush_req);
      assign(y(left to left+len(x.freeze_req)-1), convert(x.freeze_req, y(left to left+len(x.freeze_req)-1)));
      left := left + len(x.freeze_req);
      assign(y(left to left+len(x.mem_sel)-1), convert(x.mem_sel, y(left to left+len(x.mem_sel)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), convert(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.wr_ack)+1), convert(x.wr_ack, y(left downto left-len(x.wr_ack)+1)));
      left := left - len(x.wr_ack);
      assign(y(left downto left-len(x.rd_req)+1), convert(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.rd_ack)+1), convert(x.rd_ack, y(left downto left-len(x.rd_ack)+1)));
      left := left - len(x.rd_ack);
      assign(y(left downto left-len(x.flush_req)+1), convert(x.flush_req, y(left downto left-len(x.flush_req)+1)));
      left := left - len(x.flush_req);
      assign(y(left downto left-len(x.freeze_req)+1), convert(x.freeze_req, y(left downto left-len(x.freeze_req)+1)));
      left := left - len(x.freeze_req);
      assign(y(left downto left-len(x.mem_sel)+1), convert(x.mem_sel, y(left downto left-len(x.mem_sel)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t is
    variable y: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := structify(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.wr_ack := structify(x(left to left+len(y.wr_ack)-1), y.wr_ack);
      left := left + len(y.wr_ack);
      y.rd_req := structify(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.rd_ack := structify(x(left to left+len(y.rd_ack)-1), y.rd_ack);
      left := left + len(y.rd_ack);
      y.flush_req := structify(x(left to left+len(y.flush_req)-1), y.flush_req);
      left := left + len(y.flush_req);
      y.freeze_req := structify(x(left to left+len(y.freeze_req)-1), y.freeze_req);
      left := left + len(y.freeze_req);
      y.mem_sel := structify(x(left to left+len(y.mem_sel)-1), y.mem_sel);
    else
      y.wr_req := structify(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.wr_ack := structify(x(left downto left-len(y.wr_ack)+1), y.wr_ack);
      left := left - len(y.wr_ack);
      y.rd_req := structify(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.rd_ack := structify(x(left downto left-len(y.rd_ack)+1), y.rd_ack);
      left := left - len(y.rd_ack);
      y.flush_req := structify(x(left downto left-len(y.flush_req)+1), y.flush_req);
      left := left - len(y.flush_req);
      y.freeze_req := structify(x(left downto left-len(y.freeze_req)+1), y.freeze_req);
      left := left - len(y.freeze_req);
      y.mem_sel := structify(x(left downto left-len(y.mem_sel)+1), y.mem_sel);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t is
    variable y: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := convert(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.wr_ack := convert(x(left to left+len(y.wr_ack)-1), y.wr_ack);
      left := left + len(y.wr_ack);
      y.rd_req := convert(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.rd_ack := convert(x(left to left+len(y.rd_ack)-1), y.rd_ack);
      left := left + len(y.rd_ack);
      y.flush_req := convert(x(left to left+len(y.flush_req)-1), y.flush_req);
      left := left + len(y.flush_req);
      y.freeze_req := convert(x(left to left+len(y.freeze_req)-1), y.freeze_req);
      left := left + len(y.freeze_req);
      y.mem_sel := convert(x(left to left+len(y.mem_sel)-1), y.mem_sel);
    else
      y.wr_req := convert(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.wr_ack := convert(x(left downto left-len(y.wr_ack)+1), y.wr_ack);
      left := left - len(y.wr_ack);
      y.rd_req := convert(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.rd_ack := convert(x(left downto left-len(y.rd_ack)+1), y.rd_ack);
      left := left - len(y.rd_ack);
      y.flush_req := convert(x(left downto left-len(y.flush_req)+1), y.flush_req);
      left := left - len(y.flush_req);
      y.freeze_req := convert(x(left downto left-len(y.freeze_req)+1), y.freeze_req);
      left := left - len(y.freeze_req);
      y.mem_sel := convert(x(left downto left-len(y.mem_sel)+1), y.mem_sel);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t is
  variable y: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
  begin
    y.wr_req := nullify(t.wr_req);
    y.wr_ack := nullify(t.wr_ack);
    y.rd_req := nullify(t.rd_req);
    y.rd_ack := nullify(t.rd_ack);
    y.flush_req := nullify(t.flush_req);
    y.freeze_req := nullify(t.freeze_req);
    y.mem_sel := nullify(t.mem_sel);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t is
  variable y: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
  begin
    y.wr_req := zeroed(t.wr_req);
    y.wr_ack := zeroed(t.wr_ack);
    y.rd_req := zeroed(t.rd_req);
    y.rd_ack := zeroed(t.rd_ack);
    y.flush_req := zeroed(t.flush_req);
    y.freeze_req := zeroed(t.freeze_req);
    y.mem_sel := zeroed(t.mem_sel);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_data_0);
    l := l + len(x.wr_data_1);
    return l;
  end function len;
  function width(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_data_0);
    l := l + width(x.wr_data_1);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_data_0)-1), vectorify(x.wr_data_0, y(left to left+len(x.wr_data_0)-1)));
      left := left + len(x.wr_data_0);
      assign(y(left to left+len(x.wr_data_1)-1), vectorify(x.wr_data_1, y(left to left+len(x.wr_data_1)-1)));
    else
      assign(y(left downto left-len(x.wr_data_0)+1), vectorify(x.wr_data_0, y(left downto left-len(x.wr_data_0)+1)));
      left := left - len(x.wr_data_0);
      assign(y(left downto left-len(x.wr_data_1)+1), vectorify(x.wr_data_1, y(left downto left-len(x.wr_data_1)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_data_0)-1), convert(x.wr_data_0, y(left to left+len(x.wr_data_0)-1)));
      left := left + len(x.wr_data_0);
      assign(y(left to left+len(x.wr_data_1)-1), convert(x.wr_data_1, y(left to left+len(x.wr_data_1)-1)));
    else
      assign(y(left downto left-len(x.wr_data_0)+1), convert(x.wr_data_0, y(left downto left-len(x.wr_data_0)+1)));
      left := left - len(x.wr_data_0);
      assign(y(left downto left-len(x.wr_data_1)+1), convert(x.wr_data_1, y(left downto left-len(x.wr_data_1)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t is
    variable y: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_data_0 := structify(x(left to left+len(y.wr_data_0)-1), y.wr_data_0);
      left := left + len(y.wr_data_0);
      y.wr_data_1 := structify(x(left to left+len(y.wr_data_1)-1), y.wr_data_1);
    else
      y.wr_data_0 := structify(x(left downto left-len(y.wr_data_0)+1), y.wr_data_0);
      left := left - len(y.wr_data_0);
      y.wr_data_1 := structify(x(left downto left-len(y.wr_data_1)+1), y.wr_data_1);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t is
    variable y: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_data_0 := convert(x(left to left+len(y.wr_data_0)-1), y.wr_data_0);
      left := left + len(y.wr_data_0);
      y.wr_data_1 := convert(x(left to left+len(y.wr_data_1)-1), y.wr_data_1);
    else
      y.wr_data_0 := convert(x(left downto left-len(y.wr_data_0)+1), y.wr_data_0);
      left := left - len(y.wr_data_0);
      y.wr_data_1 := convert(x(left downto left-len(y.wr_data_1)+1), y.wr_data_1);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t is
  variable y: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
  begin
    y.wr_data_0 := nullify(t.wr_data_0);
    y.wr_data_1 := nullify(t.wr_data_1);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t is
  variable y: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
  begin
    y.wr_data_0 := zeroed(t.wr_data_0);
    y.wr_data_1 := zeroed(t.wr_data_1);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_data_1);
    l := l + len(x.rd_data_0);
    return l;
  end function len;
  function width(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_data_1);
    l := l + width(x.rd_data_0);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_data_1)-1), vectorify(x.rd_data_1, y(left to left+len(x.rd_data_1)-1)));
      left := left + len(x.rd_data_1);
      assign(y(left to left+len(x.rd_data_0)-1), vectorify(x.rd_data_0, y(left to left+len(x.rd_data_0)-1)));
    else
      assign(y(left downto left-len(x.rd_data_1)+1), vectorify(x.rd_data_1, y(left downto left-len(x.rd_data_1)+1)));
      left := left - len(x.rd_data_1);
      assign(y(left downto left-len(x.rd_data_0)+1), vectorify(x.rd_data_0, y(left downto left-len(x.rd_data_0)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_data_1)-1), convert(x.rd_data_1, y(left to left+len(x.rd_data_1)-1)));
      left := left + len(x.rd_data_1);
      assign(y(left to left+len(x.rd_data_0)-1), convert(x.rd_data_0, y(left to left+len(x.rd_data_0)-1)));
    else
      assign(y(left downto left-len(x.rd_data_1)+1), convert(x.rd_data_1, y(left downto left-len(x.rd_data_1)+1)));
      left := left - len(x.rd_data_1);
      assign(y(left downto left-len(x.rd_data_0)+1), convert(x.rd_data_0, y(left downto left-len(x.rd_data_0)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t is
    variable y: HPS_MDT_TC_MDT_TC_rd_data_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_data_1 := structify(x(left to left+len(y.rd_data_1)-1), y.rd_data_1);
      left := left + len(y.rd_data_1);
      y.rd_data_0 := structify(x(left to left+len(y.rd_data_0)-1), y.rd_data_0);
    else
      y.rd_data_1 := structify(x(left downto left-len(y.rd_data_1)+1), y.rd_data_1);
      left := left - len(y.rd_data_1);
      y.rd_data_0 := structify(x(left downto left-len(y.rd_data_0)+1), y.rd_data_0);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t is
    variable y: HPS_MDT_TC_MDT_TC_rd_data_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_data_1 := convert(x(left to left+len(y.rd_data_1)-1), y.rd_data_1);
      left := left + len(y.rd_data_1);
      y.rd_data_0 := convert(x(left to left+len(y.rd_data_0)-1), y.rd_data_0);
    else
      y.rd_data_1 := convert(x(left downto left-len(y.rd_data_1)+1), y.rd_data_1);
      left := left - len(y.rd_data_1);
      y.rd_data_0 := convert(x(left downto left-len(y.rd_data_0)+1), y.rd_data_0);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t is
  variable y: HPS_MDT_TC_MDT_TC_rd_data_MON_t;
  begin
    y.rd_data_1 := nullify(t.rd_data_1);
    y.rd_data_0 := nullify(t.rd_data_0);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t is
  variable y: HPS_MDT_TC_MDT_TC_rd_data_MON_t;
  begin
    y.rd_data_1 := zeroed(t.rd_data_1);
    y.rd_data_0 := zeroed(t.rd_data_0);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_MDT_TC_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SIGNALS);
    l := l + len(x.rd_data);
    return l;
  end function len;
  function width(x: HPS_MDT_TC_MDT_TC_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SIGNALS);
    l := l + width(x.rd_data);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_MDT_TC_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), vectorify(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), vectorify(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_MDT_TC_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), convert(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.rd_data)-1), convert(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), convert(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.rd_data)+1), convert(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t is
    variable y: HPS_MDT_TC_MDT_TC_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := structify(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.SIGNALS := structify(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t is
    variable y: HPS_MDT_TC_MDT_TC_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := convert(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.rd_data := convert(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.SIGNALS := convert(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.rd_data := convert(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t is
  variable y: HPS_MDT_TC_MDT_TC_MON_t;
  begin
    y.SIGNALS := nullify(t.SIGNALS);
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t is
  variable y: HPS_MDT_TC_MDT_TC_MON_t;
  begin
    y.SIGNALS := zeroed(t.SIGNALS);
    y.rd_data := zeroed(t.rd_data);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY is
    variable y : HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY is
    variable y : HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY is
    variable y : HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY is
    variable y : HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_MDT_TC_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SIGNALS);
    l := l + len(x.wr_addr);
    l := l + len(x.rd_addr);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function width(x: HPS_MDT_TC_MDT_TC_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SIGNALS);
    l := l + width(x.wr_addr);
    l := l + width(x.rd_addr);
    l := l + width(x.wr_data);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_MDT_TC_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), vectorify(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.wr_addr)-1), vectorify(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), vectorify(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), vectorify(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.wr_addr)+1), vectorify(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), vectorify(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), convert(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.wr_addr)-1), convert(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), convert(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), convert(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), convert(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.wr_addr)+1), convert(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), convert(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), convert(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t is
    variable y: HPS_MDT_TC_MDT_TC_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := structify(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.wr_addr := structify(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := structify(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.SIGNALS := structify(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.wr_addr := structify(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := structify(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t is
    variable y: HPS_MDT_TC_MDT_TC_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := convert(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.wr_addr := convert(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := convert(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := convert(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.SIGNALS := convert(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.wr_addr := convert(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := convert(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := convert(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t is
  variable y: HPS_MDT_TC_MDT_TC_CTRL_t;
  begin
    y.SIGNALS := nullify(t.SIGNALS);
    y.wr_addr := nullify(t.wr_addr);
    y.rd_addr := nullify(t.rd_addr);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t is
  variable y: HPS_MDT_TC_MDT_TC_CTRL_t;
  begin
    y.SIGNALS := zeroed(t.SIGNALS);
    y.wr_addr := zeroed(t.wr_addr);
    y.rd_addr := zeroed(t.rd_addr);
    y.wr_data := zeroed(t.wr_data);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY is
    variable y : HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY is
    variable y : HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY is
    variable y : HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY is
    variable y : HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MDT_TC);
    return l;
  end function len;
  function width(x: HPS_MDT_TC_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.MDT_TC);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_TC)-1), vectorify(x.MDT_TC, y(left to left+len(x.MDT_TC)-1)));
    else
      assign(y(left downto left-len(x.MDT_TC)+1), vectorify(x.MDT_TC, y(left downto left-len(x.MDT_TC)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_TC)-1), convert(x.MDT_TC, y(left to left+len(x.MDT_TC)-1)));
    else
      assign(y(left downto left-len(x.MDT_TC)+1), convert(x.MDT_TC, y(left downto left-len(x.MDT_TC)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t is
    variable y: HPS_MDT_TC_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_TC := structify(x(left to left+len(y.MDT_TC)-1), y.MDT_TC);
    else
      y.MDT_TC := structify(x(left downto left-len(y.MDT_TC)+1), y.MDT_TC);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t is
    variable y: HPS_MDT_TC_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_TC := convert(x(left to left+len(y.MDT_TC)-1), y.MDT_TC);
    else
      y.MDT_TC := convert(x(left downto left-len(y.MDT_TC)+1), y.MDT_TC);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t is
  variable y: HPS_MDT_TC_MON_t;
  begin
    y.MDT_TC := nullify(t.MDT_TC);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t is
  variable y: HPS_MDT_TC_MON_t;
  begin
    y.MDT_TC := zeroed(t.MDT_TC);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_TC_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MDT_TC);
    return l;
  end function len;
  function width(x: HPS_MDT_TC_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.MDT_TC);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_TC_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_TC)-1), vectorify(x.MDT_TC, y(left to left+len(x.MDT_TC)-1)));
    else
      assign(y(left downto left-len(x.MDT_TC)+1), vectorify(x.MDT_TC, y(left downto left-len(x.MDT_TC)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_TC_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_TC)-1), convert(x.MDT_TC, y(left to left+len(x.MDT_TC)-1)));
    else
      assign(y(left downto left-len(x.MDT_TC)+1), convert(x.MDT_TC, y(left downto left-len(x.MDT_TC)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t is
    variable y: HPS_MDT_TC_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_TC := structify(x(left to left+len(y.MDT_TC)-1), y.MDT_TC);
    else
      y.MDT_TC := structify(x(left downto left-len(y.MDT_TC)+1), y.MDT_TC);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t is
    variable y: HPS_MDT_TC_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_TC := convert(x(left to left+len(y.MDT_TC)-1), y.MDT_TC);
    else
      y.MDT_TC := convert(x(left downto left-len(y.MDT_TC)+1), y.MDT_TC);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t is
  variable y: HPS_MDT_TC_CTRL_t;
  begin
    y.MDT_TC := nullify(t.MDT_TC);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t is
  variable y: HPS_MDT_TC_CTRL_t;
  begin
    y.MDT_TC := zeroed(t.MDT_TC);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_rdy);
    l := l + len(x.freeze_ena);
    return l;
  end function len;
  function width(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_rdy);
    l := l + width(x.freeze_ena);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), vectorify(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.freeze_ena)-1), vectorify(x.freeze_ena, y(left to left+len(x.freeze_ena)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), vectorify(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.freeze_ena)+1), vectorify(x.freeze_ena, y(left downto left-len(x.freeze_ena)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), convert(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.freeze_ena)-1), convert(x.freeze_ena, y(left to left+len(x.freeze_ena)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), convert(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.freeze_ena)+1), convert(x.freeze_ena, y(left downto left-len(x.freeze_ena)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t is
    variable y: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := structify(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.freeze_ena := structify(x(left to left+len(y.freeze_ena)-1), y.freeze_ena);
    else
      y.rd_rdy := structify(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.freeze_ena := structify(x(left downto left-len(y.freeze_ena)+1), y.freeze_ena);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t is
    variable y: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := convert(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.freeze_ena := convert(x(left to left+len(y.freeze_ena)-1), y.freeze_ena);
    else
      y.rd_rdy := convert(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.freeze_ena := convert(x(left downto left-len(y.freeze_ena)+1), y.freeze_ena);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t is
  variable y: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
  begin
    y.rd_rdy := nullify(t.rd_rdy);
    y.freeze_ena := nullify(t.freeze_ena);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t is
  variable y: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
  begin
    y.rd_rdy := zeroed(t.rd_rdy);
    y.freeze_ena := zeroed(t.freeze_ena);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_req);
    l := l + len(x.wr_ack);
    l := l + len(x.rd_req);
    l := l + len(x.rd_ack);
    l := l + len(x.flush_req);
    l := l + len(x.freeze_req);
    l := l + len(x.mem_sel);
    return l;
  end function len;
  function width(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_req);
    l := l + width(x.wr_ack);
    l := l + width(x.rd_req);
    l := l + width(x.rd_ack);
    l := l + width(x.flush_req);
    l := l + width(x.freeze_req);
    l := l + width(x.mem_sel);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), vectorify(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.wr_ack)-1), vectorify(x.wr_ack, y(left to left+len(x.wr_ack)-1)));
      left := left + len(x.wr_ack);
      assign(y(left to left+len(x.rd_req)-1), vectorify(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.rd_ack)-1), vectorify(x.rd_ack, y(left to left+len(x.rd_ack)-1)));
      left := left + len(x.rd_ack);
      assign(y(left to left+len(x.flush_req)-1), vectorify(x.flush_req, y(left to left+len(x.flush_req)-1)));
      left := left + len(x.flush_req);
      assign(y(left to left+len(x.freeze_req)-1), vectorify(x.freeze_req, y(left to left+len(x.freeze_req)-1)));
      left := left + len(x.freeze_req);
      assign(y(left to left+len(x.mem_sel)-1), vectorify(x.mem_sel, y(left to left+len(x.mem_sel)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), vectorify(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.wr_ack)+1), vectorify(x.wr_ack, y(left downto left-len(x.wr_ack)+1)));
      left := left - len(x.wr_ack);
      assign(y(left downto left-len(x.rd_req)+1), vectorify(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.rd_ack)+1), vectorify(x.rd_ack, y(left downto left-len(x.rd_ack)+1)));
      left := left - len(x.rd_ack);
      assign(y(left downto left-len(x.flush_req)+1), vectorify(x.flush_req, y(left downto left-len(x.flush_req)+1)));
      left := left - len(x.flush_req);
      assign(y(left downto left-len(x.freeze_req)+1), vectorify(x.freeze_req, y(left downto left-len(x.freeze_req)+1)));
      left := left - len(x.freeze_req);
      assign(y(left downto left-len(x.mem_sel)+1), vectorify(x.mem_sel, y(left downto left-len(x.mem_sel)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), convert(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.wr_ack)-1), convert(x.wr_ack, y(left to left+len(x.wr_ack)-1)));
      left := left + len(x.wr_ack);
      assign(y(left to left+len(x.rd_req)-1), convert(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.rd_ack)-1), convert(x.rd_ack, y(left to left+len(x.rd_ack)-1)));
      left := left + len(x.rd_ack);
      assign(y(left to left+len(x.flush_req)-1), convert(x.flush_req, y(left to left+len(x.flush_req)-1)));
      left := left + len(x.flush_req);
      assign(y(left to left+len(x.freeze_req)-1), convert(x.freeze_req, y(left to left+len(x.freeze_req)-1)));
      left := left + len(x.freeze_req);
      assign(y(left to left+len(x.mem_sel)-1), convert(x.mem_sel, y(left to left+len(x.mem_sel)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), convert(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.wr_ack)+1), convert(x.wr_ack, y(left downto left-len(x.wr_ack)+1)));
      left := left - len(x.wr_ack);
      assign(y(left downto left-len(x.rd_req)+1), convert(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.rd_ack)+1), convert(x.rd_ack, y(left downto left-len(x.rd_ack)+1)));
      left := left - len(x.rd_ack);
      assign(y(left downto left-len(x.flush_req)+1), convert(x.flush_req, y(left downto left-len(x.flush_req)+1)));
      left := left - len(x.flush_req);
      assign(y(left downto left-len(x.freeze_req)+1), convert(x.freeze_req, y(left downto left-len(x.freeze_req)+1)));
      left := left - len(x.freeze_req);
      assign(y(left downto left-len(x.mem_sel)+1), convert(x.mem_sel, y(left downto left-len(x.mem_sel)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t is
    variable y: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := structify(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.wr_ack := structify(x(left to left+len(y.wr_ack)-1), y.wr_ack);
      left := left + len(y.wr_ack);
      y.rd_req := structify(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.rd_ack := structify(x(left to left+len(y.rd_ack)-1), y.rd_ack);
      left := left + len(y.rd_ack);
      y.flush_req := structify(x(left to left+len(y.flush_req)-1), y.flush_req);
      left := left + len(y.flush_req);
      y.freeze_req := structify(x(left to left+len(y.freeze_req)-1), y.freeze_req);
      left := left + len(y.freeze_req);
      y.mem_sel := structify(x(left to left+len(y.mem_sel)-1), y.mem_sel);
    else
      y.wr_req := structify(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.wr_ack := structify(x(left downto left-len(y.wr_ack)+1), y.wr_ack);
      left := left - len(y.wr_ack);
      y.rd_req := structify(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.rd_ack := structify(x(left downto left-len(y.rd_ack)+1), y.rd_ack);
      left := left - len(y.rd_ack);
      y.flush_req := structify(x(left downto left-len(y.flush_req)+1), y.flush_req);
      left := left - len(y.flush_req);
      y.freeze_req := structify(x(left downto left-len(y.freeze_req)+1), y.freeze_req);
      left := left - len(y.freeze_req);
      y.mem_sel := structify(x(left downto left-len(y.mem_sel)+1), y.mem_sel);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t is
    variable y: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := convert(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.wr_ack := convert(x(left to left+len(y.wr_ack)-1), y.wr_ack);
      left := left + len(y.wr_ack);
      y.rd_req := convert(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.rd_ack := convert(x(left to left+len(y.rd_ack)-1), y.rd_ack);
      left := left + len(y.rd_ack);
      y.flush_req := convert(x(left to left+len(y.flush_req)-1), y.flush_req);
      left := left + len(y.flush_req);
      y.freeze_req := convert(x(left to left+len(y.freeze_req)-1), y.freeze_req);
      left := left + len(y.freeze_req);
      y.mem_sel := convert(x(left to left+len(y.mem_sel)-1), y.mem_sel);
    else
      y.wr_req := convert(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.wr_ack := convert(x(left downto left-len(y.wr_ack)+1), y.wr_ack);
      left := left - len(y.wr_ack);
      y.rd_req := convert(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.rd_ack := convert(x(left downto left-len(y.rd_ack)+1), y.rd_ack);
      left := left - len(y.rd_ack);
      y.flush_req := convert(x(left downto left-len(y.flush_req)+1), y.flush_req);
      left := left - len(y.flush_req);
      y.freeze_req := convert(x(left downto left-len(y.freeze_req)+1), y.freeze_req);
      left := left - len(y.freeze_req);
      y.mem_sel := convert(x(left downto left-len(y.mem_sel)+1), y.mem_sel);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t is
  variable y: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
  begin
    y.wr_req := nullify(t.wr_req);
    y.wr_ack := nullify(t.wr_ack);
    y.rd_req := nullify(t.rd_req);
    y.rd_ack := nullify(t.rd_ack);
    y.flush_req := nullify(t.flush_req);
    y.freeze_req := nullify(t.freeze_req);
    y.mem_sel := nullify(t.mem_sel);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t is
  variable y: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
  begin
    y.wr_req := zeroed(t.wr_req);
    y.wr_ack := zeroed(t.wr_ack);
    y.rd_req := zeroed(t.rd_req);
    y.rd_ack := zeroed(t.rd_ack);
    y.flush_req := zeroed(t.flush_req);
    y.freeze_req := zeroed(t.freeze_req);
    y.mem_sel := zeroed(t.mem_sel);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_data_0);
    return l;
  end function len;
  function width(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_data_0);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_data_0)-1), vectorify(x.wr_data_0, y(left to left+len(x.wr_data_0)-1)));
    else
      assign(y(left downto left-len(x.wr_data_0)+1), vectorify(x.wr_data_0, y(left downto left-len(x.wr_data_0)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_data_0)-1), convert(x.wr_data_0, y(left to left+len(x.wr_data_0)-1)));
    else
      assign(y(left downto left-len(x.wr_data_0)+1), convert(x.wr_data_0, y(left downto left-len(x.wr_data_0)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t is
    variable y: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_data_0 := structify(x(left to left+len(y.wr_data_0)-1), y.wr_data_0);
    else
      y.wr_data_0 := structify(x(left downto left-len(y.wr_data_0)+1), y.wr_data_0);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t is
    variable y: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_data_0 := convert(x(left to left+len(y.wr_data_0)-1), y.wr_data_0);
    else
      y.wr_data_0 := convert(x(left downto left-len(y.wr_data_0)+1), y.wr_data_0);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t is
  variable y: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
  begin
    y.wr_data_0 := nullify(t.wr_data_0);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t is
  variable y: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
  begin
    y.wr_data_0 := zeroed(t.wr_data_0);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_data_0);
    return l;
  end function len;
  function width(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_data_0);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_data_0)-1), vectorify(x.rd_data_0, y(left to left+len(x.rd_data_0)-1)));
    else
      assign(y(left downto left-len(x.rd_data_0)+1), vectorify(x.rd_data_0, y(left downto left-len(x.rd_data_0)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_data_0)-1), convert(x.rd_data_0, y(left to left+len(x.rd_data_0)-1)));
    else
      assign(y(left downto left-len(x.rd_data_0)+1), convert(x.rd_data_0, y(left downto left-len(x.rd_data_0)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t is
    variable y: HPS_MDT_T0_MDT_T0_rd_data_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_data_0 := structify(x(left to left+len(y.rd_data_0)-1), y.rd_data_0);
    else
      y.rd_data_0 := structify(x(left downto left-len(y.rd_data_0)+1), y.rd_data_0);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t is
    variable y: HPS_MDT_T0_MDT_T0_rd_data_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_data_0 := convert(x(left to left+len(y.rd_data_0)-1), y.rd_data_0);
    else
      y.rd_data_0 := convert(x(left downto left-len(y.rd_data_0)+1), y.rd_data_0);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t is
  variable y: HPS_MDT_T0_MDT_T0_rd_data_MON_t;
  begin
    y.rd_data_0 := nullify(t.rd_data_0);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t is
  variable y: HPS_MDT_T0_MDT_T0_rd_data_MON_t;
  begin
    y.rd_data_0 := zeroed(t.rd_data_0);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_MDT_T0_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SIGNALS);
    l := l + len(x.rd_data);
    return l;
  end function len;
  function width(x: HPS_MDT_T0_MDT_T0_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SIGNALS);
    l := l + width(x.rd_data);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_MDT_T0_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), vectorify(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), vectorify(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_MDT_T0_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), convert(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.rd_data)-1), convert(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), convert(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.rd_data)+1), convert(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t is
    variable y: HPS_MDT_T0_MDT_T0_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := structify(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.SIGNALS := structify(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t is
    variable y: HPS_MDT_T0_MDT_T0_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := convert(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.rd_data := convert(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.SIGNALS := convert(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.rd_data := convert(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t is
  variable y: HPS_MDT_T0_MDT_T0_MON_t;
  begin
    y.SIGNALS := nullify(t.SIGNALS);
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t is
  variable y: HPS_MDT_T0_MDT_T0_MON_t;
  begin
    y.SIGNALS := zeroed(t.SIGNALS);
    y.rd_data := zeroed(t.rd_data);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY is
    variable y : HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY is
    variable y : HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY is
    variable y : HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY is
    variable y : HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_MDT_T0_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SIGNALS);
    l := l + len(x.wr_addr);
    l := l + len(x.rd_addr);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function width(x: HPS_MDT_T0_MDT_T0_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SIGNALS);
    l := l + width(x.wr_addr);
    l := l + width(x.rd_addr);
    l := l + width(x.wr_data);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_MDT_T0_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), vectorify(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.wr_addr)-1), vectorify(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), vectorify(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), vectorify(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.wr_addr)+1), vectorify(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), vectorify(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), convert(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.wr_addr)-1), convert(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), convert(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), convert(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), convert(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.wr_addr)+1), convert(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), convert(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), convert(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t is
    variable y: HPS_MDT_T0_MDT_T0_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := structify(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.wr_addr := structify(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := structify(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.SIGNALS := structify(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.wr_addr := structify(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := structify(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t is
    variable y: HPS_MDT_T0_MDT_T0_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := convert(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.wr_addr := convert(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := convert(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := convert(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.SIGNALS := convert(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.wr_addr := convert(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := convert(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := convert(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t is
  variable y: HPS_MDT_T0_MDT_T0_CTRL_t;
  begin
    y.SIGNALS := nullify(t.SIGNALS);
    y.wr_addr := nullify(t.wr_addr);
    y.rd_addr := nullify(t.rd_addr);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t is
  variable y: HPS_MDT_T0_MDT_T0_CTRL_t;
  begin
    y.SIGNALS := zeroed(t.SIGNALS);
    y.wr_addr := zeroed(t.wr_addr);
    y.rd_addr := zeroed(t.rd_addr);
    y.wr_data := zeroed(t.wr_data);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY is
    variable y : HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY is
    variable y : HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY is
    variable y : HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY is
    variable y : HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MDT_T0);
    return l;
  end function len;
  function width(x: HPS_MDT_T0_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.MDT_T0);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_T0)-1), vectorify(x.MDT_T0, y(left to left+len(x.MDT_T0)-1)));
    else
      assign(y(left downto left-len(x.MDT_T0)+1), vectorify(x.MDT_T0, y(left downto left-len(x.MDT_T0)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_T0)-1), convert(x.MDT_T0, y(left to left+len(x.MDT_T0)-1)));
    else
      assign(y(left downto left-len(x.MDT_T0)+1), convert(x.MDT_T0, y(left downto left-len(x.MDT_T0)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t is
    variable y: HPS_MDT_T0_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_T0 := structify(x(left to left+len(y.MDT_T0)-1), y.MDT_T0);
    else
      y.MDT_T0 := structify(x(left downto left-len(y.MDT_T0)+1), y.MDT_T0);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t is
    variable y: HPS_MDT_T0_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_T0 := convert(x(left to left+len(y.MDT_T0)-1), y.MDT_T0);
    else
      y.MDT_T0 := convert(x(left downto left-len(y.MDT_T0)+1), y.MDT_T0);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t is
  variable y: HPS_MDT_T0_MON_t;
  begin
    y.MDT_T0 := nullify(t.MDT_T0);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t is
  variable y: HPS_MDT_T0_MON_t;
  begin
    y.MDT_T0 := zeroed(t.MDT_T0);
    return y;
  end function zeroed;

  function len(x: HPS_MDT_T0_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MDT_T0);
    return l;
  end function len;
  function width(x: HPS_MDT_T0_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.MDT_T0);
    return l;
  end function width;
  function vectorify(x: HPS_MDT_T0_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_T0)-1), vectorify(x.MDT_T0, y(left to left+len(x.MDT_T0)-1)));
    else
      assign(y(left downto left-len(x.MDT_T0)+1), vectorify(x.MDT_T0, y(left downto left-len(x.MDT_T0)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MDT_T0_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_T0)-1), convert(x.MDT_T0, y(left to left+len(x.MDT_T0)-1)));
    else
      assign(y(left downto left-len(x.MDT_T0)+1), convert(x.MDT_T0, y(left downto left-len(x.MDT_T0)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t is
    variable y: HPS_MDT_T0_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_T0 := structify(x(left to left+len(y.MDT_T0)-1), y.MDT_T0);
    else
      y.MDT_T0 := structify(x(left downto left-len(y.MDT_T0)+1), y.MDT_T0);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t is
    variable y: HPS_MDT_T0_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_T0 := convert(x(left to left+len(y.MDT_T0)-1), y.MDT_T0);
    else
      y.MDT_T0 := convert(x(left downto left-len(y.MDT_T0)+1), y.MDT_T0);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t is
  variable y: HPS_MDT_T0_CTRL_t;
  begin
    y.MDT_T0 := nullify(t.MDT_T0);
    return y;
  end function nullify;
  function zeroed(t: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t is
  variable y: HPS_MDT_T0_CTRL_t;
  begin
    y.MDT_T0 := zeroed(t.MDT_T0);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.RESET);
    l := l + len(x.ENABLE);
    l := l + len(x.DISABLE);
    l := l + len(x.FREEZE);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.RESET);
    l := l + width(x.ENABLE);
    l := l + width(x.DISABLE);
    l := l + width(x.FREEZE);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), vectorify(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.ENABLE)-1), vectorify(x.ENABLE, y(left to left+len(x.ENABLE)-1)));
      left := left + len(x.ENABLE);
      assign(y(left to left+len(x.DISABLE)-1), vectorify(x.DISABLE, y(left to left+len(x.DISABLE)-1)));
      left := left + len(x.DISABLE);
      assign(y(left to left+len(x.FREEZE)-1), vectorify(x.FREEZE, y(left to left+len(x.FREEZE)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), vectorify(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.ENABLE)+1), vectorify(x.ENABLE, y(left downto left-len(x.ENABLE)+1)));
      left := left - len(x.ENABLE);
      assign(y(left downto left-len(x.DISABLE)+1), vectorify(x.DISABLE, y(left downto left-len(x.DISABLE)+1)));
      left := left - len(x.DISABLE);
      assign(y(left downto left-len(x.FREEZE)+1), vectorify(x.FREEZE, y(left downto left-len(x.FREEZE)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), convert(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.ENABLE)-1), convert(x.ENABLE, y(left to left+len(x.ENABLE)-1)));
      left := left + len(x.ENABLE);
      assign(y(left to left+len(x.DISABLE)-1), convert(x.DISABLE, y(left to left+len(x.DISABLE)-1)));
      left := left + len(x.DISABLE);
      assign(y(left to left+len(x.FREEZE)-1), convert(x.FREEZE, y(left to left+len(x.FREEZE)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), convert(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.ENABLE)+1), convert(x.ENABLE, y(left downto left-len(x.ENABLE)+1)));
      left := left - len(x.ENABLE);
      assign(y(left downto left-len(x.DISABLE)+1), convert(x.DISABLE, y(left downto left-len(x.DISABLE)+1)));
      left := left - len(x.DISABLE);
      assign(y(left downto left-len(x.FREEZE)+1), convert(x.FREEZE, y(left downto left-len(x.FREEZE)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t is
    variable y: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := structify(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.ENABLE := structify(x(left to left+len(y.ENABLE)-1), y.ENABLE);
      left := left + len(y.ENABLE);
      y.DISABLE := structify(x(left to left+len(y.DISABLE)-1), y.DISABLE);
      left := left + len(y.DISABLE);
      y.FREEZE := structify(x(left to left+len(y.FREEZE)-1), y.FREEZE);
    else
      y.RESET := structify(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.ENABLE := structify(x(left downto left-len(y.ENABLE)+1), y.ENABLE);
      left := left - len(y.ENABLE);
      y.DISABLE := structify(x(left downto left-len(y.DISABLE)+1), y.DISABLE);
      left := left - len(y.DISABLE);
      y.FREEZE := structify(x(left downto left-len(y.FREEZE)+1), y.FREEZE);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t is
    variable y: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := convert(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.ENABLE := convert(x(left to left+len(y.ENABLE)-1), y.ENABLE);
      left := left + len(y.ENABLE);
      y.DISABLE := convert(x(left to left+len(y.DISABLE)-1), y.DISABLE);
      left := left + len(y.DISABLE);
      y.FREEZE := convert(x(left to left+len(y.FREEZE)-1), y.FREEZE);
    else
      y.RESET := convert(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.ENABLE := convert(x(left downto left-len(y.ENABLE)+1), y.ENABLE);
      left := left - len(y.ENABLE);
      y.DISABLE := convert(x(left downto left-len(y.DISABLE)+1), y.DISABLE);
      left := left - len(y.DISABLE);
      y.FREEZE := convert(x(left downto left-len(y.FREEZE)+1), y.FREEZE);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t is
  variable y: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
  begin
    y.RESET := nullify(t.RESET);
    y.ENABLE := nullify(t.ENABLE);
    y.DISABLE := nullify(t.DISABLE);
    y.FREEZE := nullify(t.FREEZE);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t is
  variable y: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
  begin
    y.RESET := zeroed(t.RESET);
    y.ENABLE := zeroed(t.ENABLE);
    y.DISABLE := zeroed(t.DISABLE);
    y.FREEZE := zeroed(t.FREEZE);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.INPUT_EN);
    l := l + len(x.OUTPUT_EN);
    l := l + len(x.FLUSH_MEM_RESET);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.INPUT_EN);
    l := l + width(x.OUTPUT_EN);
    l := l + width(x.FLUSH_MEM_RESET);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.INPUT_EN)-1), vectorify(x.INPUT_EN, y(left to left+len(x.INPUT_EN)-1)));
      left := left + len(x.INPUT_EN);
      assign(y(left to left+len(x.OUTPUT_EN)-1), vectorify(x.OUTPUT_EN, y(left to left+len(x.OUTPUT_EN)-1)));
      left := left + len(x.OUTPUT_EN);
      assign(y(left to left+len(x.FLUSH_MEM_RESET)-1), vectorify(x.FLUSH_MEM_RESET, y(left to left+len(x.FLUSH_MEM_RESET)-1)));
    else
      assign(y(left downto left-len(x.INPUT_EN)+1), vectorify(x.INPUT_EN, y(left downto left-len(x.INPUT_EN)+1)));
      left := left - len(x.INPUT_EN);
      assign(y(left downto left-len(x.OUTPUT_EN)+1), vectorify(x.OUTPUT_EN, y(left downto left-len(x.OUTPUT_EN)+1)));
      left := left - len(x.OUTPUT_EN);
      assign(y(left downto left-len(x.FLUSH_MEM_RESET)+1), vectorify(x.FLUSH_MEM_RESET, y(left downto left-len(x.FLUSH_MEM_RESET)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.INPUT_EN)-1), convert(x.INPUT_EN, y(left to left+len(x.INPUT_EN)-1)));
      left := left + len(x.INPUT_EN);
      assign(y(left to left+len(x.OUTPUT_EN)-1), convert(x.OUTPUT_EN, y(left to left+len(x.OUTPUT_EN)-1)));
      left := left + len(x.OUTPUT_EN);
      assign(y(left to left+len(x.FLUSH_MEM_RESET)-1), convert(x.FLUSH_MEM_RESET, y(left to left+len(x.FLUSH_MEM_RESET)-1)));
    else
      assign(y(left downto left-len(x.INPUT_EN)+1), convert(x.INPUT_EN, y(left downto left-len(x.INPUT_EN)+1)));
      left := left - len(x.INPUT_EN);
      assign(y(left downto left-len(x.OUTPUT_EN)+1), convert(x.OUTPUT_EN, y(left downto left-len(x.OUTPUT_EN)+1)));
      left := left - len(x.OUTPUT_EN);
      assign(y(left downto left-len(x.FLUSH_MEM_RESET)+1), convert(x.FLUSH_MEM_RESET, y(left downto left-len(x.FLUSH_MEM_RESET)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t is
    variable y: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.INPUT_EN := structify(x(left to left+len(y.INPUT_EN)-1), y.INPUT_EN);
      left := left + len(y.INPUT_EN);
      y.OUTPUT_EN := structify(x(left to left+len(y.OUTPUT_EN)-1), y.OUTPUT_EN);
      left := left + len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := structify(x(left to left+len(y.FLUSH_MEM_RESET)-1), y.FLUSH_MEM_RESET);
    else
      y.INPUT_EN := structify(x(left downto left-len(y.INPUT_EN)+1), y.INPUT_EN);
      left := left - len(y.INPUT_EN);
      y.OUTPUT_EN := structify(x(left downto left-len(y.OUTPUT_EN)+1), y.OUTPUT_EN);
      left := left - len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := structify(x(left downto left-len(y.FLUSH_MEM_RESET)+1), y.FLUSH_MEM_RESET);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t is
    variable y: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.INPUT_EN := convert(x(left to left+len(y.INPUT_EN)-1), y.INPUT_EN);
      left := left + len(y.INPUT_EN);
      y.OUTPUT_EN := convert(x(left to left+len(y.OUTPUT_EN)-1), y.OUTPUT_EN);
      left := left + len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := convert(x(left to left+len(y.FLUSH_MEM_RESET)-1), y.FLUSH_MEM_RESET);
    else
      y.INPUT_EN := convert(x(left downto left-len(y.INPUT_EN)+1), y.INPUT_EN);
      left := left - len(y.INPUT_EN);
      y.OUTPUT_EN := convert(x(left downto left-len(y.OUTPUT_EN)+1), y.OUTPUT_EN);
      left := left - len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := convert(x(left downto left-len(y.FLUSH_MEM_RESET)+1), y.FLUSH_MEM_RESET);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t is
  variable y: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
  begin
    y.INPUT_EN := nullify(t.INPUT_EN);
    y.OUTPUT_EN := nullify(t.OUTPUT_EN);
    y.FLUSH_MEM_RESET := nullify(t.FLUSH_MEM_RESET);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t is
  variable y: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
  begin
    y.INPUT_EN := zeroed(t.INPUT_EN);
    y.OUTPUT_EN := zeroed(t.OUTPUT_EN);
    y.FLUSH_MEM_RESET := zeroed(t.FLUSH_MEM_RESET);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_SUPER_STATUS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ENABLED);
    l := l + len(x.READY);
    l := l + len(x.ERROR);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_SUPER_STATUS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ENABLED);
    l := l + width(x.READY);
    l := l + width(x.ERROR);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ENABLED)-1), vectorify(x.ENABLED, y(left to left+len(x.ENABLED)-1)));
      left := left + len(x.ENABLED);
      assign(y(left to left+len(x.READY)-1), vectorify(x.READY, y(left to left+len(x.READY)-1)));
      left := left + len(x.READY);
      assign(y(left to left+len(x.ERROR)-1), vectorify(x.ERROR, y(left to left+len(x.ERROR)-1)));
    else
      assign(y(left downto left-len(x.ENABLED)+1), vectorify(x.ENABLED, y(left downto left-len(x.ENABLED)+1)));
      left := left - len(x.ENABLED);
      assign(y(left downto left-len(x.READY)+1), vectorify(x.READY, y(left downto left-len(x.READY)+1)));
      left := left - len(x.READY);
      assign(y(left downto left-len(x.ERROR)+1), vectorify(x.ERROR, y(left downto left-len(x.ERROR)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_SUPER_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ENABLED)-1), convert(x.ENABLED, y(left to left+len(x.ENABLED)-1)));
      left := left + len(x.ENABLED);
      assign(y(left to left+len(x.READY)-1), convert(x.READY, y(left to left+len(x.READY)-1)));
      left := left + len(x.READY);
      assign(y(left to left+len(x.ERROR)-1), convert(x.ERROR, y(left to left+len(x.ERROR)-1)));
    else
      assign(y(left downto left-len(x.ENABLED)+1), convert(x.ENABLED, y(left downto left-len(x.ENABLED)+1)));
      left := left - len(x.ENABLED);
      assign(y(left downto left-len(x.READY)+1), convert(x.READY, y(left downto left-len(x.READY)+1)));
      left := left - len(x.READY);
      assign(y(left downto left-len(x.ERROR)+1), convert(x.ERROR, y(left downto left-len(x.ERROR)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t is
    variable y: HPS_HEG_HEG_SUPER_STATUS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ENABLED := structify(x(left to left+len(y.ENABLED)-1), y.ENABLED);
      left := left + len(y.ENABLED);
      y.READY := structify(x(left to left+len(y.READY)-1), y.READY);
      left := left + len(y.READY);
      y.ERROR := structify(x(left to left+len(y.ERROR)-1), y.ERROR);
    else
      y.ENABLED := structify(x(left downto left-len(y.ENABLED)+1), y.ENABLED);
      left := left - len(y.ENABLED);
      y.READY := structify(x(left downto left-len(y.READY)+1), y.READY);
      left := left - len(y.READY);
      y.ERROR := structify(x(left downto left-len(y.ERROR)+1), y.ERROR);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t is
    variable y: HPS_HEG_HEG_SUPER_STATUS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ENABLED := convert(x(left to left+len(y.ENABLED)-1), y.ENABLED);
      left := left + len(y.ENABLED);
      y.READY := convert(x(left to left+len(y.READY)-1), y.READY);
      left := left + len(y.READY);
      y.ERROR := convert(x(left to left+len(y.ERROR)-1), y.ERROR);
    else
      y.ENABLED := convert(x(left downto left-len(y.ENABLED)+1), y.ENABLED);
      left := left - len(y.ENABLED);
      y.READY := convert(x(left downto left-len(y.READY)+1), y.READY);
      left := left - len(y.READY);
      y.ERROR := convert(x(left downto left-len(y.ERROR)+1), y.ERROR);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t is
  variable y: HPS_HEG_HEG_SUPER_STATUS_MON_t;
  begin
    y.ENABLED := nullify(t.ENABLED);
    y.READY := nullify(t.READY);
    y.ERROR := nullify(t.ERROR);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t is
  variable y: HPS_HEG_HEG_SUPER_STATUS_MON_t;
  begin
    y.ENABLED := zeroed(t.ENABLED);
    y.READY := zeroed(t.READY);
    y.ERROR := zeroed(t.ERROR);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SLC_PROC);
    l := l + len(x.HIT_PROC);
    l := l + len(x.HIT_OK);
    l := l + len(x.ERROR);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SLC_PROC);
    l := l + width(x.HIT_PROC);
    l := l + width(x.HIT_OK);
    l := l + width(x.ERROR);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SLC_PROC)-1), vectorify(x.SLC_PROC, y(left to left+len(x.SLC_PROC)-1)));
      left := left + len(x.SLC_PROC);
      assign(y(left to left+len(x.HIT_PROC)-1), vectorify(x.HIT_PROC, y(left to left+len(x.HIT_PROC)-1)));
      left := left + len(x.HIT_PROC);
      assign(y(left to left+len(x.HIT_OK)-1), vectorify(x.HIT_OK, y(left to left+len(x.HIT_OK)-1)));
      left := left + len(x.HIT_OK);
      assign(y(left to left+len(x.ERROR)-1), vectorify(x.ERROR, y(left to left+len(x.ERROR)-1)));
    else
      assign(y(left downto left-len(x.SLC_PROC)+1), vectorify(x.SLC_PROC, y(left downto left-len(x.SLC_PROC)+1)));
      left := left - len(x.SLC_PROC);
      assign(y(left downto left-len(x.HIT_PROC)+1), vectorify(x.HIT_PROC, y(left downto left-len(x.HIT_PROC)+1)));
      left := left - len(x.HIT_PROC);
      assign(y(left downto left-len(x.HIT_OK)+1), vectorify(x.HIT_OK, y(left downto left-len(x.HIT_OK)+1)));
      left := left - len(x.HIT_OK);
      assign(y(left downto left-len(x.ERROR)+1), vectorify(x.ERROR, y(left downto left-len(x.ERROR)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SLC_PROC)-1), convert(x.SLC_PROC, y(left to left+len(x.SLC_PROC)-1)));
      left := left + len(x.SLC_PROC);
      assign(y(left to left+len(x.HIT_PROC)-1), convert(x.HIT_PROC, y(left to left+len(x.HIT_PROC)-1)));
      left := left + len(x.HIT_PROC);
      assign(y(left to left+len(x.HIT_OK)-1), convert(x.HIT_OK, y(left to left+len(x.HIT_OK)-1)));
      left := left + len(x.HIT_OK);
      assign(y(left to left+len(x.ERROR)-1), convert(x.ERROR, y(left to left+len(x.ERROR)-1)));
    else
      assign(y(left downto left-len(x.SLC_PROC)+1), convert(x.SLC_PROC, y(left downto left-len(x.SLC_PROC)+1)));
      left := left - len(x.SLC_PROC);
      assign(y(left downto left-len(x.HIT_PROC)+1), convert(x.HIT_PROC, y(left downto left-len(x.HIT_PROC)+1)));
      left := left - len(x.HIT_PROC);
      assign(y(left downto left-len(x.HIT_OK)+1), convert(x.HIT_OK, y(left downto left-len(x.HIT_OK)+1)));
      left := left - len(x.HIT_OK);
      assign(y(left downto left-len(x.ERROR)+1), convert(x.ERROR, y(left downto left-len(x.ERROR)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t is
    variable y: HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SLC_PROC := structify(x(left to left+len(y.SLC_PROC)-1), y.SLC_PROC);
      left := left + len(y.SLC_PROC);
      y.HIT_PROC := structify(x(left to left+len(y.HIT_PROC)-1), y.HIT_PROC);
      left := left + len(y.HIT_PROC);
      y.HIT_OK := structify(x(left to left+len(y.HIT_OK)-1), y.HIT_OK);
      left := left + len(y.HIT_OK);
      y.ERROR := structify(x(left to left+len(y.ERROR)-1), y.ERROR);
    else
      y.SLC_PROC := structify(x(left downto left-len(y.SLC_PROC)+1), y.SLC_PROC);
      left := left - len(y.SLC_PROC);
      y.HIT_PROC := structify(x(left downto left-len(y.HIT_PROC)+1), y.HIT_PROC);
      left := left - len(y.HIT_PROC);
      y.HIT_OK := structify(x(left downto left-len(y.HIT_OK)+1), y.HIT_OK);
      left := left - len(y.HIT_OK);
      y.ERROR := structify(x(left downto left-len(y.ERROR)+1), y.ERROR);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t is
    variable y: HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SLC_PROC := convert(x(left to left+len(y.SLC_PROC)-1), y.SLC_PROC);
      left := left + len(y.SLC_PROC);
      y.HIT_PROC := convert(x(left to left+len(y.HIT_PROC)-1), y.HIT_PROC);
      left := left + len(y.HIT_PROC);
      y.HIT_OK := convert(x(left to left+len(y.HIT_OK)-1), y.HIT_OK);
      left := left + len(y.HIT_OK);
      y.ERROR := convert(x(left to left+len(y.ERROR)-1), y.ERROR);
    else
      y.SLC_PROC := convert(x(left downto left-len(y.SLC_PROC)+1), y.SLC_PROC);
      left := left - len(y.SLC_PROC);
      y.HIT_PROC := convert(x(left downto left-len(y.HIT_PROC)+1), y.HIT_PROC);
      left := left - len(y.HIT_PROC);
      y.HIT_OK := convert(x(left downto left-len(y.HIT_OK)+1), y.HIT_OK);
      left := left - len(y.HIT_OK);
      y.ERROR := convert(x(left downto left-len(y.ERROR)+1), y.ERROR);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t is
  variable y: HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
  begin
    y.SLC_PROC := nullify(t.SLC_PROC);
    y.HIT_PROC := nullify(t.HIT_PROC);
    y.HIT_OK := nullify(t.HIT_OK);
    y.ERROR := nullify(t.ERROR);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t is
  variable y: HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
  begin
    y.SLC_PROC := zeroed(t.SLC_PROC);
    y.HIT_PROC := zeroed(t.HIT_PROC);
    y.HIT_OK := zeroed(t.HIT_OK);
    y.ERROR := zeroed(t.ERROR);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_SUPER_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.STATUS);
    l := l + len(x.COUNTERS);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_SUPER_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.STATUS);
    l := l + width(x.COUNTERS);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_SUPER_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), vectorify(x.STATUS, y(left to left+len(x.STATUS)-1)));
      left := left + len(x.STATUS);
      assign(y(left to left+len(x.COUNTERS)-1), vectorify(x.COUNTERS, y(left to left+len(x.COUNTERS)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), vectorify(x.STATUS, y(left downto left-len(x.STATUS)+1)));
      left := left - len(x.STATUS);
      assign(y(left downto left-len(x.COUNTERS)+1), vectorify(x.COUNTERS, y(left downto left-len(x.COUNTERS)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_SUPER_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), convert(x.STATUS, y(left to left+len(x.STATUS)-1)));
      left := left + len(x.STATUS);
      assign(y(left to left+len(x.COUNTERS)-1), convert(x.COUNTERS, y(left to left+len(x.COUNTERS)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), convert(x.STATUS, y(left downto left-len(x.STATUS)+1)));
      left := left - len(x.STATUS);
      assign(y(left downto left-len(x.COUNTERS)+1), convert(x.COUNTERS, y(left downto left-len(x.COUNTERS)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t is
    variable y: HPS_HEG_HEG_SUPER_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := structify(x(left to left+len(y.STATUS)-1), y.STATUS);
      left := left + len(y.STATUS);
      y.COUNTERS := structify(x(left to left+len(y.COUNTERS)-1), y.COUNTERS);
    else
      y.STATUS := structify(x(left downto left-len(y.STATUS)+1), y.STATUS);
      left := left - len(y.STATUS);
      y.COUNTERS := structify(x(left downto left-len(y.COUNTERS)+1), y.COUNTERS);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t is
    variable y: HPS_HEG_HEG_SUPER_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := convert(x(left to left+len(y.STATUS)-1), y.STATUS);
      left := left + len(y.STATUS);
      y.COUNTERS := convert(x(left to left+len(y.COUNTERS)-1), y.COUNTERS);
    else
      y.STATUS := convert(x(left downto left-len(y.STATUS)+1), y.STATUS);
      left := left - len(y.STATUS);
      y.COUNTERS := convert(x(left downto left-len(y.COUNTERS)+1), y.COUNTERS);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t is
  variable y: HPS_HEG_HEG_SUPER_MON_t;
  begin
    y.STATUS := nullify(t.STATUS);
    y.COUNTERS := nullify(t.COUNTERS);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t is
  variable y: HPS_HEG_HEG_SUPER_MON_t;
  begin
    y.STATUS := zeroed(t.STATUS);
    y.COUNTERS := zeroed(t.COUNTERS);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_SUPER_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ACTIONS);
    l := l + len(x.CONFIGS);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_SUPER_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ACTIONS);
    l := l + width(x.CONFIGS);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ACTIONS)-1), vectorify(x.ACTIONS, y(left to left+len(x.ACTIONS)-1)));
      left := left + len(x.ACTIONS);
      assign(y(left to left+len(x.CONFIGS)-1), vectorify(x.CONFIGS, y(left to left+len(x.CONFIGS)-1)));
    else
      assign(y(left downto left-len(x.ACTIONS)+1), vectorify(x.ACTIONS, y(left downto left-len(x.ACTIONS)+1)));
      left := left - len(x.ACTIONS);
      assign(y(left downto left-len(x.CONFIGS)+1), vectorify(x.CONFIGS, y(left downto left-len(x.CONFIGS)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_SUPER_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ACTIONS)-1), convert(x.ACTIONS, y(left to left+len(x.ACTIONS)-1)));
      left := left + len(x.ACTIONS);
      assign(y(left to left+len(x.CONFIGS)-1), convert(x.CONFIGS, y(left to left+len(x.CONFIGS)-1)));
    else
      assign(y(left downto left-len(x.ACTIONS)+1), convert(x.ACTIONS, y(left downto left-len(x.ACTIONS)+1)));
      left := left - len(x.ACTIONS);
      assign(y(left downto left-len(x.CONFIGS)+1), convert(x.CONFIGS, y(left downto left-len(x.CONFIGS)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t is
    variable y: HPS_HEG_HEG_SUPER_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ACTIONS := structify(x(left to left+len(y.ACTIONS)-1), y.ACTIONS);
      left := left + len(y.ACTIONS);
      y.CONFIGS := structify(x(left to left+len(y.CONFIGS)-1), y.CONFIGS);
    else
      y.ACTIONS := structify(x(left downto left-len(y.ACTIONS)+1), y.ACTIONS);
      left := left - len(y.ACTIONS);
      y.CONFIGS := structify(x(left downto left-len(y.CONFIGS)+1), y.CONFIGS);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t is
    variable y: HPS_HEG_HEG_SUPER_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ACTIONS := convert(x(left to left+len(y.ACTIONS)-1), y.ACTIONS);
      left := left + len(y.ACTIONS);
      y.CONFIGS := convert(x(left to left+len(y.CONFIGS)-1), y.CONFIGS);
    else
      y.ACTIONS := convert(x(left downto left-len(y.ACTIONS)+1), y.ACTIONS);
      left := left - len(y.ACTIONS);
      y.CONFIGS := convert(x(left downto left-len(y.CONFIGS)+1), y.CONFIGS);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t is
  variable y: HPS_HEG_HEG_SUPER_CTRL_t;
  begin
    y.ACTIONS := nullify(t.ACTIONS);
    y.CONFIGS := nullify(t.CONFIGS);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t is
  variable y: HPS_HEG_HEG_SUPER_CTRL_t;
  begin
    y.ACTIONS := zeroed(t.ACTIONS);
    y.CONFIGS := zeroed(t.CONFIGS);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_rdy);
    l := l + len(x.freeze_ena);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_rdy);
    l := l + width(x.freeze_ena);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), vectorify(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.freeze_ena)-1), vectorify(x.freeze_ena, y(left to left+len(x.freeze_ena)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), vectorify(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.freeze_ena)+1), vectorify(x.freeze_ena, y(left downto left-len(x.freeze_ena)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), convert(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.freeze_ena)-1), convert(x.freeze_ena, y(left to left+len(x.freeze_ena)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), convert(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.freeze_ena)+1), convert(x.freeze_ena, y(left downto left-len(x.freeze_ena)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := structify(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.freeze_ena := structify(x(left to left+len(y.freeze_ena)-1), y.freeze_ena);
    else
      y.rd_rdy := structify(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.freeze_ena := structify(x(left downto left-len(y.freeze_ena)+1), y.freeze_ena);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := convert(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.freeze_ena := convert(x(left to left+len(y.freeze_ena)-1), y.freeze_ena);
    else
      y.rd_rdy := convert(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.freeze_ena := convert(x(left downto left-len(y.freeze_ena)+1), y.freeze_ena);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
  begin
    y.rd_rdy := nullify(t.rd_rdy);
    y.freeze_ena := nullify(t.freeze_ena);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
  begin
    y.rd_rdy := zeroed(t.rd_rdy);
    y.freeze_ena := zeroed(t.freeze_ena);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_req);
    l := l + len(x.wr_ack);
    l := l + len(x.rd_req);
    l := l + len(x.rd_ack);
    l := l + len(x.flush_req);
    l := l + len(x.freeze_req);
    l := l + len(x.mem_sel);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_req);
    l := l + width(x.wr_ack);
    l := l + width(x.rd_req);
    l := l + width(x.rd_ack);
    l := l + width(x.flush_req);
    l := l + width(x.freeze_req);
    l := l + width(x.mem_sel);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), vectorify(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.wr_ack)-1), vectorify(x.wr_ack, y(left to left+len(x.wr_ack)-1)));
      left := left + len(x.wr_ack);
      assign(y(left to left+len(x.rd_req)-1), vectorify(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.rd_ack)-1), vectorify(x.rd_ack, y(left to left+len(x.rd_ack)-1)));
      left := left + len(x.rd_ack);
      assign(y(left to left+len(x.flush_req)-1), vectorify(x.flush_req, y(left to left+len(x.flush_req)-1)));
      left := left + len(x.flush_req);
      assign(y(left to left+len(x.freeze_req)-1), vectorify(x.freeze_req, y(left to left+len(x.freeze_req)-1)));
      left := left + len(x.freeze_req);
      assign(y(left to left+len(x.mem_sel)-1), vectorify(x.mem_sel, y(left to left+len(x.mem_sel)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), vectorify(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.wr_ack)+1), vectorify(x.wr_ack, y(left downto left-len(x.wr_ack)+1)));
      left := left - len(x.wr_ack);
      assign(y(left downto left-len(x.rd_req)+1), vectorify(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.rd_ack)+1), vectorify(x.rd_ack, y(left downto left-len(x.rd_ack)+1)));
      left := left - len(x.rd_ack);
      assign(y(left downto left-len(x.flush_req)+1), vectorify(x.flush_req, y(left downto left-len(x.flush_req)+1)));
      left := left - len(x.flush_req);
      assign(y(left downto left-len(x.freeze_req)+1), vectorify(x.freeze_req, y(left downto left-len(x.freeze_req)+1)));
      left := left - len(x.freeze_req);
      assign(y(left downto left-len(x.mem_sel)+1), vectorify(x.mem_sel, y(left downto left-len(x.mem_sel)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), convert(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.wr_ack)-1), convert(x.wr_ack, y(left to left+len(x.wr_ack)-1)));
      left := left + len(x.wr_ack);
      assign(y(left to left+len(x.rd_req)-1), convert(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.rd_ack)-1), convert(x.rd_ack, y(left to left+len(x.rd_ack)-1)));
      left := left + len(x.rd_ack);
      assign(y(left to left+len(x.flush_req)-1), convert(x.flush_req, y(left to left+len(x.flush_req)-1)));
      left := left + len(x.flush_req);
      assign(y(left to left+len(x.freeze_req)-1), convert(x.freeze_req, y(left to left+len(x.freeze_req)-1)));
      left := left + len(x.freeze_req);
      assign(y(left to left+len(x.mem_sel)-1), convert(x.mem_sel, y(left to left+len(x.mem_sel)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), convert(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.wr_ack)+1), convert(x.wr_ack, y(left downto left-len(x.wr_ack)+1)));
      left := left - len(x.wr_ack);
      assign(y(left downto left-len(x.rd_req)+1), convert(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.rd_ack)+1), convert(x.rd_ack, y(left downto left-len(x.rd_ack)+1)));
      left := left - len(x.rd_ack);
      assign(y(left downto left-len(x.flush_req)+1), convert(x.flush_req, y(left downto left-len(x.flush_req)+1)));
      left := left - len(x.flush_req);
      assign(y(left downto left-len(x.freeze_req)+1), convert(x.freeze_req, y(left downto left-len(x.freeze_req)+1)));
      left := left - len(x.freeze_req);
      assign(y(left downto left-len(x.mem_sel)+1), convert(x.mem_sel, y(left downto left-len(x.mem_sel)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := structify(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.wr_ack := structify(x(left to left+len(y.wr_ack)-1), y.wr_ack);
      left := left + len(y.wr_ack);
      y.rd_req := structify(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.rd_ack := structify(x(left to left+len(y.rd_ack)-1), y.rd_ack);
      left := left + len(y.rd_ack);
      y.flush_req := structify(x(left to left+len(y.flush_req)-1), y.flush_req);
      left := left + len(y.flush_req);
      y.freeze_req := structify(x(left to left+len(y.freeze_req)-1), y.freeze_req);
      left := left + len(y.freeze_req);
      y.mem_sel := structify(x(left to left+len(y.mem_sel)-1), y.mem_sel);
    else
      y.wr_req := structify(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.wr_ack := structify(x(left downto left-len(y.wr_ack)+1), y.wr_ack);
      left := left - len(y.wr_ack);
      y.rd_req := structify(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.rd_ack := structify(x(left downto left-len(y.rd_ack)+1), y.rd_ack);
      left := left - len(y.rd_ack);
      y.flush_req := structify(x(left downto left-len(y.flush_req)+1), y.flush_req);
      left := left - len(y.flush_req);
      y.freeze_req := structify(x(left downto left-len(y.freeze_req)+1), y.freeze_req);
      left := left - len(y.freeze_req);
      y.mem_sel := structify(x(left downto left-len(y.mem_sel)+1), y.mem_sel);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := convert(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.wr_ack := convert(x(left to left+len(y.wr_ack)-1), y.wr_ack);
      left := left + len(y.wr_ack);
      y.rd_req := convert(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.rd_ack := convert(x(left to left+len(y.rd_ack)-1), y.rd_ack);
      left := left + len(y.rd_ack);
      y.flush_req := convert(x(left to left+len(y.flush_req)-1), y.flush_req);
      left := left + len(y.flush_req);
      y.freeze_req := convert(x(left to left+len(y.freeze_req)-1), y.freeze_req);
      left := left + len(y.freeze_req);
      y.mem_sel := convert(x(left to left+len(y.mem_sel)-1), y.mem_sel);
    else
      y.wr_req := convert(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.wr_ack := convert(x(left downto left-len(y.wr_ack)+1), y.wr_ack);
      left := left - len(y.wr_ack);
      y.rd_req := convert(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.rd_ack := convert(x(left downto left-len(y.rd_ack)+1), y.rd_ack);
      left := left - len(y.rd_ack);
      y.flush_req := convert(x(left downto left-len(y.flush_req)+1), y.flush_req);
      left := left - len(y.flush_req);
      y.freeze_req := convert(x(left downto left-len(y.freeze_req)+1), y.freeze_req);
      left := left - len(y.freeze_req);
      y.mem_sel := convert(x(left downto left-len(y.mem_sel)+1), y.mem_sel);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
  begin
    y.wr_req := nullify(t.wr_req);
    y.wr_ack := nullify(t.wr_ack);
    y.rd_req := nullify(t.rd_req);
    y.rd_ack := nullify(t.rd_ack);
    y.flush_req := nullify(t.flush_req);
    y.freeze_req := nullify(t.freeze_req);
    y.mem_sel := nullify(t.mem_sel);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
  begin
    y.wr_req := zeroed(t.wr_req);
    y.wr_ack := zeroed(t.wr_ack);
    y.rd_req := zeroed(t.rd_req);
    y.rd_ack := zeroed(t.rd_ack);
    y.flush_req := zeroed(t.flush_req);
    y.freeze_req := zeroed(t.freeze_req);
    y.mem_sel := zeroed(t.mem_sel);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_data_0);
    l := l + len(x.wr_data_1);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_data_0);
    l := l + width(x.wr_data_1);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_data_0)-1), vectorify(x.wr_data_0, y(left to left+len(x.wr_data_0)-1)));
      left := left + len(x.wr_data_0);
      assign(y(left to left+len(x.wr_data_1)-1), vectorify(x.wr_data_1, y(left to left+len(x.wr_data_1)-1)));
    else
      assign(y(left downto left-len(x.wr_data_0)+1), vectorify(x.wr_data_0, y(left downto left-len(x.wr_data_0)+1)));
      left := left - len(x.wr_data_0);
      assign(y(left downto left-len(x.wr_data_1)+1), vectorify(x.wr_data_1, y(left downto left-len(x.wr_data_1)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_data_0)-1), convert(x.wr_data_0, y(left to left+len(x.wr_data_0)-1)));
      left := left + len(x.wr_data_0);
      assign(y(left to left+len(x.wr_data_1)-1), convert(x.wr_data_1, y(left to left+len(x.wr_data_1)-1)));
    else
      assign(y(left downto left-len(x.wr_data_0)+1), convert(x.wr_data_0, y(left downto left-len(x.wr_data_0)+1)));
      left := left - len(x.wr_data_0);
      assign(y(left downto left-len(x.wr_data_1)+1), convert(x.wr_data_1, y(left downto left-len(x.wr_data_1)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_data_0 := structify(x(left to left+len(y.wr_data_0)-1), y.wr_data_0);
      left := left + len(y.wr_data_0);
      y.wr_data_1 := structify(x(left to left+len(y.wr_data_1)-1), y.wr_data_1);
    else
      y.wr_data_0 := structify(x(left downto left-len(y.wr_data_0)+1), y.wr_data_0);
      left := left - len(y.wr_data_0);
      y.wr_data_1 := structify(x(left downto left-len(y.wr_data_1)+1), y.wr_data_1);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_data_0 := convert(x(left to left+len(y.wr_data_0)-1), y.wr_data_0);
      left := left + len(y.wr_data_0);
      y.wr_data_1 := convert(x(left to left+len(y.wr_data_1)-1), y.wr_data_1);
    else
      y.wr_data_0 := convert(x(left downto left-len(y.wr_data_0)+1), y.wr_data_0);
      left := left - len(y.wr_data_0);
      y.wr_data_1 := convert(x(left downto left-len(y.wr_data_1)+1), y.wr_data_1);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
  begin
    y.wr_data_0 := nullify(t.wr_data_0);
    y.wr_data_1 := nullify(t.wr_data_1);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
  begin
    y.wr_data_0 := zeroed(t.wr_data_0);
    y.wr_data_1 := zeroed(t.wr_data_1);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_data_1);
    l := l + len(x.rd_data_0);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_data_1);
    l := l + width(x.rd_data_0);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_data_1)-1), vectorify(x.rd_data_1, y(left to left+len(x.rd_data_1)-1)));
      left := left + len(x.rd_data_1);
      assign(y(left to left+len(x.rd_data_0)-1), vectorify(x.rd_data_0, y(left to left+len(x.rd_data_0)-1)));
    else
      assign(y(left downto left-len(x.rd_data_1)+1), vectorify(x.rd_data_1, y(left downto left-len(x.rd_data_1)+1)));
      left := left - len(x.rd_data_1);
      assign(y(left downto left-len(x.rd_data_0)+1), vectorify(x.rd_data_0, y(left downto left-len(x.rd_data_0)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_data_1)-1), convert(x.rd_data_1, y(left to left+len(x.rd_data_1)-1)));
      left := left + len(x.rd_data_1);
      assign(y(left to left+len(x.rd_data_0)-1), convert(x.rd_data_0, y(left to left+len(x.rd_data_0)-1)));
    else
      assign(y(left downto left-len(x.rd_data_1)+1), convert(x.rd_data_1, y(left downto left-len(x.rd_data_1)+1)));
      left := left - len(x.rd_data_1);
      assign(y(left downto left-len(x.rd_data_0)+1), convert(x.rd_data_0, y(left downto left-len(x.rd_data_0)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_data_1 := structify(x(left to left+len(y.rd_data_1)-1), y.rd_data_1);
      left := left + len(y.rd_data_1);
      y.rd_data_0 := structify(x(left to left+len(y.rd_data_0)-1), y.rd_data_0);
    else
      y.rd_data_1 := structify(x(left downto left-len(y.rd_data_1)+1), y.rd_data_1);
      left := left - len(y.rd_data_1);
      y.rd_data_0 := structify(x(left downto left-len(y.rd_data_0)+1), y.rd_data_0);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_data_1 := convert(x(left to left+len(y.rd_data_1)-1), y.rd_data_1);
      left := left + len(y.rd_data_1);
      y.rd_data_0 := convert(x(left to left+len(y.rd_data_0)-1), y.rd_data_0);
    else
      y.rd_data_1 := convert(x(left downto left-len(y.rd_data_1)+1), y.rd_data_1);
      left := left - len(y.rd_data_1);
      y.rd_data_0 := convert(x(left downto left-len(y.rd_data_0)+1), y.rd_data_0);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
  begin
    y.rd_data_1 := nullify(t.rd_data_1);
    y.rd_data_0 := nullify(t.rd_data_0);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
  begin
    y.rd_data_1 := zeroed(t.rd_data_1);
    y.rd_data_0 := zeroed(t.rd_data_0);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SIGNALS);
    l := l + len(x.rd_data);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SIGNALS);
    l := l + width(x.rd_data);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), vectorify(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), vectorify(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), convert(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.rd_data)-1), convert(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), convert(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.rd_data)+1), convert(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := structify(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.SIGNALS := structify(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := convert(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.rd_data := convert(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.SIGNALS := convert(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.rd_data := convert(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
  begin
    y.SIGNALS := nullify(t.SIGNALS);
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
  begin
    y.SIGNALS := zeroed(t.SIGNALS);
    y.rd_data := zeroed(t.rd_data);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SIGNALS);
    l := l + len(x.wr_addr);
    l := l + len(x.rd_addr);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SIGNALS);
    l := l + width(x.wr_addr);
    l := l + width(x.rd_addr);
    l := l + width(x.wr_data);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), vectorify(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.wr_addr)-1), vectorify(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), vectorify(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), vectorify(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.wr_addr)+1), vectorify(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), vectorify(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), convert(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.wr_addr)-1), convert(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), convert(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), convert(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), convert(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.wr_addr)+1), convert(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), convert(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), convert(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := structify(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.wr_addr := structify(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := structify(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.SIGNALS := structify(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.wr_addr := structify(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := structify(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := convert(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.wr_addr := convert(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := convert(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := convert(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.SIGNALS := convert(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.wr_addr := convert(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := convert(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := convert(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
  begin
    y.SIGNALS := nullify(t.SIGNALS);
    y.wr_addr := nullify(t.wr_addr);
    y.rd_addr := nullify(t.rd_addr);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
  begin
    y.SIGNALS := zeroed(t.SIGNALS);
    y.wr_addr := zeroed(t.wr_addr);
    y.rd_addr := zeroed(t.rd_addr);
    y.wr_data := zeroed(t.wr_data);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ROI_TC);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ROI_TC);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ROI_TC)-1), vectorify(x.ROI_TC, y(left to left+len(x.ROI_TC)-1)));
    else
      assign(y(left downto left-len(x.ROI_TC)+1), vectorify(x.ROI_TC, y(left downto left-len(x.ROI_TC)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ROI_TC)-1), convert(x.ROI_TC, y(left to left+len(x.ROI_TC)-1)));
    else
      assign(y(left downto left-len(x.ROI_TC)+1), convert(x.ROI_TC, y(left downto left-len(x.ROI_TC)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t is
    variable y: HPS_HEG_HEG_CTRL_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ROI_TC := structify(x(left to left+len(y.ROI_TC)-1), y.ROI_TC);
    else
      y.ROI_TC := structify(x(left downto left-len(y.ROI_TC)+1), y.ROI_TC);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t is
    variable y: HPS_HEG_HEG_CTRL_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ROI_TC := convert(x(left to left+len(y.ROI_TC)-1), y.ROI_TC);
    else
      y.ROI_TC := convert(x(left downto left-len(y.ROI_TC)+1), y.ROI_TC);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t is
  variable y: HPS_HEG_HEG_CTRL_MON_t;
  begin
    y.ROI_TC := nullify(t.ROI_TC);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t is
  variable y: HPS_HEG_HEG_CTRL_MON_t;
  begin
    y.ROI_TC := zeroed(t.ROI_TC);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ROI_TC);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ROI_TC);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ROI_TC)-1), vectorify(x.ROI_TC, y(left to left+len(x.ROI_TC)-1)));
    else
      assign(y(left downto left-len(x.ROI_TC)+1), vectorify(x.ROI_TC, y(left downto left-len(x.ROI_TC)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ROI_TC)-1), convert(x.ROI_TC, y(left to left+len(x.ROI_TC)-1)));
    else
      assign(y(left downto left-len(x.ROI_TC)+1), convert(x.ROI_TC, y(left downto left-len(x.ROI_TC)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ROI_TC := structify(x(left to left+len(y.ROI_TC)-1), y.ROI_TC);
    else
      y.ROI_TC := structify(x(left downto left-len(y.ROI_TC)+1), y.ROI_TC);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ROI_TC := convert(x(left to left+len(y.ROI_TC)-1), y.ROI_TC);
    else
      y.ROI_TC := convert(x(left downto left-len(y.ROI_TC)+1), y.ROI_TC);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_CTRL_t;
  begin
    y.ROI_TC := nullify(t.ROI_TC);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_CTRL_t;
  begin
    y.ROI_TC := zeroed(t.ROI_TC);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.RESET);
    l := l + len(x.ENABLE);
    l := l + len(x.DISABLE);
    l := l + len(x.FREEZE);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.RESET);
    l := l + width(x.ENABLE);
    l := l + width(x.DISABLE);
    l := l + width(x.FREEZE);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), vectorify(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.ENABLE)-1), vectorify(x.ENABLE, y(left to left+len(x.ENABLE)-1)));
      left := left + len(x.ENABLE);
      assign(y(left to left+len(x.DISABLE)-1), vectorify(x.DISABLE, y(left to left+len(x.DISABLE)-1)));
      left := left + len(x.DISABLE);
      assign(y(left to left+len(x.FREEZE)-1), vectorify(x.FREEZE, y(left to left+len(x.FREEZE)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), vectorify(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.ENABLE)+1), vectorify(x.ENABLE, y(left downto left-len(x.ENABLE)+1)));
      left := left - len(x.ENABLE);
      assign(y(left downto left-len(x.DISABLE)+1), vectorify(x.DISABLE, y(left downto left-len(x.DISABLE)+1)));
      left := left - len(x.DISABLE);
      assign(y(left downto left-len(x.FREEZE)+1), vectorify(x.FREEZE, y(left downto left-len(x.FREEZE)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), convert(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.ENABLE)-1), convert(x.ENABLE, y(left to left+len(x.ENABLE)-1)));
      left := left + len(x.ENABLE);
      assign(y(left to left+len(x.DISABLE)-1), convert(x.DISABLE, y(left to left+len(x.DISABLE)-1)));
      left := left + len(x.DISABLE);
      assign(y(left to left+len(x.FREEZE)-1), convert(x.FREEZE, y(left to left+len(x.FREEZE)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), convert(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.ENABLE)+1), convert(x.ENABLE, y(left downto left-len(x.ENABLE)+1)));
      left := left - len(x.ENABLE);
      assign(y(left downto left-len(x.DISABLE)+1), convert(x.DISABLE, y(left downto left-len(x.DISABLE)+1)));
      left := left - len(x.DISABLE);
      assign(y(left downto left-len(x.FREEZE)+1), convert(x.FREEZE, y(left downto left-len(x.FREEZE)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := structify(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.ENABLE := structify(x(left to left+len(y.ENABLE)-1), y.ENABLE);
      left := left + len(y.ENABLE);
      y.DISABLE := structify(x(left to left+len(y.DISABLE)-1), y.DISABLE);
      left := left + len(y.DISABLE);
      y.FREEZE := structify(x(left to left+len(y.FREEZE)-1), y.FREEZE);
    else
      y.RESET := structify(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.ENABLE := structify(x(left downto left-len(y.ENABLE)+1), y.ENABLE);
      left := left - len(y.ENABLE);
      y.DISABLE := structify(x(left downto left-len(y.DISABLE)+1), y.DISABLE);
      left := left - len(y.DISABLE);
      y.FREEZE := structify(x(left downto left-len(y.FREEZE)+1), y.FREEZE);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := convert(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.ENABLE := convert(x(left to left+len(y.ENABLE)-1), y.ENABLE);
      left := left + len(y.ENABLE);
      y.DISABLE := convert(x(left to left+len(y.DISABLE)-1), y.DISABLE);
      left := left + len(y.DISABLE);
      y.FREEZE := convert(x(left to left+len(y.FREEZE)-1), y.FREEZE);
    else
      y.RESET := convert(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.ENABLE := convert(x(left downto left-len(y.ENABLE)+1), y.ENABLE);
      left := left - len(y.ENABLE);
      y.DISABLE := convert(x(left downto left-len(y.DISABLE)+1), y.DISABLE);
      left := left - len(y.DISABLE);
      y.FREEZE := convert(x(left downto left-len(y.FREEZE)+1), y.FREEZE);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
  begin
    y.RESET := nullify(t.RESET);
    y.ENABLE := nullify(t.ENABLE);
    y.DISABLE := nullify(t.DISABLE);
    y.FREEZE := nullify(t.FREEZE);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
  begin
    y.RESET := zeroed(t.RESET);
    y.ENABLE := zeroed(t.ENABLE);
    y.DISABLE := zeroed(t.DISABLE);
    y.FREEZE := zeroed(t.FREEZE);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.INPUT_EN);
    l := l + len(x.OUTPUT_EN);
    l := l + len(x.FLUSH_MEM_RESET);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.INPUT_EN);
    l := l + width(x.OUTPUT_EN);
    l := l + width(x.FLUSH_MEM_RESET);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.INPUT_EN)-1), vectorify(x.INPUT_EN, y(left to left+len(x.INPUT_EN)-1)));
      left := left + len(x.INPUT_EN);
      assign(y(left to left+len(x.OUTPUT_EN)-1), vectorify(x.OUTPUT_EN, y(left to left+len(x.OUTPUT_EN)-1)));
      left := left + len(x.OUTPUT_EN);
      assign(y(left to left+len(x.FLUSH_MEM_RESET)-1), vectorify(x.FLUSH_MEM_RESET, y(left to left+len(x.FLUSH_MEM_RESET)-1)));
    else
      assign(y(left downto left-len(x.INPUT_EN)+1), vectorify(x.INPUT_EN, y(left downto left-len(x.INPUT_EN)+1)));
      left := left - len(x.INPUT_EN);
      assign(y(left downto left-len(x.OUTPUT_EN)+1), vectorify(x.OUTPUT_EN, y(left downto left-len(x.OUTPUT_EN)+1)));
      left := left - len(x.OUTPUT_EN);
      assign(y(left downto left-len(x.FLUSH_MEM_RESET)+1), vectorify(x.FLUSH_MEM_RESET, y(left downto left-len(x.FLUSH_MEM_RESET)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.INPUT_EN)-1), convert(x.INPUT_EN, y(left to left+len(x.INPUT_EN)-1)));
      left := left + len(x.INPUT_EN);
      assign(y(left to left+len(x.OUTPUT_EN)-1), convert(x.OUTPUT_EN, y(left to left+len(x.OUTPUT_EN)-1)));
      left := left + len(x.OUTPUT_EN);
      assign(y(left to left+len(x.FLUSH_MEM_RESET)-1), convert(x.FLUSH_MEM_RESET, y(left to left+len(x.FLUSH_MEM_RESET)-1)));
    else
      assign(y(left downto left-len(x.INPUT_EN)+1), convert(x.INPUT_EN, y(left downto left-len(x.INPUT_EN)+1)));
      left := left - len(x.INPUT_EN);
      assign(y(left downto left-len(x.OUTPUT_EN)+1), convert(x.OUTPUT_EN, y(left downto left-len(x.OUTPUT_EN)+1)));
      left := left - len(x.OUTPUT_EN);
      assign(y(left downto left-len(x.FLUSH_MEM_RESET)+1), convert(x.FLUSH_MEM_RESET, y(left downto left-len(x.FLUSH_MEM_RESET)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.INPUT_EN := structify(x(left to left+len(y.INPUT_EN)-1), y.INPUT_EN);
      left := left + len(y.INPUT_EN);
      y.OUTPUT_EN := structify(x(left to left+len(y.OUTPUT_EN)-1), y.OUTPUT_EN);
      left := left + len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := structify(x(left to left+len(y.FLUSH_MEM_RESET)-1), y.FLUSH_MEM_RESET);
    else
      y.INPUT_EN := structify(x(left downto left-len(y.INPUT_EN)+1), y.INPUT_EN);
      left := left - len(y.INPUT_EN);
      y.OUTPUT_EN := structify(x(left downto left-len(y.OUTPUT_EN)+1), y.OUTPUT_EN);
      left := left - len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := structify(x(left downto left-len(y.FLUSH_MEM_RESET)+1), y.FLUSH_MEM_RESET);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.INPUT_EN := convert(x(left to left+len(y.INPUT_EN)-1), y.INPUT_EN);
      left := left + len(y.INPUT_EN);
      y.OUTPUT_EN := convert(x(left to left+len(y.OUTPUT_EN)-1), y.OUTPUT_EN);
      left := left + len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := convert(x(left to left+len(y.FLUSH_MEM_RESET)-1), y.FLUSH_MEM_RESET);
    else
      y.INPUT_EN := convert(x(left downto left-len(y.INPUT_EN)+1), y.INPUT_EN);
      left := left - len(y.INPUT_EN);
      y.OUTPUT_EN := convert(x(left downto left-len(y.OUTPUT_EN)+1), y.OUTPUT_EN);
      left := left - len(y.OUTPUT_EN);
      y.FLUSH_MEM_RESET := convert(x(left downto left-len(y.FLUSH_MEM_RESET)+1), y.FLUSH_MEM_RESET);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
  begin
    y.INPUT_EN := nullify(t.INPUT_EN);
    y.OUTPUT_EN := nullify(t.OUTPUT_EN);
    y.FLUSH_MEM_RESET := nullify(t.FLUSH_MEM_RESET);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
  begin
    y.INPUT_EN := zeroed(t.INPUT_EN);
    y.OUTPUT_EN := zeroed(t.OUTPUT_EN);
    y.FLUSH_MEM_RESET := zeroed(t.FLUSH_MEM_RESET);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_rdy);
    l := l + len(x.freeze_ena);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_rdy);
    l := l + width(x.freeze_ena);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), vectorify(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.freeze_ena)-1), vectorify(x.freeze_ena, y(left to left+len(x.freeze_ena)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), vectorify(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.freeze_ena)+1), vectorify(x.freeze_ena, y(left downto left-len(x.freeze_ena)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_rdy)-1), convert(x.rd_rdy, y(left to left+len(x.rd_rdy)-1)));
      left := left + len(x.rd_rdy);
      assign(y(left to left+len(x.freeze_ena)-1), convert(x.freeze_ena, y(left to left+len(x.freeze_ena)-1)));
    else
      assign(y(left downto left-len(x.rd_rdy)+1), convert(x.rd_rdy, y(left downto left-len(x.rd_rdy)+1)));
      left := left - len(x.rd_rdy);
      assign(y(left downto left-len(x.freeze_ena)+1), convert(x.freeze_ena, y(left downto left-len(x.freeze_ena)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := structify(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.freeze_ena := structify(x(left to left+len(y.freeze_ena)-1), y.freeze_ena);
    else
      y.rd_rdy := structify(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.freeze_ena := structify(x(left downto left-len(y.freeze_ena)+1), y.freeze_ena);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_rdy := convert(x(left to left+len(y.rd_rdy)-1), y.rd_rdy);
      left := left + len(y.rd_rdy);
      y.freeze_ena := convert(x(left to left+len(y.freeze_ena)-1), y.freeze_ena);
    else
      y.rd_rdy := convert(x(left downto left-len(y.rd_rdy)+1), y.rd_rdy);
      left := left - len(y.rd_rdy);
      y.freeze_ena := convert(x(left downto left-len(y.freeze_ena)+1), y.freeze_ena);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
  begin
    y.rd_rdy := nullify(t.rd_rdy);
    y.freeze_ena := nullify(t.freeze_ena);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
  begin
    y.rd_rdy := zeroed(t.rd_rdy);
    y.freeze_ena := zeroed(t.freeze_ena);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_req);
    l := l + len(x.wr_ack);
    l := l + len(x.rd_req);
    l := l + len(x.rd_ack);
    l := l + len(x.flush_req);
    l := l + len(x.freeze_req);
    l := l + len(x.mem_sel);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_req);
    l := l + width(x.wr_ack);
    l := l + width(x.rd_req);
    l := l + width(x.rd_ack);
    l := l + width(x.flush_req);
    l := l + width(x.freeze_req);
    l := l + width(x.mem_sel);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), vectorify(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.wr_ack)-1), vectorify(x.wr_ack, y(left to left+len(x.wr_ack)-1)));
      left := left + len(x.wr_ack);
      assign(y(left to left+len(x.rd_req)-1), vectorify(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.rd_ack)-1), vectorify(x.rd_ack, y(left to left+len(x.rd_ack)-1)));
      left := left + len(x.rd_ack);
      assign(y(left to left+len(x.flush_req)-1), vectorify(x.flush_req, y(left to left+len(x.flush_req)-1)));
      left := left + len(x.flush_req);
      assign(y(left to left+len(x.freeze_req)-1), vectorify(x.freeze_req, y(left to left+len(x.freeze_req)-1)));
      left := left + len(x.freeze_req);
      assign(y(left to left+len(x.mem_sel)-1), vectorify(x.mem_sel, y(left to left+len(x.mem_sel)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), vectorify(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.wr_ack)+1), vectorify(x.wr_ack, y(left downto left-len(x.wr_ack)+1)));
      left := left - len(x.wr_ack);
      assign(y(left downto left-len(x.rd_req)+1), vectorify(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.rd_ack)+1), vectorify(x.rd_ack, y(left downto left-len(x.rd_ack)+1)));
      left := left - len(x.rd_ack);
      assign(y(left downto left-len(x.flush_req)+1), vectorify(x.flush_req, y(left downto left-len(x.flush_req)+1)));
      left := left - len(x.flush_req);
      assign(y(left downto left-len(x.freeze_req)+1), vectorify(x.freeze_req, y(left downto left-len(x.freeze_req)+1)));
      left := left - len(x.freeze_req);
      assign(y(left downto left-len(x.mem_sel)+1), vectorify(x.mem_sel, y(left downto left-len(x.mem_sel)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_req)-1), convert(x.wr_req, y(left to left+len(x.wr_req)-1)));
      left := left + len(x.wr_req);
      assign(y(left to left+len(x.wr_ack)-1), convert(x.wr_ack, y(left to left+len(x.wr_ack)-1)));
      left := left + len(x.wr_ack);
      assign(y(left to left+len(x.rd_req)-1), convert(x.rd_req, y(left to left+len(x.rd_req)-1)));
      left := left + len(x.rd_req);
      assign(y(left to left+len(x.rd_ack)-1), convert(x.rd_ack, y(left to left+len(x.rd_ack)-1)));
      left := left + len(x.rd_ack);
      assign(y(left to left+len(x.flush_req)-1), convert(x.flush_req, y(left to left+len(x.flush_req)-1)));
      left := left + len(x.flush_req);
      assign(y(left to left+len(x.freeze_req)-1), convert(x.freeze_req, y(left to left+len(x.freeze_req)-1)));
      left := left + len(x.freeze_req);
      assign(y(left to left+len(x.mem_sel)-1), convert(x.mem_sel, y(left to left+len(x.mem_sel)-1)));
    else
      assign(y(left downto left-len(x.wr_req)+1), convert(x.wr_req, y(left downto left-len(x.wr_req)+1)));
      left := left - len(x.wr_req);
      assign(y(left downto left-len(x.wr_ack)+1), convert(x.wr_ack, y(left downto left-len(x.wr_ack)+1)));
      left := left - len(x.wr_ack);
      assign(y(left downto left-len(x.rd_req)+1), convert(x.rd_req, y(left downto left-len(x.rd_req)+1)));
      left := left - len(x.rd_req);
      assign(y(left downto left-len(x.rd_ack)+1), convert(x.rd_ack, y(left downto left-len(x.rd_ack)+1)));
      left := left - len(x.rd_ack);
      assign(y(left downto left-len(x.flush_req)+1), convert(x.flush_req, y(left downto left-len(x.flush_req)+1)));
      left := left - len(x.flush_req);
      assign(y(left downto left-len(x.freeze_req)+1), convert(x.freeze_req, y(left downto left-len(x.freeze_req)+1)));
      left := left - len(x.freeze_req);
      assign(y(left downto left-len(x.mem_sel)+1), convert(x.mem_sel, y(left downto left-len(x.mem_sel)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := structify(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.wr_ack := structify(x(left to left+len(y.wr_ack)-1), y.wr_ack);
      left := left + len(y.wr_ack);
      y.rd_req := structify(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.rd_ack := structify(x(left to left+len(y.rd_ack)-1), y.rd_ack);
      left := left + len(y.rd_ack);
      y.flush_req := structify(x(left to left+len(y.flush_req)-1), y.flush_req);
      left := left + len(y.flush_req);
      y.freeze_req := structify(x(left to left+len(y.freeze_req)-1), y.freeze_req);
      left := left + len(y.freeze_req);
      y.mem_sel := structify(x(left to left+len(y.mem_sel)-1), y.mem_sel);
    else
      y.wr_req := structify(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.wr_ack := structify(x(left downto left-len(y.wr_ack)+1), y.wr_ack);
      left := left - len(y.wr_ack);
      y.rd_req := structify(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.rd_ack := structify(x(left downto left-len(y.rd_ack)+1), y.rd_ack);
      left := left - len(y.rd_ack);
      y.flush_req := structify(x(left downto left-len(y.flush_req)+1), y.flush_req);
      left := left - len(y.flush_req);
      y.freeze_req := structify(x(left downto left-len(y.freeze_req)+1), y.freeze_req);
      left := left - len(y.freeze_req);
      y.mem_sel := structify(x(left downto left-len(y.mem_sel)+1), y.mem_sel);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_req := convert(x(left to left+len(y.wr_req)-1), y.wr_req);
      left := left + len(y.wr_req);
      y.wr_ack := convert(x(left to left+len(y.wr_ack)-1), y.wr_ack);
      left := left + len(y.wr_ack);
      y.rd_req := convert(x(left to left+len(y.rd_req)-1), y.rd_req);
      left := left + len(y.rd_req);
      y.rd_ack := convert(x(left to left+len(y.rd_ack)-1), y.rd_ack);
      left := left + len(y.rd_ack);
      y.flush_req := convert(x(left to left+len(y.flush_req)-1), y.flush_req);
      left := left + len(y.flush_req);
      y.freeze_req := convert(x(left to left+len(y.freeze_req)-1), y.freeze_req);
      left := left + len(y.freeze_req);
      y.mem_sel := convert(x(left to left+len(y.mem_sel)-1), y.mem_sel);
    else
      y.wr_req := convert(x(left downto left-len(y.wr_req)+1), y.wr_req);
      left := left - len(y.wr_req);
      y.wr_ack := convert(x(left downto left-len(y.wr_ack)+1), y.wr_ack);
      left := left - len(y.wr_ack);
      y.rd_req := convert(x(left downto left-len(y.rd_req)+1), y.rd_req);
      left := left - len(y.rd_req);
      y.rd_ack := convert(x(left downto left-len(y.rd_ack)+1), y.rd_ack);
      left := left - len(y.rd_ack);
      y.flush_req := convert(x(left downto left-len(y.flush_req)+1), y.flush_req);
      left := left - len(y.flush_req);
      y.freeze_req := convert(x(left downto left-len(y.freeze_req)+1), y.freeze_req);
      left := left - len(y.freeze_req);
      y.mem_sel := convert(x(left downto left-len(y.mem_sel)+1), y.mem_sel);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
  begin
    y.wr_req := nullify(t.wr_req);
    y.wr_ack := nullify(t.wr_ack);
    y.rd_req := nullify(t.rd_req);
    y.rd_ack := nullify(t.rd_ack);
    y.flush_req := nullify(t.flush_req);
    y.freeze_req := nullify(t.freeze_req);
    y.mem_sel := nullify(t.mem_sel);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
  begin
    y.wr_req := zeroed(t.wr_req);
    y.wr_ack := zeroed(t.wr_ack);
    y.rd_req := zeroed(t.rd_req);
    y.rd_ack := zeroed(t.rd_ack);
    y.flush_req := zeroed(t.flush_req);
    y.freeze_req := zeroed(t.freeze_req);
    y.mem_sel := zeroed(t.mem_sel);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.wr_data_0);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.wr_data_0);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_data_0)-1), vectorify(x.wr_data_0, y(left to left+len(x.wr_data_0)-1)));
    else
      assign(y(left downto left-len(x.wr_data_0)+1), vectorify(x.wr_data_0, y(left downto left-len(x.wr_data_0)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.wr_data_0)-1), convert(x.wr_data_0, y(left to left+len(x.wr_data_0)-1)));
    else
      assign(y(left downto left-len(x.wr_data_0)+1), convert(x.wr_data_0, y(left downto left-len(x.wr_data_0)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_data_0 := structify(x(left to left+len(y.wr_data_0)-1), y.wr_data_0);
    else
      y.wr_data_0 := structify(x(left downto left-len(y.wr_data_0)+1), y.wr_data_0);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.wr_data_0 := convert(x(left to left+len(y.wr_data_0)-1), y.wr_data_0);
    else
      y.wr_data_0 := convert(x(left downto left-len(y.wr_data_0)+1), y.wr_data_0);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
  begin
    y.wr_data_0 := nullify(t.wr_data_0);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
  begin
    y.wr_data_0 := zeroed(t.wr_data_0);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.rd_data_0);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.rd_data_0);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_data_0)-1), vectorify(x.rd_data_0, y(left to left+len(x.rd_data_0)-1)));
    else
      assign(y(left downto left-len(x.rd_data_0)+1), vectorify(x.rd_data_0, y(left downto left-len(x.rd_data_0)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.rd_data_0)-1), convert(x.rd_data_0, y(left to left+len(x.rd_data_0)-1)));
    else
      assign(y(left downto left-len(x.rd_data_0)+1), convert(x.rd_data_0, y(left downto left-len(x.rd_data_0)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_data_0 := structify(x(left to left+len(y.rd_data_0)-1), y.rd_data_0);
    else
      y.rd_data_0 := structify(x(left downto left-len(y.rd_data_0)+1), y.rd_data_0);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.rd_data_0 := convert(x(left to left+len(y.rd_data_0)-1), y.rd_data_0);
    else
      y.rd_data_0 := convert(x(left downto left-len(y.rd_data_0)+1), y.rd_data_0);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
  begin
    y.rd_data_0 := nullify(t.rd_data_0);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
  begin
    y.rd_data_0 := zeroed(t.rd_data_0);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SIGNALS);
    l := l + len(x.rd_data);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SIGNALS);
    l := l + width(x.rd_data);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), vectorify(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.rd_data)-1), vectorify(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), vectorify(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.rd_data)+1), vectorify(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), convert(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.rd_data)-1), convert(x.rd_data, y(left to left+len(x.rd_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), convert(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.rd_data)+1), convert(x.rd_data, y(left downto left-len(x.rd_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := structify(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.rd_data := structify(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.SIGNALS := structify(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.rd_data := structify(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := convert(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.rd_data := convert(x(left to left+len(y.rd_data)-1), y.rd_data);
    else
      y.SIGNALS := convert(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.rd_data := convert(x(left downto left-len(y.rd_data)+1), y.rd_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
  begin
    y.SIGNALS := nullify(t.SIGNALS);
    y.rd_data := nullify(t.rd_data);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
  begin
    y.SIGNALS := zeroed(t.SIGNALS);
    y.rd_data := zeroed(t.rd_data);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SIGNALS);
    l := l + len(x.wr_addr);
    l := l + len(x.rd_addr);
    l := l + len(x.wr_data);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SIGNALS);
    l := l + width(x.wr_addr);
    l := l + width(x.rd_addr);
    l := l + width(x.wr_data);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), vectorify(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.wr_addr)-1), vectorify(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), vectorify(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), vectorify(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), vectorify(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.wr_addr)+1), vectorify(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), vectorify(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), vectorify(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SIGNALS)-1), convert(x.SIGNALS, y(left to left+len(x.SIGNALS)-1)));
      left := left + len(x.SIGNALS);
      assign(y(left to left+len(x.wr_addr)-1), convert(x.wr_addr, y(left to left+len(x.wr_addr)-1)));
      left := left + len(x.wr_addr);
      assign(y(left to left+len(x.rd_addr)-1), convert(x.rd_addr, y(left to left+len(x.rd_addr)-1)));
      left := left + len(x.rd_addr);
      assign(y(left to left+len(x.wr_data)-1), convert(x.wr_data, y(left to left+len(x.wr_data)-1)));
    else
      assign(y(left downto left-len(x.SIGNALS)+1), convert(x.SIGNALS, y(left downto left-len(x.SIGNALS)+1)));
      left := left - len(x.SIGNALS);
      assign(y(left downto left-len(x.wr_addr)+1), convert(x.wr_addr, y(left downto left-len(x.wr_addr)+1)));
      left := left - len(x.wr_addr);
      assign(y(left downto left-len(x.rd_addr)+1), convert(x.rd_addr, y(left downto left-len(x.rd_addr)+1)));
      left := left - len(x.rd_addr);
      assign(y(left downto left-len(x.wr_data)+1), convert(x.wr_data, y(left downto left-len(x.wr_data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := structify(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.wr_addr := structify(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := structify(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := structify(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.SIGNALS := structify(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.wr_addr := structify(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := structify(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := structify(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SIGNALS := convert(x(left to left+len(y.SIGNALS)-1), y.SIGNALS);
      left := left + len(y.SIGNALS);
      y.wr_addr := convert(x(left to left+len(y.wr_addr)-1), y.wr_addr);
      left := left + len(y.wr_addr);
      y.rd_addr := convert(x(left to left+len(y.rd_addr)-1), y.rd_addr);
      left := left + len(y.rd_addr);
      y.wr_data := convert(x(left to left+len(y.wr_data)-1), y.wr_data);
    else
      y.SIGNALS := convert(x(left downto left-len(y.SIGNALS)+1), y.SIGNALS);
      left := left - len(y.SIGNALS);
      y.wr_addr := convert(x(left downto left-len(y.wr_addr)+1), y.wr_addr);
      left := left - len(y.wr_addr);
      y.rd_addr := convert(x(left downto left-len(y.rd_addr)+1), y.rd_addr);
      left := left - len(y.rd_addr);
      y.wr_data := convert(x(left downto left-len(y.wr_data)+1), y.wr_data);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
  begin
    y.SIGNALS := nullify(t.SIGNALS);
    y.wr_addr := nullify(t.wr_addr);
    y.rd_addr := nullify(t.rd_addr);
    y.wr_data := nullify(t.wr_data);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
  begin
    y.SIGNALS := zeroed(t.SIGNALS);
    y.wr_addr := zeroed(t.wr_addr);
    y.rd_addr := zeroed(t.rd_addr);
    y.wr_data := zeroed(t.wr_data);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.MDT_DT2R);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.MDT_DT2R);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_DT2R)-1), vectorify(x.MDT_DT2R, y(left to left+len(x.MDT_DT2R)-1)));
    else
      assign(y(left downto left-len(x.MDT_DT2R)+1), vectorify(x.MDT_DT2R, y(left downto left-len(x.MDT_DT2R)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.MDT_DT2R)-1), convert(x.MDT_DT2R, y(left to left+len(x.MDT_DT2R)-1)));
    else
      assign(y(left downto left-len(x.MDT_DT2R)+1), convert(x.MDT_DT2R, y(left downto left-len(x.MDT_DT2R)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t is
    variable y: HPS_HEG_HEG_HP_HP_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_DT2R := structify(x(left to left+len(y.MDT_DT2R)-1), y.MDT_DT2R);
    else
      y.MDT_DT2R := structify(x(left downto left-len(y.MDT_DT2R)+1), y.MDT_DT2R);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t is
    variable y: HPS_HEG_HEG_HP_HP_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.MDT_DT2R := convert(x(left to left+len(y.MDT_DT2R)-1), y.MDT_DT2R);
    else
      y.MDT_DT2R := convert(x(left downto left-len(y.MDT_DT2R)+1), y.MDT_DT2R);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t is
  variable y: HPS_HEG_HEG_HP_HP_MON_t;
  begin
    y.MDT_DT2R := nullify(t.MDT_DT2R);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t is
  variable y: HPS_HEG_HEG_HP_HP_MON_t;
  begin
    y.MDT_DT2R := zeroed(t.MDT_DT2R);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY is
    variable y : HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY is
    variable y : HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY is
    variable y : HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY is
    variable y : HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ACTIONS);
    l := l + len(x.CONFIGS);
    l := l + len(x.MDT_DT2R);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ACTIONS);
    l := l + width(x.CONFIGS);
    l := l + width(x.MDT_DT2R);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ACTIONS)-1), vectorify(x.ACTIONS, y(left to left+len(x.ACTIONS)-1)));
      left := left + len(x.ACTIONS);
      assign(y(left to left+len(x.CONFIGS)-1), vectorify(x.CONFIGS, y(left to left+len(x.CONFIGS)-1)));
      left := left + len(x.CONFIGS);
      assign(y(left to left+len(x.MDT_DT2R)-1), vectorify(x.MDT_DT2R, y(left to left+len(x.MDT_DT2R)-1)));
    else
      assign(y(left downto left-len(x.ACTIONS)+1), vectorify(x.ACTIONS, y(left downto left-len(x.ACTIONS)+1)));
      left := left - len(x.ACTIONS);
      assign(y(left downto left-len(x.CONFIGS)+1), vectorify(x.CONFIGS, y(left downto left-len(x.CONFIGS)+1)));
      left := left - len(x.CONFIGS);
      assign(y(left downto left-len(x.MDT_DT2R)+1), vectorify(x.MDT_DT2R, y(left downto left-len(x.MDT_DT2R)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ACTIONS)-1), convert(x.ACTIONS, y(left to left+len(x.ACTIONS)-1)));
      left := left + len(x.ACTIONS);
      assign(y(left to left+len(x.CONFIGS)-1), convert(x.CONFIGS, y(left to left+len(x.CONFIGS)-1)));
      left := left + len(x.CONFIGS);
      assign(y(left to left+len(x.MDT_DT2R)-1), convert(x.MDT_DT2R, y(left to left+len(x.MDT_DT2R)-1)));
    else
      assign(y(left downto left-len(x.ACTIONS)+1), convert(x.ACTIONS, y(left downto left-len(x.ACTIONS)+1)));
      left := left - len(x.ACTIONS);
      assign(y(left downto left-len(x.CONFIGS)+1), convert(x.CONFIGS, y(left downto left-len(x.CONFIGS)+1)));
      left := left - len(x.CONFIGS);
      assign(y(left downto left-len(x.MDT_DT2R)+1), convert(x.MDT_DT2R, y(left downto left-len(x.MDT_DT2R)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ACTIONS := structify(x(left to left+len(y.ACTIONS)-1), y.ACTIONS);
      left := left + len(y.ACTIONS);
      y.CONFIGS := structify(x(left to left+len(y.CONFIGS)-1), y.CONFIGS);
      left := left + len(y.CONFIGS);
      y.MDT_DT2R := structify(x(left to left+len(y.MDT_DT2R)-1), y.MDT_DT2R);
    else
      y.ACTIONS := structify(x(left downto left-len(y.ACTIONS)+1), y.ACTIONS);
      left := left - len(y.ACTIONS);
      y.CONFIGS := structify(x(left downto left-len(y.CONFIGS)+1), y.CONFIGS);
      left := left - len(y.CONFIGS);
      y.MDT_DT2R := structify(x(left downto left-len(y.MDT_DT2R)+1), y.MDT_DT2R);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t is
    variable y: HPS_HEG_HEG_HP_HP_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ACTIONS := convert(x(left to left+len(y.ACTIONS)-1), y.ACTIONS);
      left := left + len(y.ACTIONS);
      y.CONFIGS := convert(x(left to left+len(y.CONFIGS)-1), y.CONFIGS);
      left := left + len(y.CONFIGS);
      y.MDT_DT2R := convert(x(left to left+len(y.MDT_DT2R)-1), y.MDT_DT2R);
    else
      y.ACTIONS := convert(x(left downto left-len(y.ACTIONS)+1), y.ACTIONS);
      left := left - len(y.ACTIONS);
      y.CONFIGS := convert(x(left downto left-len(y.CONFIGS)+1), y.CONFIGS);
      left := left - len(y.CONFIGS);
      y.MDT_DT2R := convert(x(left downto left-len(y.MDT_DT2R)+1), y.MDT_DT2R);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_CTRL_t;
  begin
    y.ACTIONS := nullify(t.ACTIONS);
    y.CONFIGS := nullify(t.CONFIGS);
    y.MDT_DT2R := nullify(t.MDT_DT2R);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t is
  variable y: HPS_HEG_HEG_HP_HP_CTRL_t;
  begin
    y.ACTIONS := zeroed(t.ACTIONS);
    y.CONFIGS := zeroed(t.CONFIGS);
    y.MDT_DT2R := zeroed(t.MDT_DT2R);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY is
    variable y : HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY is
    variable y : HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY is
    variable y : HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY is
    variable y : HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.HP);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.HP);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.HP)-1), vectorify(x.HP, y(left to left+len(x.HP)-1)));
    else
      assign(y(left downto left-len(x.HP)+1), vectorify(x.HP, y(left downto left-len(x.HP)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.HP)-1), convert(x.HP, y(left to left+len(x.HP)-1)));
    else
      assign(y(left downto left-len(x.HP)+1), convert(x.HP, y(left downto left-len(x.HP)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t is
    variable y: HPS_HEG_HEG_HP_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.HP := structify(x(left to left+len(y.HP)-1), y.HP);
    else
      y.HP := structify(x(left downto left-len(y.HP)+1), y.HP);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t is
    variable y: HPS_HEG_HEG_HP_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.HP := convert(x(left to left+len(y.HP)-1), y.HP);
    else
      y.HP := convert(x(left downto left-len(y.HP)+1), y.HP);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t is
  variable y: HPS_HEG_HEG_HP_MON_t;
  begin
    y.HP := nullify(t.HP);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t is
  variable y: HPS_HEG_HEG_HP_MON_t;
  begin
    y.HP := zeroed(t.HP);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_HP_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.HP);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_HP_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.HP);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_HP_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.HP)-1), vectorify(x.HP, y(left to left+len(x.HP)-1)));
    else
      assign(y(left downto left-len(x.HP)+1), vectorify(x.HP, y(left downto left-len(x.HP)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_HP_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.HP)-1), convert(x.HP, y(left to left+len(x.HP)-1)));
    else
      assign(y(left downto left-len(x.HP)+1), convert(x.HP, y(left downto left-len(x.HP)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t is
    variable y: HPS_HEG_HEG_HP_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.HP := structify(x(left to left+len(y.HP)-1), y.HP);
    else
      y.HP := structify(x(left downto left-len(y.HP)+1), y.HP);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t is
    variable y: HPS_HEG_HEG_HP_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.HP := convert(x(left to left+len(y.HP)-1), y.HP);
    else
      y.HP := convert(x(left downto left-len(y.HP)+1), y.HP);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t is
  variable y: HPS_HEG_HEG_HP_CTRL_t;
  begin
    y.HP := nullify(t.HP);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t is
  variable y: HPS_HEG_HEG_HP_CTRL_t;
  begin
    y.HP := zeroed(t.HP);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SUPER);
    l := l + len(x.CTRL);
    l := l + len(x.HP);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SUPER);
    l := l + width(x.CTRL);
    l := l + width(x.HP);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), vectorify(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.CTRL)-1), vectorify(x.CTRL, y(left to left+len(x.CTRL)-1)));
      left := left + len(x.CTRL);
      assign(y(left to left+len(x.HP)-1), vectorify(x.HP, y(left to left+len(x.HP)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), vectorify(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.CTRL)+1), vectorify(x.CTRL, y(left downto left-len(x.CTRL)+1)));
      left := left - len(x.CTRL);
      assign(y(left downto left-len(x.HP)+1), vectorify(x.HP, y(left downto left-len(x.HP)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), convert(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.CTRL)-1), convert(x.CTRL, y(left to left+len(x.CTRL)-1)));
      left := left + len(x.CTRL);
      assign(y(left to left+len(x.HP)-1), convert(x.HP, y(left to left+len(x.HP)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), convert(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.CTRL)+1), convert(x.CTRL, y(left downto left-len(x.CTRL)+1)));
      left := left - len(x.CTRL);
      assign(y(left downto left-len(x.HP)+1), convert(x.HP, y(left downto left-len(x.HP)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t is
    variable y: HPS_HEG_HEG_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := structify(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.CTRL := structify(x(left to left+len(y.CTRL)-1), y.CTRL);
      left := left + len(y.CTRL);
      y.HP := structify(x(left to left+len(y.HP)-1), y.HP);
    else
      y.SUPER := structify(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.CTRL := structify(x(left downto left-len(y.CTRL)+1), y.CTRL);
      left := left - len(y.CTRL);
      y.HP := structify(x(left downto left-len(y.HP)+1), y.HP);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t is
    variable y: HPS_HEG_HEG_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := convert(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.CTRL := convert(x(left to left+len(y.CTRL)-1), y.CTRL);
      left := left + len(y.CTRL);
      y.HP := convert(x(left to left+len(y.HP)-1), y.HP);
    else
      y.SUPER := convert(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.CTRL := convert(x(left downto left-len(y.CTRL)+1), y.CTRL);
      left := left - len(y.CTRL);
      y.HP := convert(x(left downto left-len(y.HP)+1), y.HP);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t is
  variable y: HPS_HEG_HEG_MON_t;
  begin
    y.SUPER := nullify(t.SUPER);
    y.CTRL := nullify(t.CTRL);
    y.HP := nullify(t.HP);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t is
  variable y: HPS_HEG_HEG_MON_t;
  begin
    y.SUPER := zeroed(t.SUPER);
    y.CTRL := zeroed(t.CTRL);
    y.HP := zeroed(t.HP);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY is
    variable y : HPS_HEG_HEG_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY is
    variable y : HPS_HEG_HEG_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY is
    variable y : HPS_HEG_HEG_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY is
    variable y : HPS_HEG_HEG_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SUPER);
    l := l + len(x.CTRL);
    l := l + len(x.HP);
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SUPER);
    l := l + width(x.CTRL);
    l := l + width(x.HP);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), vectorify(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.CTRL)-1), vectorify(x.CTRL, y(left to left+len(x.CTRL)-1)));
      left := left + len(x.CTRL);
      assign(y(left to left+len(x.HP)-1), vectorify(x.HP, y(left to left+len(x.HP)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), vectorify(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.CTRL)+1), vectorify(x.CTRL, y(left downto left-len(x.CTRL)+1)));
      left := left - len(x.CTRL);
      assign(y(left downto left-len(x.HP)+1), vectorify(x.HP, y(left downto left-len(x.HP)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), convert(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.CTRL)-1), convert(x.CTRL, y(left to left+len(x.CTRL)-1)));
      left := left + len(x.CTRL);
      assign(y(left to left+len(x.HP)-1), convert(x.HP, y(left to left+len(x.HP)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), convert(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.CTRL)+1), convert(x.CTRL, y(left downto left-len(x.CTRL)+1)));
      left := left - len(x.CTRL);
      assign(y(left downto left-len(x.HP)+1), convert(x.HP, y(left downto left-len(x.HP)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := structify(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.CTRL := structify(x(left to left+len(y.CTRL)-1), y.CTRL);
      left := left + len(y.CTRL);
      y.HP := structify(x(left to left+len(y.HP)-1), y.HP);
    else
      y.SUPER := structify(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.CTRL := structify(x(left downto left-len(y.CTRL)+1), y.CTRL);
      left := left - len(y.CTRL);
      y.HP := structify(x(left downto left-len(y.HP)+1), y.HP);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t is
    variable y: HPS_HEG_HEG_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := convert(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.CTRL := convert(x(left to left+len(y.CTRL)-1), y.CTRL);
      left := left + len(y.CTRL);
      y.HP := convert(x(left to left+len(y.HP)-1), y.HP);
    else
      y.SUPER := convert(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.CTRL := convert(x(left downto left-len(y.CTRL)+1), y.CTRL);
      left := left - len(y.CTRL);
      y.HP := convert(x(left downto left-len(y.HP)+1), y.HP);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_t;
  begin
    y.SUPER := nullify(t.SUPER);
    y.CTRL := nullify(t.CTRL);
    y.HP := nullify(t.HP);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t is
  variable y: HPS_HEG_HEG_CTRL_t;
  begin
    y.SUPER := zeroed(t.SUPER);
    y.CTRL := zeroed(t.CTRL);
    y.HP := zeroed(t.HP);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_HEG_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_HEG_HEG_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_HEG_HEG_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_HEG_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY is
    variable y : HPS_HEG_HEG_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY is
    variable y : HPS_HEG_HEG_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY is
    variable y : HPS_HEG_HEG_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY is
    variable y : HPS_HEG_HEG_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_HEG_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.HEG);
    return l;
  end function len;
  function width(x: HPS_HEG_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.HEG);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.HEG)-1), vectorify(x.HEG, y(left to left+len(x.HEG)-1)));
    else
      assign(y(left downto left-len(x.HEG)+1), vectorify(x.HEG, y(left downto left-len(x.HEG)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.HEG)-1), convert(x.HEG, y(left to left+len(x.HEG)-1)));
    else
      assign(y(left downto left-len(x.HEG)+1), convert(x.HEG, y(left downto left-len(x.HEG)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_MON_t) return HPS_HEG_MON_t is
    variable y: HPS_HEG_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.HEG := structify(x(left to left+len(y.HEG)-1), y.HEG);
    else
      y.HEG := structify(x(left downto left-len(y.HEG)+1), y.HEG);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_MON_t) return HPS_HEG_MON_t is
    variable y: HPS_HEG_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.HEG := convert(x(left to left+len(y.HEG)-1), y.HEG);
    else
      y.HEG := convert(x(left downto left-len(y.HEG)+1), y.HEG);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_MON_t) return HPS_HEG_MON_t is
  variable y: HPS_HEG_MON_t;
  begin
    y.HEG := nullify(t.HEG);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_MON_t) return HPS_HEG_MON_t is
  variable y: HPS_HEG_MON_t;
  begin
    y.HEG := zeroed(t.HEG);
    return y;
  end function zeroed;

  function len(x: HPS_HEG_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.HEG);
    return l;
  end function len;
  function width(x: HPS_HEG_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.HEG);
    return l;
  end function width;
  function vectorify(x: HPS_HEG_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.HEG)-1), vectorify(x.HEG, y(left to left+len(x.HEG)-1)));
    else
      assign(y(left downto left-len(x.HEG)+1), vectorify(x.HEG, y(left downto left-len(x.HEG)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_HEG_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.HEG)-1), convert(x.HEG, y(left to left+len(x.HEG)-1)));
    else
      assign(y(left downto left-len(x.HEG)+1), convert(x.HEG, y(left downto left-len(x.HEG)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t is
    variable y: HPS_HEG_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.HEG := structify(x(left to left+len(y.HEG)-1), y.HEG);
    else
      y.HEG := structify(x(left downto left-len(y.HEG)+1), y.HEG);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t is
    variable y: HPS_HEG_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.HEG := convert(x(left to left+len(y.HEG)-1), y.HEG);
    else
      y.HEG := convert(x(left downto left-len(y.HEG)+1), y.HEG);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t is
  variable y: HPS_HEG_CTRL_t;
  begin
    y.HEG := nullify(t.HEG);
    return y;
  end function nullify;
  function zeroed(t: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t is
  variable y: HPS_HEG_CTRL_t;
  begin
    y.HEG := zeroed(t.HEG);
    return y;
  end function zeroed;

  function len(x: HPS_LSF_LSF_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.STATUS);
    l := l + len(x.sb_lsf_mdt_hits_rdata_31_0);
    l := l + len(x.sb_lsf_mdt_hits_rdata_40_32);
    return l;
  end function len;
  function width(x: HPS_LSF_LSF_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.STATUS);
    l := l + width(x.sb_lsf_mdt_hits_rdata_31_0);
    l := l + width(x.sb_lsf_mdt_hits_rdata_40_32);
    return l;
  end function width;
  function vectorify(x: HPS_LSF_LSF_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), vectorify(x.STATUS, y(left to left+len(x.STATUS)-1)));
      left := left + len(x.STATUS);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_rdata_31_0)-1), vectorify(x.sb_lsf_mdt_hits_rdata_31_0, y(left to left+len(x.sb_lsf_mdt_hits_rdata_31_0)-1)));
      left := left + len(x.sb_lsf_mdt_hits_rdata_31_0);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_rdata_40_32)-1), vectorify(x.sb_lsf_mdt_hits_rdata_40_32, y(left to left+len(x.sb_lsf_mdt_hits_rdata_40_32)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), vectorify(x.STATUS, y(left downto left-len(x.STATUS)+1)));
      left := left - len(x.STATUS);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_rdata_31_0)+1), vectorify(x.sb_lsf_mdt_hits_rdata_31_0, y(left downto left-len(x.sb_lsf_mdt_hits_rdata_31_0)+1)));
      left := left - len(x.sb_lsf_mdt_hits_rdata_31_0);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_rdata_40_32)+1), vectorify(x.sb_lsf_mdt_hits_rdata_40_32, y(left downto left-len(x.sb_lsf_mdt_hits_rdata_40_32)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_LSF_LSF_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), convert(x.STATUS, y(left to left+len(x.STATUS)-1)));
      left := left + len(x.STATUS);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_rdata_31_0)-1), convert(x.sb_lsf_mdt_hits_rdata_31_0, y(left to left+len(x.sb_lsf_mdt_hits_rdata_31_0)-1)));
      left := left + len(x.sb_lsf_mdt_hits_rdata_31_0);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_rdata_40_32)-1), convert(x.sb_lsf_mdt_hits_rdata_40_32, y(left to left+len(x.sb_lsf_mdt_hits_rdata_40_32)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), convert(x.STATUS, y(left downto left-len(x.STATUS)+1)));
      left := left - len(x.STATUS);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_rdata_31_0)+1), convert(x.sb_lsf_mdt_hits_rdata_31_0, y(left downto left-len(x.sb_lsf_mdt_hits_rdata_31_0)+1)));
      left := left - len(x.sb_lsf_mdt_hits_rdata_31_0);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_rdata_40_32)+1), convert(x.sb_lsf_mdt_hits_rdata_40_32, y(left downto left-len(x.sb_lsf_mdt_hits_rdata_40_32)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t is
    variable y: HPS_LSF_LSF_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := structify(x(left to left+len(y.STATUS)-1), y.STATUS);
      left := left + len(y.STATUS);
      y.sb_lsf_mdt_hits_rdata_31_0 := structify(x(left to left+len(y.sb_lsf_mdt_hits_rdata_31_0)-1), y.sb_lsf_mdt_hits_rdata_31_0);
      left := left + len(y.sb_lsf_mdt_hits_rdata_31_0);
      y.sb_lsf_mdt_hits_rdata_40_32 := structify(x(left to left+len(y.sb_lsf_mdt_hits_rdata_40_32)-1), y.sb_lsf_mdt_hits_rdata_40_32);
    else
      y.STATUS := structify(x(left downto left-len(y.STATUS)+1), y.STATUS);
      left := left - len(y.STATUS);
      y.sb_lsf_mdt_hits_rdata_31_0 := structify(x(left downto left-len(y.sb_lsf_mdt_hits_rdata_31_0)+1), y.sb_lsf_mdt_hits_rdata_31_0);
      left := left - len(y.sb_lsf_mdt_hits_rdata_31_0);
      y.sb_lsf_mdt_hits_rdata_40_32 := structify(x(left downto left-len(y.sb_lsf_mdt_hits_rdata_40_32)+1), y.sb_lsf_mdt_hits_rdata_40_32);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t is
    variable y: HPS_LSF_LSF_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := convert(x(left to left+len(y.STATUS)-1), y.STATUS);
      left := left + len(y.STATUS);
      y.sb_lsf_mdt_hits_rdata_31_0 := convert(x(left to left+len(y.sb_lsf_mdt_hits_rdata_31_0)-1), y.sb_lsf_mdt_hits_rdata_31_0);
      left := left + len(y.sb_lsf_mdt_hits_rdata_31_0);
      y.sb_lsf_mdt_hits_rdata_40_32 := convert(x(left to left+len(y.sb_lsf_mdt_hits_rdata_40_32)-1), y.sb_lsf_mdt_hits_rdata_40_32);
    else
      y.STATUS := convert(x(left downto left-len(y.STATUS)+1), y.STATUS);
      left := left - len(y.STATUS);
      y.sb_lsf_mdt_hits_rdata_31_0 := convert(x(left downto left-len(y.sb_lsf_mdt_hits_rdata_31_0)+1), y.sb_lsf_mdt_hits_rdata_31_0);
      left := left - len(y.sb_lsf_mdt_hits_rdata_31_0);
      y.sb_lsf_mdt_hits_rdata_40_32 := convert(x(left downto left-len(y.sb_lsf_mdt_hits_rdata_40_32)+1), y.sb_lsf_mdt_hits_rdata_40_32);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t is
  variable y: HPS_LSF_LSF_MON_t;
  begin
    y.STATUS := nullify(t.STATUS);
    y.sb_lsf_mdt_hits_rdata_31_0 := nullify(t.sb_lsf_mdt_hits_rdata_31_0);
    y.sb_lsf_mdt_hits_rdata_40_32 := nullify(t.sb_lsf_mdt_hits_rdata_40_32);
    return y;
  end function nullify;
  function zeroed(t: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t is
  variable y: HPS_LSF_LSF_MON_t;
  begin
    y.STATUS := zeroed(t.STATUS);
    y.sb_lsf_mdt_hits_rdata_31_0 := zeroed(t.sb_lsf_mdt_hits_rdata_31_0);
    y.sb_lsf_mdt_hits_rdata_40_32 := zeroed(t.sb_lsf_mdt_hits_rdata_40_32);
    return y;
  end function zeroed;

  function len(x: HPS_LSF_LSF_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_LSF_LSF_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_LSF_LSF_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_LSF_LSF_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY is
    variable y : HPS_LSF_LSF_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY is
    variable y : HPS_LSF_LSF_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY is
    variable y : HPS_LSF_LSF_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY is
    variable y : HPS_LSF_LSF_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_LSF_LSF_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.RESET);
    l := l + len(x.HBA_MAX_CLOCKS);
    l := l + len(x.sb_lsf_mdt_hits_freeze);
    l := l + len(x.sb_lsf_mdt_hits_raddr);
    l := l + len(x.sb_lsf_mdt_hits_re);
    return l;
  end function len;
  function width(x: HPS_LSF_LSF_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.RESET);
    l := l + width(x.HBA_MAX_CLOCKS);
    l := l + width(x.sb_lsf_mdt_hits_freeze);
    l := l + width(x.sb_lsf_mdt_hits_raddr);
    l := l + width(x.sb_lsf_mdt_hits_re);
    return l;
  end function width;
  function vectorify(x: HPS_LSF_LSF_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), vectorify(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.HBA_MAX_CLOCKS)-1), vectorify(x.HBA_MAX_CLOCKS, y(left to left+len(x.HBA_MAX_CLOCKS)-1)));
      left := left + len(x.HBA_MAX_CLOCKS);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_freeze)-1), vectorify(x.sb_lsf_mdt_hits_freeze, y(left to left+len(x.sb_lsf_mdt_hits_freeze)-1)));
      left := left + len(x.sb_lsf_mdt_hits_freeze);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_raddr)-1), vectorify(x.sb_lsf_mdt_hits_raddr, y(left to left+len(x.sb_lsf_mdt_hits_raddr)-1)));
      left := left + len(x.sb_lsf_mdt_hits_raddr);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_re)-1), vectorify(x.sb_lsf_mdt_hits_re, y(left to left+len(x.sb_lsf_mdt_hits_re)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), vectorify(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.HBA_MAX_CLOCKS)+1), vectorify(x.HBA_MAX_CLOCKS, y(left downto left-len(x.HBA_MAX_CLOCKS)+1)));
      left := left - len(x.HBA_MAX_CLOCKS);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_freeze)+1), vectorify(x.sb_lsf_mdt_hits_freeze, y(left downto left-len(x.sb_lsf_mdt_hits_freeze)+1)));
      left := left - len(x.sb_lsf_mdt_hits_freeze);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_raddr)+1), vectorify(x.sb_lsf_mdt_hits_raddr, y(left downto left-len(x.sb_lsf_mdt_hits_raddr)+1)));
      left := left - len(x.sb_lsf_mdt_hits_raddr);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_re)+1), vectorify(x.sb_lsf_mdt_hits_re, y(left downto left-len(x.sb_lsf_mdt_hits_re)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_LSF_LSF_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), convert(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.HBA_MAX_CLOCKS)-1), convert(x.HBA_MAX_CLOCKS, y(left to left+len(x.HBA_MAX_CLOCKS)-1)));
      left := left + len(x.HBA_MAX_CLOCKS);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_freeze)-1), convert(x.sb_lsf_mdt_hits_freeze, y(left to left+len(x.sb_lsf_mdt_hits_freeze)-1)));
      left := left + len(x.sb_lsf_mdt_hits_freeze);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_raddr)-1), convert(x.sb_lsf_mdt_hits_raddr, y(left to left+len(x.sb_lsf_mdt_hits_raddr)-1)));
      left := left + len(x.sb_lsf_mdt_hits_raddr);
      assign(y(left to left+len(x.sb_lsf_mdt_hits_re)-1), convert(x.sb_lsf_mdt_hits_re, y(left to left+len(x.sb_lsf_mdt_hits_re)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), convert(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.HBA_MAX_CLOCKS)+1), convert(x.HBA_MAX_CLOCKS, y(left downto left-len(x.HBA_MAX_CLOCKS)+1)));
      left := left - len(x.HBA_MAX_CLOCKS);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_freeze)+1), convert(x.sb_lsf_mdt_hits_freeze, y(left downto left-len(x.sb_lsf_mdt_hits_freeze)+1)));
      left := left - len(x.sb_lsf_mdt_hits_freeze);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_raddr)+1), convert(x.sb_lsf_mdt_hits_raddr, y(left downto left-len(x.sb_lsf_mdt_hits_raddr)+1)));
      left := left - len(x.sb_lsf_mdt_hits_raddr);
      assign(y(left downto left-len(x.sb_lsf_mdt_hits_re)+1), convert(x.sb_lsf_mdt_hits_re, y(left downto left-len(x.sb_lsf_mdt_hits_re)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t is
    variable y: HPS_LSF_LSF_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := structify(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.HBA_MAX_CLOCKS := structify(x(left to left+len(y.HBA_MAX_CLOCKS)-1), y.HBA_MAX_CLOCKS);
      left := left + len(y.HBA_MAX_CLOCKS);
      y.sb_lsf_mdt_hits_freeze := structify(x(left to left+len(y.sb_lsf_mdt_hits_freeze)-1), y.sb_lsf_mdt_hits_freeze);
      left := left + len(y.sb_lsf_mdt_hits_freeze);
      y.sb_lsf_mdt_hits_raddr := structify(x(left to left+len(y.sb_lsf_mdt_hits_raddr)-1), y.sb_lsf_mdt_hits_raddr);
      left := left + len(y.sb_lsf_mdt_hits_raddr);
      y.sb_lsf_mdt_hits_re := structify(x(left to left+len(y.sb_lsf_mdt_hits_re)-1), y.sb_lsf_mdt_hits_re);
    else
      y.RESET := structify(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.HBA_MAX_CLOCKS := structify(x(left downto left-len(y.HBA_MAX_CLOCKS)+1), y.HBA_MAX_CLOCKS);
      left := left - len(y.HBA_MAX_CLOCKS);
      y.sb_lsf_mdt_hits_freeze := structify(x(left downto left-len(y.sb_lsf_mdt_hits_freeze)+1), y.sb_lsf_mdt_hits_freeze);
      left := left - len(y.sb_lsf_mdt_hits_freeze);
      y.sb_lsf_mdt_hits_raddr := structify(x(left downto left-len(y.sb_lsf_mdt_hits_raddr)+1), y.sb_lsf_mdt_hits_raddr);
      left := left - len(y.sb_lsf_mdt_hits_raddr);
      y.sb_lsf_mdt_hits_re := structify(x(left downto left-len(y.sb_lsf_mdt_hits_re)+1), y.sb_lsf_mdt_hits_re);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t is
    variable y: HPS_LSF_LSF_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := convert(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.HBA_MAX_CLOCKS := convert(x(left to left+len(y.HBA_MAX_CLOCKS)-1), y.HBA_MAX_CLOCKS);
      left := left + len(y.HBA_MAX_CLOCKS);
      y.sb_lsf_mdt_hits_freeze := convert(x(left to left+len(y.sb_lsf_mdt_hits_freeze)-1), y.sb_lsf_mdt_hits_freeze);
      left := left + len(y.sb_lsf_mdt_hits_freeze);
      y.sb_lsf_mdt_hits_raddr := convert(x(left to left+len(y.sb_lsf_mdt_hits_raddr)-1), y.sb_lsf_mdt_hits_raddr);
      left := left + len(y.sb_lsf_mdt_hits_raddr);
      y.sb_lsf_mdt_hits_re := convert(x(left to left+len(y.sb_lsf_mdt_hits_re)-1), y.sb_lsf_mdt_hits_re);
    else
      y.RESET := convert(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.HBA_MAX_CLOCKS := convert(x(left downto left-len(y.HBA_MAX_CLOCKS)+1), y.HBA_MAX_CLOCKS);
      left := left - len(y.HBA_MAX_CLOCKS);
      y.sb_lsf_mdt_hits_freeze := convert(x(left downto left-len(y.sb_lsf_mdt_hits_freeze)+1), y.sb_lsf_mdt_hits_freeze);
      left := left - len(y.sb_lsf_mdt_hits_freeze);
      y.sb_lsf_mdt_hits_raddr := convert(x(left downto left-len(y.sb_lsf_mdt_hits_raddr)+1), y.sb_lsf_mdt_hits_raddr);
      left := left - len(y.sb_lsf_mdt_hits_raddr);
      y.sb_lsf_mdt_hits_re := convert(x(left downto left-len(y.sb_lsf_mdt_hits_re)+1), y.sb_lsf_mdt_hits_re);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t is
  variable y: HPS_LSF_LSF_CTRL_t;
  begin
    y.RESET := nullify(t.RESET);
    y.HBA_MAX_CLOCKS := nullify(t.HBA_MAX_CLOCKS);
    y.sb_lsf_mdt_hits_freeze := nullify(t.sb_lsf_mdt_hits_freeze);
    y.sb_lsf_mdt_hits_raddr := nullify(t.sb_lsf_mdt_hits_raddr);
    y.sb_lsf_mdt_hits_re := nullify(t.sb_lsf_mdt_hits_re);
    return y;
  end function nullify;
  function zeroed(t: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t is
  variable y: HPS_LSF_LSF_CTRL_t;
  begin
    y.RESET := zeroed(t.RESET);
    y.HBA_MAX_CLOCKS := zeroed(t.HBA_MAX_CLOCKS);
    y.sb_lsf_mdt_hits_freeze := zeroed(t.sb_lsf_mdt_hits_freeze);
    y.sb_lsf_mdt_hits_raddr := zeroed(t.sb_lsf_mdt_hits_raddr);
    y.sb_lsf_mdt_hits_re := zeroed(t.sb_lsf_mdt_hits_re);
    return y;
  end function zeroed;

  function len(x: HPS_LSF_LSF_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_LSF_LSF_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_LSF_LSF_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_LSF_LSF_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY is
    variable y : HPS_LSF_LSF_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY is
    variable y : HPS_LSF_LSF_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY is
    variable y : HPS_LSF_LSF_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY is
    variable y : HPS_LSF_LSF_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_LSF_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.LSF);
    return l;
  end function len;
  function width(x: HPS_LSF_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.LSF);
    return l;
  end function width;
  function vectorify(x: HPS_LSF_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.LSF)-1), vectorify(x.LSF, y(left to left+len(x.LSF)-1)));
    else
      assign(y(left downto left-len(x.LSF)+1), vectorify(x.LSF, y(left downto left-len(x.LSF)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_LSF_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.LSF)-1), convert(x.LSF, y(left to left+len(x.LSF)-1)));
    else
      assign(y(left downto left-len(x.LSF)+1), convert(x.LSF, y(left downto left-len(x.LSF)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_LSF_MON_t) return HPS_LSF_MON_t is
    variable y: HPS_LSF_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.LSF := structify(x(left to left+len(y.LSF)-1), y.LSF);
    else
      y.LSF := structify(x(left downto left-len(y.LSF)+1), y.LSF);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_LSF_MON_t) return HPS_LSF_MON_t is
    variable y: HPS_LSF_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.LSF := convert(x(left to left+len(y.LSF)-1), y.LSF);
    else
      y.LSF := convert(x(left downto left-len(y.LSF)+1), y.LSF);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_LSF_MON_t) return HPS_LSF_MON_t is
  variable y: HPS_LSF_MON_t;
  begin
    y.LSF := nullify(t.LSF);
    return y;
  end function nullify;
  function zeroed(t: HPS_LSF_MON_t) return HPS_LSF_MON_t is
  variable y: HPS_LSF_MON_t;
  begin
    y.LSF := zeroed(t.LSF);
    return y;
  end function zeroed;

  function len(x: HPS_LSF_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.LSF);
    return l;
  end function len;
  function width(x: HPS_LSF_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.LSF);
    return l;
  end function width;
  function vectorify(x: HPS_LSF_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.LSF)-1), vectorify(x.LSF, y(left to left+len(x.LSF)-1)));
    else
      assign(y(left downto left-len(x.LSF)+1), vectorify(x.LSF, y(left downto left-len(x.LSF)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_LSF_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.LSF)-1), convert(x.LSF, y(left to left+len(x.LSF)-1)));
    else
      assign(y(left downto left-len(x.LSF)+1), convert(x.LSF, y(left downto left-len(x.LSF)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t is
    variable y: HPS_LSF_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.LSF := structify(x(left to left+len(y.LSF)-1), y.LSF);
    else
      y.LSF := structify(x(left downto left-len(y.LSF)+1), y.LSF);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t is
    variable y: HPS_LSF_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.LSF := convert(x(left to left+len(y.LSF)-1), y.LSF);
    else
      y.LSF := convert(x(left downto left-len(y.LSF)+1), y.LSF);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t is
  variable y: HPS_LSF_CTRL_t;
  begin
    y.LSF := nullify(t.LSF);
    return y;
  end function nullify;
  function zeroed(t: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t is
  variable y: HPS_LSF_CTRL_t;
  begin
    y.LSF := zeroed(t.LSF);
    return y;
  end function zeroed;

  function len(x: HPS_CSF_CSF_ACTIONS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.RESET);
    l := l + len(x.ENABLE);
    l := l + len(x.DISABLE);
    l := l + len(x.FREEZE);
    return l;
  end function len;
  function width(x: HPS_CSF_CSF_ACTIONS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.RESET);
    l := l + width(x.ENABLE);
    l := l + width(x.DISABLE);
    l := l + width(x.FREEZE);
    return l;
  end function width;
  function vectorify(x: HPS_CSF_CSF_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), vectorify(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.ENABLE)-1), vectorify(x.ENABLE, y(left to left+len(x.ENABLE)-1)));
      left := left + len(x.ENABLE);
      assign(y(left to left+len(x.DISABLE)-1), vectorify(x.DISABLE, y(left to left+len(x.DISABLE)-1)));
      left := left + len(x.DISABLE);
      assign(y(left to left+len(x.FREEZE)-1), vectorify(x.FREEZE, y(left to left+len(x.FREEZE)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), vectorify(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.ENABLE)+1), vectorify(x.ENABLE, y(left downto left-len(x.ENABLE)+1)));
      left := left - len(x.ENABLE);
      assign(y(left downto left-len(x.DISABLE)+1), vectorify(x.DISABLE, y(left downto left-len(x.DISABLE)+1)));
      left := left - len(x.DISABLE);
      assign(y(left downto left-len(x.FREEZE)+1), vectorify(x.FREEZE, y(left downto left-len(x.FREEZE)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_CSF_CSF_ACTIONS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.RESET)-1), convert(x.RESET, y(left to left+len(x.RESET)-1)));
      left := left + len(x.RESET);
      assign(y(left to left+len(x.ENABLE)-1), convert(x.ENABLE, y(left to left+len(x.ENABLE)-1)));
      left := left + len(x.ENABLE);
      assign(y(left to left+len(x.DISABLE)-1), convert(x.DISABLE, y(left to left+len(x.DISABLE)-1)));
      left := left + len(x.DISABLE);
      assign(y(left to left+len(x.FREEZE)-1), convert(x.FREEZE, y(left to left+len(x.FREEZE)-1)));
    else
      assign(y(left downto left-len(x.RESET)+1), convert(x.RESET, y(left downto left-len(x.RESET)+1)));
      left := left - len(x.RESET);
      assign(y(left downto left-len(x.ENABLE)+1), convert(x.ENABLE, y(left downto left-len(x.ENABLE)+1)));
      left := left - len(x.ENABLE);
      assign(y(left downto left-len(x.DISABLE)+1), convert(x.DISABLE, y(left downto left-len(x.DISABLE)+1)));
      left := left - len(x.DISABLE);
      assign(y(left downto left-len(x.FREEZE)+1), convert(x.FREEZE, y(left downto left-len(x.FREEZE)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t is
    variable y: HPS_CSF_CSF_ACTIONS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := structify(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.ENABLE := structify(x(left to left+len(y.ENABLE)-1), y.ENABLE);
      left := left + len(y.ENABLE);
      y.DISABLE := structify(x(left to left+len(y.DISABLE)-1), y.DISABLE);
      left := left + len(y.DISABLE);
      y.FREEZE := structify(x(left to left+len(y.FREEZE)-1), y.FREEZE);
    else
      y.RESET := structify(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.ENABLE := structify(x(left downto left-len(y.ENABLE)+1), y.ENABLE);
      left := left - len(y.ENABLE);
      y.DISABLE := structify(x(left downto left-len(y.DISABLE)+1), y.DISABLE);
      left := left - len(y.DISABLE);
      y.FREEZE := structify(x(left downto left-len(y.FREEZE)+1), y.FREEZE);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t is
    variable y: HPS_CSF_CSF_ACTIONS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.RESET := convert(x(left to left+len(y.RESET)-1), y.RESET);
      left := left + len(y.RESET);
      y.ENABLE := convert(x(left to left+len(y.ENABLE)-1), y.ENABLE);
      left := left + len(y.ENABLE);
      y.DISABLE := convert(x(left to left+len(y.DISABLE)-1), y.DISABLE);
      left := left + len(y.DISABLE);
      y.FREEZE := convert(x(left to left+len(y.FREEZE)-1), y.FREEZE);
    else
      y.RESET := convert(x(left downto left-len(y.RESET)+1), y.RESET);
      left := left - len(y.RESET);
      y.ENABLE := convert(x(left downto left-len(y.ENABLE)+1), y.ENABLE);
      left := left - len(y.ENABLE);
      y.DISABLE := convert(x(left downto left-len(y.DISABLE)+1), y.DISABLE);
      left := left - len(y.DISABLE);
      y.FREEZE := convert(x(left downto left-len(y.FREEZE)+1), y.FREEZE);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t is
  variable y: HPS_CSF_CSF_ACTIONS_CTRL_t;
  begin
    y.RESET := nullify(t.RESET);
    y.ENABLE := nullify(t.ENABLE);
    y.DISABLE := nullify(t.DISABLE);
    y.FREEZE := nullify(t.FREEZE);
    return y;
  end function nullify;
  function zeroed(t: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t is
  variable y: HPS_CSF_CSF_ACTIONS_CTRL_t;
  begin
    y.RESET := zeroed(t.RESET);
    y.ENABLE := zeroed(t.ENABLE);
    y.DISABLE := zeroed(t.DISABLE);
    y.FREEZE := zeroed(t.FREEZE);
    return y;
  end function zeroed;

  function len(x: HPS_CSF_CSF_STATUS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ENABLED);
    l := l + len(x.READY);
    l := l + len(x.ERROR);
    return l;
  end function len;
  function width(x: HPS_CSF_CSF_STATUS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ENABLED);
    l := l + width(x.READY);
    l := l + width(x.ERROR);
    return l;
  end function width;
  function vectorify(x: HPS_CSF_CSF_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ENABLED)-1), vectorify(x.ENABLED, y(left to left+len(x.ENABLED)-1)));
      left := left + len(x.ENABLED);
      assign(y(left to left+len(x.READY)-1), vectorify(x.READY, y(left to left+len(x.READY)-1)));
      left := left + len(x.READY);
      assign(y(left to left+len(x.ERROR)-1), vectorify(x.ERROR, y(left to left+len(x.ERROR)-1)));
    else
      assign(y(left downto left-len(x.ENABLED)+1), vectorify(x.ENABLED, y(left downto left-len(x.ENABLED)+1)));
      left := left - len(x.ENABLED);
      assign(y(left downto left-len(x.READY)+1), vectorify(x.READY, y(left downto left-len(x.READY)+1)));
      left := left - len(x.READY);
      assign(y(left downto left-len(x.ERROR)+1), vectorify(x.ERROR, y(left downto left-len(x.ERROR)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_CSF_CSF_STATUS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ENABLED)-1), convert(x.ENABLED, y(left to left+len(x.ENABLED)-1)));
      left := left + len(x.ENABLED);
      assign(y(left to left+len(x.READY)-1), convert(x.READY, y(left to left+len(x.READY)-1)));
      left := left + len(x.READY);
      assign(y(left to left+len(x.ERROR)-1), convert(x.ERROR, y(left to left+len(x.ERROR)-1)));
    else
      assign(y(left downto left-len(x.ENABLED)+1), convert(x.ENABLED, y(left downto left-len(x.ENABLED)+1)));
      left := left - len(x.ENABLED);
      assign(y(left downto left-len(x.READY)+1), convert(x.READY, y(left downto left-len(x.READY)+1)));
      left := left - len(x.READY);
      assign(y(left downto left-len(x.ERROR)+1), convert(x.ERROR, y(left downto left-len(x.ERROR)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t is
    variable y: HPS_CSF_CSF_STATUS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ENABLED := structify(x(left to left+len(y.ENABLED)-1), y.ENABLED);
      left := left + len(y.ENABLED);
      y.READY := structify(x(left to left+len(y.READY)-1), y.READY);
      left := left + len(y.READY);
      y.ERROR := structify(x(left to left+len(y.ERROR)-1), y.ERROR);
    else
      y.ENABLED := structify(x(left downto left-len(y.ENABLED)+1), y.ENABLED);
      left := left - len(y.ENABLED);
      y.READY := structify(x(left downto left-len(y.READY)+1), y.READY);
      left := left - len(y.READY);
      y.ERROR := structify(x(left downto left-len(y.ERROR)+1), y.ERROR);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t is
    variable y: HPS_CSF_CSF_STATUS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ENABLED := convert(x(left to left+len(y.ENABLED)-1), y.ENABLED);
      left := left + len(y.ENABLED);
      y.READY := convert(x(left to left+len(y.READY)-1), y.READY);
      left := left + len(y.READY);
      y.ERROR := convert(x(left to left+len(y.ERROR)-1), y.ERROR);
    else
      y.ENABLED := convert(x(left downto left-len(y.ENABLED)+1), y.ENABLED);
      left := left - len(y.ENABLED);
      y.READY := convert(x(left downto left-len(y.READY)+1), y.READY);
      left := left - len(y.READY);
      y.ERROR := convert(x(left downto left-len(y.ERROR)+1), y.ERROR);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t is
  variable y: HPS_CSF_CSF_STATUS_MON_t;
  begin
    y.ENABLED := nullify(t.ENABLED);
    y.READY := nullify(t.READY);
    y.ERROR := nullify(t.ERROR);
    return y;
  end function nullify;
  function zeroed(t: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t is
  variable y: HPS_CSF_CSF_STATUS_MON_t;
  begin
    y.ENABLED := zeroed(t.ENABLED);
    y.READY := zeroed(t.READY);
    y.ERROR := zeroed(t.ERROR);
    return y;
  end function zeroed;

  function len(x: HPS_CSF_CSF_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.STATUS);
    return l;
  end function len;
  function width(x: HPS_CSF_CSF_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.STATUS);
    return l;
  end function width;
  function vectorify(x: HPS_CSF_CSF_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), vectorify(x.STATUS, y(left to left+len(x.STATUS)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), vectorify(x.STATUS, y(left downto left-len(x.STATUS)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_CSF_CSF_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.STATUS)-1), convert(x.STATUS, y(left to left+len(x.STATUS)-1)));
    else
      assign(y(left downto left-len(x.STATUS)+1), convert(x.STATUS, y(left downto left-len(x.STATUS)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t is
    variable y: HPS_CSF_CSF_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := structify(x(left to left+len(y.STATUS)-1), y.STATUS);
    else
      y.STATUS := structify(x(left downto left-len(y.STATUS)+1), y.STATUS);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t is
    variable y: HPS_CSF_CSF_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.STATUS := convert(x(left to left+len(y.STATUS)-1), y.STATUS);
    else
      y.STATUS := convert(x(left downto left-len(y.STATUS)+1), y.STATUS);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t is
  variable y: HPS_CSF_CSF_MON_t;
  begin
    y.STATUS := nullify(t.STATUS);
    return y;
  end function nullify;
  function zeroed(t: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t is
  variable y: HPS_CSF_CSF_MON_t;
  begin
    y.STATUS := zeroed(t.STATUS);
    return y;
  end function zeroed;

  function len(x: HPS_CSF_CSF_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_CSF_CSF_MON_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_CSF_CSF_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_CSF_CSF_MON_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY is
    variable y : HPS_CSF_CSF_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY is
    variable y : HPS_CSF_CSF_MON_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY is
    variable y : HPS_CSF_CSF_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY is
    variable y : HPS_CSF_CSF_MON_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_CSF_CSF_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.ACTIONS);
    return l;
  end function len;
  function width(x: HPS_CSF_CSF_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.ACTIONS);
    return l;
  end function width;
  function vectorify(x: HPS_CSF_CSF_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ACTIONS)-1), vectorify(x.ACTIONS, y(left to left+len(x.ACTIONS)-1)));
    else
      assign(y(left downto left-len(x.ACTIONS)+1), vectorify(x.ACTIONS, y(left downto left-len(x.ACTIONS)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_CSF_CSF_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.ACTIONS)-1), convert(x.ACTIONS, y(left to left+len(x.ACTIONS)-1)));
    else
      assign(y(left downto left-len(x.ACTIONS)+1), convert(x.ACTIONS, y(left downto left-len(x.ACTIONS)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t is
    variable y: HPS_CSF_CSF_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ACTIONS := structify(x(left to left+len(y.ACTIONS)-1), y.ACTIONS);
    else
      y.ACTIONS := structify(x(left downto left-len(y.ACTIONS)+1), y.ACTIONS);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t is
    variable y: HPS_CSF_CSF_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.ACTIONS := convert(x(left to left+len(y.ACTIONS)-1), y.ACTIONS);
    else
      y.ACTIONS := convert(x(left downto left-len(y.ACTIONS)+1), y.ACTIONS);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t is
  variable y: HPS_CSF_CSF_CTRL_t;
  begin
    y.ACTIONS := nullify(t.ACTIONS);
    return y;
  end function nullify;
  function zeroed(t: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t is
  variable y: HPS_CSF_CSF_CTRL_t;
  begin
    y.ACTIONS := zeroed(t.ACTIONS);
    return y;
  end function zeroed;

  function len(x: HPS_CSF_CSF_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: HPS_CSF_CSF_CTRL_t_ARRAY) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: HPS_CSF_CSF_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_CSF_CSF_CTRL_t_ARRAY; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY is
    variable y : HPS_CSF_CSF_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY is
    variable y : HPS_CSF_CSF_CTRL_t_ARRAY;
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY is
    variable y : HPS_CSF_CSF_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY is
    variable y : HPS_CSF_CSF_CTRL_t_ARRAY;
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: HPS_CSF_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.CSF);
    return l;
  end function len;
  function width(x: HPS_CSF_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.CSF);
    return l;
  end function width;
  function vectorify(x: HPS_CSF_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CSF)-1), vectorify(x.CSF, y(left to left+len(x.CSF)-1)));
    else
      assign(y(left downto left-len(x.CSF)+1), vectorify(x.CSF, y(left downto left-len(x.CSF)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_CSF_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CSF)-1), convert(x.CSF, y(left to left+len(x.CSF)-1)));
    else
      assign(y(left downto left-len(x.CSF)+1), convert(x.CSF, y(left downto left-len(x.CSF)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_CSF_MON_t) return HPS_CSF_MON_t is
    variable y: HPS_CSF_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CSF := structify(x(left to left+len(y.CSF)-1), y.CSF);
    else
      y.CSF := structify(x(left downto left-len(y.CSF)+1), y.CSF);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_CSF_MON_t) return HPS_CSF_MON_t is
    variable y: HPS_CSF_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CSF := convert(x(left to left+len(y.CSF)-1), y.CSF);
    else
      y.CSF := convert(x(left downto left-len(y.CSF)+1), y.CSF);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_CSF_MON_t) return HPS_CSF_MON_t is
  variable y: HPS_CSF_MON_t;
  begin
    y.CSF := nullify(t.CSF);
    return y;
  end function nullify;
  function zeroed(t: HPS_CSF_MON_t) return HPS_CSF_MON_t is
  variable y: HPS_CSF_MON_t;
  begin
    y.CSF := zeroed(t.CSF);
    return y;
  end function zeroed;

  function len(x: HPS_CSF_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.CSF);
    return l;
  end function len;
  function width(x: HPS_CSF_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.CSF);
    return l;
  end function width;
  function vectorify(x: HPS_CSF_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CSF)-1), vectorify(x.CSF, y(left to left+len(x.CSF)-1)));
    else
      assign(y(left downto left-len(x.CSF)+1), vectorify(x.CSF, y(left downto left-len(x.CSF)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_CSF_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.CSF)-1), convert(x.CSF, y(left to left+len(x.CSF)-1)));
    else
      assign(y(left downto left-len(x.CSF)+1), convert(x.CSF, y(left downto left-len(x.CSF)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t is
    variable y: HPS_CSF_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CSF := structify(x(left to left+len(y.CSF)-1), y.CSF);
    else
      y.CSF := structify(x(left downto left-len(y.CSF)+1), y.CSF);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t is
    variable y: HPS_CSF_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.CSF := convert(x(left to left+len(y.CSF)-1), y.CSF);
    else
      y.CSF := convert(x(left downto left-len(y.CSF)+1), y.CSF);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t is
  variable y: HPS_CSF_CTRL_t;
  begin
    y.CSF := nullify(t.CSF);
    return y;
  end function nullify;
  function zeroed(t: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t is
  variable y: HPS_CSF_CTRL_t;
  begin
    y.CSF := zeroed(t.CSF);
    return y;
  end function zeroed;

  function len(x: HPS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SUPER);
    l := l + len(x.MDT_TC);
    l := l + len(x.MDT_T0);
    l := l + len(x.HEG);
    l := l + len(x.LSF);
    l := l + len(x.CSF);
    return l;
  end function len;
  function width(x: HPS_MON_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SUPER);
    l := l + width(x.MDT_TC);
    l := l + width(x.MDT_T0);
    l := l + width(x.HEG);
    l := l + width(x.LSF);
    l := l + width(x.CSF);
    return l;
  end function width;
  function vectorify(x: HPS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), vectorify(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.MDT_TC)-1), vectorify(x.MDT_TC, y(left to left+len(x.MDT_TC)-1)));
      left := left + len(x.MDT_TC);
      assign(y(left to left+len(x.MDT_T0)-1), vectorify(x.MDT_T0, y(left to left+len(x.MDT_T0)-1)));
      left := left + len(x.MDT_T0);
      assign(y(left to left+len(x.HEG)-1), vectorify(x.HEG, y(left to left+len(x.HEG)-1)));
      left := left + len(x.HEG);
      assign(y(left to left+len(x.LSF)-1), vectorify(x.LSF, y(left to left+len(x.LSF)-1)));
      left := left + len(x.LSF);
      assign(y(left to left+len(x.CSF)-1), vectorify(x.CSF, y(left to left+len(x.CSF)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), vectorify(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.MDT_TC)+1), vectorify(x.MDT_TC, y(left downto left-len(x.MDT_TC)+1)));
      left := left - len(x.MDT_TC);
      assign(y(left downto left-len(x.MDT_T0)+1), vectorify(x.MDT_T0, y(left downto left-len(x.MDT_T0)+1)));
      left := left - len(x.MDT_T0);
      assign(y(left downto left-len(x.HEG)+1), vectorify(x.HEG, y(left downto left-len(x.HEG)+1)));
      left := left - len(x.HEG);
      assign(y(left downto left-len(x.LSF)+1), vectorify(x.LSF, y(left downto left-len(x.LSF)+1)));
      left := left - len(x.LSF);
      assign(y(left downto left-len(x.CSF)+1), vectorify(x.CSF, y(left downto left-len(x.CSF)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_MON_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), convert(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.MDT_TC)-1), convert(x.MDT_TC, y(left to left+len(x.MDT_TC)-1)));
      left := left + len(x.MDT_TC);
      assign(y(left to left+len(x.MDT_T0)-1), convert(x.MDT_T0, y(left to left+len(x.MDT_T0)-1)));
      left := left + len(x.MDT_T0);
      assign(y(left to left+len(x.HEG)-1), convert(x.HEG, y(left to left+len(x.HEG)-1)));
      left := left + len(x.HEG);
      assign(y(left to left+len(x.LSF)-1), convert(x.LSF, y(left to left+len(x.LSF)-1)));
      left := left + len(x.LSF);
      assign(y(left to left+len(x.CSF)-1), convert(x.CSF, y(left to left+len(x.CSF)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), convert(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.MDT_TC)+1), convert(x.MDT_TC, y(left downto left-len(x.MDT_TC)+1)));
      left := left - len(x.MDT_TC);
      assign(y(left downto left-len(x.MDT_T0)+1), convert(x.MDT_T0, y(left downto left-len(x.MDT_T0)+1)));
      left := left - len(x.MDT_T0);
      assign(y(left downto left-len(x.HEG)+1), convert(x.HEG, y(left downto left-len(x.HEG)+1)));
      left := left - len(x.HEG);
      assign(y(left downto left-len(x.LSF)+1), convert(x.LSF, y(left downto left-len(x.LSF)+1)));
      left := left - len(x.LSF);
      assign(y(left downto left-len(x.CSF)+1), convert(x.CSF, y(left downto left-len(x.CSF)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_MON_t) return HPS_MON_t is
    variable y: HPS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := structify(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.MDT_TC := structify(x(left to left+len(y.MDT_TC)-1), y.MDT_TC);
      left := left + len(y.MDT_TC);
      y.MDT_T0 := structify(x(left to left+len(y.MDT_T0)-1), y.MDT_T0);
      left := left + len(y.MDT_T0);
      y.HEG := structify(x(left to left+len(y.HEG)-1), y.HEG);
      left := left + len(y.HEG);
      y.LSF := structify(x(left to left+len(y.LSF)-1), y.LSF);
      left := left + len(y.LSF);
      y.CSF := structify(x(left to left+len(y.CSF)-1), y.CSF);
    else
      y.SUPER := structify(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.MDT_TC := structify(x(left downto left-len(y.MDT_TC)+1), y.MDT_TC);
      left := left - len(y.MDT_TC);
      y.MDT_T0 := structify(x(left downto left-len(y.MDT_T0)+1), y.MDT_T0);
      left := left - len(y.MDT_T0);
      y.HEG := structify(x(left downto left-len(y.HEG)+1), y.HEG);
      left := left - len(y.HEG);
      y.LSF := structify(x(left downto left-len(y.LSF)+1), y.LSF);
      left := left - len(y.LSF);
      y.CSF := structify(x(left downto left-len(y.CSF)+1), y.CSF);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_MON_t) return HPS_MON_t is
    variable y: HPS_MON_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := convert(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.MDT_TC := convert(x(left to left+len(y.MDT_TC)-1), y.MDT_TC);
      left := left + len(y.MDT_TC);
      y.MDT_T0 := convert(x(left to left+len(y.MDT_T0)-1), y.MDT_T0);
      left := left + len(y.MDT_T0);
      y.HEG := convert(x(left to left+len(y.HEG)-1), y.HEG);
      left := left + len(y.HEG);
      y.LSF := convert(x(left to left+len(y.LSF)-1), y.LSF);
      left := left + len(y.LSF);
      y.CSF := convert(x(left to left+len(y.CSF)-1), y.CSF);
    else
      y.SUPER := convert(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.MDT_TC := convert(x(left downto left-len(y.MDT_TC)+1), y.MDT_TC);
      left := left - len(y.MDT_TC);
      y.MDT_T0 := convert(x(left downto left-len(y.MDT_T0)+1), y.MDT_T0);
      left := left - len(y.MDT_T0);
      y.HEG := convert(x(left downto left-len(y.HEG)+1), y.HEG);
      left := left - len(y.HEG);
      y.LSF := convert(x(left downto left-len(y.LSF)+1), y.LSF);
      left := left - len(y.LSF);
      y.CSF := convert(x(left downto left-len(y.CSF)+1), y.CSF);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_MON_t) return HPS_MON_t is
  variable y: HPS_MON_t;
  begin
    y.SUPER := nullify(t.SUPER);
    y.MDT_TC := nullify(t.MDT_TC);
    y.MDT_T0 := nullify(t.MDT_T0);
    y.HEG := nullify(t.HEG);
    y.LSF := nullify(t.LSF);
    y.CSF := nullify(t.CSF);
    return y;
  end function nullify;
  function zeroed(t: HPS_MON_t) return HPS_MON_t is
  variable y: HPS_MON_t;
  begin
    y.SUPER := zeroed(t.SUPER);
    y.MDT_TC := zeroed(t.MDT_TC);
    y.MDT_T0 := zeroed(t.MDT_T0);
    y.HEG := zeroed(t.HEG);
    y.LSF := zeroed(t.LSF);
    y.CSF := zeroed(t.CSF);
    return y;
  end function zeroed;

  function len(x: HPS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.SUPER);
    l := l + len(x.MDT_TC);
    l := l + len(x.MDT_T0);
    l := l + len(x.HEG);
    l := l + len(x.LSF);
    l := l + len(x.CSF);
    return l;
  end function len;
  function width(x: HPS_CTRL_t) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.SUPER);
    l := l + width(x.MDT_TC);
    l := l + width(x.MDT_T0);
    l := l + width(x.HEG);
    l := l + width(x.LSF);
    l := l + width(x.CSF);
    return l;
  end function width;
  function vectorify(x: HPS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), vectorify(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.MDT_TC)-1), vectorify(x.MDT_TC, y(left to left+len(x.MDT_TC)-1)));
      left := left + len(x.MDT_TC);
      assign(y(left to left+len(x.MDT_T0)-1), vectorify(x.MDT_T0, y(left to left+len(x.MDT_T0)-1)));
      left := left + len(x.MDT_T0);
      assign(y(left to left+len(x.HEG)-1), vectorify(x.HEG, y(left to left+len(x.HEG)-1)));
      left := left + len(x.HEG);
      assign(y(left to left+len(x.LSF)-1), vectorify(x.LSF, y(left to left+len(x.LSF)-1)));
      left := left + len(x.LSF);
      assign(y(left to left+len(x.CSF)-1), vectorify(x.CSF, y(left to left+len(x.CSF)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), vectorify(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.MDT_TC)+1), vectorify(x.MDT_TC, y(left downto left-len(x.MDT_TC)+1)));
      left := left - len(x.MDT_TC);
      assign(y(left downto left-len(x.MDT_T0)+1), vectorify(x.MDT_T0, y(left downto left-len(x.MDT_T0)+1)));
      left := left - len(x.MDT_T0);
      assign(y(left downto left-len(x.HEG)+1), vectorify(x.HEG, y(left downto left-len(x.HEG)+1)));
      left := left - len(x.HEG);
      assign(y(left downto left-len(x.LSF)+1), vectorify(x.LSF, y(left downto left-len(x.LSF)+1)));
      left := left - len(x.LSF);
      assign(y(left downto left-len(x.CSF)+1), vectorify(x.CSF, y(left downto left-len(x.CSF)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: HPS_CTRL_t; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.SUPER)-1), convert(x.SUPER, y(left to left+len(x.SUPER)-1)));
      left := left + len(x.SUPER);
      assign(y(left to left+len(x.MDT_TC)-1), convert(x.MDT_TC, y(left to left+len(x.MDT_TC)-1)));
      left := left + len(x.MDT_TC);
      assign(y(left to left+len(x.MDT_T0)-1), convert(x.MDT_T0, y(left to left+len(x.MDT_T0)-1)));
      left := left + len(x.MDT_T0);
      assign(y(left to left+len(x.HEG)-1), convert(x.HEG, y(left to left+len(x.HEG)-1)));
      left := left + len(x.HEG);
      assign(y(left to left+len(x.LSF)-1), convert(x.LSF, y(left to left+len(x.LSF)-1)));
      left := left + len(x.LSF);
      assign(y(left to left+len(x.CSF)-1), convert(x.CSF, y(left to left+len(x.CSF)-1)));
    else
      assign(y(left downto left-len(x.SUPER)+1), convert(x.SUPER, y(left downto left-len(x.SUPER)+1)));
      left := left - len(x.SUPER);
      assign(y(left downto left-len(x.MDT_TC)+1), convert(x.MDT_TC, y(left downto left-len(x.MDT_TC)+1)));
      left := left - len(x.MDT_TC);
      assign(y(left downto left-len(x.MDT_T0)+1), convert(x.MDT_T0, y(left downto left-len(x.MDT_T0)+1)));
      left := left - len(x.MDT_T0);
      assign(y(left downto left-len(x.HEG)+1), convert(x.HEG, y(left downto left-len(x.HEG)+1)));
      left := left - len(x.HEG);
      assign(y(left downto left-len(x.LSF)+1), convert(x.LSF, y(left downto left-len(x.LSF)+1)));
      left := left - len(x.LSF);
      assign(y(left downto left-len(x.CSF)+1), convert(x.CSF, y(left downto left-len(x.CSF)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: HPS_CTRL_t) return HPS_CTRL_t is
    variable y: HPS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := structify(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.MDT_TC := structify(x(left to left+len(y.MDT_TC)-1), y.MDT_TC);
      left := left + len(y.MDT_TC);
      y.MDT_T0 := structify(x(left to left+len(y.MDT_T0)-1), y.MDT_T0);
      left := left + len(y.MDT_T0);
      y.HEG := structify(x(left to left+len(y.HEG)-1), y.HEG);
      left := left + len(y.HEG);
      y.LSF := structify(x(left to left+len(y.LSF)-1), y.LSF);
      left := left + len(y.LSF);
      y.CSF := structify(x(left to left+len(y.CSF)-1), y.CSF);
    else
      y.SUPER := structify(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.MDT_TC := structify(x(left downto left-len(y.MDT_TC)+1), y.MDT_TC);
      left := left - len(y.MDT_TC);
      y.MDT_T0 := structify(x(left downto left-len(y.MDT_T0)+1), y.MDT_T0);
      left := left - len(y.MDT_T0);
      y.HEG := structify(x(left downto left-len(y.HEG)+1), y.HEG);
      left := left - len(y.HEG);
      y.LSF := structify(x(left downto left-len(y.LSF)+1), y.LSF);
      left := left - len(y.LSF);
      y.CSF := structify(x(left downto left-len(y.CSF)+1), y.CSF);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: HPS_CTRL_t) return HPS_CTRL_t is
    variable y: HPS_CTRL_t;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.SUPER := convert(x(left to left+len(y.SUPER)-1), y.SUPER);
      left := left + len(y.SUPER);
      y.MDT_TC := convert(x(left to left+len(y.MDT_TC)-1), y.MDT_TC);
      left := left + len(y.MDT_TC);
      y.MDT_T0 := convert(x(left to left+len(y.MDT_T0)-1), y.MDT_T0);
      left := left + len(y.MDT_T0);
      y.HEG := convert(x(left to left+len(y.HEG)-1), y.HEG);
      left := left + len(y.HEG);
      y.LSF := convert(x(left to left+len(y.LSF)-1), y.LSF);
      left := left + len(y.LSF);
      y.CSF := convert(x(left to left+len(y.CSF)-1), y.CSF);
    else
      y.SUPER := convert(x(left downto left-len(y.SUPER)+1), y.SUPER);
      left := left - len(y.SUPER);
      y.MDT_TC := convert(x(left downto left-len(y.MDT_TC)+1), y.MDT_TC);
      left := left - len(y.MDT_TC);
      y.MDT_T0 := convert(x(left downto left-len(y.MDT_T0)+1), y.MDT_T0);
      left := left - len(y.MDT_T0);
      y.HEG := convert(x(left downto left-len(y.HEG)+1), y.HEG);
      left := left - len(y.HEG);
      y.LSF := convert(x(left downto left-len(y.LSF)+1), y.LSF);
      left := left - len(y.LSF);
      y.CSF := convert(x(left downto left-len(y.CSF)+1), y.CSF);
    end if;
    return y;
  end function convert;
  function nullify(t: HPS_CTRL_t) return HPS_CTRL_t is
  variable y: HPS_CTRL_t;
  begin
    y.SUPER := nullify(t.SUPER);
    y.MDT_TC := nullify(t.MDT_TC);
    y.MDT_T0 := nullify(t.MDT_T0);
    y.HEG := nullify(t.HEG);
    y.LSF := nullify(t.LSF);
    y.CSF := nullify(t.CSF);
    return y;
  end function nullify;
  function zeroed(t: HPS_CTRL_t) return HPS_CTRL_t is
  variable y: HPS_CTRL_t;
  begin
    y.SUPER := zeroed(t.SUPER);
    y.MDT_TC := zeroed(t.MDT_TC);
    y.MDT_T0 := zeroed(t.MDT_T0);
    y.HEG := zeroed(t.HEG);
    y.LSF := zeroed(t.LSF);
    y.CSF := zeroed(t.CSF);
    return y;
  end function zeroed;

end package body HPS_CTRL;
