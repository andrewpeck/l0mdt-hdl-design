-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl
-- 2023-10-16 13:23:06

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package HPS_CTRL is

   -- Custom types and functions --

   type HPS_SUPER_ACTIONS_CTRL_t is record
      RESET : std_logic;
      ENABLE : std_logic;
      DISABLE : std_logic;
      FREEZE : std_logic;
   end record HPS_SUPER_ACTIONS_CTRL_t;
   attribute w of HPS_SUPER_ACTIONS_CTRL_t : type is 4;
   function width(x: HPS_SUPER_ACTIONS_CTRL_t) return natural;
   function convert(x: HPS_SUPER_ACTIONS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t;
   function zero(tpl: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t;

   type HPS_SUPER_CONFIGS_CTRL_t is record
      THREADS : std_logic_vector(4 - 1 downto 0);
      INPUT_EN : std_logic;
      OUTPUT_EN : std_logic;
      FLUSH_MEM_RESET : std_logic;
   end record HPS_SUPER_CONFIGS_CTRL_t;
   attribute w of HPS_SUPER_CONFIGS_CTRL_t : type is 7;
   function width(x: HPS_SUPER_CONFIGS_CTRL_t) return natural;
   function convert(x: HPS_SUPER_CONFIGS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t;
   function zero(tpl: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t;

   type HPS_SUPER_STATUS_MON_t is record
      ENABLED : std_logic;
      READY : std_logic;
      ERROR : std_logic_vector(8 - 1 downto 0);
   end record HPS_SUPER_STATUS_MON_t;
   attribute w of HPS_SUPER_STATUS_MON_t : type is 10;
   function width(x: HPS_SUPER_STATUS_MON_t) return natural;
   function convert(x: HPS_SUPER_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t;
   function zero(tpl: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t;

   type HPS_SUPER_MON_t is record
      STATUS : HPS_SUPER_STATUS_MON_t;
   end record HPS_SUPER_MON_t;
   attribute w of HPS_SUPER_MON_t : type is 10;
   function width(x: HPS_SUPER_MON_t) return natural;
   function convert(x: HPS_SUPER_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_MON_t) return HPS_SUPER_MON_t;
   function zero(tpl: HPS_SUPER_MON_t) return HPS_SUPER_MON_t;

   type HPS_SUPER_CTRL_t is record
      ACTIONS : HPS_SUPER_ACTIONS_CTRL_t;
      CONFIGS : HPS_SUPER_CONFIGS_CTRL_t;
   end record HPS_SUPER_CTRL_t;
   attribute w of HPS_SUPER_CTRL_t : type is 11;
   function width(x: HPS_SUPER_CTRL_t) return natural;
   function convert(x: HPS_SUPER_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t;
   function zero(tpl: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t;

   type HPS_MDT_TC_MDT_TC_SIGNALS_MON_t is record
      rd_rdy : std_logic;
      freeze_ena : std_logic;
   end record HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
   attribute w of HPS_MDT_TC_MDT_TC_SIGNALS_MON_t : type is 2;
   function width(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return natural;
   function convert(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
   function zero(tpl: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;

   type HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t is record
      wr_req : std_logic;
      wr_ack : std_logic;
      rd_req : std_logic;
      rd_ack : std_logic;
      flush_req : std_logic;
      freeze_req : std_logic;
      mem_sel : std_logic_vector(3 - 1 downto 0);
   end record HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
   attribute w of HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t : type is 9;
   function width(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return natural;
   function convert(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
   function zero(tpl: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;

   type HPS_MDT_TC_MDT_TC_wr_data_CTRL_t is record
      wr_data_0 : std_logic_vector(32 - 1 downto 0);
      wr_data_1 : std_logic_vector(6 - 1 downto 0);
   end record HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
   attribute w of HPS_MDT_TC_MDT_TC_wr_data_CTRL_t : type is 38;
   function width(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return natural;
   function convert(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
   function zero(tpl: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;

   type HPS_MDT_TC_MDT_TC_rd_data_MON_t is record
      rd_data_1 : std_logic_vector(6 - 1 downto 0);
      rd_data_0 : std_logic_vector(32 - 1 downto 0);
   end record HPS_MDT_TC_MDT_TC_rd_data_MON_t;
   attribute w of HPS_MDT_TC_MDT_TC_rd_data_MON_t : type is 38;
   function width(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return natural;
   function convert(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t;
   function zero(tpl: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t;

   type HPS_MDT_TC_MDT_TC_MON_t is record
      SIGNALS : HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
      rd_data : HPS_MDT_TC_MDT_TC_rd_data_MON_t;
   end record HPS_MDT_TC_MDT_TC_MON_t;
   attribute w of HPS_MDT_TC_MDT_TC_MON_t : type is 40;
   function width(x: HPS_MDT_TC_MDT_TC_MON_t) return natural;
   function convert(x: HPS_MDT_TC_MDT_TC_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t;
   function zero(tpl: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t;

   type HPS_MDT_TC_MDT_TC_MON_t_ARRAY is array(6 -1 downto 0) of HPS_MDT_TC_MDT_TC_MON_t;
   attribute w of HPS_MDT_TC_MDT_TC_MON_t_ARRAY : type is 240;
   function width(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return integer;
   function convert(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
   function zero(tpl: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
   function convert(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY;

   type HPS_MDT_TC_MDT_TC_CTRL_t is record
      SIGNALS : HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
      wr_addr : std_logic_vector(10 - 1 downto 0);
      rd_addr : std_logic_vector(10 - 1 downto 0);
      wr_data : HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
   end record HPS_MDT_TC_MDT_TC_CTRL_t;
   attribute w of HPS_MDT_TC_MDT_TC_CTRL_t : type is 67;
   function width(x: HPS_MDT_TC_MDT_TC_CTRL_t) return natural;
   function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t;
   function zero(tpl: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t;

   type HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY is array(6 -1 downto 0) of HPS_MDT_TC_MDT_TC_CTRL_t;
   attribute w of HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY : type is 402;
   function width(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return integer;
   function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
   function zero(tpl: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
   function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;

   type HPS_MDT_TC_MON_t is record
      MDT_TC : HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
   end record HPS_MDT_TC_MON_t;
   attribute w of HPS_MDT_TC_MON_t : type is 240;
   function width(x: HPS_MDT_TC_MON_t) return natural;
   function convert(x: HPS_MDT_TC_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t;
   function zero(tpl: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t;

   type HPS_MDT_TC_CTRL_t is record
      MDT_TC : HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
   end record HPS_MDT_TC_CTRL_t;
   attribute w of HPS_MDT_TC_CTRL_t : type is 402;
   function width(x: HPS_MDT_TC_CTRL_t) return natural;
   function convert(x: HPS_MDT_TC_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t;
   function zero(tpl: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t;

   type HPS_MDT_T0_MDT_T0_SIGNALS_MON_t is record
      rd_rdy : std_logic;
      freeze_ena : std_logic;
   end record HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
   attribute w of HPS_MDT_T0_MDT_T0_SIGNALS_MON_t : type is 2;
   function width(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return natural;
   function convert(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
   function zero(tpl: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;

   type HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t is record
      wr_req : std_logic;
      wr_ack : std_logic;
      rd_req : std_logic;
      rd_ack : std_logic;
      flush_req : std_logic;
      freeze_req : std_logic;
      mem_sel : std_logic_vector(3 - 1 downto 0);
   end record HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
   attribute w of HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t : type is 9;
   function width(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return natural;
   function convert(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
   function zero(tpl: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;

   type HPS_MDT_T0_MDT_T0_wr_data_CTRL_t is record
      wr_data_0 : std_logic_vector(17 - 1 downto 0);
   end record HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
   attribute w of HPS_MDT_T0_MDT_T0_wr_data_CTRL_t : type is 17;
   function width(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return natural;
   function convert(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
   function zero(tpl: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;

   type HPS_MDT_T0_MDT_T0_rd_data_MON_t is record
      rd_data_0 : std_logic_vector(17 - 1 downto 0);
   end record HPS_MDT_T0_MDT_T0_rd_data_MON_t;
   attribute w of HPS_MDT_T0_MDT_T0_rd_data_MON_t : type is 17;
   function width(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return natural;
   function convert(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t;
   function zero(tpl: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t;

   type HPS_MDT_T0_MDT_T0_MON_t is record
      SIGNALS : HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
      rd_data : HPS_MDT_T0_MDT_T0_rd_data_MON_t;
   end record HPS_MDT_T0_MDT_T0_MON_t;
   attribute w of HPS_MDT_T0_MDT_T0_MON_t : type is 19;
   function width(x: HPS_MDT_T0_MDT_T0_MON_t) return natural;
   function convert(x: HPS_MDT_T0_MDT_T0_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t;
   function zero(tpl: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t;

   type HPS_MDT_T0_MDT_T0_MON_t_ARRAY is array(6 -1 downto 0) of HPS_MDT_T0_MDT_T0_MON_t;
   attribute w of HPS_MDT_T0_MDT_T0_MON_t_ARRAY : type is 114;
   function width(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return integer;
   function convert(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
   function zero(tpl: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
   function convert(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY;

   type HPS_MDT_T0_MDT_T0_CTRL_t is record
      SIGNALS : HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
      wr_addr : std_logic_vector(4 - 1 downto 0);
      rd_addr : std_logic_vector(4 - 1 downto 0);
      wr_data : HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
   end record HPS_MDT_T0_MDT_T0_CTRL_t;
   attribute w of HPS_MDT_T0_MDT_T0_CTRL_t : type is 34;
   function width(x: HPS_MDT_T0_MDT_T0_CTRL_t) return natural;
   function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t;
   function zero(tpl: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t;

   type HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY is array(6 -1 downto 0) of HPS_MDT_T0_MDT_T0_CTRL_t;
   attribute w of HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY : type is 204;
   function width(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return integer;
   function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
   function zero(tpl: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
   function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;

   type HPS_MDT_T0_MON_t is record
      MDT_T0 : HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
   end record HPS_MDT_T0_MON_t;
   attribute w of HPS_MDT_T0_MON_t : type is 114;
   function width(x: HPS_MDT_T0_MON_t) return natural;
   function convert(x: HPS_MDT_T0_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t;
   function zero(tpl: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t;

   type HPS_MDT_T0_CTRL_t is record
      MDT_T0 : HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
   end record HPS_MDT_T0_CTRL_t;
   attribute w of HPS_MDT_T0_CTRL_t : type is 204;
   function width(x: HPS_MDT_T0_CTRL_t) return natural;
   function convert(x: HPS_MDT_T0_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t;
   function zero(tpl: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t;

   type HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t is record
      RESET : std_logic;
      ENABLE : std_logic;
      DISABLE : std_logic;
      FREEZE : std_logic;
   end record HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
   attribute w of HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t : type is 4;
   function width(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;

   type HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t is record
      INPUT_EN : std_logic;
      OUTPUT_EN : std_logic;
      FLUSH_MEM_RESET : std_logic;
   end record HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
   attribute w of HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t : type is 3;
   function width(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;

   type HPS_HEG_HEG_SUPER_STATUS_MON_t is record
      ENABLED : std_logic;
      READY : std_logic;
      ERROR : std_logic;
   end record HPS_HEG_HEG_SUPER_STATUS_MON_t;
   attribute w of HPS_HEG_HEG_SUPER_STATUS_MON_t : type is 3;
   function width(x: HPS_HEG_HEG_SUPER_STATUS_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_SUPER_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t;
   function zero(tpl: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t;

   type HPS_HEG_HEG_SUPER_COUNTERS_MON_t is record
      SLC_PROC : std_logic_vector(32 - 1 downto 0);
      HIT_PROC : std_logic_vector(32 - 1 downto 0);
      HIT_OK : std_logic_vector(32 - 1 downto 0);
      ERROR : std_logic_vector(32 - 1 downto 0);
   end record HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
   attribute w of HPS_HEG_HEG_SUPER_COUNTERS_MON_t : type is 128;
   function width(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
   function zero(tpl: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t;

   type HPS_HEG_HEG_SUPER_MON_t is record
      STATUS : HPS_HEG_HEG_SUPER_STATUS_MON_t;
      COUNTERS : HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
   end record HPS_HEG_HEG_SUPER_MON_t;
   attribute w of HPS_HEG_HEG_SUPER_MON_t : type is 131;
   function width(x: HPS_HEG_HEG_SUPER_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_SUPER_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t;
   function zero(tpl: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t;

   type HPS_HEG_HEG_SUPER_CTRL_t is record
      ACTIONS : HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
      CONFIGS : HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
   end record HPS_HEG_HEG_SUPER_CTRL_t;
   attribute w of HPS_HEG_HEG_SUPER_CTRL_t : type is 7;
   function width(x: HPS_HEG_HEG_SUPER_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_SUPER_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t;

   type HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t is record
      rd_rdy : std_logic;
      freeze_ena : std_logic;
   end record HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
   attribute w of HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t : type is 2;
   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;

   type HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t is record
      wr_req : std_logic;
      wr_ack : std_logic;
      rd_req : std_logic;
      rd_ack : std_logic;
      flush_req : std_logic;
      freeze_req : std_logic;
      mem_sel : std_logic_vector(3 - 1 downto 0);
   end record HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
   attribute w of HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t : type is 9;
   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;

   type HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t is record
      wr_data_0 : std_logic_vector(32 - 1 downto 0);
      wr_data_1 : std_logic_vector(6 - 1 downto 0);
   end record HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
   attribute w of HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t : type is 38;
   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;

   type HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t is record
      rd_data_1 : std_logic_vector(6 - 1 downto 0);
      rd_data_0 : std_logic_vector(32 - 1 downto 0);
   end record HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
   attribute w of HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t : type is 38;
   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;

   type HPS_HEG_HEG_CTRL_ROI_TC_MON_t is record
      SIGNALS : HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
      rd_data : HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
   end record HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
   attribute w of HPS_HEG_HEG_CTRL_ROI_TC_MON_t : type is 40;
   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t;

   type HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t is record
      SIGNALS : HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
      wr_addr : std_logic_vector(10 - 1 downto 0);
      rd_addr : std_logic_vector(10 - 1 downto 0);
      wr_data : HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
   end record HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
   attribute w of HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t : type is 67;
   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;

   type HPS_HEG_HEG_CTRL_MON_t is record
      ROI_TC : HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
   end record HPS_HEG_HEG_CTRL_MON_t;
   attribute w of HPS_HEG_HEG_CTRL_MON_t : type is 40;
   function width(x: HPS_HEG_HEG_CTRL_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_CTRL_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t;
   function zero(tpl: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t;

   type HPS_HEG_HEG_CTRL_CTRL_t is record
      ROI_TC : HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
   end record HPS_HEG_HEG_CTRL_CTRL_t;
   attribute w of HPS_HEG_HEG_CTRL_CTRL_t : type is 67;
   function width(x: HPS_HEG_HEG_CTRL_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_CTRL_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t;

   type HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t is record
      RESET : std_logic;
      ENABLE : std_logic;
      DISABLE : std_logic;
      FREEZE : std_logic;
   end record HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
   attribute w of HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t : type is 4;
   function width(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;

   type HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t is record
      INPUT_EN : std_logic;
      OUTPUT_EN : std_logic;
      FLUSH_MEM_RESET : std_logic;
   end record HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
   attribute w of HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t : type is 3;
   function width(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;

   type HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t is record
      rd_rdy : std_logic;
      freeze_ena : std_logic;
   end record HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
   attribute w of HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t : type is 2;
   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;

   type HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t is record
      wr_req : std_logic;
      wr_ack : std_logic;
      rd_req : std_logic;
      rd_ack : std_logic;
      flush_req : std_logic;
      freeze_req : std_logic;
      mem_sel : std_logic_vector(3 - 1 downto 0);
   end record HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
   attribute w of HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t : type is 9;
   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;

   type HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t is record
      wr_data_0 : std_logic_vector(9 - 1 downto 0);
   end record HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
   attribute w of HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t : type is 9;
   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;

   type HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t is record
      rd_data_0 : std_logic_vector(9 - 1 downto 0);
   end record HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
   attribute w of HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t : type is 9;
   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;

   type HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t is record
      SIGNALS : HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
      rd_data : HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
   end record HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
   attribute w of HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t : type is 11;
   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;

   type HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t is record
      SIGNALS : HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
      wr_addr : std_logic_vector(10 - 1 downto 0);
      rd_addr : std_logic_vector(10 - 1 downto 0);
      wr_data : HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
   end record HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
   attribute w of HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t : type is 38;
   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;

   type HPS_HEG_HEG_HP_HP_MON_t is record
      MDT_DT2R : HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
   end record HPS_HEG_HEG_HP_HP_MON_t;
   attribute w of HPS_HEG_HEG_HP_HP_MON_t : type is 11;
   function width(x: HPS_HEG_HEG_HP_HP_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t;

   type HPS_HEG_HEG_HP_HP_MON_t_ARRAY is array(6 -1 downto 0) of HPS_HEG_HEG_HP_HP_MON_t;
   attribute w of HPS_HEG_HEG_HP_HP_MON_t_ARRAY : type is 66;
   function width(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return integer;
   function convert(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
   function convert(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY;

   type HPS_HEG_HEG_HP_HP_CTRL_t is record
      ACTIONS : HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
      CONFIGS : HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
      MDT_DT2R : HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
   end record HPS_HEG_HEG_HP_HP_CTRL_t;
   attribute w of HPS_HEG_HEG_HP_HP_CTRL_t : type is 45;
   function width(x: HPS_HEG_HEG_HP_HP_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t;

   type HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY is array(6 -1 downto 0) of HPS_HEG_HEG_HP_HP_CTRL_t;
   attribute w of HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY : type is 270;
   function width(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return integer;
   function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
   function zero(tpl: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
   function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;

   type HPS_HEG_HEG_HP_MON_t is record
      HP : HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
   end record HPS_HEG_HEG_HP_MON_t;
   attribute w of HPS_HEG_HEG_HP_MON_t : type is 66;
   function width(x: HPS_HEG_HEG_HP_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t;
   function zero(tpl: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t;

   type HPS_HEG_HEG_HP_CTRL_t is record
      HP : HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
   end record HPS_HEG_HEG_HP_CTRL_t;
   attribute w of HPS_HEG_HEG_HP_CTRL_t : type is 270;
   function width(x: HPS_HEG_HEG_HP_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_HP_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t;

   type HPS_HEG_HEG_MON_t is record
      SUPER : HPS_HEG_HEG_SUPER_MON_t;
      CTRL : HPS_HEG_HEG_CTRL_MON_t;
      HP : HPS_HEG_HEG_HP_MON_t;
   end record HPS_HEG_HEG_MON_t;
   attribute w of HPS_HEG_HEG_MON_t : type is 237;
   function width(x: HPS_HEG_HEG_MON_t) return natural;
   function convert(x: HPS_HEG_HEG_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t;
   function zero(tpl: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t;

   type HPS_HEG_HEG_MON_t_ARRAY is array(3 -1 downto 0) of HPS_HEG_HEG_MON_t;
   attribute w of HPS_HEG_HEG_MON_t_ARRAY : type is 711;
   function width(x: HPS_HEG_HEG_MON_t_ARRAY) return integer;
   function convert(x: HPS_HEG_HEG_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY;
   function zero(tpl: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY;
   function convert(x: HPS_HEG_HEG_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY;

   type HPS_HEG_HEG_CTRL_t is record
      SUPER : HPS_HEG_HEG_SUPER_CTRL_t;
      CTRL : HPS_HEG_HEG_CTRL_CTRL_t;
      HP : HPS_HEG_HEG_HP_CTRL_t;
   end record HPS_HEG_HEG_CTRL_t;
   attribute w of HPS_HEG_HEG_CTRL_t : type is 344;
   function width(x: HPS_HEG_HEG_CTRL_t) return natural;
   function convert(x: HPS_HEG_HEG_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t;
   function zero(tpl: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t;

   type HPS_HEG_HEG_CTRL_t_ARRAY is array(3 -1 downto 0) of HPS_HEG_HEG_CTRL_t;
   attribute w of HPS_HEG_HEG_CTRL_t_ARRAY : type is 1032;
   function width(x: HPS_HEG_HEG_CTRL_t_ARRAY) return integer;
   function convert(x: HPS_HEG_HEG_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY;
   function zero(tpl: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY;
   function convert(x: HPS_HEG_HEG_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY;

   type HPS_HEG_MON_t is record
      HEG : HPS_HEG_HEG_MON_t_ARRAY;
   end record HPS_HEG_MON_t;
   attribute w of HPS_HEG_MON_t : type is 711;
   function width(x: HPS_HEG_MON_t) return natural;
   function convert(x: HPS_HEG_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_MON_t) return HPS_HEG_MON_t;
   function zero(tpl: HPS_HEG_MON_t) return HPS_HEG_MON_t;

   type HPS_HEG_CTRL_t is record
      HEG : HPS_HEG_HEG_CTRL_t_ARRAY;
   end record HPS_HEG_CTRL_t;
   attribute w of HPS_HEG_CTRL_t : type is 1032;
   function width(x: HPS_HEG_CTRL_t) return natural;
   function convert(x: HPS_HEG_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t;
   function zero(tpl: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t;

   type HPS_LSF_LSF_MON_t is record
      STATUS : std_logic;
      sb_lsf_mdt_hits_rdata_31_0 : std_logic_vector(32 - 1 downto 0);
      sb_lsf_mdt_hits_rdata_40_32 : std_logic_vector(9 - 1 downto 0);
   end record HPS_LSF_LSF_MON_t;
   attribute w of HPS_LSF_LSF_MON_t : type is 42;
   function width(x: HPS_LSF_LSF_MON_t) return natural;
   function convert(x: HPS_LSF_LSF_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t;
   function zero(tpl: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t;

   type HPS_LSF_LSF_MON_t_ARRAY is array(3 -1 downto 0) of HPS_LSF_LSF_MON_t;
   attribute w of HPS_LSF_LSF_MON_t_ARRAY : type is 126;
   function width(x: HPS_LSF_LSF_MON_t_ARRAY) return integer;
   function convert(x: HPS_LSF_LSF_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY;
   function zero(tpl: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY;
   function convert(x: HPS_LSF_LSF_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY;

   type HPS_LSF_LSF_CTRL_t is record
      RESET : std_logic;
      HBA_MAX_CLOCKS : std_logic_vector(10 - 1 downto 0);
      sb_lsf_mdt_hits_freeze : std_logic;
      sb_lsf_mdt_hits_raddr : std_logic_vector(8 - 1 downto 0);
      sb_lsf_mdt_hits_re : std_logic;
   end record HPS_LSF_LSF_CTRL_t;
   attribute w of HPS_LSF_LSF_CTRL_t : type is 21;
   function width(x: HPS_LSF_LSF_CTRL_t) return natural;
   function convert(x: HPS_LSF_LSF_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t;
   function zero(tpl: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t;

   type HPS_LSF_LSF_CTRL_t_ARRAY is array(3 -1 downto 0) of HPS_LSF_LSF_CTRL_t;
   attribute w of HPS_LSF_LSF_CTRL_t_ARRAY : type is 63;
   function width(x: HPS_LSF_LSF_CTRL_t_ARRAY) return integer;
   function convert(x: HPS_LSF_LSF_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY;
   function zero(tpl: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY;
   function convert(x: HPS_LSF_LSF_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY;

   type HPS_LSF_MON_t is record
      LSF : HPS_LSF_LSF_MON_t_ARRAY;
   end record HPS_LSF_MON_t;
   attribute w of HPS_LSF_MON_t : type is 126;
   function width(x: HPS_LSF_MON_t) return natural;
   function convert(x: HPS_LSF_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_LSF_MON_t) return HPS_LSF_MON_t;
   function zero(tpl: HPS_LSF_MON_t) return HPS_LSF_MON_t;

   type HPS_LSF_CTRL_t is record
      LSF : HPS_LSF_LSF_CTRL_t_ARRAY;
   end record HPS_LSF_CTRL_t;
   attribute w of HPS_LSF_CTRL_t : type is 63;
   function width(x: HPS_LSF_CTRL_t) return natural;
   function convert(x: HPS_LSF_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t;
   function zero(tpl: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t;

   type HPS_CSF_CSF_ACTIONS_CTRL_t is record
      RESET : std_logic;
      ENABLE : std_logic;
      DISABLE : std_logic;
      FREEZE : std_logic;
   end record HPS_CSF_CSF_ACTIONS_CTRL_t;
   attribute w of HPS_CSF_CSF_ACTIONS_CTRL_t : type is 4;
   function width(x: HPS_CSF_CSF_ACTIONS_CTRL_t) return natural;
   function convert(x: HPS_CSF_CSF_ACTIONS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t;
   function zero(tpl: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t;

   type HPS_CSF_CSF_STATUS_MON_t is record
      ENABLED : std_logic;
      READY : std_logic;
      ERROR : std_logic;
   end record HPS_CSF_CSF_STATUS_MON_t;
   attribute w of HPS_CSF_CSF_STATUS_MON_t : type is 3;
   function width(x: HPS_CSF_CSF_STATUS_MON_t) return natural;
   function convert(x: HPS_CSF_CSF_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t;
   function zero(tpl: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t;

   type HPS_CSF_CSF_MON_t is record
      STATUS : HPS_CSF_CSF_STATUS_MON_t;
   end record HPS_CSF_CSF_MON_t;
   attribute w of HPS_CSF_CSF_MON_t : type is 3;
   function width(x: HPS_CSF_CSF_MON_t) return natural;
   function convert(x: HPS_CSF_CSF_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t;
   function zero(tpl: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t;

   type HPS_CSF_CSF_MON_t_ARRAY is array(3 -1 downto 0) of HPS_CSF_CSF_MON_t;
   attribute w of HPS_CSF_CSF_MON_t_ARRAY : type is 9;
   function width(x: HPS_CSF_CSF_MON_t_ARRAY) return integer;
   function convert(x: HPS_CSF_CSF_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY;
   function zero(tpl: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY;
   function convert(x: HPS_CSF_CSF_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY;

   type HPS_CSF_CSF_CTRL_t is record
      ACTIONS : HPS_CSF_CSF_ACTIONS_CTRL_t;
   end record HPS_CSF_CSF_CTRL_t;
   attribute w of HPS_CSF_CSF_CTRL_t : type is 4;
   function width(x: HPS_CSF_CSF_CTRL_t) return natural;
   function convert(x: HPS_CSF_CSF_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t;
   function zero(tpl: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t;

   type HPS_CSF_CSF_CTRL_t_ARRAY is array(3 -1 downto 0) of HPS_CSF_CSF_CTRL_t;
   attribute w of HPS_CSF_CSF_CTRL_t_ARRAY : type is 12;
   function width(x: HPS_CSF_CSF_CTRL_t_ARRAY) return integer;
   function convert(x: HPS_CSF_CSF_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY;
   function zero(tpl: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY;
   function convert(x: HPS_CSF_CSF_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array;
   function convert(x: std_logic_vector_array; tpl: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY;

   type HPS_CSF_MON_t is record
      CSF : HPS_CSF_CSF_MON_t_ARRAY;
   end record HPS_CSF_MON_t;
   attribute w of HPS_CSF_MON_t : type is 9;
   function width(x: HPS_CSF_MON_t) return natural;
   function convert(x: HPS_CSF_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_CSF_MON_t) return HPS_CSF_MON_t;
   function zero(tpl: HPS_CSF_MON_t) return HPS_CSF_MON_t;

   type HPS_CSF_CTRL_t is record
      CSF : HPS_CSF_CSF_CTRL_t_ARRAY;
   end record HPS_CSF_CTRL_t;
   attribute w of HPS_CSF_CTRL_t : type is 12;
   function width(x: HPS_CSF_CTRL_t) return natural;
   function convert(x: HPS_CSF_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t;
   function zero(tpl: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t;

   type HPS_MON_t is record
      SUPER : HPS_SUPER_MON_t;
      MDT_TC : HPS_MDT_TC_MON_t;
      MDT_T0 : HPS_MDT_T0_MON_t;
      HEG : HPS_HEG_MON_t;
      LSF : HPS_LSF_MON_t;
      CSF : HPS_CSF_MON_t;
   end record HPS_MON_t;
   attribute w of HPS_MON_t : type is 1210;
   function width(x: HPS_MON_t) return natural;
   function convert(x: HPS_MON_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_MON_t) return HPS_MON_t;
   function zero(tpl: HPS_MON_t) return HPS_MON_t;

   type HPS_CTRL_t is record
      SUPER : HPS_SUPER_CTRL_t;
      MDT_TC : HPS_MDT_TC_CTRL_t;
      MDT_T0 : HPS_MDT_T0_CTRL_t;
      HEG : HPS_HEG_CTRL_t;
      LSF : HPS_LSF_CTRL_t;
      CSF : HPS_CSF_CTRL_t;
   end record HPS_CTRL_t;
   attribute w of HPS_CTRL_t : type is 1724;
   function width(x: HPS_CTRL_t) return natural;
   function convert(x: HPS_CTRL_t; tpl: std_logic_vector) return std_logic_vector;
   function convert(x: std_logic_vector; tpl: HPS_CTRL_t) return HPS_CTRL_t;
   function zero(tpl: HPS_CTRL_t) return HPS_CTRL_t;

end package HPS_CTRL;

------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.math_real.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package body HPS_CTRL is

   -- Custom types and functions --

   function width(x: HPS_SUPER_ACTIONS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET);
      w := w + width(x.ENABLE);
      w := w + width(x.DISABLE);
      w := w + width(x.FREEZE);
      return w;
   end function width;
   function convert(x: HPS_SUPER_ACTIONS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET);
         y(u to u+w-1) := convert(x.RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.ENABLE);
         y(u to u+w-1) := convert(x.ENABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.DISABLE);
         y(u to u+w-1) := convert(x.DISABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.FREEZE);
         y(u to u+w-1) := convert(x.FREEZE, y(u to u+w-1));
      else
         w := width(x.RESET);
         y(u downto u-w+1) := convert(x.RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.ENABLE);
         y(u downto u-w+1) := convert(x.ENABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.DISABLE);
         y(u downto u-w+1) := convert(x.DISABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.FREEZE);
         y(u downto u-w+1) := convert(x.FREEZE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t is
      variable y : HPS_SUPER_ACTIONS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET);
         y.RESET := convert(x(u to u+w-1), tpl.RESET);
         u := u + w;
         w := width(tpl.ENABLE);
         y.ENABLE := convert(x(u to u+w-1), tpl.ENABLE);
         u := u + w;
         w := width(tpl.DISABLE);
         y.DISABLE := convert(x(u to u+w-1), tpl.DISABLE);
         u := u + w;
         w := width(tpl.FREEZE);
         y.FREEZE := convert(x(u to u+w-1), tpl.FREEZE);
      else
         w := width(tpl.RESET);
         y.RESET := convert(x(u downto u-w+1), tpl.RESET);
         u := u - w;
         w := width(tpl.ENABLE);
         y.ENABLE := convert(x(u downto u-w+1), tpl.ENABLE);
         u := u - w;
         w := width(tpl.DISABLE);
         y.DISABLE := convert(x(u downto u-w+1), tpl.DISABLE);
         u := u - w;
         w := width(tpl.FREEZE);
         y.FREEZE := convert(x(u downto u-w+1), tpl.FREEZE);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_SUPER_ACTIONS_CTRL_t) return HPS_SUPER_ACTIONS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_SUPER_CONFIGS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.THREADS);
      w := w + width(x.INPUT_EN);
      w := w + width(x.OUTPUT_EN);
      w := w + width(x.FLUSH_MEM_RESET);
      return w;
   end function width;
   function convert(x: HPS_SUPER_CONFIGS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.THREADS);
         y(u to u+w-1) := convert(x.THREADS, y(u to u+w-1));
         u := u + w;
         w := width(x.INPUT_EN);
         y(u to u+w-1) := convert(x.INPUT_EN, y(u to u+w-1));
         u := u + w;
         w := width(x.OUTPUT_EN);
         y(u to u+w-1) := convert(x.OUTPUT_EN, y(u to u+w-1));
         u := u + w;
         w := width(x.FLUSH_MEM_RESET);
         y(u to u+w-1) := convert(x.FLUSH_MEM_RESET, y(u to u+w-1));
      else
         w := width(x.THREADS);
         y(u downto u-w+1) := convert(x.THREADS, y(u downto u-w+1));
         u := u - w;
         w := width(x.INPUT_EN);
         y(u downto u-w+1) := convert(x.INPUT_EN, y(u downto u-w+1));
         u := u - w;
         w := width(x.OUTPUT_EN);
         y(u downto u-w+1) := convert(x.OUTPUT_EN, y(u downto u-w+1));
         u := u - w;
         w := width(x.FLUSH_MEM_RESET);
         y(u downto u-w+1) := convert(x.FLUSH_MEM_RESET, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t is
      variable y : HPS_SUPER_CONFIGS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.THREADS);
         y.THREADS := convert(x(u to u+w-1), tpl.THREADS);
         u := u + w;
         w := width(tpl.INPUT_EN);
         y.INPUT_EN := convert(x(u to u+w-1), tpl.INPUT_EN);
         u := u + w;
         w := width(tpl.OUTPUT_EN);
         y.OUTPUT_EN := convert(x(u to u+w-1), tpl.OUTPUT_EN);
         u := u + w;
         w := width(tpl.FLUSH_MEM_RESET);
         y.FLUSH_MEM_RESET := convert(x(u to u+w-1), tpl.FLUSH_MEM_RESET);
      else
         w := width(tpl.THREADS);
         y.THREADS := convert(x(u downto u-w+1), tpl.THREADS);
         u := u - w;
         w := width(tpl.INPUT_EN);
         y.INPUT_EN := convert(x(u downto u-w+1), tpl.INPUT_EN);
         u := u - w;
         w := width(tpl.OUTPUT_EN);
         y.OUTPUT_EN := convert(x(u downto u-w+1), tpl.OUTPUT_EN);
         u := u - w;
         w := width(tpl.FLUSH_MEM_RESET);
         y.FLUSH_MEM_RESET := convert(x(u downto u-w+1), tpl.FLUSH_MEM_RESET);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_SUPER_CONFIGS_CTRL_t) return HPS_SUPER_CONFIGS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_SUPER_STATUS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ENABLED);
      w := w + width(x.READY);
      w := w + width(x.ERROR);
      return w;
   end function width;
   function convert(x: HPS_SUPER_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ENABLED);
         y(u to u+w-1) := convert(x.ENABLED, y(u to u+w-1));
         u := u + w;
         w := width(x.READY);
         y(u to u+w-1) := convert(x.READY, y(u to u+w-1));
         u := u + w;
         w := width(x.ERROR);
         y(u to u+w-1) := convert(x.ERROR, y(u to u+w-1));
      else
         w := width(x.ENABLED);
         y(u downto u-w+1) := convert(x.ENABLED, y(u downto u-w+1));
         u := u - w;
         w := width(x.READY);
         y(u downto u-w+1) := convert(x.READY, y(u downto u-w+1));
         u := u - w;
         w := width(x.ERROR);
         y(u downto u-w+1) := convert(x.ERROR, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t is
      variable y : HPS_SUPER_STATUS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ENABLED);
         y.ENABLED := convert(x(u to u+w-1), tpl.ENABLED);
         u := u + w;
         w := width(tpl.READY);
         y.READY := convert(x(u to u+w-1), tpl.READY);
         u := u + w;
         w := width(tpl.ERROR);
         y.ERROR := convert(x(u to u+w-1), tpl.ERROR);
      else
         w := width(tpl.ENABLED);
         y.ENABLED := convert(x(u downto u-w+1), tpl.ENABLED);
         u := u - w;
         w := width(tpl.READY);
         y.READY := convert(x(u downto u-w+1), tpl.READY);
         u := u - w;
         w := width(tpl.ERROR);
         y.ERROR := convert(x(u downto u-w+1), tpl.ERROR);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_SUPER_STATUS_MON_t) return HPS_SUPER_STATUS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_SUPER_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.STATUS);
      return w;
   end function width;
   function convert(x: HPS_SUPER_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.STATUS);
         y(u to u+w-1) := convert(x.STATUS, y(u to u+w-1));
      else
         w := width(x.STATUS);
         y(u downto u-w+1) := convert(x.STATUS, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_MON_t) return HPS_SUPER_MON_t is
      variable y : HPS_SUPER_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u to u+w-1), tpl.STATUS);
      else
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u downto u-w+1), tpl.STATUS);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_SUPER_MON_t) return HPS_SUPER_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_SUPER_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ACTIONS);
      w := w + width(x.CONFIGS);
      return w;
   end function width;
   function convert(x: HPS_SUPER_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ACTIONS);
         y(u to u+w-1) := convert(x.ACTIONS, y(u to u+w-1));
         u := u + w;
         w := width(x.CONFIGS);
         y(u to u+w-1) := convert(x.CONFIGS, y(u to u+w-1));
      else
         w := width(x.ACTIONS);
         y(u downto u-w+1) := convert(x.ACTIONS, y(u downto u-w+1));
         u := u - w;
         w := width(x.CONFIGS);
         y(u downto u-w+1) := convert(x.CONFIGS, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t is
      variable y : HPS_SUPER_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ACTIONS);
         y.ACTIONS := convert(x(u to u+w-1), tpl.ACTIONS);
         u := u + w;
         w := width(tpl.CONFIGS);
         y.CONFIGS := convert(x(u to u+w-1), tpl.CONFIGS);
      else
         w := width(tpl.ACTIONS);
         y.ACTIONS := convert(x(u downto u-w+1), tpl.ACTIONS);
         u := u - w;
         w := width(tpl.CONFIGS);
         y.CONFIGS := convert(x(u downto u-w+1), tpl.CONFIGS);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_SUPER_CTRL_t) return HPS_SUPER_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_rdy);
      w := w + width(x.freeze_ena);
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_rdy);
         y(u to u+w-1) := convert(x.rd_rdy, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_ena);
         y(u to u+w-1) := convert(x.freeze_ena, y(u to u+w-1));
      else
         w := width(x.rd_rdy);
         y(u downto u-w+1) := convert(x.rd_rdy, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_ena);
         y(u downto u-w+1) := convert(x.freeze_ena, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t is
      variable y : HPS_MDT_TC_MDT_TC_SIGNALS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u to u+w-1), tpl.rd_rdy);
         u := u + w;
         w := width(tpl.freeze_ena);
         y.freeze_ena := convert(x(u to u+w-1), tpl.freeze_ena);
      else
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u downto u-w+1), tpl.rd_rdy);
         u := u - w;
         w := width(tpl.freeze_ena);
         y.freeze_ena := convert(x(u downto u-w+1), tpl.freeze_ena);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_MDT_TC_SIGNALS_MON_t) return HPS_MDT_TC_MDT_TC_SIGNALS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_req);
      w := w + width(x.wr_ack);
      w := w + width(x.rd_req);
      w := w + width(x.rd_ack);
      w := w + width(x.flush_req);
      w := w + width(x.freeze_req);
      w := w + width(x.mem_sel);
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.wr_req);
         y(u to u+w-1) := convert(x.wr_req, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_ack);
         y(u to u+w-1) := convert(x.wr_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_req);
         y(u to u+w-1) := convert(x.rd_req, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_ack);
         y(u to u+w-1) := convert(x.rd_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.flush_req);
         y(u to u+w-1) := convert(x.flush_req, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_req);
         y(u to u+w-1) := convert(x.freeze_req, y(u to u+w-1));
         u := u + w;
         w := width(x.mem_sel);
         y(u to u+w-1) := convert(x.mem_sel, y(u to u+w-1));
      else
         w := width(x.wr_req);
         y(u downto u-w+1) := convert(x.wr_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_ack);
         y(u downto u-w+1) := convert(x.wr_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_req);
         y(u downto u-w+1) := convert(x.rd_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_ack);
         y(u downto u-w+1) := convert(x.rd_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.flush_req);
         y(u downto u-w+1) := convert(x.flush_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_req);
         y(u downto u-w+1) := convert(x.freeze_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.mem_sel);
         y(u downto u-w+1) := convert(x.mem_sel, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t is
      variable y : HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.wr_req);
         y.wr_req := convert(x(u to u+w-1), tpl.wr_req);
         u := u + w;
         w := width(tpl.wr_ack);
         y.wr_ack := convert(x(u to u+w-1), tpl.wr_ack);
         u := u + w;
         w := width(tpl.rd_req);
         y.rd_req := convert(x(u to u+w-1), tpl.rd_req);
         u := u + w;
         w := width(tpl.rd_ack);
         y.rd_ack := convert(x(u to u+w-1), tpl.rd_ack);
         u := u + w;
         w := width(tpl.flush_req);
         y.flush_req := convert(x(u to u+w-1), tpl.flush_req);
         u := u + w;
         w := width(tpl.freeze_req);
         y.freeze_req := convert(x(u to u+w-1), tpl.freeze_req);
         u := u + w;
         w := width(tpl.mem_sel);
         y.mem_sel := convert(x(u to u+w-1), tpl.mem_sel);
      else
         w := width(tpl.wr_req);
         y.wr_req := convert(x(u downto u-w+1), tpl.wr_req);
         u := u - w;
         w := width(tpl.wr_ack);
         y.wr_ack := convert(x(u downto u-w+1), tpl.wr_ack);
         u := u - w;
         w := width(tpl.rd_req);
         y.rd_req := convert(x(u downto u-w+1), tpl.rd_req);
         u := u - w;
         w := width(tpl.rd_ack);
         y.rd_ack := convert(x(u downto u-w+1), tpl.rd_ack);
         u := u - w;
         w := width(tpl.flush_req);
         y.flush_req := convert(x(u downto u-w+1), tpl.flush_req);
         u := u - w;
         w := width(tpl.freeze_req);
         y.freeze_req := convert(x(u downto u-w+1), tpl.freeze_req);
         u := u - w;
         w := width(tpl.mem_sel);
         y.mem_sel := convert(x(u downto u-w+1), tpl.mem_sel);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t) return HPS_MDT_TC_MDT_TC_SIGNALS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_data_0);
      w := w + width(x.wr_data_1);
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.wr_data_0);
         y(u to u+w-1) := convert(x.wr_data_0, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data_1);
         y(u to u+w-1) := convert(x.wr_data_1, y(u to u+w-1));
      else
         w := width(x.wr_data_0);
         y(u downto u-w+1) := convert(x.wr_data_0, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data_1);
         y(u downto u-w+1) := convert(x.wr_data_1, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t is
      variable y : HPS_MDT_TC_MDT_TC_wr_data_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.wr_data_0);
         y.wr_data_0 := convert(x(u to u+w-1), tpl.wr_data_0);
         u := u + w;
         w := width(tpl.wr_data_1);
         y.wr_data_1 := convert(x(u to u+w-1), tpl.wr_data_1);
      else
         w := width(tpl.wr_data_0);
         y.wr_data_0 := convert(x(u downto u-w+1), tpl.wr_data_0);
         u := u - w;
         w := width(tpl.wr_data_1);
         y.wr_data_1 := convert(x(u downto u-w+1), tpl.wr_data_1);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_MDT_TC_wr_data_CTRL_t) return HPS_MDT_TC_MDT_TC_wr_data_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_data_1);
      w := w + width(x.rd_data_0);
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_MDT_TC_rd_data_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_data_1);
         y(u to u+w-1) := convert(x.rd_data_1, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data_0);
         y(u to u+w-1) := convert(x.rd_data_0, y(u to u+w-1));
      else
         w := width(x.rd_data_1);
         y(u downto u-w+1) := convert(x.rd_data_1, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data_0);
         y(u downto u-w+1) := convert(x.rd_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t is
      variable y : HPS_MDT_TC_MDT_TC_rd_data_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_data_1);
         y.rd_data_1 := convert(x(u to u+w-1), tpl.rd_data_1);
         u := u + w;
         w := width(tpl.rd_data_0);
         y.rd_data_0 := convert(x(u to u+w-1), tpl.rd_data_0);
      else
         w := width(tpl.rd_data_1);
         y.rd_data_1 := convert(x(u downto u-w+1), tpl.rd_data_1);
         u := u - w;
         w := width(tpl.rd_data_0);
         y.rd_data_0 := convert(x(u downto u-w+1), tpl.rd_data_0);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_MDT_TC_rd_data_MON_t) return HPS_MDT_TC_MDT_TC_rd_data_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_TC_MDT_TC_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_MDT_TC_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t is
      variable y : HPS_MDT_TC_MDT_TC_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), tpl.SIGNALS);
         u := u + w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u to u+w-1), tpl.rd_data);
      else
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), tpl.SIGNALS);
         u := u - w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u downto u-w+1), tpl.rd_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_MDT_TC_MON_t) return HPS_MDT_TC_MDT_TC_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY is
      variable y : HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_MDT_TC_MDT_TC_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_MDT_TC_MDT_TC_MON_t_ARRAY) return HPS_MDT_TC_MDT_TC_MON_t_ARRAY is
      variable y : HPS_MDT_TC_MDT_TC_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_MDT_TC_MDT_TC_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.wr_addr);
      w := w + width(x.rd_addr);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_addr);
         y(u to u+w-1) := convert(x.wr_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_addr);
         y(u to u+w-1) := convert(x.rd_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_addr);
         y(u downto u-w+1) := convert(x.wr_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_addr);
         y(u downto u-w+1) := convert(x.rd_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t is
      variable y : HPS_MDT_TC_MDT_TC_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), tpl.SIGNALS);
         u := u + w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u to u+w-1), tpl.wr_addr);
         u := u + w;
         w := width(tpl.rd_addr);
         y.rd_addr := convert(x(u to u+w-1), tpl.rd_addr);
         u := u + w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u to u+w-1), tpl.wr_data);
      else
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), tpl.SIGNALS);
         u := u - w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u downto u-w+1), tpl.wr_addr);
         u := u - w;
         w := width(tpl.rd_addr);
         y.rd_addr := convert(x(u downto u-w+1), tpl.rd_addr);
         u := u - w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u downto u-w+1), tpl.wr_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_MDT_TC_CTRL_t) return HPS_MDT_TC_MDT_TC_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY is
      variable y : HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY) return HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY is
      variable y : HPS_MDT_TC_MDT_TC_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_MDT_TC_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MDT_TC);
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MDT_TC);
         y(u to u+w-1) := convert(x.MDT_TC, y(u to u+w-1));
      else
         w := width(x.MDT_TC);
         y(u downto u-w+1) := convert(x.MDT_TC, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t is
      variable y : HPS_MDT_TC_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MDT_TC);
         y.MDT_TC := convert(x(u to u+w-1), tpl.MDT_TC);
      else
         w := width(tpl.MDT_TC);
         y.MDT_TC := convert(x(u downto u-w+1), tpl.MDT_TC);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_MON_t) return HPS_MDT_TC_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_TC_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MDT_TC);
      return w;
   end function width;
   function convert(x: HPS_MDT_TC_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MDT_TC);
         y(u to u+w-1) := convert(x.MDT_TC, y(u to u+w-1));
      else
         w := width(x.MDT_TC);
         y(u downto u-w+1) := convert(x.MDT_TC, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t is
      variable y : HPS_MDT_TC_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MDT_TC);
         y.MDT_TC := convert(x(u to u+w-1), tpl.MDT_TC);
      else
         w := width(tpl.MDT_TC);
         y.MDT_TC := convert(x(u downto u-w+1), tpl.MDT_TC);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_TC_CTRL_t) return HPS_MDT_TC_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_rdy);
      w := w + width(x.freeze_ena);
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_rdy);
         y(u to u+w-1) := convert(x.rd_rdy, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_ena);
         y(u to u+w-1) := convert(x.freeze_ena, y(u to u+w-1));
      else
         w := width(x.rd_rdy);
         y(u downto u-w+1) := convert(x.rd_rdy, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_ena);
         y(u downto u-w+1) := convert(x.freeze_ena, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t is
      variable y : HPS_MDT_T0_MDT_T0_SIGNALS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u to u+w-1), tpl.rd_rdy);
         u := u + w;
         w := width(tpl.freeze_ena);
         y.freeze_ena := convert(x(u to u+w-1), tpl.freeze_ena);
      else
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u downto u-w+1), tpl.rd_rdy);
         u := u - w;
         w := width(tpl.freeze_ena);
         y.freeze_ena := convert(x(u downto u-w+1), tpl.freeze_ena);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_MDT_T0_SIGNALS_MON_t) return HPS_MDT_T0_MDT_T0_SIGNALS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_req);
      w := w + width(x.wr_ack);
      w := w + width(x.rd_req);
      w := w + width(x.rd_ack);
      w := w + width(x.flush_req);
      w := w + width(x.freeze_req);
      w := w + width(x.mem_sel);
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.wr_req);
         y(u to u+w-1) := convert(x.wr_req, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_ack);
         y(u to u+w-1) := convert(x.wr_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_req);
         y(u to u+w-1) := convert(x.rd_req, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_ack);
         y(u to u+w-1) := convert(x.rd_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.flush_req);
         y(u to u+w-1) := convert(x.flush_req, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_req);
         y(u to u+w-1) := convert(x.freeze_req, y(u to u+w-1));
         u := u + w;
         w := width(x.mem_sel);
         y(u to u+w-1) := convert(x.mem_sel, y(u to u+w-1));
      else
         w := width(x.wr_req);
         y(u downto u-w+1) := convert(x.wr_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_ack);
         y(u downto u-w+1) := convert(x.wr_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_req);
         y(u downto u-w+1) := convert(x.rd_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_ack);
         y(u downto u-w+1) := convert(x.rd_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.flush_req);
         y(u downto u-w+1) := convert(x.flush_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_req);
         y(u downto u-w+1) := convert(x.freeze_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.mem_sel);
         y(u downto u-w+1) := convert(x.mem_sel, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t is
      variable y : HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.wr_req);
         y.wr_req := convert(x(u to u+w-1), tpl.wr_req);
         u := u + w;
         w := width(tpl.wr_ack);
         y.wr_ack := convert(x(u to u+w-1), tpl.wr_ack);
         u := u + w;
         w := width(tpl.rd_req);
         y.rd_req := convert(x(u to u+w-1), tpl.rd_req);
         u := u + w;
         w := width(tpl.rd_ack);
         y.rd_ack := convert(x(u to u+w-1), tpl.rd_ack);
         u := u + w;
         w := width(tpl.flush_req);
         y.flush_req := convert(x(u to u+w-1), tpl.flush_req);
         u := u + w;
         w := width(tpl.freeze_req);
         y.freeze_req := convert(x(u to u+w-1), tpl.freeze_req);
         u := u + w;
         w := width(tpl.mem_sel);
         y.mem_sel := convert(x(u to u+w-1), tpl.mem_sel);
      else
         w := width(tpl.wr_req);
         y.wr_req := convert(x(u downto u-w+1), tpl.wr_req);
         u := u - w;
         w := width(tpl.wr_ack);
         y.wr_ack := convert(x(u downto u-w+1), tpl.wr_ack);
         u := u - w;
         w := width(tpl.rd_req);
         y.rd_req := convert(x(u downto u-w+1), tpl.rd_req);
         u := u - w;
         w := width(tpl.rd_ack);
         y.rd_ack := convert(x(u downto u-w+1), tpl.rd_ack);
         u := u - w;
         w := width(tpl.flush_req);
         y.flush_req := convert(x(u downto u-w+1), tpl.flush_req);
         u := u - w;
         w := width(tpl.freeze_req);
         y.freeze_req := convert(x(u downto u-w+1), tpl.freeze_req);
         u := u - w;
         w := width(tpl.mem_sel);
         y.mem_sel := convert(x(u downto u-w+1), tpl.mem_sel);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t) return HPS_MDT_T0_MDT_T0_SIGNALS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_data_0);
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.wr_data_0);
         y(u to u+w-1) := convert(x.wr_data_0, y(u to u+w-1));
      else
         w := width(x.wr_data_0);
         y(u downto u-w+1) := convert(x.wr_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t is
      variable y : HPS_MDT_T0_MDT_T0_wr_data_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.wr_data_0);
         y.wr_data_0 := convert(x(u to u+w-1), tpl.wr_data_0);
      else
         w := width(tpl.wr_data_0);
         y.wr_data_0 := convert(x(u downto u-w+1), tpl.wr_data_0);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_MDT_T0_wr_data_CTRL_t) return HPS_MDT_T0_MDT_T0_wr_data_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_data_0);
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_MDT_T0_rd_data_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_data_0);
         y(u to u+w-1) := convert(x.rd_data_0, y(u to u+w-1));
      else
         w := width(x.rd_data_0);
         y(u downto u-w+1) := convert(x.rd_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t is
      variable y : HPS_MDT_T0_MDT_T0_rd_data_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_data_0);
         y.rd_data_0 := convert(x(u to u+w-1), tpl.rd_data_0);
      else
         w := width(tpl.rd_data_0);
         y.rd_data_0 := convert(x(u downto u-w+1), tpl.rd_data_0);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_MDT_T0_rd_data_MON_t) return HPS_MDT_T0_MDT_T0_rd_data_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_T0_MDT_T0_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_MDT_T0_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t is
      variable y : HPS_MDT_T0_MDT_T0_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), tpl.SIGNALS);
         u := u + w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u to u+w-1), tpl.rd_data);
      else
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), tpl.SIGNALS);
         u := u - w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u downto u-w+1), tpl.rd_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_MDT_T0_MON_t) return HPS_MDT_T0_MDT_T0_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY is
      variable y : HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_MDT_T0_MDT_T0_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_MDT_T0_MDT_T0_MON_t_ARRAY) return HPS_MDT_T0_MDT_T0_MON_t_ARRAY is
      variable y : HPS_MDT_T0_MDT_T0_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_MDT_T0_MDT_T0_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.wr_addr);
      w := w + width(x.rd_addr);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_addr);
         y(u to u+w-1) := convert(x.wr_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_addr);
         y(u to u+w-1) := convert(x.rd_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_addr);
         y(u downto u-w+1) := convert(x.wr_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_addr);
         y(u downto u-w+1) := convert(x.rd_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t is
      variable y : HPS_MDT_T0_MDT_T0_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), tpl.SIGNALS);
         u := u + w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u to u+w-1), tpl.wr_addr);
         u := u + w;
         w := width(tpl.rd_addr);
         y.rd_addr := convert(x(u to u+w-1), tpl.rd_addr);
         u := u + w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u to u+w-1), tpl.wr_data);
      else
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), tpl.SIGNALS);
         u := u - w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u downto u-w+1), tpl.wr_addr);
         u := u - w;
         w := width(tpl.rd_addr);
         y.rd_addr := convert(x(u downto u-w+1), tpl.rd_addr);
         u := u - w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u downto u-w+1), tpl.wr_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_MDT_T0_CTRL_t) return HPS_MDT_T0_MDT_T0_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY is
      variable y : HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY) return HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY is
      variable y : HPS_MDT_T0_MDT_T0_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_MDT_T0_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MDT_T0);
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MDT_T0);
         y(u to u+w-1) := convert(x.MDT_T0, y(u to u+w-1));
      else
         w := width(x.MDT_T0);
         y(u downto u-w+1) := convert(x.MDT_T0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t is
      variable y : HPS_MDT_T0_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MDT_T0);
         y.MDT_T0 := convert(x(u to u+w-1), tpl.MDT_T0);
      else
         w := width(tpl.MDT_T0);
         y.MDT_T0 := convert(x(u downto u-w+1), tpl.MDT_T0);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_MON_t) return HPS_MDT_T0_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MDT_T0_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MDT_T0);
      return w;
   end function width;
   function convert(x: HPS_MDT_T0_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MDT_T0);
         y(u to u+w-1) := convert(x.MDT_T0, y(u to u+w-1));
      else
         w := width(x.MDT_T0);
         y(u downto u-w+1) := convert(x.MDT_T0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t is
      variable y : HPS_MDT_T0_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MDT_T0);
         y.MDT_T0 := convert(x(u to u+w-1), tpl.MDT_T0);
      else
         w := width(tpl.MDT_T0);
         y.MDT_T0 := convert(x(u downto u-w+1), tpl.MDT_T0);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MDT_T0_CTRL_t) return HPS_MDT_T0_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET);
      w := w + width(x.ENABLE);
      w := w + width(x.DISABLE);
      w := w + width(x.FREEZE);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET);
         y(u to u+w-1) := convert(x.RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.ENABLE);
         y(u to u+w-1) := convert(x.ENABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.DISABLE);
         y(u to u+w-1) := convert(x.DISABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.FREEZE);
         y(u to u+w-1) := convert(x.FREEZE, y(u to u+w-1));
      else
         w := width(x.RESET);
         y(u downto u-w+1) := convert(x.RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.ENABLE);
         y(u downto u-w+1) := convert(x.ENABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.DISABLE);
         y(u downto u-w+1) := convert(x.DISABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.FREEZE);
         y(u downto u-w+1) := convert(x.FREEZE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t is
      variable y : HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET);
         y.RESET := convert(x(u to u+w-1), tpl.RESET);
         u := u + w;
         w := width(tpl.ENABLE);
         y.ENABLE := convert(x(u to u+w-1), tpl.ENABLE);
         u := u + w;
         w := width(tpl.DISABLE);
         y.DISABLE := convert(x(u to u+w-1), tpl.DISABLE);
         u := u + w;
         w := width(tpl.FREEZE);
         y.FREEZE := convert(x(u to u+w-1), tpl.FREEZE);
      else
         w := width(tpl.RESET);
         y.RESET := convert(x(u downto u-w+1), tpl.RESET);
         u := u - w;
         w := width(tpl.ENABLE);
         y.ENABLE := convert(x(u downto u-w+1), tpl.ENABLE);
         u := u - w;
         w := width(tpl.DISABLE);
         y.DISABLE := convert(x(u downto u-w+1), tpl.DISABLE);
         u := u - w;
         w := width(tpl.FREEZE);
         y.FREEZE := convert(x(u downto u-w+1), tpl.FREEZE);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t) return HPS_HEG_HEG_SUPER_ACTIONS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.INPUT_EN);
      w := w + width(x.OUTPUT_EN);
      w := w + width(x.FLUSH_MEM_RESET);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.INPUT_EN);
         y(u to u+w-1) := convert(x.INPUT_EN, y(u to u+w-1));
         u := u + w;
         w := width(x.OUTPUT_EN);
         y(u to u+w-1) := convert(x.OUTPUT_EN, y(u to u+w-1));
         u := u + w;
         w := width(x.FLUSH_MEM_RESET);
         y(u to u+w-1) := convert(x.FLUSH_MEM_RESET, y(u to u+w-1));
      else
         w := width(x.INPUT_EN);
         y(u downto u-w+1) := convert(x.INPUT_EN, y(u downto u-w+1));
         u := u - w;
         w := width(x.OUTPUT_EN);
         y(u downto u-w+1) := convert(x.OUTPUT_EN, y(u downto u-w+1));
         u := u - w;
         w := width(x.FLUSH_MEM_RESET);
         y(u downto u-w+1) := convert(x.FLUSH_MEM_RESET, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t is
      variable y : HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.INPUT_EN);
         y.INPUT_EN := convert(x(u to u+w-1), tpl.INPUT_EN);
         u := u + w;
         w := width(tpl.OUTPUT_EN);
         y.OUTPUT_EN := convert(x(u to u+w-1), tpl.OUTPUT_EN);
         u := u + w;
         w := width(tpl.FLUSH_MEM_RESET);
         y.FLUSH_MEM_RESET := convert(x(u to u+w-1), tpl.FLUSH_MEM_RESET);
      else
         w := width(tpl.INPUT_EN);
         y.INPUT_EN := convert(x(u downto u-w+1), tpl.INPUT_EN);
         u := u - w;
         w := width(tpl.OUTPUT_EN);
         y.OUTPUT_EN := convert(x(u downto u-w+1), tpl.OUTPUT_EN);
         u := u - w;
         w := width(tpl.FLUSH_MEM_RESET);
         y.FLUSH_MEM_RESET := convert(x(u downto u-w+1), tpl.FLUSH_MEM_RESET);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t) return HPS_HEG_HEG_SUPER_CONFIGS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_SUPER_STATUS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ENABLED);
      w := w + width(x.READY);
      w := w + width(x.ERROR);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_SUPER_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ENABLED);
         y(u to u+w-1) := convert(x.ENABLED, y(u to u+w-1));
         u := u + w;
         w := width(x.READY);
         y(u to u+w-1) := convert(x.READY, y(u to u+w-1));
         u := u + w;
         w := width(x.ERROR);
         y(u to u+w-1) := convert(x.ERROR, y(u to u+w-1));
      else
         w := width(x.ENABLED);
         y(u downto u-w+1) := convert(x.ENABLED, y(u downto u-w+1));
         u := u - w;
         w := width(x.READY);
         y(u downto u-w+1) := convert(x.READY, y(u downto u-w+1));
         u := u - w;
         w := width(x.ERROR);
         y(u downto u-w+1) := convert(x.ERROR, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t is
      variable y : HPS_HEG_HEG_SUPER_STATUS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ENABLED);
         y.ENABLED := convert(x(u to u+w-1), tpl.ENABLED);
         u := u + w;
         w := width(tpl.READY);
         y.READY := convert(x(u to u+w-1), tpl.READY);
         u := u + w;
         w := width(tpl.ERROR);
         y.ERROR := convert(x(u to u+w-1), tpl.ERROR);
      else
         w := width(tpl.ENABLED);
         y.ENABLED := convert(x(u downto u-w+1), tpl.ENABLED);
         u := u - w;
         w := width(tpl.READY);
         y.READY := convert(x(u downto u-w+1), tpl.READY);
         u := u - w;
         w := width(tpl.ERROR);
         y.ERROR := convert(x(u downto u-w+1), tpl.ERROR);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_SUPER_STATUS_MON_t) return HPS_HEG_HEG_SUPER_STATUS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SLC_PROC);
      w := w + width(x.HIT_PROC);
      w := w + width(x.HIT_OK);
      w := w + width(x.ERROR);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_SUPER_COUNTERS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SLC_PROC);
         y(u to u+w-1) := convert(x.SLC_PROC, y(u to u+w-1));
         u := u + w;
         w := width(x.HIT_PROC);
         y(u to u+w-1) := convert(x.HIT_PROC, y(u to u+w-1));
         u := u + w;
         w := width(x.HIT_OK);
         y(u to u+w-1) := convert(x.HIT_OK, y(u to u+w-1));
         u := u + w;
         w := width(x.ERROR);
         y(u to u+w-1) := convert(x.ERROR, y(u to u+w-1));
      else
         w := width(x.SLC_PROC);
         y(u downto u-w+1) := convert(x.SLC_PROC, y(u downto u-w+1));
         u := u - w;
         w := width(x.HIT_PROC);
         y(u downto u-w+1) := convert(x.HIT_PROC, y(u downto u-w+1));
         u := u - w;
         w := width(x.HIT_OK);
         y(u downto u-w+1) := convert(x.HIT_OK, y(u downto u-w+1));
         u := u - w;
         w := width(x.ERROR);
         y(u downto u-w+1) := convert(x.ERROR, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t is
      variable y : HPS_HEG_HEG_SUPER_COUNTERS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SLC_PROC);
         y.SLC_PROC := convert(x(u to u+w-1), tpl.SLC_PROC);
         u := u + w;
         w := width(tpl.HIT_PROC);
         y.HIT_PROC := convert(x(u to u+w-1), tpl.HIT_PROC);
         u := u + w;
         w := width(tpl.HIT_OK);
         y.HIT_OK := convert(x(u to u+w-1), tpl.HIT_OK);
         u := u + w;
         w := width(tpl.ERROR);
         y.ERROR := convert(x(u to u+w-1), tpl.ERROR);
      else
         w := width(tpl.SLC_PROC);
         y.SLC_PROC := convert(x(u downto u-w+1), tpl.SLC_PROC);
         u := u - w;
         w := width(tpl.HIT_PROC);
         y.HIT_PROC := convert(x(u downto u-w+1), tpl.HIT_PROC);
         u := u - w;
         w := width(tpl.HIT_OK);
         y.HIT_OK := convert(x(u downto u-w+1), tpl.HIT_OK);
         u := u - w;
         w := width(tpl.ERROR);
         y.ERROR := convert(x(u downto u-w+1), tpl.ERROR);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_SUPER_COUNTERS_MON_t) return HPS_HEG_HEG_SUPER_COUNTERS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_SUPER_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.STATUS);
      w := w + width(x.COUNTERS);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_SUPER_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.STATUS);
         y(u to u+w-1) := convert(x.STATUS, y(u to u+w-1));
         u := u + w;
         w := width(x.COUNTERS);
         y(u to u+w-1) := convert(x.COUNTERS, y(u to u+w-1));
      else
         w := width(x.STATUS);
         y(u downto u-w+1) := convert(x.STATUS, y(u downto u-w+1));
         u := u - w;
         w := width(x.COUNTERS);
         y(u downto u-w+1) := convert(x.COUNTERS, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t is
      variable y : HPS_HEG_HEG_SUPER_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u to u+w-1), tpl.STATUS);
         u := u + w;
         w := width(tpl.COUNTERS);
         y.COUNTERS := convert(x(u to u+w-1), tpl.COUNTERS);
      else
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u downto u-w+1), tpl.STATUS);
         u := u - w;
         w := width(tpl.COUNTERS);
         y.COUNTERS := convert(x(u downto u-w+1), tpl.COUNTERS);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_SUPER_MON_t) return HPS_HEG_HEG_SUPER_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_SUPER_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ACTIONS);
      w := w + width(x.CONFIGS);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_SUPER_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ACTIONS);
         y(u to u+w-1) := convert(x.ACTIONS, y(u to u+w-1));
         u := u + w;
         w := width(x.CONFIGS);
         y(u to u+w-1) := convert(x.CONFIGS, y(u to u+w-1));
      else
         w := width(x.ACTIONS);
         y(u downto u-w+1) := convert(x.ACTIONS, y(u downto u-w+1));
         u := u - w;
         w := width(x.CONFIGS);
         y(u downto u-w+1) := convert(x.CONFIGS, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t is
      variable y : HPS_HEG_HEG_SUPER_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ACTIONS);
         y.ACTIONS := convert(x(u to u+w-1), tpl.ACTIONS);
         u := u + w;
         w := width(tpl.CONFIGS);
         y.CONFIGS := convert(x(u to u+w-1), tpl.CONFIGS);
      else
         w := width(tpl.ACTIONS);
         y.ACTIONS := convert(x(u downto u-w+1), tpl.ACTIONS);
         u := u - w;
         w := width(tpl.CONFIGS);
         y.CONFIGS := convert(x(u downto u-w+1), tpl.CONFIGS);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_SUPER_CTRL_t) return HPS_HEG_HEG_SUPER_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_rdy);
      w := w + width(x.freeze_ena);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_rdy);
         y(u to u+w-1) := convert(x.rd_rdy, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_ena);
         y(u to u+w-1) := convert(x.freeze_ena, y(u to u+w-1));
      else
         w := width(x.rd_rdy);
         y(u downto u-w+1) := convert(x.rd_rdy, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_ena);
         y(u downto u-w+1) := convert(x.freeze_ena, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t is
      variable y : HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u to u+w-1), tpl.rd_rdy);
         u := u + w;
         w := width(tpl.freeze_ena);
         y.freeze_ena := convert(x(u to u+w-1), tpl.freeze_ena);
      else
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u downto u-w+1), tpl.rd_rdy);
         u := u - w;
         w := width(tpl.freeze_ena);
         y.freeze_ena := convert(x(u downto u-w+1), tpl.freeze_ena);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_req);
      w := w + width(x.wr_ack);
      w := w + width(x.rd_req);
      w := w + width(x.rd_ack);
      w := w + width(x.flush_req);
      w := w + width(x.freeze_req);
      w := w + width(x.mem_sel);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.wr_req);
         y(u to u+w-1) := convert(x.wr_req, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_ack);
         y(u to u+w-1) := convert(x.wr_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_req);
         y(u to u+w-1) := convert(x.rd_req, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_ack);
         y(u to u+w-1) := convert(x.rd_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.flush_req);
         y(u to u+w-1) := convert(x.flush_req, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_req);
         y(u to u+w-1) := convert(x.freeze_req, y(u to u+w-1));
         u := u + w;
         w := width(x.mem_sel);
         y(u to u+w-1) := convert(x.mem_sel, y(u to u+w-1));
      else
         w := width(x.wr_req);
         y(u downto u-w+1) := convert(x.wr_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_ack);
         y(u downto u-w+1) := convert(x.wr_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_req);
         y(u downto u-w+1) := convert(x.rd_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_ack);
         y(u downto u-w+1) := convert(x.rd_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.flush_req);
         y(u downto u-w+1) := convert(x.flush_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_req);
         y(u downto u-w+1) := convert(x.freeze_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.mem_sel);
         y(u downto u-w+1) := convert(x.mem_sel, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t is
      variable y : HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.wr_req);
         y.wr_req := convert(x(u to u+w-1), tpl.wr_req);
         u := u + w;
         w := width(tpl.wr_ack);
         y.wr_ack := convert(x(u to u+w-1), tpl.wr_ack);
         u := u + w;
         w := width(tpl.rd_req);
         y.rd_req := convert(x(u to u+w-1), tpl.rd_req);
         u := u + w;
         w := width(tpl.rd_ack);
         y.rd_ack := convert(x(u to u+w-1), tpl.rd_ack);
         u := u + w;
         w := width(tpl.flush_req);
         y.flush_req := convert(x(u to u+w-1), tpl.flush_req);
         u := u + w;
         w := width(tpl.freeze_req);
         y.freeze_req := convert(x(u to u+w-1), tpl.freeze_req);
         u := u + w;
         w := width(tpl.mem_sel);
         y.mem_sel := convert(x(u to u+w-1), tpl.mem_sel);
      else
         w := width(tpl.wr_req);
         y.wr_req := convert(x(u downto u-w+1), tpl.wr_req);
         u := u - w;
         w := width(tpl.wr_ack);
         y.wr_ack := convert(x(u downto u-w+1), tpl.wr_ack);
         u := u - w;
         w := width(tpl.rd_req);
         y.rd_req := convert(x(u downto u-w+1), tpl.rd_req);
         u := u - w;
         w := width(tpl.rd_ack);
         y.rd_ack := convert(x(u downto u-w+1), tpl.rd_ack);
         u := u - w;
         w := width(tpl.flush_req);
         y.flush_req := convert(x(u downto u-w+1), tpl.flush_req);
         u := u - w;
         w := width(tpl.freeze_req);
         y.freeze_req := convert(x(u downto u-w+1), tpl.freeze_req);
         u := u - w;
         w := width(tpl.mem_sel);
         y.mem_sel := convert(x(u downto u-w+1), tpl.mem_sel);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_SIGNALS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_data_0);
      w := w + width(x.wr_data_1);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.wr_data_0);
         y(u to u+w-1) := convert(x.wr_data_0, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data_1);
         y(u to u+w-1) := convert(x.wr_data_1, y(u to u+w-1));
      else
         w := width(x.wr_data_0);
         y(u downto u-w+1) := convert(x.wr_data_0, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data_1);
         y(u downto u-w+1) := convert(x.wr_data_1, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t is
      variable y : HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.wr_data_0);
         y.wr_data_0 := convert(x(u to u+w-1), tpl.wr_data_0);
         u := u + w;
         w := width(tpl.wr_data_1);
         y.wr_data_1 := convert(x(u to u+w-1), tpl.wr_data_1);
      else
         w := width(tpl.wr_data_0);
         y.wr_data_0 := convert(x(u downto u-w+1), tpl.wr_data_0);
         u := u - w;
         w := width(tpl.wr_data_1);
         y.wr_data_1 := convert(x(u downto u-w+1), tpl.wr_data_1);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_wr_data_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_data_1);
      w := w + width(x.rd_data_0);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_data_1);
         y(u to u+w-1) := convert(x.rd_data_1, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data_0);
         y(u to u+w-1) := convert(x.rd_data_0, y(u to u+w-1));
      else
         w := width(x.rd_data_1);
         y(u downto u-w+1) := convert(x.rd_data_1, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data_0);
         y(u downto u-w+1) := convert(x.rd_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t is
      variable y : HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_data_1);
         y.rd_data_1 := convert(x(u to u+w-1), tpl.rd_data_1);
         u := u + w;
         w := width(tpl.rd_data_0);
         y.rd_data_0 := convert(x(u to u+w-1), tpl.rd_data_0);
      else
         w := width(tpl.rd_data_1);
         y.rd_data_1 := convert(x(u downto u-w+1), tpl.rd_data_1);
         u := u - w;
         w := width(tpl.rd_data_0);
         y.rd_data_0 := convert(x(u downto u-w+1), tpl.rd_data_0);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_rd_data_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t is
      variable y : HPS_HEG_HEG_CTRL_ROI_TC_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), tpl.SIGNALS);
         u := u + w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u to u+w-1), tpl.rd_data);
      else
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), tpl.SIGNALS);
         u := u - w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u downto u-w+1), tpl.rd_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_MON_t) return HPS_HEG_HEG_CTRL_ROI_TC_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.wr_addr);
      w := w + width(x.rd_addr);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_addr);
         y(u to u+w-1) := convert(x.wr_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_addr);
         y(u to u+w-1) := convert(x.rd_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_addr);
         y(u downto u-w+1) := convert(x.wr_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_addr);
         y(u downto u-w+1) := convert(x.rd_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t is
      variable y : HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), tpl.SIGNALS);
         u := u + w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u to u+w-1), tpl.wr_addr);
         u := u + w;
         w := width(tpl.rd_addr);
         y.rd_addr := convert(x(u to u+w-1), tpl.rd_addr);
         u := u + w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u to u+w-1), tpl.wr_data);
      else
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), tpl.SIGNALS);
         u := u - w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u downto u-w+1), tpl.wr_addr);
         u := u - w;
         w := width(tpl.rd_addr);
         y.rd_addr := convert(x(u downto u-w+1), tpl.rd_addr);
         u := u - w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u downto u-w+1), tpl.wr_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t) return HPS_HEG_HEG_CTRL_ROI_TC_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_CTRL_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ROI_TC);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ROI_TC);
         y(u to u+w-1) := convert(x.ROI_TC, y(u to u+w-1));
      else
         w := width(x.ROI_TC);
         y(u downto u-w+1) := convert(x.ROI_TC, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t is
      variable y : HPS_HEG_HEG_CTRL_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ROI_TC);
         y.ROI_TC := convert(x(u to u+w-1), tpl.ROI_TC);
      else
         w := width(tpl.ROI_TC);
         y.ROI_TC := convert(x(u downto u-w+1), tpl.ROI_TC);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_MON_t) return HPS_HEG_HEG_CTRL_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_CTRL_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ROI_TC);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ROI_TC);
         y(u to u+w-1) := convert(x.ROI_TC, y(u to u+w-1));
      else
         w := width(x.ROI_TC);
         y(u downto u-w+1) := convert(x.ROI_TC, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t is
      variable y : HPS_HEG_HEG_CTRL_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ROI_TC);
         y.ROI_TC := convert(x(u to u+w-1), tpl.ROI_TC);
      else
         w := width(tpl.ROI_TC);
         y.ROI_TC := convert(x(u downto u-w+1), tpl.ROI_TC);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_CTRL_t) return HPS_HEG_HEG_CTRL_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET);
      w := w + width(x.ENABLE);
      w := w + width(x.DISABLE);
      w := w + width(x.FREEZE);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET);
         y(u to u+w-1) := convert(x.RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.ENABLE);
         y(u to u+w-1) := convert(x.ENABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.DISABLE);
         y(u to u+w-1) := convert(x.DISABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.FREEZE);
         y(u to u+w-1) := convert(x.FREEZE, y(u to u+w-1));
      else
         w := width(x.RESET);
         y(u downto u-w+1) := convert(x.RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.ENABLE);
         y(u downto u-w+1) := convert(x.ENABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.DISABLE);
         y(u downto u-w+1) := convert(x.DISABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.FREEZE);
         y(u downto u-w+1) := convert(x.FREEZE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t is
      variable y : HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET);
         y.RESET := convert(x(u to u+w-1), tpl.RESET);
         u := u + w;
         w := width(tpl.ENABLE);
         y.ENABLE := convert(x(u to u+w-1), tpl.ENABLE);
         u := u + w;
         w := width(tpl.DISABLE);
         y.DISABLE := convert(x(u to u+w-1), tpl.DISABLE);
         u := u + w;
         w := width(tpl.FREEZE);
         y.FREEZE := convert(x(u to u+w-1), tpl.FREEZE);
      else
         w := width(tpl.RESET);
         y.RESET := convert(x(u downto u-w+1), tpl.RESET);
         u := u - w;
         w := width(tpl.ENABLE);
         y.ENABLE := convert(x(u downto u-w+1), tpl.ENABLE);
         u := u - w;
         w := width(tpl.DISABLE);
         y.DISABLE := convert(x(u downto u-w+1), tpl.DISABLE);
         u := u - w;
         w := width(tpl.FREEZE);
         y.FREEZE := convert(x(u downto u-w+1), tpl.FREEZE);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t) return HPS_HEG_HEG_HP_HP_ACTIONS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.INPUT_EN);
      w := w + width(x.OUTPUT_EN);
      w := w + width(x.FLUSH_MEM_RESET);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.INPUT_EN);
         y(u to u+w-1) := convert(x.INPUT_EN, y(u to u+w-1));
         u := u + w;
         w := width(x.OUTPUT_EN);
         y(u to u+w-1) := convert(x.OUTPUT_EN, y(u to u+w-1));
         u := u + w;
         w := width(x.FLUSH_MEM_RESET);
         y(u to u+w-1) := convert(x.FLUSH_MEM_RESET, y(u to u+w-1));
      else
         w := width(x.INPUT_EN);
         y(u downto u-w+1) := convert(x.INPUT_EN, y(u downto u-w+1));
         u := u - w;
         w := width(x.OUTPUT_EN);
         y(u downto u-w+1) := convert(x.OUTPUT_EN, y(u downto u-w+1));
         u := u - w;
         w := width(x.FLUSH_MEM_RESET);
         y(u downto u-w+1) := convert(x.FLUSH_MEM_RESET, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t is
      variable y : HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.INPUT_EN);
         y.INPUT_EN := convert(x(u to u+w-1), tpl.INPUT_EN);
         u := u + w;
         w := width(tpl.OUTPUT_EN);
         y.OUTPUT_EN := convert(x(u to u+w-1), tpl.OUTPUT_EN);
         u := u + w;
         w := width(tpl.FLUSH_MEM_RESET);
         y.FLUSH_MEM_RESET := convert(x(u to u+w-1), tpl.FLUSH_MEM_RESET);
      else
         w := width(tpl.INPUT_EN);
         y.INPUT_EN := convert(x(u downto u-w+1), tpl.INPUT_EN);
         u := u - w;
         w := width(tpl.OUTPUT_EN);
         y.OUTPUT_EN := convert(x(u downto u-w+1), tpl.OUTPUT_EN);
         u := u - w;
         w := width(tpl.FLUSH_MEM_RESET);
         y.FLUSH_MEM_RESET := convert(x(u downto u-w+1), tpl.FLUSH_MEM_RESET);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t) return HPS_HEG_HEG_HP_HP_CONFIGS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_rdy);
      w := w + width(x.freeze_ena);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_rdy);
         y(u to u+w-1) := convert(x.rd_rdy, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_ena);
         y(u to u+w-1) := convert(x.freeze_ena, y(u to u+w-1));
      else
         w := width(x.rd_rdy);
         y(u downto u-w+1) := convert(x.rd_rdy, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_ena);
         y(u downto u-w+1) := convert(x.freeze_ena, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t is
      variable y : HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u to u+w-1), tpl.rd_rdy);
         u := u + w;
         w := width(tpl.freeze_ena);
         y.freeze_ena := convert(x(u to u+w-1), tpl.freeze_ena);
      else
         w := width(tpl.rd_rdy);
         y.rd_rdy := convert(x(u downto u-w+1), tpl.rd_rdy);
         u := u - w;
         w := width(tpl.freeze_ena);
         y.freeze_ena := convert(x(u downto u-w+1), tpl.freeze_ena);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_req);
      w := w + width(x.wr_ack);
      w := w + width(x.rd_req);
      w := w + width(x.rd_ack);
      w := w + width(x.flush_req);
      w := w + width(x.freeze_req);
      w := w + width(x.mem_sel);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.wr_req);
         y(u to u+w-1) := convert(x.wr_req, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_ack);
         y(u to u+w-1) := convert(x.wr_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_req);
         y(u to u+w-1) := convert(x.rd_req, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_ack);
         y(u to u+w-1) := convert(x.rd_ack, y(u to u+w-1));
         u := u + w;
         w := width(x.flush_req);
         y(u to u+w-1) := convert(x.flush_req, y(u to u+w-1));
         u := u + w;
         w := width(x.freeze_req);
         y(u to u+w-1) := convert(x.freeze_req, y(u to u+w-1));
         u := u + w;
         w := width(x.mem_sel);
         y(u to u+w-1) := convert(x.mem_sel, y(u to u+w-1));
      else
         w := width(x.wr_req);
         y(u downto u-w+1) := convert(x.wr_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_ack);
         y(u downto u-w+1) := convert(x.wr_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_req);
         y(u downto u-w+1) := convert(x.rd_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_ack);
         y(u downto u-w+1) := convert(x.rd_ack, y(u downto u-w+1));
         u := u - w;
         w := width(x.flush_req);
         y(u downto u-w+1) := convert(x.flush_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.freeze_req);
         y(u downto u-w+1) := convert(x.freeze_req, y(u downto u-w+1));
         u := u - w;
         w := width(x.mem_sel);
         y(u downto u-w+1) := convert(x.mem_sel, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t is
      variable y : HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.wr_req);
         y.wr_req := convert(x(u to u+w-1), tpl.wr_req);
         u := u + w;
         w := width(tpl.wr_ack);
         y.wr_ack := convert(x(u to u+w-1), tpl.wr_ack);
         u := u + w;
         w := width(tpl.rd_req);
         y.rd_req := convert(x(u to u+w-1), tpl.rd_req);
         u := u + w;
         w := width(tpl.rd_ack);
         y.rd_ack := convert(x(u to u+w-1), tpl.rd_ack);
         u := u + w;
         w := width(tpl.flush_req);
         y.flush_req := convert(x(u to u+w-1), tpl.flush_req);
         u := u + w;
         w := width(tpl.freeze_req);
         y.freeze_req := convert(x(u to u+w-1), tpl.freeze_req);
         u := u + w;
         w := width(tpl.mem_sel);
         y.mem_sel := convert(x(u to u+w-1), tpl.mem_sel);
      else
         w := width(tpl.wr_req);
         y.wr_req := convert(x(u downto u-w+1), tpl.wr_req);
         u := u - w;
         w := width(tpl.wr_ack);
         y.wr_ack := convert(x(u downto u-w+1), tpl.wr_ack);
         u := u - w;
         w := width(tpl.rd_req);
         y.rd_req := convert(x(u downto u-w+1), tpl.rd_req);
         u := u - w;
         w := width(tpl.rd_ack);
         y.rd_ack := convert(x(u downto u-w+1), tpl.rd_ack);
         u := u - w;
         w := width(tpl.flush_req);
         y.flush_req := convert(x(u downto u-w+1), tpl.flush_req);
         u := u - w;
         w := width(tpl.freeze_req);
         y.freeze_req := convert(x(u downto u-w+1), tpl.freeze_req);
         u := u - w;
         w := width(tpl.mem_sel);
         y.mem_sel := convert(x(u downto u-w+1), tpl.mem_sel);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_SIGNALS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.wr_data_0);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.wr_data_0);
         y(u to u+w-1) := convert(x.wr_data_0, y(u to u+w-1));
      else
         w := width(x.wr_data_0);
         y(u downto u-w+1) := convert(x.wr_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t is
      variable y : HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.wr_data_0);
         y.wr_data_0 := convert(x(u to u+w-1), tpl.wr_data_0);
      else
         w := width(tpl.wr_data_0);
         y.wr_data_0 := convert(x(u downto u-w+1), tpl.wr_data_0);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_wr_data_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.rd_data_0);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.rd_data_0);
         y(u to u+w-1) := convert(x.rd_data_0, y(u to u+w-1));
      else
         w := width(x.rd_data_0);
         y(u downto u-w+1) := convert(x.rd_data_0, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t is
      variable y : HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.rd_data_0);
         y.rd_data_0 := convert(x(u to u+w-1), tpl.rd_data_0);
      else
         w := width(tpl.rd_data_0);
         y.rd_data_0 := convert(x(u downto u-w+1), tpl.rd_data_0);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_rd_data_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.rd_data);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_data);
         y(u to u+w-1) := convert(x.rd_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_data);
         y(u downto u-w+1) := convert(x.rd_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t is
      variable y : HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), tpl.SIGNALS);
         u := u + w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u to u+w-1), tpl.rd_data);
      else
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), tpl.SIGNALS);
         u := u - w;
         w := width(tpl.rd_data);
         y.rd_data := convert(x(u downto u-w+1), tpl.rd_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SIGNALS);
      w := w + width(x.wr_addr);
      w := w + width(x.rd_addr);
      w := w + width(x.wr_data);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SIGNALS);
         y(u to u+w-1) := convert(x.SIGNALS, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_addr);
         y(u to u+w-1) := convert(x.wr_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.rd_addr);
         y(u to u+w-1) := convert(x.rd_addr, y(u to u+w-1));
         u := u + w;
         w := width(x.wr_data);
         y(u to u+w-1) := convert(x.wr_data, y(u to u+w-1));
      else
         w := width(x.SIGNALS);
         y(u downto u-w+1) := convert(x.SIGNALS, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_addr);
         y(u downto u-w+1) := convert(x.wr_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.rd_addr);
         y(u downto u-w+1) := convert(x.rd_addr, y(u downto u-w+1));
         u := u - w;
         w := width(x.wr_data);
         y(u downto u-w+1) := convert(x.wr_data, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t is
      variable y : HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u to u+w-1), tpl.SIGNALS);
         u := u + w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u to u+w-1), tpl.wr_addr);
         u := u + w;
         w := width(tpl.rd_addr);
         y.rd_addr := convert(x(u to u+w-1), tpl.rd_addr);
         u := u + w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u to u+w-1), tpl.wr_data);
      else
         w := width(tpl.SIGNALS);
         y.SIGNALS := convert(x(u downto u-w+1), tpl.SIGNALS);
         u := u - w;
         w := width(tpl.wr_addr);
         y.wr_addr := convert(x(u downto u-w+1), tpl.wr_addr);
         u := u - w;
         w := width(tpl.rd_addr);
         y.rd_addr := convert(x(u downto u-w+1), tpl.rd_addr);
         u := u - w;
         w := width(tpl.wr_data);
         y.wr_data := convert(x(u downto u-w+1), tpl.wr_data);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t) return HPS_HEG_HEG_HP_HP_MDT_DT2R_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.MDT_DT2R);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.MDT_DT2R);
         y(u to u+w-1) := convert(x.MDT_DT2R, y(u to u+w-1));
      else
         w := width(x.MDT_DT2R);
         y(u downto u-w+1) := convert(x.MDT_DT2R, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t is
      variable y : HPS_HEG_HEG_HP_HP_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.MDT_DT2R);
         y.MDT_DT2R := convert(x(u to u+w-1), tpl.MDT_DT2R);
      else
         w := width(tpl.MDT_DT2R);
         y.MDT_DT2R := convert(x(u downto u-w+1), tpl.MDT_DT2R);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MON_t) return HPS_HEG_HEG_HP_HP_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY is
      variable y : HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_HEG_HEG_HP_HP_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_HEG_HEG_HP_HP_MON_t_ARRAY) return HPS_HEG_HEG_HP_HP_MON_t_ARRAY is
      variable y : HPS_HEG_HEG_HP_HP_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_HEG_HEG_HP_HP_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ACTIONS);
      w := w + width(x.CONFIGS);
      w := w + width(x.MDT_DT2R);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ACTIONS);
         y(u to u+w-1) := convert(x.ACTIONS, y(u to u+w-1));
         u := u + w;
         w := width(x.CONFIGS);
         y(u to u+w-1) := convert(x.CONFIGS, y(u to u+w-1));
         u := u + w;
         w := width(x.MDT_DT2R);
         y(u to u+w-1) := convert(x.MDT_DT2R, y(u to u+w-1));
      else
         w := width(x.ACTIONS);
         y(u downto u-w+1) := convert(x.ACTIONS, y(u downto u-w+1));
         u := u - w;
         w := width(x.CONFIGS);
         y(u downto u-w+1) := convert(x.CONFIGS, y(u downto u-w+1));
         u := u - w;
         w := width(x.MDT_DT2R);
         y(u downto u-w+1) := convert(x.MDT_DT2R, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t is
      variable y : HPS_HEG_HEG_HP_HP_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ACTIONS);
         y.ACTIONS := convert(x(u to u+w-1), tpl.ACTIONS);
         u := u + w;
         w := width(tpl.CONFIGS);
         y.CONFIGS := convert(x(u to u+w-1), tpl.CONFIGS);
         u := u + w;
         w := width(tpl.MDT_DT2R);
         y.MDT_DT2R := convert(x(u to u+w-1), tpl.MDT_DT2R);
      else
         w := width(tpl.ACTIONS);
         y.ACTIONS := convert(x(u downto u-w+1), tpl.ACTIONS);
         u := u - w;
         w := width(tpl.CONFIGS);
         y.CONFIGS := convert(x(u downto u-w+1), tpl.CONFIGS);
         u := u - w;
         w := width(tpl.MDT_DT2R);
         y.MDT_DT2R := convert(x(u downto u-w+1), tpl.MDT_DT2R);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_CTRL_t) return HPS_HEG_HEG_HP_HP_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY is
      variable y : HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY) return HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY is
      variable y : HPS_HEG_HEG_HP_HP_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_HEG_HEG_HP_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.HP);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.HP);
         y(u to u+w-1) := convert(x.HP, y(u to u+w-1));
      else
         w := width(x.HP);
         y(u downto u-w+1) := convert(x.HP, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t is
      variable y : HPS_HEG_HEG_HP_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.HP);
         y.HP := convert(x(u to u+w-1), tpl.HP);
      else
         w := width(tpl.HP);
         y.HP := convert(x(u downto u-w+1), tpl.HP);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_MON_t) return HPS_HEG_HEG_HP_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_HP_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.HP);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_HP_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.HP);
         y(u to u+w-1) := convert(x.HP, y(u to u+w-1));
      else
         w := width(x.HP);
         y(u downto u-w+1) := convert(x.HP, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t is
      variable y : HPS_HEG_HEG_HP_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.HP);
         y.HP := convert(x(u to u+w-1), tpl.HP);
      else
         w := width(tpl.HP);
         y.HP := convert(x(u downto u-w+1), tpl.HP);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_HP_CTRL_t) return HPS_HEG_HEG_HP_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SUPER);
      w := w + width(x.CTRL);
      w := w + width(x.HP);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SUPER);
         y(u to u+w-1) := convert(x.SUPER, y(u to u+w-1));
         u := u + w;
         w := width(x.CTRL);
         y(u to u+w-1) := convert(x.CTRL, y(u to u+w-1));
         u := u + w;
         w := width(x.HP);
         y(u to u+w-1) := convert(x.HP, y(u to u+w-1));
      else
         w := width(x.SUPER);
         y(u downto u-w+1) := convert(x.SUPER, y(u downto u-w+1));
         u := u - w;
         w := width(x.CTRL);
         y(u downto u-w+1) := convert(x.CTRL, y(u downto u-w+1));
         u := u - w;
         w := width(x.HP);
         y(u downto u-w+1) := convert(x.HP, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t is
      variable y : HPS_HEG_HEG_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SUPER);
         y.SUPER := convert(x(u to u+w-1), tpl.SUPER);
         u := u + w;
         w := width(tpl.CTRL);
         y.CTRL := convert(x(u to u+w-1), tpl.CTRL);
         u := u + w;
         w := width(tpl.HP);
         y.HP := convert(x(u to u+w-1), tpl.HP);
      else
         w := width(tpl.SUPER);
         y.SUPER := convert(x(u downto u-w+1), tpl.SUPER);
         u := u - w;
         w := width(tpl.CTRL);
         y.CTRL := convert(x(u downto u-w+1), tpl.CTRL);
         u := u - w;
         w := width(tpl.HP);
         y.HP := convert(x(u downto u-w+1), tpl.HP);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_MON_t) return HPS_HEG_HEG_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY is
      variable y : HPS_HEG_HEG_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_HEG_HEG_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_HEG_HEG_MON_t_ARRAY) return HPS_HEG_HEG_MON_t_ARRAY is
      variable y : HPS_HEG_HEG_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_HEG_HEG_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SUPER);
      w := w + width(x.CTRL);
      w := w + width(x.HP);
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SUPER);
         y(u to u+w-1) := convert(x.SUPER, y(u to u+w-1));
         u := u + w;
         w := width(x.CTRL);
         y(u to u+w-1) := convert(x.CTRL, y(u to u+w-1));
         u := u + w;
         w := width(x.HP);
         y(u to u+w-1) := convert(x.HP, y(u to u+w-1));
      else
         w := width(x.SUPER);
         y(u downto u-w+1) := convert(x.SUPER, y(u downto u-w+1));
         u := u - w;
         w := width(x.CTRL);
         y(u downto u-w+1) := convert(x.CTRL, y(u downto u-w+1));
         u := u - w;
         w := width(x.HP);
         y(u downto u-w+1) := convert(x.HP, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t is
      variable y : HPS_HEG_HEG_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SUPER);
         y.SUPER := convert(x(u to u+w-1), tpl.SUPER);
         u := u + w;
         w := width(tpl.CTRL);
         y.CTRL := convert(x(u to u+w-1), tpl.CTRL);
         u := u + w;
         w := width(tpl.HP);
         y.HP := convert(x(u to u+w-1), tpl.HP);
      else
         w := width(tpl.SUPER);
         y.SUPER := convert(x(u downto u-w+1), tpl.SUPER);
         u := u - w;
         w := width(tpl.CTRL);
         y.CTRL := convert(x(u downto u-w+1), tpl.CTRL);
         u := u - w;
         w := width(tpl.HP);
         y.HP := convert(x(u downto u-w+1), tpl.HP);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_t) return HPS_HEG_HEG_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_HEG_CTRL_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_HEG_HEG_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY is
      variable y : HPS_HEG_HEG_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_HEG_HEG_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_HEG_HEG_CTRL_t_ARRAY) return HPS_HEG_HEG_CTRL_t_ARRAY is
      variable y : HPS_HEG_HEG_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_HEG_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.HEG);
      return w;
   end function width;
   function convert(x: HPS_HEG_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.HEG);
         y(u to u+w-1) := convert(x.HEG, y(u to u+w-1));
      else
         w := width(x.HEG);
         y(u downto u-w+1) := convert(x.HEG, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_MON_t) return HPS_HEG_MON_t is
      variable y : HPS_HEG_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.HEG);
         y.HEG := convert(x(u to u+w-1), tpl.HEG);
      else
         w := width(tpl.HEG);
         y.HEG := convert(x(u downto u-w+1), tpl.HEG);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_MON_t) return HPS_HEG_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_HEG_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.HEG);
      return w;
   end function width;
   function convert(x: HPS_HEG_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.HEG);
         y(u to u+w-1) := convert(x.HEG, y(u to u+w-1));
      else
         w := width(x.HEG);
         y(u downto u-w+1) := convert(x.HEG, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t is
      variable y : HPS_HEG_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.HEG);
         y.HEG := convert(x(u to u+w-1), tpl.HEG);
      else
         w := width(tpl.HEG);
         y.HEG := convert(x(u downto u-w+1), tpl.HEG);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_HEG_CTRL_t) return HPS_HEG_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_LSF_LSF_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.STATUS);
      w := w + width(x.sb_lsf_mdt_hits_rdata_31_0);
      w := w + width(x.sb_lsf_mdt_hits_rdata_40_32);
      return w;
   end function width;
   function convert(x: HPS_LSF_LSF_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.STATUS);
         y(u to u+w-1) := convert(x.STATUS, y(u to u+w-1));
         u := u + w;
         w := width(x.sb_lsf_mdt_hits_rdata_31_0);
         y(u to u+w-1) := convert(x.sb_lsf_mdt_hits_rdata_31_0, y(u to u+w-1));
         u := u + w;
         w := width(x.sb_lsf_mdt_hits_rdata_40_32);
         y(u to u+w-1) := convert(x.sb_lsf_mdt_hits_rdata_40_32, y(u to u+w-1));
      else
         w := width(x.STATUS);
         y(u downto u-w+1) := convert(x.STATUS, y(u downto u-w+1));
         u := u - w;
         w := width(x.sb_lsf_mdt_hits_rdata_31_0);
         y(u downto u-w+1) := convert(x.sb_lsf_mdt_hits_rdata_31_0, y(u downto u-w+1));
         u := u - w;
         w := width(x.sb_lsf_mdt_hits_rdata_40_32);
         y(u downto u-w+1) := convert(x.sb_lsf_mdt_hits_rdata_40_32, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t is
      variable y : HPS_LSF_LSF_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u to u+w-1), tpl.STATUS);
         u := u + w;
         w := width(tpl.sb_lsf_mdt_hits_rdata_31_0);
         y.sb_lsf_mdt_hits_rdata_31_0 := convert(x(u to u+w-1), tpl.sb_lsf_mdt_hits_rdata_31_0);
         u := u + w;
         w := width(tpl.sb_lsf_mdt_hits_rdata_40_32);
         y.sb_lsf_mdt_hits_rdata_40_32 := convert(x(u to u+w-1), tpl.sb_lsf_mdt_hits_rdata_40_32);
      else
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u downto u-w+1), tpl.STATUS);
         u := u - w;
         w := width(tpl.sb_lsf_mdt_hits_rdata_31_0);
         y.sb_lsf_mdt_hits_rdata_31_0 := convert(x(u downto u-w+1), tpl.sb_lsf_mdt_hits_rdata_31_0);
         u := u - w;
         w := width(tpl.sb_lsf_mdt_hits_rdata_40_32);
         y.sb_lsf_mdt_hits_rdata_40_32 := convert(x(u downto u-w+1), tpl.sb_lsf_mdt_hits_rdata_40_32);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_LSF_LSF_MON_t) return HPS_LSF_LSF_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_LSF_LSF_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_LSF_LSF_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY is
      variable y : HPS_LSF_LSF_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_LSF_LSF_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_LSF_LSF_MON_t_ARRAY) return HPS_LSF_LSF_MON_t_ARRAY is
      variable y : HPS_LSF_LSF_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_LSF_LSF_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET);
      w := w + width(x.HBA_MAX_CLOCKS);
      w := w + width(x.sb_lsf_mdt_hits_freeze);
      w := w + width(x.sb_lsf_mdt_hits_raddr);
      w := w + width(x.sb_lsf_mdt_hits_re);
      return w;
   end function width;
   function convert(x: HPS_LSF_LSF_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET);
         y(u to u+w-1) := convert(x.RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.HBA_MAX_CLOCKS);
         y(u to u+w-1) := convert(x.HBA_MAX_CLOCKS, y(u to u+w-1));
         u := u + w;
         w := width(x.sb_lsf_mdt_hits_freeze);
         y(u to u+w-1) := convert(x.sb_lsf_mdt_hits_freeze, y(u to u+w-1));
         u := u + w;
         w := width(x.sb_lsf_mdt_hits_raddr);
         y(u to u+w-1) := convert(x.sb_lsf_mdt_hits_raddr, y(u to u+w-1));
         u := u + w;
         w := width(x.sb_lsf_mdt_hits_re);
         y(u to u+w-1) := convert(x.sb_lsf_mdt_hits_re, y(u to u+w-1));
      else
         w := width(x.RESET);
         y(u downto u-w+1) := convert(x.RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.HBA_MAX_CLOCKS);
         y(u downto u-w+1) := convert(x.HBA_MAX_CLOCKS, y(u downto u-w+1));
         u := u - w;
         w := width(x.sb_lsf_mdt_hits_freeze);
         y(u downto u-w+1) := convert(x.sb_lsf_mdt_hits_freeze, y(u downto u-w+1));
         u := u - w;
         w := width(x.sb_lsf_mdt_hits_raddr);
         y(u downto u-w+1) := convert(x.sb_lsf_mdt_hits_raddr, y(u downto u-w+1));
         u := u - w;
         w := width(x.sb_lsf_mdt_hits_re);
         y(u downto u-w+1) := convert(x.sb_lsf_mdt_hits_re, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t is
      variable y : HPS_LSF_LSF_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET);
         y.RESET := convert(x(u to u+w-1), tpl.RESET);
         u := u + w;
         w := width(tpl.HBA_MAX_CLOCKS);
         y.HBA_MAX_CLOCKS := convert(x(u to u+w-1), tpl.HBA_MAX_CLOCKS);
         u := u + w;
         w := width(tpl.sb_lsf_mdt_hits_freeze);
         y.sb_lsf_mdt_hits_freeze := convert(x(u to u+w-1), tpl.sb_lsf_mdt_hits_freeze);
         u := u + w;
         w := width(tpl.sb_lsf_mdt_hits_raddr);
         y.sb_lsf_mdt_hits_raddr := convert(x(u to u+w-1), tpl.sb_lsf_mdt_hits_raddr);
         u := u + w;
         w := width(tpl.sb_lsf_mdt_hits_re);
         y.sb_lsf_mdt_hits_re := convert(x(u to u+w-1), tpl.sb_lsf_mdt_hits_re);
      else
         w := width(tpl.RESET);
         y.RESET := convert(x(u downto u-w+1), tpl.RESET);
         u := u - w;
         w := width(tpl.HBA_MAX_CLOCKS);
         y.HBA_MAX_CLOCKS := convert(x(u downto u-w+1), tpl.HBA_MAX_CLOCKS);
         u := u - w;
         w := width(tpl.sb_lsf_mdt_hits_freeze);
         y.sb_lsf_mdt_hits_freeze := convert(x(u downto u-w+1), tpl.sb_lsf_mdt_hits_freeze);
         u := u - w;
         w := width(tpl.sb_lsf_mdt_hits_raddr);
         y.sb_lsf_mdt_hits_raddr := convert(x(u downto u-w+1), tpl.sb_lsf_mdt_hits_raddr);
         u := u - w;
         w := width(tpl.sb_lsf_mdt_hits_re);
         y.sb_lsf_mdt_hits_re := convert(x(u downto u-w+1), tpl.sb_lsf_mdt_hits_re);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_LSF_LSF_CTRL_t) return HPS_LSF_LSF_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_LSF_LSF_CTRL_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_LSF_LSF_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY is
      variable y : HPS_LSF_LSF_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_LSF_LSF_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_LSF_LSF_CTRL_t_ARRAY) return HPS_LSF_LSF_CTRL_t_ARRAY is
      variable y : HPS_LSF_LSF_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_LSF_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.LSF);
      return w;
   end function width;
   function convert(x: HPS_LSF_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.LSF);
         y(u to u+w-1) := convert(x.LSF, y(u to u+w-1));
      else
         w := width(x.LSF);
         y(u downto u-w+1) := convert(x.LSF, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_LSF_MON_t) return HPS_LSF_MON_t is
      variable y : HPS_LSF_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.LSF);
         y.LSF := convert(x(u to u+w-1), tpl.LSF);
      else
         w := width(tpl.LSF);
         y.LSF := convert(x(u downto u-w+1), tpl.LSF);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_LSF_MON_t) return HPS_LSF_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_LSF_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.LSF);
      return w;
   end function width;
   function convert(x: HPS_LSF_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.LSF);
         y(u to u+w-1) := convert(x.LSF, y(u to u+w-1));
      else
         w := width(x.LSF);
         y(u downto u-w+1) := convert(x.LSF, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t is
      variable y : HPS_LSF_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.LSF);
         y.LSF := convert(x(u to u+w-1), tpl.LSF);
      else
         w := width(tpl.LSF);
         y.LSF := convert(x(u downto u-w+1), tpl.LSF);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_LSF_CTRL_t) return HPS_LSF_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_CSF_CSF_ACTIONS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.RESET);
      w := w + width(x.ENABLE);
      w := w + width(x.DISABLE);
      w := w + width(x.FREEZE);
      return w;
   end function width;
   function convert(x: HPS_CSF_CSF_ACTIONS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.RESET);
         y(u to u+w-1) := convert(x.RESET, y(u to u+w-1));
         u := u + w;
         w := width(x.ENABLE);
         y(u to u+w-1) := convert(x.ENABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.DISABLE);
         y(u to u+w-1) := convert(x.DISABLE, y(u to u+w-1));
         u := u + w;
         w := width(x.FREEZE);
         y(u to u+w-1) := convert(x.FREEZE, y(u to u+w-1));
      else
         w := width(x.RESET);
         y(u downto u-w+1) := convert(x.RESET, y(u downto u-w+1));
         u := u - w;
         w := width(x.ENABLE);
         y(u downto u-w+1) := convert(x.ENABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.DISABLE);
         y(u downto u-w+1) := convert(x.DISABLE, y(u downto u-w+1));
         u := u - w;
         w := width(x.FREEZE);
         y(u downto u-w+1) := convert(x.FREEZE, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t is
      variable y : HPS_CSF_CSF_ACTIONS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.RESET);
         y.RESET := convert(x(u to u+w-1), tpl.RESET);
         u := u + w;
         w := width(tpl.ENABLE);
         y.ENABLE := convert(x(u to u+w-1), tpl.ENABLE);
         u := u + w;
         w := width(tpl.DISABLE);
         y.DISABLE := convert(x(u to u+w-1), tpl.DISABLE);
         u := u + w;
         w := width(tpl.FREEZE);
         y.FREEZE := convert(x(u to u+w-1), tpl.FREEZE);
      else
         w := width(tpl.RESET);
         y.RESET := convert(x(u downto u-w+1), tpl.RESET);
         u := u - w;
         w := width(tpl.ENABLE);
         y.ENABLE := convert(x(u downto u-w+1), tpl.ENABLE);
         u := u - w;
         w := width(tpl.DISABLE);
         y.DISABLE := convert(x(u downto u-w+1), tpl.DISABLE);
         u := u - w;
         w := width(tpl.FREEZE);
         y.FREEZE := convert(x(u downto u-w+1), tpl.FREEZE);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_CSF_CSF_ACTIONS_CTRL_t) return HPS_CSF_CSF_ACTIONS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_CSF_CSF_STATUS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ENABLED);
      w := w + width(x.READY);
      w := w + width(x.ERROR);
      return w;
   end function width;
   function convert(x: HPS_CSF_CSF_STATUS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ENABLED);
         y(u to u+w-1) := convert(x.ENABLED, y(u to u+w-1));
         u := u + w;
         w := width(x.READY);
         y(u to u+w-1) := convert(x.READY, y(u to u+w-1));
         u := u + w;
         w := width(x.ERROR);
         y(u to u+w-1) := convert(x.ERROR, y(u to u+w-1));
      else
         w := width(x.ENABLED);
         y(u downto u-w+1) := convert(x.ENABLED, y(u downto u-w+1));
         u := u - w;
         w := width(x.READY);
         y(u downto u-w+1) := convert(x.READY, y(u downto u-w+1));
         u := u - w;
         w := width(x.ERROR);
         y(u downto u-w+1) := convert(x.ERROR, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t is
      variable y : HPS_CSF_CSF_STATUS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ENABLED);
         y.ENABLED := convert(x(u to u+w-1), tpl.ENABLED);
         u := u + w;
         w := width(tpl.READY);
         y.READY := convert(x(u to u+w-1), tpl.READY);
         u := u + w;
         w := width(tpl.ERROR);
         y.ERROR := convert(x(u to u+w-1), tpl.ERROR);
      else
         w := width(tpl.ENABLED);
         y.ENABLED := convert(x(u downto u-w+1), tpl.ENABLED);
         u := u - w;
         w := width(tpl.READY);
         y.READY := convert(x(u downto u-w+1), tpl.READY);
         u := u - w;
         w := width(tpl.ERROR);
         y.ERROR := convert(x(u downto u-w+1), tpl.ERROR);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_CSF_CSF_STATUS_MON_t) return HPS_CSF_CSF_STATUS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_CSF_CSF_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.STATUS);
      return w;
   end function width;
   function convert(x: HPS_CSF_CSF_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.STATUS);
         y(u to u+w-1) := convert(x.STATUS, y(u to u+w-1));
      else
         w := width(x.STATUS);
         y(u downto u-w+1) := convert(x.STATUS, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t is
      variable y : HPS_CSF_CSF_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u to u+w-1), tpl.STATUS);
      else
         w := width(tpl.STATUS);
         y.STATUS := convert(x(u downto u-w+1), tpl.STATUS);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_CSF_CSF_MON_t) return HPS_CSF_CSF_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_CSF_CSF_MON_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_CSF_CSF_MON_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY is
      variable y : HPS_CSF_CSF_MON_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_CSF_CSF_MON_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_CSF_CSF_MON_t_ARRAY) return HPS_CSF_CSF_MON_t_ARRAY is
      variable y : HPS_CSF_CSF_MON_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_CSF_CSF_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.ACTIONS);
      return w;
   end function width;
   function convert(x: HPS_CSF_CSF_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.ACTIONS);
         y(u to u+w-1) := convert(x.ACTIONS, y(u to u+w-1));
      else
         w := width(x.ACTIONS);
         y(u downto u-w+1) := convert(x.ACTIONS, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t is
      variable y : HPS_CSF_CSF_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.ACTIONS);
         y.ACTIONS := convert(x(u to u+w-1), tpl.ACTIONS);
      else
         w := width(tpl.ACTIONS);
         y.ACTIONS := convert(x(u downto u-w+1), tpl.ACTIONS);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_CSF_CSF_CTRL_t) return HPS_CSF_CSF_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_CSF_CSF_CTRL_t_ARRAY) return integer is
      variable w : integer;
   begin
      if x'length < 1 then
        w := 0;
      else
        w := x'length * width(x(x'low));
      end if;
      return w;
   end function width;
   function convert(x: HPS_CSF_CSF_CTRL_t_ARRAY; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      constant W : natural := width(x(x'low));
      variable a : integer;
      variable b : integer;
   begin
      if y'ascending then
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(b to a), convert(x(i+x'low), y(b to a)));
         end loop;
      else
         for i in 0 to x'length-1 loop
            a := W*i + y'low + W - 1;
            b := W*i + y'low;
            assign(y(a downto b), convert(x(i+x'low), y(a downto b)));
         end loop;
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY is
      variable y : HPS_CSF_CSF_CTRL_t_ARRAY;
      constant W : natural := width(y(y'low));
      variable a : integer;
      variable b : integer;
   begin
      if x'ascending then
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(b to a), y(i+y'low));
         end loop;
      else
         for i in 0 to y'length-1 loop
            a := W*i + x'low + W - 1;
            b := W*i + x'low;
            y(i+y'low) := convert(x(a downto b), y(i+y'low));
         end loop;
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;
   function convert(x: HPS_CSF_CSF_CTRL_t_ARRAY; tpl: std_logic_vector_array) return std_logic_vector_array is
      variable y : std_logic_vector_array(tpl'range)(tpl(tpl'low)'range);
   begin
      for j in y'range loop
          y(j) := convert(x(j), (y(j)'range => '0'));
      end loop;
      return y;
   end function convert;
   function convert(x: std_logic_vector_array; tpl: HPS_CSF_CSF_CTRL_t_ARRAY) return HPS_CSF_CSF_CTRL_t_ARRAY is
      variable y : HPS_CSF_CSF_CTRL_t_ARRAY;
   begin
      for j in y'range loop
          y(j) := convert(x(j), y(j));
      end loop;
      return y;
   end function convert;

   function width(x: HPS_CSF_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CSF);
      return w;
   end function width;
   function convert(x: HPS_CSF_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.CSF);
         y(u to u+w-1) := convert(x.CSF, y(u to u+w-1));
      else
         w := width(x.CSF);
         y(u downto u-w+1) := convert(x.CSF, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_CSF_MON_t) return HPS_CSF_MON_t is
      variable y : HPS_CSF_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.CSF);
         y.CSF := convert(x(u to u+w-1), tpl.CSF);
      else
         w := width(tpl.CSF);
         y.CSF := convert(x(u downto u-w+1), tpl.CSF);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_CSF_MON_t) return HPS_CSF_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_CSF_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.CSF);
      return w;
   end function width;
   function convert(x: HPS_CSF_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.CSF);
         y(u to u+w-1) := convert(x.CSF, y(u to u+w-1));
      else
         w := width(x.CSF);
         y(u downto u-w+1) := convert(x.CSF, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t is
      variable y : HPS_CSF_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.CSF);
         y.CSF := convert(x(u to u+w-1), tpl.CSF);
      else
         w := width(tpl.CSF);
         y.CSF := convert(x(u downto u-w+1), tpl.CSF);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_CSF_CTRL_t) return HPS_CSF_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_MON_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SUPER);
      w := w + width(x.MDT_TC);
      w := w + width(x.MDT_T0);
      w := w + width(x.HEG);
      w := w + width(x.LSF);
      w := w + width(x.CSF);
      return w;
   end function width;
   function convert(x: HPS_MON_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SUPER);
         y(u to u+w-1) := convert(x.SUPER, y(u to u+w-1));
         u := u + w;
         w := width(x.MDT_TC);
         y(u to u+w-1) := convert(x.MDT_TC, y(u to u+w-1));
         u := u + w;
         w := width(x.MDT_T0);
         y(u to u+w-1) := convert(x.MDT_T0, y(u to u+w-1));
         u := u + w;
         w := width(x.HEG);
         y(u to u+w-1) := convert(x.HEG, y(u to u+w-1));
         u := u + w;
         w := width(x.LSF);
         y(u to u+w-1) := convert(x.LSF, y(u to u+w-1));
         u := u + w;
         w := width(x.CSF);
         y(u to u+w-1) := convert(x.CSF, y(u to u+w-1));
      else
         w := width(x.SUPER);
         y(u downto u-w+1) := convert(x.SUPER, y(u downto u-w+1));
         u := u - w;
         w := width(x.MDT_TC);
         y(u downto u-w+1) := convert(x.MDT_TC, y(u downto u-w+1));
         u := u - w;
         w := width(x.MDT_T0);
         y(u downto u-w+1) := convert(x.MDT_T0, y(u downto u-w+1));
         u := u - w;
         w := width(x.HEG);
         y(u downto u-w+1) := convert(x.HEG, y(u downto u-w+1));
         u := u - w;
         w := width(x.LSF);
         y(u downto u-w+1) := convert(x.LSF, y(u downto u-w+1));
         u := u - w;
         w := width(x.CSF);
         y(u downto u-w+1) := convert(x.CSF, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_MON_t) return HPS_MON_t is
      variable y : HPS_MON_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SUPER);
         y.SUPER := convert(x(u to u+w-1), tpl.SUPER);
         u := u + w;
         w := width(tpl.MDT_TC);
         y.MDT_TC := convert(x(u to u+w-1), tpl.MDT_TC);
         u := u + w;
         w := width(tpl.MDT_T0);
         y.MDT_T0 := convert(x(u to u+w-1), tpl.MDT_T0);
         u := u + w;
         w := width(tpl.HEG);
         y.HEG := convert(x(u to u+w-1), tpl.HEG);
         u := u + w;
         w := width(tpl.LSF);
         y.LSF := convert(x(u to u+w-1), tpl.LSF);
         u := u + w;
         w := width(tpl.CSF);
         y.CSF := convert(x(u to u+w-1), tpl.CSF);
      else
         w := width(tpl.SUPER);
         y.SUPER := convert(x(u downto u-w+1), tpl.SUPER);
         u := u - w;
         w := width(tpl.MDT_TC);
         y.MDT_TC := convert(x(u downto u-w+1), tpl.MDT_TC);
         u := u - w;
         w := width(tpl.MDT_T0);
         y.MDT_T0 := convert(x(u downto u-w+1), tpl.MDT_T0);
         u := u - w;
         w := width(tpl.HEG);
         y.HEG := convert(x(u downto u-w+1), tpl.HEG);
         u := u - w;
         w := width(tpl.LSF);
         y.LSF := convert(x(u downto u-w+1), tpl.LSF);
         u := u - w;
         w := width(tpl.CSF);
         y.CSF := convert(x(u downto u-w+1), tpl.CSF);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_MON_t) return HPS_MON_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

   function width(x: HPS_CTRL_t) return natural is
      variable w : natural := 0;
   begin
      w := w + width(x.SUPER);
      w := w + width(x.MDT_TC);
      w := w + width(x.MDT_T0);
      w := w + width(x.HEG);
      w := w + width(x.LSF);
      w := w + width(x.CSF);
      return w;
   end function width;
   function convert(x: HPS_CTRL_t; tpl: std_logic_vector) return std_logic_vector is
      variable y : std_logic_vector(tpl'range);
      variable w : integer;
      variable u : integer := tpl'left;
   begin
      if tpl'ascending then
         w := width(x.SUPER);
         y(u to u+w-1) := convert(x.SUPER, y(u to u+w-1));
         u := u + w;
         w := width(x.MDT_TC);
         y(u to u+w-1) := convert(x.MDT_TC, y(u to u+w-1));
         u := u + w;
         w := width(x.MDT_T0);
         y(u to u+w-1) := convert(x.MDT_T0, y(u to u+w-1));
         u := u + w;
         w := width(x.HEG);
         y(u to u+w-1) := convert(x.HEG, y(u to u+w-1));
         u := u + w;
         w := width(x.LSF);
         y(u to u+w-1) := convert(x.LSF, y(u to u+w-1));
         u := u + w;
         w := width(x.CSF);
         y(u to u+w-1) := convert(x.CSF, y(u to u+w-1));
      else
         w := width(x.SUPER);
         y(u downto u-w+1) := convert(x.SUPER, y(u downto u-w+1));
         u := u - w;
         w := width(x.MDT_TC);
         y(u downto u-w+1) := convert(x.MDT_TC, y(u downto u-w+1));
         u := u - w;
         w := width(x.MDT_T0);
         y(u downto u-w+1) := convert(x.MDT_T0, y(u downto u-w+1));
         u := u - w;
         w := width(x.HEG);
         y(u downto u-w+1) := convert(x.HEG, y(u downto u-w+1));
         u := u - w;
         w := width(x.LSF);
         y(u downto u-w+1) := convert(x.LSF, y(u downto u-w+1));
         u := u - w;
         w := width(x.CSF);
         y(u downto u-w+1) := convert(x.CSF, y(u downto u-w+1));
      end if;
      return y;
   end function convert;
   function convert(x: std_logic_vector; tpl: HPS_CTRL_t) return HPS_CTRL_t is
      variable y : HPS_CTRL_t;
      variable w : integer;
      variable u : integer := x'left;
   begin
      if x'ascending then
         w := width(tpl.SUPER);
         y.SUPER := convert(x(u to u+w-1), tpl.SUPER);
         u := u + w;
         w := width(tpl.MDT_TC);
         y.MDT_TC := convert(x(u to u+w-1), tpl.MDT_TC);
         u := u + w;
         w := width(tpl.MDT_T0);
         y.MDT_T0 := convert(x(u to u+w-1), tpl.MDT_T0);
         u := u + w;
         w := width(tpl.HEG);
         y.HEG := convert(x(u to u+w-1), tpl.HEG);
         u := u + w;
         w := width(tpl.LSF);
         y.LSF := convert(x(u to u+w-1), tpl.LSF);
         u := u + w;
         w := width(tpl.CSF);
         y.CSF := convert(x(u to u+w-1), tpl.CSF);
      else
         w := width(tpl.SUPER);
         y.SUPER := convert(x(u downto u-w+1), tpl.SUPER);
         u := u - w;
         w := width(tpl.MDT_TC);
         y.MDT_TC := convert(x(u downto u-w+1), tpl.MDT_TC);
         u := u - w;
         w := width(tpl.MDT_T0);
         y.MDT_T0 := convert(x(u downto u-w+1), tpl.MDT_T0);
         u := u - w;
         w := width(tpl.HEG);
         y.HEG := convert(x(u downto u-w+1), tpl.HEG);
         u := u - w;
         w := width(tpl.LSF);
         y.LSF := convert(x(u downto u-w+1), tpl.LSF);
         u := u - w;
         w := width(tpl.CSF);
         y.CSF := convert(x(u downto u-w+1), tpl.CSF);
      end if;
      return y;
   end function convert;
   function zero(tpl: HPS_CTRL_t) return HPS_CTRL_t is
   begin
      return convert(std_logic_vector'(width(tpl)-1 downto 0 => '0'), tpl);
   end function zero;

end package body HPS_CTRL;
