-- This file was auto-generated by YML2HDL tool.
-- https://gitlab.com/tcpaiva/yml2hdl

library ieee;
use ieee.math_real.all;
use ieee.numeric_std.all;
use ieee.std_logic_1164.all;

library shared_lib;
use shared_lib.common_ieee_pkg.all;

package ttc_defs is

  subtype ttc_clk_t is std_logic;

  subtype ttc_bcid_t is unsigned(12-1 downto 0);

  type ttc_bcid_at is array(integer range <>) of ttc_bcid_t;
  function len(x: ttc_bcid_at) return natural;
  function width(x: ttc_bcid_at) return natural;
  function vectorify(x: ttc_bcid_at; t: std_logic_vector) return std_logic_vector;
  function convert(x: ttc_bcid_at; t: std_logic_vector) return std_logic_vector;
  function structify(x: std_logic_vector; t: ttc_bcid_at) return ttc_bcid_at;
  function convert(x: std_logic_vector; t: ttc_bcid_at) return ttc_bcid_at;
  function nullify(x: ttc_bcid_at) return ttc_bcid_at;
  function zeroed(x: ttc_bcid_at) return ttc_bcid_at;

  subtype ttc_evid_t is unsigned(32-1 downto 0);

  subtype ttc_orid_t is unsigned(32-1 downto 0);

  type ttc_sys_rt is record
    clk40 : std_logic;
    clk320 : std_logic;
    rst : std_logic;
  end record ttc_sys_rt;
  function len(x: ttc_sys_rt) return natural;
  function width(x: ttc_sys_rt) return natural;
  function vectorify(x: ttc_sys_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ttc_sys_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ttc_sys_rt) return ttc_sys_rt;
  function convert(x: in std_logic_vector; t: ttc_sys_rt) return ttc_sys_rt;
  function nullify(t: ttc_sys_rt) return ttc_sys_rt;
  function zeroed(t: ttc_sys_rt) return ttc_sys_rt;

  type ttc_fmt_rt is record
    bcr : std_logic;
    ecr : std_logic;
    lxa : std_logic;
    reserved0 : std_logic;
    reserved1 : std_logic;
    reserved2 : std_logic;
    reserved3 : std_logic;
    reserved4 : std_logic;
  end record ttc_fmt_rt;
  function len(x: ttc_fmt_rt) return natural;
  function width(x: ttc_fmt_rt) return natural;
  function vectorify(x: ttc_fmt_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ttc_fmt_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ttc_fmt_rt) return ttc_fmt_rt;
  function convert(x: in std_logic_vector; t: ttc_fmt_rt) return ttc_fmt_rt;
  function nullify(t: ttc_fmt_rt) return ttc_fmt_rt;
  function zeroed(t: ttc_fmt_rt) return ttc_fmt_rt;

  -- ttc_fmt_vt: 40MHz domain
  subtype ttc_fmt_vt is std_logic_vector(8-1 downto 0);

  -- ttc_cmds_rt:
  -- 320MHz domain
  type ttc_cmds_rt is record
    bcr : std_logic;
    ocr : std_logic;
    ecr : std_logic;
    lxa : std_logic;
    bx : std_logic;
  end record ttc_cmds_rt;
  function len(x: ttc_cmds_rt) return natural;
  function width(x: ttc_cmds_rt) return natural;
  function vectorify(x: ttc_cmds_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ttc_cmds_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ttc_cmds_rt) return ttc_cmds_rt;
  function convert(x: in std_logic_vector; t: ttc_cmds_rt) return ttc_cmds_rt;
  function nullify(t: ttc_cmds_rt) return ttc_cmds_rt;
  function zeroed(t: ttc_cmds_rt) return ttc_cmds_rt;

  type ttc_counters_rt is record
    bcid : ttc_bcid_t;
    evid : ttc_evid_t;
    orid : ttc_orid_t;
  end record ttc_counters_rt;
  function len(x: ttc_counters_rt) return natural;
  function width(x: ttc_counters_rt) return natural;
  function vectorify(x: ttc_counters_rt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ttc_counters_rt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ttc_counters_rt) return ttc_counters_rt;
  function convert(x: in std_logic_vector; t: ttc_counters_rt) return ttc_counters_rt;
  function nullify(t: ttc_counters_rt) return ttc_counters_rt;
  function zeroed(t: ttc_counters_rt) return ttc_counters_rt;

  type ttc_irt is record
    sys : ttc_sys_rt;
    data : ttc_fmt_vt;
  end record ttc_irt;
  function len(x: ttc_irt) return natural;
  function width(x: ttc_irt) return natural;
  function vectorify(x: ttc_irt; t: std_logic_vector) return std_logic_vector;
  function convert(x: ttc_irt; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ttc_irt) return ttc_irt;
  function convert(x: in std_logic_vector; t: ttc_irt) return ttc_irt;
  function nullify(t: ttc_irt) return ttc_irt;
  function zeroed(t: ttc_irt) return ttc_irt;

  subtype ttc_ivt is std_logic_vector(11-1 downto 0);

  type ttc_ort is record
    cmds : ttc_cmds_rt;
    cnt : ttc_counters_rt;
  end record ttc_ort;
  function len(x: ttc_ort) return natural;
  function width(x: ttc_ort) return natural;
  function vectorify(x: ttc_ort; t: std_logic_vector) return std_logic_vector;
  function convert(x: ttc_ort; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ttc_ort) return ttc_ort;
  function convert(x: in std_logic_vector; t: ttc_ort) return ttc_ort;
  function nullify(t: ttc_ort) return ttc_ort;
  function zeroed(t: ttc_ort) return ttc_ort;

  subtype ttc_ovt is std_logic_vector(81-1 downto 0);

  type ttc_ert is record
    i : ttc_irt;
    o : ttc_ort;
  end record ttc_ert;
  function len(x: ttc_ert) return natural;
  function width(x: ttc_ert) return natural;
  function vectorify(x: ttc_ert; t: std_logic_vector) return std_logic_vector;
  function convert(x: ttc_ert; t: std_logic_vector) return std_logic_vector;
  function structify(x: in std_logic_vector; t: ttc_ert) return ttc_ert;
  function convert(x: in std_logic_vector; t: ttc_ert) return ttc_ert;
  function nullify(t: ttc_ert) return ttc_ert;
  function zeroed(t: ttc_ert) return ttc_ert;

end package ttc_defs;

------------------------------------------------------------

package body ttc_defs is

  function len(x: ttc_bcid_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * len(x(x'left));
    return l;
  end function len;
  function width(x: ttc_bcid_at) return natural is
    variable l : natural := 0;
  begin
    l := x'length * width(x(x'left));
    return l;
  end function width;
  function vectorify(x: ttc_bcid_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), vectorify(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), vectorify(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function vectorify;
  function convert(x: ttc_bcid_at; t: std_logic_vector) return std_logic_vector is
    variable y : std_logic_vector(t'range);
    constant l :  integer := len(x(x'right));
    variable a :  integer;
    variable b :  integer;
  begin
    if t'ascending then
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(b to a), convert(x(i), y(b to a)));
      end loop;
    else
      for i in x'range loop
        a := l*i + y'low + l - 1;
        b := l*i + y'low;
        assign(y(a downto b), convert(x(i), y(a downto b)));
      end loop;
    end if;
    return y;
  end function convert;
  function structify(x: std_logic_vector; t: ttc_bcid_at) return ttc_bcid_at is
    variable y : ttc_bcid_at(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := structify(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := structify(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function structify;
  function convert(x: std_logic_vector; t: ttc_bcid_at) return ttc_bcid_at is
    variable y : ttc_bcid_at(t'range);
    constant l :  integer := len(y(y'left));
    variable a :  integer;
    variable b :  integer;
  begin
    if x'ascending then
      for i in y'range loop
        a := l*i + x'low + l - 1;
        b := l*i + x'low;
        y(i) := convert(x(b to a), y(i));
      end loop;
    else
      for i in y'range loop
        a := l*i + x'low + l-1;
        b := l*i + x'low;
        y(i) := convert(x(a downto b), y(i));
      end loop;
    end if;
    return y;
  end function convert;
  function nullify(x: ttc_bcid_at) return ttc_bcid_at is
    variable y : ttc_bcid_at(x'range);
  begin
    l: for i in y'range loop
      y(i) := nullify(y(i));
    end loop l;
    return y;
  end function nullify;
  function zeroed(x: ttc_bcid_at) return ttc_bcid_at is
    variable y : ttc_bcid_at(x'range);
  begin
    l: for i in y'range loop
      y(i) := zeroed(y(i));
    end loop l;
    return y;
  end function zeroed;

  function len(x: ttc_sys_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.clk40);
    l := l + len(x.clk320);
    l := l + len(x.rst);
    return l;
  end function len;
  function width(x: ttc_sys_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.clk40);
    l := l + width(x.clk320);
    l := l + width(x.rst);
    return l;
  end function width;
  function vectorify(x: ttc_sys_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.clk40)-1), vectorify(x.clk40, y(left to left+len(x.clk40)-1)));
      left := left + len(x.clk40);
      assign(y(left to left+len(x.clk320)-1), vectorify(x.clk320, y(left to left+len(x.clk320)-1)));
      left := left + len(x.clk320);
      assign(y(left to left+len(x.rst)-1), vectorify(x.rst, y(left to left+len(x.rst)-1)));
    else
      assign(y(left downto left-len(x.clk40)+1), vectorify(x.clk40, y(left downto left-len(x.clk40)+1)));
      left := left - len(x.clk40);
      assign(y(left downto left-len(x.clk320)+1), vectorify(x.clk320, y(left downto left-len(x.clk320)+1)));
      left := left - len(x.clk320);
      assign(y(left downto left-len(x.rst)+1), vectorify(x.rst, y(left downto left-len(x.rst)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ttc_sys_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.clk40)-1), convert(x.clk40, y(left to left+len(x.clk40)-1)));
      left := left + len(x.clk40);
      assign(y(left to left+len(x.clk320)-1), convert(x.clk320, y(left to left+len(x.clk320)-1)));
      left := left + len(x.clk320);
      assign(y(left to left+len(x.rst)-1), convert(x.rst, y(left to left+len(x.rst)-1)));
    else
      assign(y(left downto left-len(x.clk40)+1), convert(x.clk40, y(left downto left-len(x.clk40)+1)));
      left := left - len(x.clk40);
      assign(y(left downto left-len(x.clk320)+1), convert(x.clk320, y(left downto left-len(x.clk320)+1)));
      left := left - len(x.clk320);
      assign(y(left downto left-len(x.rst)+1), convert(x.rst, y(left downto left-len(x.rst)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ttc_sys_rt) return ttc_sys_rt is
    variable y: ttc_sys_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.clk40 := structify(x(left to left+len(y.clk40)-1), y.clk40);
      left := left + len(y.clk40);
      y.clk320 := structify(x(left to left+len(y.clk320)-1), y.clk320);
      left := left + len(y.clk320);
      y.rst := structify(x(left to left+len(y.rst)-1), y.rst);
    else
      y.clk40 := structify(x(left downto left-len(y.clk40)+1), y.clk40);
      left := left - len(y.clk40);
      y.clk320 := structify(x(left downto left-len(y.clk320)+1), y.clk320);
      left := left - len(y.clk320);
      y.rst := structify(x(left downto left-len(y.rst)+1), y.rst);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ttc_sys_rt) return ttc_sys_rt is
    variable y: ttc_sys_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.clk40 := convert(x(left to left+len(y.clk40)-1), y.clk40);
      left := left + len(y.clk40);
      y.clk320 := convert(x(left to left+len(y.clk320)-1), y.clk320);
      left := left + len(y.clk320);
      y.rst := convert(x(left to left+len(y.rst)-1), y.rst);
    else
      y.clk40 := convert(x(left downto left-len(y.clk40)+1), y.clk40);
      left := left - len(y.clk40);
      y.clk320 := convert(x(left downto left-len(y.clk320)+1), y.clk320);
      left := left - len(y.clk320);
      y.rst := convert(x(left downto left-len(y.rst)+1), y.rst);
    end if;
    return y;
  end function convert;
  function nullify(t: ttc_sys_rt) return ttc_sys_rt is
  variable y: ttc_sys_rt;
  begin
    y.clk40 := nullify(t.clk40);
    y.clk320 := nullify(t.clk320);
    y.rst := nullify(t.rst);
    return y;
  end function nullify;
  function zeroed(t: ttc_sys_rt) return ttc_sys_rt is
  variable y: ttc_sys_rt;
  begin
    y.clk40 := zeroed(t.clk40);
    y.clk320 := zeroed(t.clk320);
    y.rst := zeroed(t.rst);
    return y;
  end function zeroed;

  function len(x: ttc_fmt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.bcr);
    l := l + len(x.ecr);
    l := l + len(x.lxa);
    l := l + len(x.reserved0);
    l := l + len(x.reserved1);
    l := l + len(x.reserved2);
    l := l + len(x.reserved3);
    l := l + len(x.reserved4);
    return l;
  end function len;
  function width(x: ttc_fmt_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.bcr);
    l := l + width(x.ecr);
    l := l + width(x.lxa);
    l := l + width(x.reserved0);
    l := l + width(x.reserved1);
    l := l + width(x.reserved2);
    l := l + width(x.reserved3);
    l := l + width(x.reserved4);
    return l;
  end function width;
  function vectorify(x: ttc_fmt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcr)-1), vectorify(x.bcr, y(left to left+len(x.bcr)-1)));
      left := left + len(x.bcr);
      assign(y(left to left+len(x.ecr)-1), vectorify(x.ecr, y(left to left+len(x.ecr)-1)));
      left := left + len(x.ecr);
      assign(y(left to left+len(x.lxa)-1), vectorify(x.lxa, y(left to left+len(x.lxa)-1)));
      left := left + len(x.lxa);
      assign(y(left to left+len(x.reserved0)-1), vectorify(x.reserved0, y(left to left+len(x.reserved0)-1)));
      left := left + len(x.reserved0);
      assign(y(left to left+len(x.reserved1)-1), vectorify(x.reserved1, y(left to left+len(x.reserved1)-1)));
      left := left + len(x.reserved1);
      assign(y(left to left+len(x.reserved2)-1), vectorify(x.reserved2, y(left to left+len(x.reserved2)-1)));
      left := left + len(x.reserved2);
      assign(y(left to left+len(x.reserved3)-1), vectorify(x.reserved3, y(left to left+len(x.reserved3)-1)));
      left := left + len(x.reserved3);
      assign(y(left to left+len(x.reserved4)-1), vectorify(x.reserved4, y(left to left+len(x.reserved4)-1)));
    else
      assign(y(left downto left-len(x.bcr)+1), vectorify(x.bcr, y(left downto left-len(x.bcr)+1)));
      left := left - len(x.bcr);
      assign(y(left downto left-len(x.ecr)+1), vectorify(x.ecr, y(left downto left-len(x.ecr)+1)));
      left := left - len(x.ecr);
      assign(y(left downto left-len(x.lxa)+1), vectorify(x.lxa, y(left downto left-len(x.lxa)+1)));
      left := left - len(x.lxa);
      assign(y(left downto left-len(x.reserved0)+1), vectorify(x.reserved0, y(left downto left-len(x.reserved0)+1)));
      left := left - len(x.reserved0);
      assign(y(left downto left-len(x.reserved1)+1), vectorify(x.reserved1, y(left downto left-len(x.reserved1)+1)));
      left := left - len(x.reserved1);
      assign(y(left downto left-len(x.reserved2)+1), vectorify(x.reserved2, y(left downto left-len(x.reserved2)+1)));
      left := left - len(x.reserved2);
      assign(y(left downto left-len(x.reserved3)+1), vectorify(x.reserved3, y(left downto left-len(x.reserved3)+1)));
      left := left - len(x.reserved3);
      assign(y(left downto left-len(x.reserved4)+1), vectorify(x.reserved4, y(left downto left-len(x.reserved4)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ttc_fmt_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcr)-1), convert(x.bcr, y(left to left+len(x.bcr)-1)));
      left := left + len(x.bcr);
      assign(y(left to left+len(x.ecr)-1), convert(x.ecr, y(left to left+len(x.ecr)-1)));
      left := left + len(x.ecr);
      assign(y(left to left+len(x.lxa)-1), convert(x.lxa, y(left to left+len(x.lxa)-1)));
      left := left + len(x.lxa);
      assign(y(left to left+len(x.reserved0)-1), convert(x.reserved0, y(left to left+len(x.reserved0)-1)));
      left := left + len(x.reserved0);
      assign(y(left to left+len(x.reserved1)-1), convert(x.reserved1, y(left to left+len(x.reserved1)-1)));
      left := left + len(x.reserved1);
      assign(y(left to left+len(x.reserved2)-1), convert(x.reserved2, y(left to left+len(x.reserved2)-1)));
      left := left + len(x.reserved2);
      assign(y(left to left+len(x.reserved3)-1), convert(x.reserved3, y(left to left+len(x.reserved3)-1)));
      left := left + len(x.reserved3);
      assign(y(left to left+len(x.reserved4)-1), convert(x.reserved4, y(left to left+len(x.reserved4)-1)));
    else
      assign(y(left downto left-len(x.bcr)+1), convert(x.bcr, y(left downto left-len(x.bcr)+1)));
      left := left - len(x.bcr);
      assign(y(left downto left-len(x.ecr)+1), convert(x.ecr, y(left downto left-len(x.ecr)+1)));
      left := left - len(x.ecr);
      assign(y(left downto left-len(x.lxa)+1), convert(x.lxa, y(left downto left-len(x.lxa)+1)));
      left := left - len(x.lxa);
      assign(y(left downto left-len(x.reserved0)+1), convert(x.reserved0, y(left downto left-len(x.reserved0)+1)));
      left := left - len(x.reserved0);
      assign(y(left downto left-len(x.reserved1)+1), convert(x.reserved1, y(left downto left-len(x.reserved1)+1)));
      left := left - len(x.reserved1);
      assign(y(left downto left-len(x.reserved2)+1), convert(x.reserved2, y(left downto left-len(x.reserved2)+1)));
      left := left - len(x.reserved2);
      assign(y(left downto left-len(x.reserved3)+1), convert(x.reserved3, y(left downto left-len(x.reserved3)+1)));
      left := left - len(x.reserved3);
      assign(y(left downto left-len(x.reserved4)+1), convert(x.reserved4, y(left downto left-len(x.reserved4)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ttc_fmt_rt) return ttc_fmt_rt is
    variable y: ttc_fmt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcr := structify(x(left to left+len(y.bcr)-1), y.bcr);
      left := left + len(y.bcr);
      y.ecr := structify(x(left to left+len(y.ecr)-1), y.ecr);
      left := left + len(y.ecr);
      y.lxa := structify(x(left to left+len(y.lxa)-1), y.lxa);
      left := left + len(y.lxa);
      y.reserved0 := structify(x(left to left+len(y.reserved0)-1), y.reserved0);
      left := left + len(y.reserved0);
      y.reserved1 := structify(x(left to left+len(y.reserved1)-1), y.reserved1);
      left := left + len(y.reserved1);
      y.reserved2 := structify(x(left to left+len(y.reserved2)-1), y.reserved2);
      left := left + len(y.reserved2);
      y.reserved3 := structify(x(left to left+len(y.reserved3)-1), y.reserved3);
      left := left + len(y.reserved3);
      y.reserved4 := structify(x(left to left+len(y.reserved4)-1), y.reserved4);
    else
      y.bcr := structify(x(left downto left-len(y.bcr)+1), y.bcr);
      left := left - len(y.bcr);
      y.ecr := structify(x(left downto left-len(y.ecr)+1), y.ecr);
      left := left - len(y.ecr);
      y.lxa := structify(x(left downto left-len(y.lxa)+1), y.lxa);
      left := left - len(y.lxa);
      y.reserved0 := structify(x(left downto left-len(y.reserved0)+1), y.reserved0);
      left := left - len(y.reserved0);
      y.reserved1 := structify(x(left downto left-len(y.reserved1)+1), y.reserved1);
      left := left - len(y.reserved1);
      y.reserved2 := structify(x(left downto left-len(y.reserved2)+1), y.reserved2);
      left := left - len(y.reserved2);
      y.reserved3 := structify(x(left downto left-len(y.reserved3)+1), y.reserved3);
      left := left - len(y.reserved3);
      y.reserved4 := structify(x(left downto left-len(y.reserved4)+1), y.reserved4);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ttc_fmt_rt) return ttc_fmt_rt is
    variable y: ttc_fmt_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcr := convert(x(left to left+len(y.bcr)-1), y.bcr);
      left := left + len(y.bcr);
      y.ecr := convert(x(left to left+len(y.ecr)-1), y.ecr);
      left := left + len(y.ecr);
      y.lxa := convert(x(left to left+len(y.lxa)-1), y.lxa);
      left := left + len(y.lxa);
      y.reserved0 := convert(x(left to left+len(y.reserved0)-1), y.reserved0);
      left := left + len(y.reserved0);
      y.reserved1 := convert(x(left to left+len(y.reserved1)-1), y.reserved1);
      left := left + len(y.reserved1);
      y.reserved2 := convert(x(left to left+len(y.reserved2)-1), y.reserved2);
      left := left + len(y.reserved2);
      y.reserved3 := convert(x(left to left+len(y.reserved3)-1), y.reserved3);
      left := left + len(y.reserved3);
      y.reserved4 := convert(x(left to left+len(y.reserved4)-1), y.reserved4);
    else
      y.bcr := convert(x(left downto left-len(y.bcr)+1), y.bcr);
      left := left - len(y.bcr);
      y.ecr := convert(x(left downto left-len(y.ecr)+1), y.ecr);
      left := left - len(y.ecr);
      y.lxa := convert(x(left downto left-len(y.lxa)+1), y.lxa);
      left := left - len(y.lxa);
      y.reserved0 := convert(x(left downto left-len(y.reserved0)+1), y.reserved0);
      left := left - len(y.reserved0);
      y.reserved1 := convert(x(left downto left-len(y.reserved1)+1), y.reserved1);
      left := left - len(y.reserved1);
      y.reserved2 := convert(x(left downto left-len(y.reserved2)+1), y.reserved2);
      left := left - len(y.reserved2);
      y.reserved3 := convert(x(left downto left-len(y.reserved3)+1), y.reserved3);
      left := left - len(y.reserved3);
      y.reserved4 := convert(x(left downto left-len(y.reserved4)+1), y.reserved4);
    end if;
    return y;
  end function convert;
  function nullify(t: ttc_fmt_rt) return ttc_fmt_rt is
  variable y: ttc_fmt_rt;
  begin
    y.bcr := nullify(t.bcr);
    y.ecr := nullify(t.ecr);
    y.lxa := nullify(t.lxa);
    y.reserved0 := nullify(t.reserved0);
    y.reserved1 := nullify(t.reserved1);
    y.reserved2 := nullify(t.reserved2);
    y.reserved3 := nullify(t.reserved3);
    y.reserved4 := nullify(t.reserved4);
    return y;
  end function nullify;
  function zeroed(t: ttc_fmt_rt) return ttc_fmt_rt is
  variable y: ttc_fmt_rt;
  begin
    y.bcr := zeroed(t.bcr);
    y.ecr := zeroed(t.ecr);
    y.lxa := zeroed(t.lxa);
    y.reserved0 := zeroed(t.reserved0);
    y.reserved1 := zeroed(t.reserved1);
    y.reserved2 := zeroed(t.reserved2);
    y.reserved3 := zeroed(t.reserved3);
    y.reserved4 := zeroed(t.reserved4);
    return y;
  end function zeroed;

  function len(x: ttc_cmds_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.bcr);
    l := l + len(x.ocr);
    l := l + len(x.ecr);
    l := l + len(x.lxa);
    l := l + len(x.bx);
    return l;
  end function len;
  function width(x: ttc_cmds_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.bcr);
    l := l + width(x.ocr);
    l := l + width(x.ecr);
    l := l + width(x.lxa);
    l := l + width(x.bx);
    return l;
  end function width;
  function vectorify(x: ttc_cmds_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcr)-1), vectorify(x.bcr, y(left to left+len(x.bcr)-1)));
      left := left + len(x.bcr);
      assign(y(left to left+len(x.ocr)-1), vectorify(x.ocr, y(left to left+len(x.ocr)-1)));
      left := left + len(x.ocr);
      assign(y(left to left+len(x.ecr)-1), vectorify(x.ecr, y(left to left+len(x.ecr)-1)));
      left := left + len(x.ecr);
      assign(y(left to left+len(x.lxa)-1), vectorify(x.lxa, y(left to left+len(x.lxa)-1)));
      left := left + len(x.lxa);
      assign(y(left to left+len(x.bx)-1), vectorify(x.bx, y(left to left+len(x.bx)-1)));
    else
      assign(y(left downto left-len(x.bcr)+1), vectorify(x.bcr, y(left downto left-len(x.bcr)+1)));
      left := left - len(x.bcr);
      assign(y(left downto left-len(x.ocr)+1), vectorify(x.ocr, y(left downto left-len(x.ocr)+1)));
      left := left - len(x.ocr);
      assign(y(left downto left-len(x.ecr)+1), vectorify(x.ecr, y(left downto left-len(x.ecr)+1)));
      left := left - len(x.ecr);
      assign(y(left downto left-len(x.lxa)+1), vectorify(x.lxa, y(left downto left-len(x.lxa)+1)));
      left := left - len(x.lxa);
      assign(y(left downto left-len(x.bx)+1), vectorify(x.bx, y(left downto left-len(x.bx)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ttc_cmds_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcr)-1), convert(x.bcr, y(left to left+len(x.bcr)-1)));
      left := left + len(x.bcr);
      assign(y(left to left+len(x.ocr)-1), convert(x.ocr, y(left to left+len(x.ocr)-1)));
      left := left + len(x.ocr);
      assign(y(left to left+len(x.ecr)-1), convert(x.ecr, y(left to left+len(x.ecr)-1)));
      left := left + len(x.ecr);
      assign(y(left to left+len(x.lxa)-1), convert(x.lxa, y(left to left+len(x.lxa)-1)));
      left := left + len(x.lxa);
      assign(y(left to left+len(x.bx)-1), convert(x.bx, y(left to left+len(x.bx)-1)));
    else
      assign(y(left downto left-len(x.bcr)+1), convert(x.bcr, y(left downto left-len(x.bcr)+1)));
      left := left - len(x.bcr);
      assign(y(left downto left-len(x.ocr)+1), convert(x.ocr, y(left downto left-len(x.ocr)+1)));
      left := left - len(x.ocr);
      assign(y(left downto left-len(x.ecr)+1), convert(x.ecr, y(left downto left-len(x.ecr)+1)));
      left := left - len(x.ecr);
      assign(y(left downto left-len(x.lxa)+1), convert(x.lxa, y(left downto left-len(x.lxa)+1)));
      left := left - len(x.lxa);
      assign(y(left downto left-len(x.bx)+1), convert(x.bx, y(left downto left-len(x.bx)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ttc_cmds_rt) return ttc_cmds_rt is
    variable y: ttc_cmds_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcr := structify(x(left to left+len(y.bcr)-1), y.bcr);
      left := left + len(y.bcr);
      y.ocr := structify(x(left to left+len(y.ocr)-1), y.ocr);
      left := left + len(y.ocr);
      y.ecr := structify(x(left to left+len(y.ecr)-1), y.ecr);
      left := left + len(y.ecr);
      y.lxa := structify(x(left to left+len(y.lxa)-1), y.lxa);
      left := left + len(y.lxa);
      y.bx := structify(x(left to left+len(y.bx)-1), y.bx);
    else
      y.bcr := structify(x(left downto left-len(y.bcr)+1), y.bcr);
      left := left - len(y.bcr);
      y.ocr := structify(x(left downto left-len(y.ocr)+1), y.ocr);
      left := left - len(y.ocr);
      y.ecr := structify(x(left downto left-len(y.ecr)+1), y.ecr);
      left := left - len(y.ecr);
      y.lxa := structify(x(left downto left-len(y.lxa)+1), y.lxa);
      left := left - len(y.lxa);
      y.bx := structify(x(left downto left-len(y.bx)+1), y.bx);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ttc_cmds_rt) return ttc_cmds_rt is
    variable y: ttc_cmds_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcr := convert(x(left to left+len(y.bcr)-1), y.bcr);
      left := left + len(y.bcr);
      y.ocr := convert(x(left to left+len(y.ocr)-1), y.ocr);
      left := left + len(y.ocr);
      y.ecr := convert(x(left to left+len(y.ecr)-1), y.ecr);
      left := left + len(y.ecr);
      y.lxa := convert(x(left to left+len(y.lxa)-1), y.lxa);
      left := left + len(y.lxa);
      y.bx := convert(x(left to left+len(y.bx)-1), y.bx);
    else
      y.bcr := convert(x(left downto left-len(y.bcr)+1), y.bcr);
      left := left - len(y.bcr);
      y.ocr := convert(x(left downto left-len(y.ocr)+1), y.ocr);
      left := left - len(y.ocr);
      y.ecr := convert(x(left downto left-len(y.ecr)+1), y.ecr);
      left := left - len(y.ecr);
      y.lxa := convert(x(left downto left-len(y.lxa)+1), y.lxa);
      left := left - len(y.lxa);
      y.bx := convert(x(left downto left-len(y.bx)+1), y.bx);
    end if;
    return y;
  end function convert;
  function nullify(t: ttc_cmds_rt) return ttc_cmds_rt is
  variable y: ttc_cmds_rt;
  begin
    y.bcr := nullify(t.bcr);
    y.ocr := nullify(t.ocr);
    y.ecr := nullify(t.ecr);
    y.lxa := nullify(t.lxa);
    y.bx := nullify(t.bx);
    return y;
  end function nullify;
  function zeroed(t: ttc_cmds_rt) return ttc_cmds_rt is
  variable y: ttc_cmds_rt;
  begin
    y.bcr := zeroed(t.bcr);
    y.ocr := zeroed(t.ocr);
    y.ecr := zeroed(t.ecr);
    y.lxa := zeroed(t.lxa);
    y.bx := zeroed(t.bx);
    return y;
  end function zeroed;

  function len(x: ttc_counters_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.bcid);
    l := l + len(x.evid);
    l := l + len(x.orid);
    return l;
  end function len;
  function width(x: ttc_counters_rt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.bcid);
    l := l + width(x.evid);
    l := l + width(x.orid);
    return l;
  end function width;
  function vectorify(x: ttc_counters_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcid)-1), vectorify(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.evid)-1), vectorify(x.evid, y(left to left+len(x.evid)-1)));
      left := left + len(x.evid);
      assign(y(left to left+len(x.orid)-1), vectorify(x.orid, y(left to left+len(x.orid)-1)));
    else
      assign(y(left downto left-len(x.bcid)+1), vectorify(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.evid)+1), vectorify(x.evid, y(left downto left-len(x.evid)+1)));
      left := left - len(x.evid);
      assign(y(left downto left-len(x.orid)+1), vectorify(x.orid, y(left downto left-len(x.orid)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ttc_counters_rt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.bcid)-1), convert(x.bcid, y(left to left+len(x.bcid)-1)));
      left := left + len(x.bcid);
      assign(y(left to left+len(x.evid)-1), convert(x.evid, y(left to left+len(x.evid)-1)));
      left := left + len(x.evid);
      assign(y(left to left+len(x.orid)-1), convert(x.orid, y(left to left+len(x.orid)-1)));
    else
      assign(y(left downto left-len(x.bcid)+1), convert(x.bcid, y(left downto left-len(x.bcid)+1)));
      left := left - len(x.bcid);
      assign(y(left downto left-len(x.evid)+1), convert(x.evid, y(left downto left-len(x.evid)+1)));
      left := left - len(x.evid);
      assign(y(left downto left-len(x.orid)+1), convert(x.orid, y(left downto left-len(x.orid)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ttc_counters_rt) return ttc_counters_rt is
    variable y: ttc_counters_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcid := structify(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.evid := structify(x(left to left+len(y.evid)-1), y.evid);
      left := left + len(y.evid);
      y.orid := structify(x(left to left+len(y.orid)-1), y.orid);
    else
      y.bcid := structify(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.evid := structify(x(left downto left-len(y.evid)+1), y.evid);
      left := left - len(y.evid);
      y.orid := structify(x(left downto left-len(y.orid)+1), y.orid);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ttc_counters_rt) return ttc_counters_rt is
    variable y: ttc_counters_rt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.bcid := convert(x(left to left+len(y.bcid)-1), y.bcid);
      left := left + len(y.bcid);
      y.evid := convert(x(left to left+len(y.evid)-1), y.evid);
      left := left + len(y.evid);
      y.orid := convert(x(left to left+len(y.orid)-1), y.orid);
    else
      y.bcid := convert(x(left downto left-len(y.bcid)+1), y.bcid);
      left := left - len(y.bcid);
      y.evid := convert(x(left downto left-len(y.evid)+1), y.evid);
      left := left - len(y.evid);
      y.orid := convert(x(left downto left-len(y.orid)+1), y.orid);
    end if;
    return y;
  end function convert;
  function nullify(t: ttc_counters_rt) return ttc_counters_rt is
  variable y: ttc_counters_rt;
  begin
    y.bcid := nullify(t.bcid);
    y.evid := nullify(t.evid);
    y.orid := nullify(t.orid);
    return y;
  end function nullify;
  function zeroed(t: ttc_counters_rt) return ttc_counters_rt is
  variable y: ttc_counters_rt;
  begin
    y.bcid := zeroed(t.bcid);
    y.evid := zeroed(t.evid);
    y.orid := zeroed(t.orid);
    return y;
  end function zeroed;

  function len(x: ttc_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.sys);
    l := l + len(x.data);
    return l;
  end function len;
  function width(x: ttc_irt) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.sys);
    l := l + width(x.data);
    return l;
  end function width;
  function vectorify(x: ttc_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), vectorify(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.data)-1), vectorify(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), vectorify(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.data)+1), vectorify(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ttc_irt; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.sys)-1), convert(x.sys, y(left to left+len(x.sys)-1)));
      left := left + len(x.sys);
      assign(y(left to left+len(x.data)-1), convert(x.data, y(left to left+len(x.data)-1)));
    else
      assign(y(left downto left-len(x.sys)+1), convert(x.sys, y(left downto left-len(x.sys)+1)));
      left := left - len(x.sys);
      assign(y(left downto left-len(x.data)+1), convert(x.data, y(left downto left-len(x.data)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ttc_irt) return ttc_irt is
    variable y: ttc_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := structify(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.data := structify(x(left to left+len(y.data)-1), y.data);
    else
      y.sys := structify(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.data := structify(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ttc_irt) return ttc_irt is
    variable y: ttc_irt;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.sys := convert(x(left to left+len(y.sys)-1), y.sys);
      left := left + len(y.sys);
      y.data := convert(x(left to left+len(y.data)-1), y.data);
    else
      y.sys := convert(x(left downto left-len(y.sys)+1), y.sys);
      left := left - len(y.sys);
      y.data := convert(x(left downto left-len(y.data)+1), y.data);
    end if;
    return y;
  end function convert;
  function nullify(t: ttc_irt) return ttc_irt is
  variable y: ttc_irt;
  begin
    y.sys := nullify(t.sys);
    y.data := nullify(t.data);
    return y;
  end function nullify;
  function zeroed(t: ttc_irt) return ttc_irt is
  variable y: ttc_irt;
  begin
    y.sys := zeroed(t.sys);
    y.data := zeroed(t.data);
    return y;
  end function zeroed;

  function len(x: ttc_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.cmds);
    l := l + len(x.cnt);
    return l;
  end function len;
  function width(x: ttc_ort) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.cmds);
    l := l + width(x.cnt);
    return l;
  end function width;
  function vectorify(x: ttc_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.cmds)-1), vectorify(x.cmds, y(left to left+len(x.cmds)-1)));
      left := left + len(x.cmds);
      assign(y(left to left+len(x.cnt)-1), vectorify(x.cnt, y(left to left+len(x.cnt)-1)));
    else
      assign(y(left downto left-len(x.cmds)+1), vectorify(x.cmds, y(left downto left-len(x.cmds)+1)));
      left := left - len(x.cmds);
      assign(y(left downto left-len(x.cnt)+1), vectorify(x.cnt, y(left downto left-len(x.cnt)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ttc_ort; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.cmds)-1), convert(x.cmds, y(left to left+len(x.cmds)-1)));
      left := left + len(x.cmds);
      assign(y(left to left+len(x.cnt)-1), convert(x.cnt, y(left to left+len(x.cnt)-1)));
    else
      assign(y(left downto left-len(x.cmds)+1), convert(x.cmds, y(left downto left-len(x.cmds)+1)));
      left := left - len(x.cmds);
      assign(y(left downto left-len(x.cnt)+1), convert(x.cnt, y(left downto left-len(x.cnt)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ttc_ort) return ttc_ort is
    variable y: ttc_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.cmds := structify(x(left to left+len(y.cmds)-1), y.cmds);
      left := left + len(y.cmds);
      y.cnt := structify(x(left to left+len(y.cnt)-1), y.cnt);
    else
      y.cmds := structify(x(left downto left-len(y.cmds)+1), y.cmds);
      left := left - len(y.cmds);
      y.cnt := structify(x(left downto left-len(y.cnt)+1), y.cnt);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ttc_ort) return ttc_ort is
    variable y: ttc_ort;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.cmds := convert(x(left to left+len(y.cmds)-1), y.cmds);
      left := left + len(y.cmds);
      y.cnt := convert(x(left to left+len(y.cnt)-1), y.cnt);
    else
      y.cmds := convert(x(left downto left-len(y.cmds)+1), y.cmds);
      left := left - len(y.cmds);
      y.cnt := convert(x(left downto left-len(y.cnt)+1), y.cnt);
    end if;
    return y;
  end function convert;
  function nullify(t: ttc_ort) return ttc_ort is
  variable y: ttc_ort;
  begin
    y.cmds := nullify(t.cmds);
    y.cnt := nullify(t.cnt);
    return y;
  end function nullify;
  function zeroed(t: ttc_ort) return ttc_ort is
  variable y: ttc_ort;
  begin
    y.cmds := zeroed(t.cmds);
    y.cnt := zeroed(t.cnt);
    return y;
  end function zeroed;

  function len(x: ttc_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + len(x.i);
    l := l + len(x.o);
    return l;
  end function len;
  function width(x: ttc_ert) return natural is
    variable l : natural := 0;
  begin
    l := l + width(x.i);
    l := l + width(x.o);
    return l;
  end function width;
  function vectorify(x: ttc_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), vectorify(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), vectorify(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), vectorify(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), vectorify(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function vectorify;
  function convert(x: ttc_ert; t: std_logic_vector) return std_logic_vector is
    variable left : natural := t'left;
    variable y : std_logic_vector(t'range);
  begin
    if t'ascending then
      assign(y(left to left+len(x.i)-1), convert(x.i, y(left to left+len(x.i)-1)));
      left := left + len(x.i);
      assign(y(left to left+len(x.o)-1), convert(x.o, y(left to left+len(x.o)-1)));
    else
      assign(y(left downto left-len(x.i)+1), convert(x.i, y(left downto left-len(x.i)+1)));
      left := left - len(x.i);
      assign(y(left downto left-len(x.o)+1), convert(x.o, y(left downto left-len(x.o)+1)));
    end if;
    return y;
  end function convert;
  function structify(x: in std_logic_vector; t: ttc_ert) return ttc_ert is
    variable y: ttc_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := structify(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := structify(x(left to left+len(y.o)-1), y.o);
    else
      y.i := structify(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := structify(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function structify;
  function convert(x: in std_logic_vector; t: ttc_ert) return ttc_ert is
    variable y: ttc_ert;
    variable left : natural := x'left;
  begin
    if x'ascending then
      y.i := convert(x(left to left+len(y.i)-1), y.i);
      left := left + len(y.i);
      y.o := convert(x(left to left+len(y.o)-1), y.o);
    else
      y.i := convert(x(left downto left-len(y.i)+1), y.i);
      left := left - len(y.i);
      y.o := convert(x(left downto left-len(y.o)+1), y.o);
    end if;
    return y;
  end function convert;
  function nullify(t: ttc_ert) return ttc_ert is
  variable y: ttc_ert;
  begin
    y.i := nullify(t.i);
    y.o := nullify(t.o);
    return y;
  end function nullify;
  function zeroed(t: ttc_ert) return ttc_ert is
  variable y: ttc_ert;
  begin
    y.i := zeroed(t.i);
    y.o := zeroed(t.o);
    return y;
  end function zeroed;

end package body ttc_defs;
