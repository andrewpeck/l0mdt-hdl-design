#This function writes a dtsi_post_chunk file to append a XILINX axi slave so it
#  can be used as a UIO device.
#This takes the name of the device (as it appears in the DTSI file generated by xilinx)
proc AXI_DEV_UIO_DTSI_POST_CHUNK {device_name} {
    assign_bd_address [get_bd_addr_segs {${device_name}/S_AXI/Reg }]
    set dtsi_file [open "../os/hw/${device_name}.dtsi_post_chunk" w+]
    puts $dtsi_file "  &${device_name}{"
    puts $dtsi_file "    compatible = \"generic-uio\";"
    puts $dtsi_file "      label = \"$device_name\";"
    puts $dtsi_file "  };"
    close $dtsi_file
}

#function to create a DTSI chunk file for a full PL AXI slave.
proc AXI_DEV_UIO_DTSI_CHUNK {axi_interconnect_name axi_master_name device_name} {
    puts ${axi_master_name}
    #    set addr       [format %X [get_property "CONFIG.${axi_master_name}_A00_BASE_ADDR" [get_bd_cells "${axi_interconnect_name}/xbar"]]]
    #    set addr_width [get_property "CONFIG.${axi_master_name}_A00_ADDR_WIDTH" [get_bd_cells "${axi_interconnect_name}/xbar"]]
    #    set addr_range [format %X [expr 1 << $addr_width]]
    set addr [format %X [lindex [get_property OFFSET [get_bd_addr_segs *${device_name}*]] 1] ]
    set addr_range [format %X [lindex [get_property RANGE [get_bd_addr_segs *${device_name}*]] 1] ]

    
    #build dtsi file for this for later    
    set dtsi_file [open "../os/hw/$device_name.dtsi_chunk" w+]
    puts $dtsi_file "  amba_pl {"
    puts $dtsi_file "    axiSlave$device_name: $device_name@${addr} {"
    puts $dtsi_file "      compatible = \"generic-uio\";"
    puts $dtsi_file "      reg = <0x${addr} 0x${addr_range}>;"
    puts $dtsi_file "      label = \"$device_name\";"
    puts $dtsi_file "    };"
    puts $dtsi_file "  };"
    close $dtsi_file
}
